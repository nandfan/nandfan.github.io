<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>链接</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">链接</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9fe94d4">1. 编译器驱动程序</a></li>
<li><a href="#org426df64">2. 静态链接</a></li>
<li><a href="#org83570d6">3. 目标文件</a></li>
<li><a href="#orgc1bcbe1">4. 可重定位目标文件</a></li>
<li><a href="#org424c5d9">5. 符号和符号表</a></li>
<li><a href="#orga42b4e3">6. 符号解析</a>
<ul>
<li><a href="#orga5122b7">6.1. 处理多重定义的全局符号</a></li>
<li><a href="#orgd8037e9">6.2. 与静态库链接</a></li>
<li><a href="#org07df4ab">6.3. 链接器如何使用静态库解析引用</a></li>
</ul>
</li>
<li><a href="#orga62db09">7. 重定位</a>
<ul>
<li><a href="#orgb7829f6">7.1. 重定位条目</a></li>
<li><a href="#org42f2cb8">7.2. 重定位符号引用</a>
<ul>
<li><a href="#org8c02476">7.2.1. PC相对地址的重定位</a></li>
<li><a href="#orge441345">7.2.2. 重定位绝对地址</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org466d6ea">8. 可执行目标文件</a></li>
<li><a href="#org1297139">9. 加载可执行目标文件</a></li>
<li><a href="#orgd8a479f">10. 动态链接共享库</a></li>
<li><a href="#orgc1f710c">11. 从应用程序加载和链接共享库</a></li>
<li><a href="#orgcddf279">12. 位置无关代码</a></li>
<li><a href="#org97dff9e">13. 库打桩机制</a>
<ul>
<li><a href="#orge7a2302">13.1. 编译时打桩</a></li>
<li><a href="#org251bd23">13.2. 链接时打桩</a></li>
<li><a href="#org48a65ce">13.3. 运行时打桩</a></li>
</ul>
</li>
<li><a href="#org14eb716">14. 处理目标文件的工具</a></li>
</ul>
</div>
</div>
<p>
<b>Section: 目标文件中的代码节、数据节&#x2026;</b>
</p>

<p>
<b>Segment: 可执行文件中Program Header中的段，通过类型区分：可读可执行、只读、可读写</b>
</p>


<div id="outline-container-org9fe94d4" class="outline-2">
<h2 id="org9fe94d4"><span class="section-number-2">1.</span> 编译器驱动程序</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/** main.c */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">sum</span>(<span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">a</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">n</span>);
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">array</span>[2] = {1, 2};
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">main</span>()
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">val</span> = sum(array, 2);
        <span style="color: #F92672;">return</span> val;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/** sum.c */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">sum</span>(<span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">a</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">n</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>, <span style="color: #FD971F;">s</span> = 0;
        <span style="color: #F92672;">for</span> (i = 0; i &lt; n; i++) {
                s += a[i];
        }
        <span style="color: #F92672;">return</span> s;
}
</pre>
</div>


<p>
编译命令： <code>gcc -Og -o prob main.c sum.c</code> ，编译的详细过程可以通过 <code>-v</code> 选项查看。
</p>

<p>
过程分为以下几部分：
</p>
<ul class="org-ul">
<li>cpp 预处理</li>
<li>cc1 编译</li>
<li>as 汇编</li>
<li>ld 链接</li>
</ul>
</div>
</div>


<div id="outline-container-org426df64" class="outline-2">
<h2 id="org426df64"><span class="section-number-2">2.</span> 静态链接</h2>
<div class="outline-text-2" id="text-2">
<p>
链接器的两个主要任务：
</p>
<dl class="org-dl">
<dt>符号解析</dt><dd>目标文件定义和引用符号，每个符号对应于一个函数、全局变量或者静态变量。符号解析的目的是：将每个符号引用和一个符号定义关联起来。</dd>
<dt>重定位</dt><dd>编译器和汇编器生成从地址0开始的代码节和数据节。链接器通过将每个符号定义与一个内存位置关联，从而重定位这些节，然后修改所有对这些符号的引用，使其执行正确的内存位置。</dd>
</dl>
</div>
</div>


<div id="outline-container-org83570d6" class="outline-2">
<h2 id="org83570d6"><span class="section-number-2">3.</span> 目标文件</h2>
<div class="outline-text-2" id="text-3">
<p>
目标文件三种形式：
</p>
<ul class="org-ul">
<li>可重定位目标文件。可以在编译时与其他可重定位目标文件合并（.o文件）</li>
<li>可执行目标文件。可以直接复制到内存并执行（程序文件）</li>
<li>共享目标文件。可以在加载或者运行时被动态加载（动态库so）</li>
</ul>
</div>
</div>


<div id="outline-container-orgc1bcbe1" class="outline-2">
<h2 id="orgc1bcbe1"><span class="section-number-2">4.</span> 可重定位目标文件</h2>
<div class="outline-text-2" id="text-4">
<p>
ELF可重定位目标文件的节。
</p>

<ul class="org-ul">
<li>.text 代码节，已经编译程序的机器代码</li>
<li>.data 已经初始化的全局变量和局部静态变量</li>
<li>.bss 未初始化的全局变量和局部静态变量</li>
<li>.rodata 只读数据（常量字符串，const变量）</li>
<li>.rel.text .text节中需要重定位符号的位置列表</li>
<li>.rel.data .data节中需要重定位符号的位置列表</li>
<li>.comment 存放编译器版本信息</li>
<li>.debug 调试信息</li>
<li>.line 调试的行号</li>
<li>.strtab  String Table字符串表</li>
</ul>
</div>
</div>


<div id="outline-container-org424c5d9" class="outline-2">
<h2 id="org424c5d9"><span class="section-number-2">5.</span> 符号和符号表</h2>
<div class="outline-text-2" id="text-5">
<p>
链接器上下文中，有三种不同的符号：
</p>
<ul class="org-ul">
<li>由模块m定义并能被其他模块引用的全局符号。</li>
<li>由其他模块定义，并被模块m引用的全局符号。</li>
<li>只被模块m定义和引用的局部符号（static属性修饰的函数和全局变量）。</li>
</ul>

<p>
ELF符号条目结构：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">typedef</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">elf64_sym</span> {
        <span style="color: #E6DB74;">/** &#31526;&#21495;&#21517;&#65292;&#26631;&#35782;&#35813;&#31526;&#21495;&#21517;&#22312;&#23383;&#31526;&#20018;&#34920;&#20013;&#30340;&#19979;&#26631; */</span>
        <span style="color: #66D9EF;">Elf64_Word</span> <span style="color: #FD971F;">st_name</span>;             <span style="color: #75715E;">/* </span><span style="color: #75715E;">Symbol name, index in string tbl</span><span style="color: #75715E;"> */</span>
        <span style="color: #E6DB74;">/** &#31526;&#21495;&#31867;&#22411;&#21644;&#32465;&#23450;&#20449;&#24687; */</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span>   <span style="color: #FD971F;">st_info</span>;        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Type and binding attributes</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span>   <span style="color: #FD971F;">st_other</span>;       <span style="color: #75715E;">/* </span><span style="color: #75715E;">No defined meaning, 0</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">Elf64_Half</span> <span style="color: #FD971F;">st_shndx</span>;            <span style="color: #75715E;">/* </span><span style="color: #75715E;">Associated section index</span><span style="color: #75715E;"> */</span>
        <span style="color: #E6DB74;">/** &#31526;&#21495;&#20540;&#65292;&#20540;&#19982;&#31526;&#21495;&#26377;&#20851;&#65292;&#21487;&#33021;&#26159;&#32477;&#23545;&#20540;&#65292;&#20063;&#21487;&#33021;&#26159;&#30456;&#23545;&#20540;*/</span>
        <span style="color: #66D9EF;">Elf64_Addr</span> <span style="color: #FD971F;">st_value</span>;            <span style="color: #75715E;">/* </span><span style="color: #75715E;">Value of the symbol</span><span style="color: #75715E;"> */</span>
        <span style="color: #E6DB74;">/** &#31526;&#21495;&#22823;&#23567;&#65292;&#23545;&#20110;&#21253;&#21547;&#25968;&#25454;&#30340;&#31526;&#21495;&#65292;&#20195;&#34920;&#25968;&#25454;&#31867;&#22411;&#30340;&#22823;&#23567;&#12290; &#20026;0&#34920;&#31034;&#22823;&#23567;&#26159;0&#25110;&#32773;&#26410;&#30693;*/</span>
        <span style="color: #66D9EF;">Elf64_Xword</span> <span style="color: #FD971F;">st_size</span>;            <span style="color: #75715E;">/* </span><span style="color: #75715E;">Associated symbol size</span><span style="color: #75715E;"> */</span>
} <span style="color: #66D9EF;">Elf64_Sym</span>;
</pre>
</div>

<p>
st_shndx表示符号所在节在节表中的下标。
</p>

<p>
有三种特殊类型的符号，不存在对应的节，只有可重定位目标文件才存在这些符号类型：
</p>
<ul class="org-ul">
<li>ABS 代表不该被重定位的符号。</li>
<li>UNDEF 代表未定义的符号</li>
<li>COMMON 代表还未被分配位置的未初始化的数据，对于COMMON类型的符号， <code>st_value</code> 表示字段的对齐要求， <code>st_size</code> 给出最小的大小</li>
</ul>



<div class="org-src-container">
<pre class="src src-sh">~/tmp/csapp/tmp $ readelf -W -Ss main.o
There are 12 section headers, starting at offset 0x208:

Section Headers:
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        0000000000000000 000040 00001a 00  AX  0   0  1
  [ 2] .rela.text        RELA            0000000000000000 000160 000030 18   I  9   1  8
  [ 3] .data             PROGBITS        0000000000000000 000060 000008 00  WA  0   0  8
  [ 4] .bss              NOBITS          0000000000000000 000068 000000 00  WA  0   0  1
  [ 5] .comment          PROGBITS        0000000000000000 000068 000020 01  MS  0   0  1
  [ 6] .note.GNU-stack   PROGBITS        0000000000000000 000088 000000 00      0   0  1
  [ 7] .eh_frame         PROGBITS        0000000000000000 000088 000030 00   A  0   0  8
  [ 8] .rela.eh_frame    RELA            0000000000000000 000190 000018 18   I  9   7  8
  [ 9] .symtab           SYMTAB          0000000000000000 0000b8 000090 18     10   3  8
  [10] .strtab           STRTAB          0000000000000000 000148 000017 00      0   0  1
  [11] .shstrtab         STRTAB          0000000000000000 0001a8 000059 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)

Symbol table <span style="color: #E6DB74;">'.symtab'</span> contains 6 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000000    26 FUNC    GLOBAL DEFAULT    1 main
     4: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 array
     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sum
~/tmp/csapp/tmp $
</pre>
</div>

<ol class="org-ol">
<li>main：st_shndx 为1，代表.text节。 st_value为0，相对于.text偏移0。size大小为26bytes。</li>
<li>array：st_shndx 为3，代表.data节。st_value为0，相对于.data偏移0。size大小为8bytes。</li>
<li>sum：st_shndx 为UND，代表未定义。</li>
</ol>
</div>
</div>


<div id="outline-container-orga42b4e3" class="outline-2">
<h2 id="orga42b4e3"><span class="section-number-2">6.</span> 符号解析</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orga5122b7" class="outline-3">
<h3 id="orga5122b7"><span class="section-number-3">6.1.</span> 处理多重定义的全局符号</h3>
<div class="outline-text-3" id="text-6-1">
<p>
强符号：函数和已经初始化的全局符号
</p>

<p>
弱符号：未初始化的全局变量
</p>

<p>
处理规则：
</p>
<ol class="org-ol">
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，则选择强符号</li>
<li>如果有多个弱符号同名，优先选择初始化的弱符号，否则选择占用空间最大的符号。此时编译需要加 <code>-fcommon</code> 选项。</li>
</ol>
</div>
</div>

<div id="outline-container-orgd8037e9" class="outline-3">
<h3 id="orgd8037e9"><span class="section-number-3">6.2.</span> 与静态库链接</h3>
<div class="outline-text-3" id="text-6-2">
<p>
linux中，静态库以存档（archive）的文件格式存储。其中包含的是一组可重定位的目标文件的集合。
</p>

<p>
链接时，链接器只复制被程序引用的目标模块。
</p>
</div>
</div>

<div id="outline-container-org07df4ab" class="outline-3">
<h3 id="org07df4ab"><span class="section-number-3">6.3.</span> 链接器如何使用静态库解析引用</h3>
<div class="outline-text-3" id="text-6-3">
<p>
符号解析阶段，连接器从左到右按照命令行中文件出现的顺序开扫描可重定位目标文件和存档文件。
</p>

<p>
扫描过程中，链接器维护三个集合：
</p>
<ul class="org-ul">
<li>一个可重定位目标文件的集合E（该集合中的文件会被合并成可执行文件）</li>
<li>一个未解析的符号集合U（也就是已经引用但还未定义的的符号）</li>
<li>输入文件中的已定义符号的集合D</li>
</ul>

<p>
初始时，E、U、D 都为空。
</p>

<p>
处理规则：
</p>
<ul class="org-ul">
<li>对于命令行上的每个输入文件 f，链接器判断f是目标文件还是存档文件，如果是目标文件，则添加到E，修改U和D来反映f中的符号定义和引用，然后继续下一个输入文件。</li>
<li>如果 f 是个存档文件，链接器尝试匹配 U中未解析的符号 和 存档文件中定义的符号。如果 存档文件成员m定义的符号被 U 引用，则将m添加到E，并修改U和D来反映m中的符号定义和引用。对存档文件的成员重复该过程，直到U和D都不再变化。此时任何不包含在E中的成员目标文件都被丢弃，然后继续处理下一个输入文件。</li>
<li>链接器完成对命令行文件的扫描后，如果U是非空，则链接器输出错误并终止。否则合并E中的目标文件，构建输出的可执行文件。</li>
</ul>

<div class="warning" id="orgc5ebe96">
<p>
注意：
</p>
<ul class="org-ul">
<li>这种方式的弊端： 命令行中的库和目标文件的顺序变得非常重要。如果一个符号的库出现在引用这个符号的目标文件之前，则引用不能被解析，导致链接失败。 例如： <code>gcc -static ./libvector.a main.c</code> ，main函数中引用libvector.a中的addvec，但是对addvec的引用无法被解析。</li>
</ul>

</div>
<div class="tip" id="org244f8fb">
<p>
库的一般准则：
</p>
<ul class="org-ul">
<li>库放置在命令行的结尾。如果各个库的成员相互独立，则可以任意放置在结尾；否则需要对库进行排序，使得每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义实在对s的引用之后。（如果有交叉引用，则可以重复放置）</li>
</ul>

</div>
</div>
</div>
</div>


<div id="outline-container-orga62db09" class="outline-2">
<h2 id="orga62db09"><span class="section-number-2">7.</span> 重定位</h2>
<div class="outline-text-2" id="text-7">
<p>
符号解析完成后，代码中每个符号引用和符号定义就被关联起来了，此时链接器知道输入目标模块的代码节和数据节的确切大小。此时可以开始重定位了。
</p>

<p>
重定位将合并输入模块，为每个符号分配运行时地址，分两步：
</p>
<ul class="org-ul">
<li>将节和符号定义进行重定位。 这一步，合并同类型的节（称为Segment），然后将运行时的内存地址赋值给新的Segment（包括其中的节、符号），此时程序中每条指令和全局变量都有唯一的运行时地址。</li>
<li>将节中的符号引用进行重定位。这一步，链接器修改代码节和数据节中对每个符号的引用，时的他们指向正确的运行时地址（依赖目标模块中的重定位条目）。</li>
</ul>
</div>


<div id="outline-container-orgb7829f6" class="outline-3">
<h3 id="orgb7829f6"><span class="section-number-3">7.1.</span> 重定位条目</h3>
<div class="outline-text-3" id="text-7-1">
<p>
ELF重定位条目：每个条目表示一个必须被重定位的引用，并指明如果计算被修改的引用。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">typedef</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">elf64_rela</span> {
        <span style="color: #E6DB74;">/** &#38656;&#35201;&#34987;&#20462;&#25913;&#24341;&#29992;&#30340;&#33410;&#20559;&#31227;*/</span>
        <span style="color: #66D9EF;">Elf64_Addr</span> <span style="color: #FD971F;">r_offset</span>;    <span style="color: #75715E;">/* </span><span style="color: #75715E;">Location at which to apply the action</span><span style="color: #75715E;"> */</span>
        <span style="color: #E6DB74;">/** &#20302;32&#20301;&#65306;type&#65292;&#21578;&#30693;&#38142;&#25509;&#22120;&#22914;&#20309;&#20462;&#25913;&#24341;&#29992;</span>
<span style="color: #E6DB74;">         ,  &#39640;32&#20301;&#65306;&#31526;&#21495;&#34920;&#20013;&#30340;&#19979;&#26631; */</span>
        <span style="color: #66D9EF;">Elf64_Xword</span> <span style="color: #FD971F;">r_info</span>;     <span style="color: #75715E;">/* </span><span style="color: #75715E;">index and type of relocation</span><span style="color: #75715E;"> */</span>
        <span style="color: #E6DB74;">/** &#37096;&#20998;&#31867;&#22411;&#30340;&#37325;&#23450;&#20301;&#35201;&#20351;&#29992;&#35813;&#25104;&#21592;&#23545;&#34987;&#20462;&#25913;&#24341;&#29992;&#30340;&#20540;&#36827;&#34892;&#35843;&#25972;*/</span>
        <span style="color: #66D9EF;">Elf64_Sxword</span> <span style="color: #FD971F;">r_addend</span>;  <span style="color: #75715E;">/* </span><span style="color: #75715E;">Constant addend used to compute value</span><span style="color: #75715E;"> */</span>
} <span style="color: #66D9EF;">Elf64_Rela</span>;
</pre>
</div>

<p>
基本的重定位类型：
</p>
<ul class="org-ul">
<li>R_X86_64_PC32 重定位一个使用32位PC相对地址的引用</li>
<li>R_X86_64_32 重定位一个使用32为绝对地址的引用</li>
</ul>
</div>
</div>


<div id="outline-container-org42f2cb8" class="outline-3">
<h3 id="org42f2cb8"><span class="section-number-3">7.2.</span> 重定位符号引用</h3>
<div class="outline-text-3" id="text-7-2">
<p>
重定位算法伪代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;">   &#27599;&#20010;&#31526;&#21495;&#30340;&#36816;&#34892;&#26102;&#22320;&#22336;&#34920;&#31034;&#65306; ADDR(r.symbol)</span>
<span style="color: #E6DB74;"> */</span>
foreach <span style="color: #66D9EF;">section</span> <span style="color: #FD971F;">s</span> {  <span style="color: #E6DB74;">/** &#36941;&#21382;&#27599;&#20010;&#33410; s*/</span>
        foreach relocation <span style="color: #66D9EF;">entry</span> <span style="color: #FD971F;">r</span> { <span style="color: #E6DB74;">/** &#36941;&#21382;&#33410;&#20013;&#30340;&#27599;&#20010;&#37325;&#23450;&#20301;&#26465;&#30446; r*/</span>
                <span style="color: #E6DB74;">/** &#38656;&#35201;&#34987;&#37325;&#23450;&#20301;&#24341;&#29992;&#30340;&#22320;&#22336; */</span>
                refptr = s + r.offset;
                <span style="color: #E6DB74;">/** &#30456;&#23545;&#22320;&#22336;&#24341;&#29992; */</span>
                <span style="color: #F92672;">if</span> (r.type == R_X86_64_PC32) {
                        <span style="color: #E6DB74;">/** &#24341;&#29992;&#30340;&#36816;&#34892;&#26102;&#22320;&#22336; */</span>
                        refaddr = ADDR(s) + r.offset;
                        *refptr = (<span style="color: #66D9EF;">unsigned</span>)(ADDR(r.symbol) + r.addend - refaddr);
                }
                <span style="color: #E6DB74;">/** &#32477;&#23545;&#22320;&#22336;&#24341;&#29992; */</span>
                <span style="color: #F92672;">if</span> (r.type == R_X86_64_32) {
                        *refptr = (<span style="color: #66D9EF;">unsigned</span>) (ADDR(r.symbol) + r.addend);
                }
        }
}
</pre>
</div>
</div>

<div id="outline-container-org8c02476" class="outline-4">
<h4 id="org8c02476"><span class="section-number-4">7.2.1.</span> PC相对地址的重定位</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
使用objdump将main.o反汇编：
</p>
<div class="org-src-container">
<pre class="src src-asm">~/tmp/csapp/tmp $ objdump -dx main.o

......

<span style="color: #A6E22E;">Disassembly</span> <span style="color: #F92672;">of</span> section .text:

<span style="color: #A6E22E;">0000000000000000</span> &lt;main&gt;:
   <span style="color: #F92672;">0</span>:   48 83 ec 08             sub    $0x8,<span style="color: #FD971F;">%rsp</span>
   <span style="color: #F92672;">4</span>:   be 02 00 00 00          mov    $0x2,<span style="color: #FD971F;">%esi</span>
   <span style="color: #F92672;">9</span>:   48 8d 3d 00 00 00 00    lea    0x0(<span style="color: #FD971F;">%rip</span>),<span style="color: #FD971F;">%rdi</span>        # 10 &lt;main+0x10&gt;
                        <span style="color: #F92672;">c</span>: R_X86_64_PC32        array-0x4
  <span style="color: #F92672;">10</span>:   e8 00 00 00 00          call   15 &lt;main+0x15&gt;
                        <span style="color: #F92672;">11</span>: R_X86_64_PLT32      sum-0x4
  <span style="color: #F92672;">15</span>:   48 83 c4 08             add    $0x8,<span style="color: #FD971F;">%rsp</span>
  <span style="color: #F92672;">19</span>:   c3                      ret
~/tmp/csapp/tmp $
</pre>
</div>

<p>
上面输出中，call指令位于.text偏移0x10位置处，包括一个字节操作码 0xe8， 后跟目标地址 sum 的32位PC相对引用的占位符。
</p>

<p>
sum的重定位条目：
</p>
<ul class="org-ul">
<li>r.offset = 0x11</li>
<li>r.symbol = sum</li>
<li>r.type   = R_X86_64_PC32</li>
<li>r.addend = -4</li>
</ul>

<p>
假设.text的运行时地址： ADDR(.text) = 0x4004d0。 sum的运行时地址 ADDR(r.symbol) = 0x4004e8
</p>

<div class="org-src-container">
<pre class="src src-fundamental">refaddr = ADDR(s) + r.offset
        = 0x4004d0 + 0x11
        = 0x4004e1

*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr)
        = (unsigned) (0x4004e8 + (-4) - 0x4004e1)
        = (unsigned) (0x3)

&#36816;&#34892;call&#25351;&#20196;&#26102;&#65292;PC&#20540;&#20026;call&#19979;&#19968;&#26465;&#25351;&#20196;&#65292;CPU&#25191;&#34892;&#20197;&#19979;&#27493;&#39588;&#35745;&#31639;sum&#30340;&#22320;&#22336;&#65306;
    1. &#23558;PC&#21387;&#26632;
    2. PC = PC+0x3
    3. PC&#20540;&#23601;&#26159;sum&#22320;&#22336;&#65292;&#19979;&#19968;&#26465;&#25351;&#20196;&#23601;&#26159;PC&#12290;
</pre>
</div>
</div>
</div>

<div id="outline-container-orge441345" class="outline-4">
<h4 id="orge441345"><span class="section-number-4">7.2.2.</span> 重定位绝对地址</h4>
</div>
</div>
</div>


<div id="outline-container-org466d6ea" class="outline-2">
<h2 id="org466d6ea"><span class="section-number-2">8.</span> 可执行目标文件</h2>
<div class="outline-text-2" id="text-8">
<p>
可执行目标文件包含了程序加载到内存所需的所有信息。
</p>

<p>
ELF可执行文件中包含了 <b>程序头部表（Program Header Table）</b> ，可通过 <code>readelf -l 查看程序头部表</code> 。 该表中按照 Section 的类型进行组合，合并为Segment。
</p>

<p>
<b>系统加载程序时，不关心是什么类型的节，只关心属性是可读、可执行、可写。</b>
</p>

<div class="org-src-container">
<pre class="src src-sh">~/tmp/csapp/tmp $ readelf -W -l prob

Elf file type is DYN (Position-Independent Executable file)
Entry point 0x1040
There are 13 program headers, starting at offset 64

Program Headers:
  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R   0x8
  INTERP         0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R   0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x0005e0 0x0005e0 R   0x1000
  LOAD           0x001000 0x0000000000001000 0x0000000000001000 0x000169 0x000169 R E 0x1000
  LOAD           0x002000 0x0000000000002000 0x0000000000002000 0x0000f0 0x0000f0 R   0x1000
  LOAD           0x002e00 0x0000000000003e00 0x0000000000003e00 0x000218 0x000220 RW  0x1000
  DYNAMIC        0x002e10 0x0000000000003e10 0x0000000000003e10 0x0001b0 0x0001b0 RW  0x8
  NOTE           0x000338 0x0000000000000338 0x0000000000000338 0x000020 0x000020 R   0x8
  NOTE           0x000358 0x0000000000000358 0x0000000000000358 0x000044 0x000044 R   0x4
  GNU_PROPERTY   0x000338 0x0000000000000338 0x0000000000000338 0x000020 0x000020 R   0x8
  GNU_EH_FRAME   0x002004 0x0000000000002004 0x0000000000002004 0x000034 0x000034 R   0x4
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
  GNU_RELRO      0x002e00 0x0000000000003e00 0x0000000000003e00 0x000200 0x000200 R   0x1

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn
   03     .init .plt .plt.got .text .fini
   04     .rodata .eh_frame_hdr .eh_frame
   05     .init_array .fini_array .dynamic .got .got.plt .data .bss
   06     .dynamic
   07     .note.gnu.property
   08     .note.gnu.build-id .note.ABI-tag
   09     .note.gnu.property
   10     .eh_frame_hdr
   11
   12     .init_array .fini_array .dynamic .got .got.plt
~/tmp/csapp/tmp $
</pre>
</div>

<ul class="org-ul">
<li>Type</li>
<li>Offset：目标文件中的偏移</li>
<li>VirtAddr/PhysAddr：内存地址</li>
<li>FileSiz：目标文件中段的大小</li>
<li>MemSiz：内存中段的大小</li>
<li>Flg：运行时访问权限</li>
<li>Align：对齐要求</li>
</ul>
</div>
</div>


<div id="outline-container-org1297139" class="outline-2">
<h2 id="org1297139"><span class="section-number-2">9.</span> 加载可执行目标文件</h2>
<div class="outline-text-2" id="text-9">
<p>
linux x86_64中，代码段从地址 0x400000 位置开始，后跟数据段。
</p>

<p>
用户栈地址总是从最大的合法地址开始（2<sup>48</sup> - 1）开始，向低地址扩展。
</p>
</div>
</div>


<div id="outline-container-orgd8a479f" class="outline-2">
<h2 id="orgd8a479f"><span class="section-number-2">10.</span> 动态链接共享库</h2>
<div class="outline-text-2" id="text-10">
<p>
动态库的编译： <code>gcc -shared -fpic ...</code> 。 <code>-fipc</code> 指示编译器生成位置无关的代码。
</p>


<dl class="org-dl">
<dt>.interp</dt><dd>可执行目标文件中有个 <code>.interp</code> 的节，包含了动态链接器的路径名。动态链接器本身就是个共享目标库（linux上为 ld-linux.so）。程序中有.interp时，控制权首先传递给动态加载器，由动态加载器执行重定位操作。</dd>
</dl>

<p>
动态链接器的工作：
</p>
<ul class="org-ul">
<li>重定位所有动态库的文本和数据到某个内存段</li>
<li>重定位可执行目标文件内对动态库符号的引用</li>
<li>将控制传递给应用程序</li>
</ul>
</div>
</div>


<div id="outline-container-orgc1f710c" class="outline-2">
<h2 id="orgc1f710c"><span class="section-number-2">11.</span> 从应用程序加载和链接共享库</h2>
<div class="outline-text-2" id="text-11">
<div class="org-src-container">
<pre class="src src-c">
<span style="color: #75715E;">/* </span><span style="color: #75715E;">Open the shared object FILE and map it in; return a handle that can be</span>
<span style="color: #75715E;">   passed to `dlsym' to get symbol values from it.</span><span style="color: #75715E;">  */</span>
<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E;">dlopen</span> (<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">__file</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__mode</span>) __THROWNL;

<span style="color: #75715E;">/* </span><span style="color: #75715E;">Unmap and close a shared object opened by `dlopen'.</span>
<span style="color: #75715E;">   The handle cannot be used again after calling `dlclose'.</span><span style="color: #75715E;">  */</span>
<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">dlclose</span> (<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">__handle</span>) <span style="color: #66D9EF;">__THROWNL</span> <span style="color: #A6E22E;">__nonnull</span> ((1));

<span style="color: #75715E;">/* </span><span style="color: #75715E;">Find the run-time address in the shared object HANDLE refers to</span>
<span style="color: #75715E;">   of the symbol called NAME.</span><span style="color: #75715E;">  */</span>
<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E;">dlsym</span> (<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">__restrict</span> __handle,
                    <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">__restrict</span> __name) <span style="color: #66D9EF;">__THROW</span> <span style="color: #A6E22E;">__nonnull</span> ((2));

<span style="color: #F92672;">#ifdef</span> __USE_GNU
<span style="color: #75715E;">/* </span><span style="color: #75715E;">Like `dlopen', but request object to be allocated in a new namespace.</span><span style="color: #75715E;">  */</span>
<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E;">dlmopen</span> (<span style="color: #66D9EF;">Lmid_t</span> <span style="color: #FD971F;">__nsid</span>, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">__file</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__mode</span>) __THROWNL;

<span style="color: #75715E;">/* </span><span style="color: #75715E;">Find the run-time address in the shared object HANDLE refers to</span>
<span style="color: #75715E;">   of the symbol called NAME with VERSION.</span><span style="color: #75715E;">  */</span>
<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E;">dlvsym</span> (<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">__restrict</span> __handle,
                     <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">__restrict</span> __name,
                     <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">__restrict</span> __version)
     <span style="color: #66D9EF;">__THROW</span> <span style="color: #A6E22E;">__nonnull</span> ((2, 3));
</pre>
</div>
</div>
</div>


<div id="outline-container-orgcddf279" class="outline-2">
<h2 id="orgcddf279"><span class="section-number-2">12.</span> 位置无关代码</h2>
<div class="outline-text-2" id="text-12">
<p>
可以加载而无需重定位的代码成为 <code>位置无关代码（Position-Indenpendent Code,PIC）</code> ，gcc的 -fPIC选项指示GNU编译系统生成PIC代码，共享库的编译必须使用该选项。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">addcnt</span> = 0;

<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">addvec</span>(<span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">x</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">y</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">z</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">n</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>;

        addcnt++;
        <span style="color: #F92672;">for</span> (i = 0; i &lt; n; i++) {
                z[i] = x[i] + y[i];
        }
}
</pre>
</div>

<p>
引用共享模块定义的外部过程和全局变量时，有一些特殊技巧：
</p>
<dl class="org-dl">
<dt>PIC数据引用</dt><dd>代码段和数据段中任何变量之间的距离都是一个常量，与其运行时的内存位置无关。编译器如何生成对全局变量PIC引用呢：在数据段开始的地方创建一个表，叫做全局偏移量表（GOT），GOT中每个被这个目标模块引用的全局数据目标（过程或全局变量）都有一个8字节的条目。编译器还为GOT中每个条目生成一个重定位记录。加载时，动态链接器会重定位GOT中的每个条目，使得包含目标的正确绝对地址。每个引用全局目标的目标模块都有自己的GOT。</dd>
</dl>



<div id="org60b9183" class="figure">
<p><img src="dot/link-pic-data.svg" alt="link-pic-data.svg" class="org-svg" />
</p>
</div>

<dl class="org-dl">
<dt>PIC函数调用</dt><dd>使用延迟绑定将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定通过两个结构实现： GOT和过程链接表（Procedure Linkage Table，PLT）。如果一个目标模块调用了定义在共享库中的任何函数，则该模块就有自己的GOT和PLT。GOT是数据段的一部分，PLT是代码段的一部分。

<dl class="org-dl">
<dt>过程链接表PLT</dt><dd>PLT是一个数组，其中每个条目是16字节代码。PLT[0]是个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目负责调用一个具体的函数。PLT[1]调用系统启动函数（__libc_start_main），它初始化执行环境，调用main函数并处理其返回值。从PLT[2]开始的条目调用用户代码调用的函数。</dd>
<dt>全局偏移量表GOT</dt><dd>GOT是一个数组，其中每个条目是个8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。例如，GOT[4]和PLT[2]对应于addvec。初始时，每个GOT条目都指向对应PLT条目的第二条指令。</dd>
</dl></dd>
</dl>


<div id="org0b824ca" class="figure">
<p><img src="dot/link-pic-func.svg" alt="link-pic-func.svg" class="org-svg" />
</p>
</div>
</div>
</div>


<div id="outline-container-org97dff9e" class="outline-2">
<h2 id="org97dff9e"><span class="section-number-2">13.</span> 库打桩机制</h2>
<div class="outline-text-2" id="text-13">
<p>
库打桩（library interpositioning）机制 可以用来截获对共享库的调用，而执行自己的代码。例如追踪对某个特殊库函数的调用次数，验证和追踪其输入和输出值，或者替换为另一种实现方式。
</p>

<p>
基本思想：给定一个需要打桩的目标函数，创建一个包装函数，其原型和目标函数完全一致。使用某种特殊的打桩机制，可以欺骗系统调用包装函数而非库函数。包装函数通常执行自身的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。
</p>

<p>
打桩可以发生在编译时、链接时、程序被加载执行的运行时。
</p>

<p>
以下使用libc.so中的malloc和free函数进行演示。
</p>
</div>



<div id="outline-container-orge7a2302" class="outline-3">
<h3 id="orge7a2302"><span class="section-number-3">13.1.</span> 编译时打桩</h3>
<div class="outline-text-3" id="text-13-1">
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #E6DB74;">/** int.c */</span>
<span style="color: #F92672;">  #include</span> <span style="color: #E6DB74;">&lt;stdio.h&gt;</span>
<span style="color: #F92672;">  #include</span> <span style="color: #E6DB74;">&lt;malloc.h&gt;</span>

  <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">main</span>()
  {
          <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">p</span> = malloc(32);
          free(p);
          <span style="color: #F92672;">return</span> 0;
  }
<span style="color: #75715E;">/*************************************************************/</span>

  <span style="color: #E6DB74;">/** malloc.h */</span>
<span style="color: #F92672;">  #define</span> <span style="color: #A6E22E;">malloc</span>(<span style="color: #FD971F;">size</span>) mymalloc(size)
<span style="color: #F92672;">  #define</span> <span style="color: #A6E22E;">free</span>(<span style="color: #FD971F;">ptr</span>) myfree(ptr)

  <span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E;">mymalloc</span>(<span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">size</span>);
  <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">myfree</span>(<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">ptr</span>);
<span style="color: #75715E;">/*************************************************************/</span>

  <span style="color: #E6DB74;">/** malloc.c */</span>
<span style="color: #F92672;">  #ifdef</span> COMPILETIME
<span style="color: #F92672;">  #include</span> <span style="color: #E6DB74;">&lt;stdio.h&gt;</span>
<span style="color: #F92672;">  #include</span> <span style="color: #E6DB74;">&lt;malloc.h&gt;</span>

  <span style="color: #E6DB74;">/** malloc&#21253;&#35013;&#20989;&#25968; */</span>
  <span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E;">mymalloc</span>(<span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">size</span>)
  {
          <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">ptr</span> = malloc(size);
          printf(<span style="color: #E6DB74;">"malloc(%d)=%p\n"</span>, (<span style="color: #66D9EF;">int</span>)size, ptr);
          <span style="color: #F92672;">return</span> ptr;
  }
  <span style="color: #E6DB74;">/** free&#21253;&#35013;&#20989;&#25968; */</span>
  <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">myfree</span>(<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">ptr</span>)
  {
          free(ptr);
          printf(<span style="color: #E6DB74;">"free(%d)\n"</span>, ptr);
  }
<span style="color: #F92672;">  #endif</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">$ gcc -DCOMPILETIME -c mymalloc.c
$ gcc -I. -o intc int.c mymalloc.o
</pre>
</div>

<p>
由于使用了 <code>-I.</code> 参数，所以先在当前目录执行查找头文件，所以会执行打桩。
</p>
</div>
</div>


<div id="outline-container-org251bd23" class="outline-3">
<h3 id="org251bd23"><span class="section-number-3">13.2.</span> 链接时打桩</h3>
<div class="outline-text-3" id="text-13-2">
<p>
linux 静态链接器支持使用 <code>--wrap f</code> 标志进行链接时打桩。这个标志告诉链接器，把对符号 <code>f</code> 的引用解析成 <code>__wrap_f</code> ，还要把对符号 <code>__real_f</code> 的引用解析为 <code>f</code> 。
</p>

<div class="org-src-container">
<pre class="src src-c">  <span style="color: #E6DB74;">/** int.c */</span>
<span style="color: #F92672;">  #include</span> <span style="color: #E6DB74;">&lt;stdio.h&gt;</span>
<span style="color: #F92672;">  #include</span> <span style="color: #E6DB74;">&lt;malloc.h&gt;</span>

  <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">main</span>()
  {
          <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">p</span> = malloc(32);
          free(p);
          <span style="color: #F92672;">return</span> 0;
  }
<span style="color: #75715E;">/*************************************************************/</span>
  <span style="color: #E6DB74;">/** mymalloc.c */</span>
<span style="color: #F92672;">  #ifdef</span> LINKTIME
<span style="color: #F92672;">  #include</span> <span style="color: #E6DB74;">&lt;stdio.h&gt;</span>

  <span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E;">__real_malloc</span>(<span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">size</span>);
  <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">__real_free</span>(<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">ptr</span>);

  <span style="color: #E6DB74;">/** malloc&#21253;&#35013;&#20989;&#25968; */</span>
  <span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E;">__wrap_malloc</span>(<span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">size</span>)
  {
          <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">ptr</span> = __real_malloc(size);
          printf(<span style="color: #E6DB74;">"malloc(%d)=%p\n"</span>, (<span style="color: #66D9EF;">int</span>)size, ptr);
          <span style="color: #F92672;">return</span> ptr;
  }

  <span style="color: #E6DB74;">/** free&#21253;&#35013;&#20989;&#25968; */</span>
  <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">__wrap_free</span>(<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">ptr</span>)
  {
          __real_free(ptr);
          printf(<span style="color: #E6DB74;">"free(%d)\n"</span>, ptr);
  }
<span style="color: #F92672;">  #endif</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">$ gcc -DLINKTIME -c mymalloc.c
$ gcc -c int.c
$ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o
</pre>
</div>

<p>
<code>-Wl,option</code> 标志将option传递给链接器。 <code>option</code> 中的每个逗号都要替换为一个空格。所以 <code>-Wl,--wrap,malloc</code> 会将 <code>--wrap malloc</code> 传递给链接器。
</p>
</div>
</div>


<div id="outline-container-org48a65ce" class="outline-3">
<h3 id="org48a65ce"><span class="section-number-3">13.3.</span> 运行时打桩</h3>
<div class="outline-text-3" id="text-13-3">
<p>
编译时打桩需要能够访问程序的源代码。
</p>

<p>
链接时打桩需要能够访问程序的可重定位对象文件。
</p>

<p>
运行时打桩则基于动态链接器的 <code>LD_PRELOAD</code> 环境变量。
</p>

<p>
如果 <code>LD_PRELOAD</code> 环境变量被设置为一个共享库路径名的列表（以空格或分号分隔），那么当加载和执行一个程序，需要解析未定义的引用时，动态链接器（ld-linux.so）会先搜索 <code>LD_PRELOAD</code> 库，然后才搜索其他的库。通过这个机制，可以对任何共享库中的任何函数打桩。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/** int.c */</span>
<span style="color: #F92672;">#include</span> <span style="color: #E6DB74;">&lt;stdio.h&gt;</span>
<span style="color: #F92672;">#include</span> <span style="color: #E6DB74;">&lt;malloc.h&gt;</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">main</span>()
{
        <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">p</span> = malloc(32);
        free(p);
        <span style="color: #F92672;">return</span> 0;
}
<span style="color: #75715E;">/*************************************************************/</span>
<span style="color: #E6DB74;">/** mymalloc.c */</span>
<span style="color: #F92672;">#ifdef</span> RUNTIME
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">_GNU_SOURCE</span>
<span style="color: #F92672;">#include</span> <span style="color: #E6DB74;">&lt;stdio.h&gt;</span>
<span style="color: #F92672;">#include</span> <span style="color: #E6DB74;">&lt;stdlib.h&gt;</span>
<span style="color: #F92672;">#include</span> <span style="color: #E6DB74;">&lt;dlfcn.h&gt;</span>

<span style="color: #E6DB74;">/** malloc&#21253;&#35013;&#20989;&#25968; */</span>
<span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E;">malloc</span>(<span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">size</span>)
{
        <span style="color: #66D9EF;">void</span> *(*<span style="color: #A6E22E;">mallocp</span>)(<span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">size</span>);
        <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">error</span>;

        <span style="color: #E6DB74;">/** &#33719;&#21462;libc&#20013;malloc&#20989;&#25968;&#30340;&#22320;&#22336; */</span>
        mallocp = dlsym(RTLD_NEXT, <span style="color: #E6DB74;">"malloc"</span>);
        <span style="color: #F92672;">if</span> ((error = dlerror()) != <span style="color: #AE81FF;">NULL</span>) {
                fputs(error, stderr);
                exit(1);
        }

        <span style="color: #E6DB74;">/** &#35843;&#29992;libc&#30340;malloc */</span>
        <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">ptr</span> = mallocp(size);
        printf(<span style="color: #E6DB74;">"malloc(%d)=%p\n"</span>, (<span style="color: #66D9EF;">int</span>)size, ptr);
        <span style="color: #F92672;">return</span> ptr;
}

<span style="color: #E6DB74;">/** free&#21253;&#35013;&#20989;&#25968; */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">__wrap_free</span>(<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">ptr</span>)
{
        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">freep</span>)(<span style="color: #66D9EF;">void</span>*) = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">error</span>;

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>ptr)
                <span style="color: #F92672;">return</span>;

        freep = dlsym(RTLD_NEXT, <span style="color: #E6DB74;">"free"</span>);
        <span style="color: #F92672;">if</span> ((error = dlerror()) != <span style="color: #AE81FF;">NULL</span>) {
                fputs(error, stderr);
                exit(1);
        }

        freep(ptr);
        printf(<span style="color: #E6DB74;">"free(%d)\n"</span>, ptr);
}
<span style="color: #F92672;">#endif</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-sh">$ gcc -DRUNTIME -shared -fpic -o malloc.so myalloc.c -ldl <span style="color: #75715E;"># </span><span style="color: #75715E;">&#32534;&#35793;&#24211;</span>
$ gcc -o intr int.c  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#32534;&#35793;&#20027;&#31243;&#24207;</span>
$ <span style="color: #FD971F;">LD_PRELOAD</span>=<span style="color: #E6DB74;">"./mymalloc.so"</span> ./intr   <span style="color: #75715E;"># </span><span style="color: #75715E;">&#25191;&#34892;</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org14eb716" class="outline-2">
<h2 id="org14eb716"><span class="section-number-2">14.</span> 处理目标文件的工具</h2>
<div class="outline-text-2" id="text-14">
<ul class="org-ul">
<li>AR：创建静态库，插入、删除、列出、提取成员</li>
<li>STRINGS：列出一个目标文件中所有可打印的字符串</li>
<li>STRIP：从目标文件中删除符号表信息</li>
<li>NM：列出一个目标文件的符号表中定义的符号</li>
<li>SIZE：列出目标文件中section（节）的名字和大小</li>
<li>READELF：显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能。</li>
<li>OBJDUMP：所有二进制工具之母。能够显示一个目标文件中所有的信息。其最大作用的反汇编.text节中的二进制指令。</li>
<li>LDD：列出一个可执行文件在运行时所需要的共享库。</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:54</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
