<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BPF和XDP技术学习</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">BPF和XDP技术学习</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org75def23">1. BPF基础</a>
<ul>
<li><a href="#orgd64f74c">1.1. 指令集</a></li>
<li><a href="#org0c6a04e">1.2. 辅助函数</a></li>
<li><a href="#orged6b0f9">1.3. 映射</a></li>
<li><a href="#org99561cf">1.4. 对象的固定</a></li>
<li><a href="#orgcdcc2f0">1.5. 尾调用</a></li>
<li><a href="#org6ebcb1c">1.6. BPF到BPF的调用</a></li>
<li><a href="#org4d1bf74">1.7. JIT</a></li>
<li><a href="#org12d0b43">1.8. Hardening</a></li>
<li><a href="#org7e63eab">1.9. Offload</a></li>
<li><a href="#org97c63f3">1.10. BPF sysctls</a></li>
</ul>
</li>
<li><a href="#orgd1dabbd">2. 开发工具</a>
<ul>
<li><a href="#orge1de17e">2.1. 开发环境</a></li>
<li><a href="#orgf7d96ce">2.2. 内核编译</a></li>
<li><a href="#org7f3eb03">2.3. 配置验证</a></li>
<li><a href="#org0f88eca">2.4. 编译iproute2</a></li>
<li><a href="#orgc8238a4">2.5. 编译bpftool</a></li>
<li><a href="#org8021091">2.6. LLVM</a></li>
<li><a href="#orge1b53d4">2.7. iproute2</a></li>
</ul>
</li>
<li><a href="#org8b1678a">3. 调试及测试</a>
<ul>
<li><a href="#orgcc3de05">3.1. bpftool</a></li>
<li><a href="#orga0ab273">3.2. 内核测试</a></li>
<li><a href="#org42fe0d6">3.3. JIT调试</a></li>
<li><a href="#org634ab2f">3.4. Introspection</a></li>
<li><a href="#org89ae70c">3.5. Tracing pipe</a></li>
<li><a href="#org96ceaf3">3.6. 其他</a></li>
</ul>
</li>
<li><a href="#orge705041">4. BPF程序类型</a>
<ul>
<li><a href="#orgcc114d1">4.1. XDP</a>
<ul>
<li><a href="#org385ea4f">4.1.1. XDP程序的 <code>action code</code></a></li>
<li><a href="#org9b5c7c7">4.1.2. XDP用例</a></li>
<li><a href="#org489818e">4.1.3. XDP的执行模式</a></li>
<li><a href="#orgadfdc0c">4.1.4. Driver支持情况</a>
<ul>
<li><a href="#org4e50091">4.1.4.1. 支持 <code>native XDP</code> 的驱动</a></li>
</ul>
</li>
<li><a href="#orgc4620f9">4.1.5. 支持 <code>offloaded XDP</code> 的驱动</a></li>
</ul>
</li>
<li><a href="#org83cee3c">4.2. tc (traffic control)</a>
<ul>
<li><a href="#org43d8b2f">4.2.1. tc BPF程序返回值</a></li>
<li><a href="#org0275c63">4.2.2. tc BPF FAQ</a></li>
<li><a href="#orgb764870">4.2.3. tc BPF的用例</a></li>
<li><a href="#org3f37947">4.2.4. Driver support</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org30cf25d">5. 进一步阅读</a>
<ul>
<li><a href="#org026072a">5.1. Kernel Developer FAQ</a></li>
<li><a href="#orgbbca3a2">5.2. Projects using BPF</a>
<ul>
<li><a href="#org7f0649a">5.2.1. Tracing</a></li>
<li><a href="#org49c2cbb">5.2.2. Networking</a></li>
<li><a href="#org3f32686">5.2.3. Others</a></li>
</ul>
</li>
<li><a href="#orga696022">5.3. XDP Newbies</a></li>
<li><a href="#orgdef357e">5.4. BPF Newsletter</a></li>
<li><a href="#orgf0d3cdb">5.5. Podcasts</a></li>
<li><a href="#orgab25612">5.6. Blog posts</a></li>
<li><a href="#org4164127">5.7. Books</a></li>
<li><a href="#orgc35bf12">5.8. Talks</a></li>
<li><a href="#org1b3d5fd">5.9. Further Documents</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org75def23" class="outline-2">
<h2 id="org75def23"><span class="section-number-2">1.</span> BPF基础</h2>
<div class="outline-text-2" id="text-1">
<p>
BPF提供了自定义的指令集，同时提供了一些高效的映射（键值存储）结构、辅助函数、尾调用、伪文件系统（用来保持对map、program对象的锁定），以及支持将BPF卸载到硬件（例如网卡）。
</p>

<p>
XDP的BPF程序用于挂载到网络驱动的早期阶段，当有数据包接收时，触发BPF程序执行，由于此时数据包还没有被软件处理，所以此时可以获得最优的包处理性能。与此同时，由于此时网络堆栈还未进行处理，数据包相关的元数据还未被提取。
</p>

<p>
tc的BPF程序则晚于网络堆栈执行，可以访问更多的元数据，以及核心的内核功能。
</p>

<p>
除了tc和XDP使用BPF外，tracing也使用了BPF，例如kprobes、uprobes、tracepoints等等。
</p>
</div>


<div id="outline-container-orgd64f74c" class="outline-3">
<h3 id="orgd64f74c"><span class="section-number-3">1.1.</span> 指令集</h3>
<div class="outline-text-3" id="text-1-1">
<p>
BPF是通用的RISC指令集，其目的是用于使用C子集编写程序，并通过编译器后端（例如LLVM）编译为BPF指令，以便于内核通过内置的JIT编译器映射为本机操作码，以使其执行的性能最优。
</p>

<p>
将指令映射到内核内部执行的优点如下：
</p>
<ul class="org-ul">
<li>使得内核可编程而无需在内核和用户态切换。例如Cilium，可以实现灵活的容器策略、负载均衡，并且无需将数据包在用户态和内核态来回传递。BPF程序之前可以通过maps共享状态，也可以在内核和用户空间之间共享。</li>
<li>鉴于可编程数据路径的灵活性，可以通过编译程序去除不必要的功能，达到更好的性能。例如，容器不需要ipv4时，可以使BPF程序只处理IPv6，以节省资源。</li>
<li>在网络场景下（tc及XDP），BPF程序可以实现原子更新，并不需要重启内核以及系统服务或者容器，且不会中断流量。并且在更新过程中，可以通过BPF maps维护程序状态。</li>
<li>BPF为用户空间提供了稳定的ABI，且不依赖任何第三方内核模块。</li>
<li>BPF程序与内核协同工作，并使用内核现有的设施，例如驱动、网络设备、socket，还有工具链（iproute2），同时内核提供了安全保障。内核通过内置的验证器进行验证，以保证BPF程序不会破坏内核，且能够结束。</li>
</ul>

<p>
BPF程序的执行始终是通过事件触发的：
</p>
<ul class="org-ul">
<li>BPF挂载到网络设备的输入路径时，一旦接收到数据包就会触发执行BPF程序。</li>
<li>BPF程序通过kprobe对内核地址进行插桩时，一旦该地址对应的代码执行时，会调用kprobe的callback，然后执行BPF程序。</li>
</ul>


<p>
BPF包含11个64位寄存器以及32位子寄存器，一个程序计数器以及512字节大小的BPF栈。寄存器为 R0-R10。寄存器默认操作模式为64位，只有通过特殊的ALU操作时才会访问32为子寄存器。
</p>
<ul class="org-ul">
<li>r0 包含辅助函数的返回值</li>
<li>r1 - r5 保存BPF程序的向kernel辅助函数传递的参数</li>
<li>r6 - r9 由被调用者保存的寄存器。</li>
</ul>

<p>
BPF调用惯例可以直接映射为x86_64、arm64以及其他的ABI，因此所有BPF寄存器可以一对一的映射到CPU硬件寄存器，JIT仅仅需要执行一条call指令而无需执行额外的参数移动。当前暂不支持6个及以上参数的调用。为了此调用惯例，BPF定义的专用的辅助函数 <code>BPF_CALL_0()</code> &#x2013; <code>BPF_CALL_5()</code> 。
</p>

<p>
BPF程序进入执行时，r1寄存器保存了程序的上下文（也即程序的参数，类似C语言的 argc，argv）。BPF程序被限制为只能运行在单独的上下文中，该上下文由程序类型定义。例如网络程序使用skb作为程序参数。
</p>

<p>
从5.1内核开始，BPF最大指令数限制为100万条。BPF验证器禁止循环，以保证程序可以结束。
</p>

<p>
尾调用表示BPF程序可以调用另一个BPF程序执行，最多可以嵌入33个尾调用。尾调用通常用于将程序的逻辑拆分为不同阶段。
</p>


<p>
BPF有两种指令编码方式：
</p>
<ul class="org-ul">
<li>基础指令编码：使用64比特位进行编码</li>
<li>宽指令编码：基础指令编码后跟64为立即操作数，总共128比特。</li>
</ul>

<p>
MSB：最高有效位，LSB：最低有效位。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">32 bits (MSB)</th>
<th scope="col" class="org-left">16 bits</th>
<th scope="col" class="org-left">4 bits</th>
<th scope="col" class="org-left">4 bits</th>
<th scope="col" class="org-left">8 bits(LSB)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">imm</td>
<td class="org-left">off</td>
<td class="org-left">src_reg</td>
<td class="org-left">dst_reg</td>
<td class="org-left">op</td>
</tr>
</tbody>
</table>

<p>
<code>op</code> 定义实际执行的操作。 <code>src_reg</code> 和 <code>dst_reg</code> 描述实际操作使用的寄存器操作数。 <code>off</code> 用于相对偏移。 <code>imm</code> 包含立即操作数。
</p>


<p>
大部分指令不会使用全部的字段，未使用的字段应当清零。
</p>

<p>
<code>op</code> 可以划分为不同的指令类型。 <code>op</code> 被编码为三部分：指令类型， source（描述源操作数是寄存器还是立即数），以及描述指令类中特定操作的操作码。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">4 bits(MSB)</th>
<th scope="col" class="org-left">1 bit</th>
<th scope="col" class="org-left">3 bits(LSB)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">operation code</td>
<td class="org-left">source</td>
<td class="org-left">instruction class</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">instruction class</th>
<th scope="col" class="org-right">value</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">BPF_LD</td>
<td class="org-right">0x00</td>
<td class="org-left">不常用的加载操作</td>
</tr>

<tr>
<td class="org-left">BPF_LDX</td>
<td class="org-right">0x01</td>
<td class="org-left">加载到寄存器</td>
</tr>

<tr>
<td class="org-left">BPF_ST</td>
<td class="org-right">0x02</td>
<td class="org-left">将立即数存储到内存</td>
</tr>

<tr>
<td class="org-left">BPF_STX</td>
<td class="org-right">0x03</td>
<td class="org-left">从寄存器存储到内存</td>
</tr>

<tr>
<td class="org-left">BPF_ALU</td>
<td class="org-right">0x04</td>
<td class="org-left">32位的算术操作</td>
</tr>

<tr>
<td class="org-left">BPF_JMP</td>
<td class="org-right">0x05</td>
<td class="org-left">64位跳转操作</td>
</tr>

<tr>
<td class="org-left">BPF_JMP32</td>
<td class="org-right">0x06</td>
<td class="org-left">32位跳转操作</td>
</tr>

<tr>
<td class="org-left">BPF_ALU64</td>
<td class="org-right">0x07</td>
<td class="org-left">64位算术操作</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">source</th>
<th scope="col" class="org-right">value</th>
<th scope="col" class="org-left">dexcription</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">BPF_K</td>
<td class="org-right">0x00</td>
<td class="org-left">使用32位立即数作为源操作数</td>
</tr>

<tr>
<td class="org-left">BPF_X</td>
<td class="org-right">0x08</td>
<td class="org-left">使用 source register作为源操作数</td>
</tr>
</tbody>
</table>

<p>
所有的BPF处理都通过 <code>bpf()</code> 系统调用完成，例如加载BPF程序，创建映射。 <code>bpf()</code> 系统调用也用于映射的管理，包括添加、删除、查找等。
</p>
</div>
</div>

<div id="outline-container-org0c6a04e" class="outline-3">
<h3 id="org0c6a04e"><span class="section-number-3">1.2.</span> 辅助函数</h3>
<div class="outline-text-3" id="text-1-2">
<p>
BPF程序类型不同，能够使用辅助函数也不同。
</p>

<p>
每个帮助函数都使用类似系统调用的通用共享函数签名实现。签名定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">u64</span> <span style="color: #87D700;">fn</span>(<span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">r1</span>, <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">r2</span>, <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">r3</span>, <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">r4</span>, <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">r5</span>)
</pre>
</div>

<p>
内核将辅助函数抽象为宏定义： <code>BPF_CALL_0()</code> 到 <code>BPF_CALL_5()</code> 。
</p>

<p>
以下是一个从映射中更新对应条目的辅助函数定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #87D700;">BPF_CALL_4</span>(bpf_map_update_elem, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">bpf_map</span> *, map, <span style="color: #5FD7FF;">void</span> *, key,
           <span style="color: #5FD7FF;">void</span> *, value, u64, flags)
{
        WARN_ON_ONCE(<span style="color: #CDC673; font-weight: bold;">!</span>rcu_read_lock_held());
        <span style="color: #FF1493;">return</span> map-&gt;ops-&gt;map_update_elem(map, key, value, flags);
}

<span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">bpf_func_proto</span> <span style="color: #FF8C00;">bpf_map_update_elem_proto</span> = {
        .func           = bpf_map_update_elem,
        .gpl_only       = <span style="color: #AF87FF;">false</span>,
        .ret_type       = RET_INTEGER,
        .arg1_type      = ARG_CONST_MAP_PTR,
        .arg2_type      = ARG_PTR_TO_MAP_KEY,
        .arg3_type      = ARG_PTR_TO_MAP_VALUE,
        .arg4_type      = ARG_ANYTHING,
};

</pre>
</div>

<p>
通过这种方法，eBPF中添加的辅助函数都可以被JIT透明高效的编译，也就是说JIT编译器只需要发出调用指令，由于BPF寄存器和底层架构的调用惯例相匹配，可以直接映射。
</p>
</div>
</div>

<div id="outline-container-orged6b0f9" class="outline-3">
<h3 id="orged6b0f9"><span class="section-number-3">1.3.</span> 映射</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Map是BPF中高效的键值存储结构，位于内核空间。调用多个BPF程序时，可以通过Map维护状态。用户空间可以通过文件描述符来访问Map结构，并且可以与其他BPF程序或者应用程序共享。
</p>

<p>
不同的程序类型之间也可以共享Map。
</p>

<p>
根据可以存储数据的类型可以将Map分为两大类：普通Map和特殊Map。普通Map可以存储任意的数据类型；特殊Map则只能存储固定的类型。
</p>
<ul class="org-ul">
<li>普通Map：BPF_MAP_TYPE_HASH, BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_HASH, BPF_MAP_TYPE_PERCPU_ARRAY, BPF_MAP_TYPE_LRU_HASH, BPF_MAP_TYPE_LRU_PERCPU_HASH and BPF_MAP_TYPE_LPM_TRIE。</li>
<li>特殊Map：BPF_MAP_TYPE_PROG_ARRAY, BPF_MAP_TYPE_PERF_EVENT_ARRAY, BPF_MAP_TYPE_CGROUP_ARRAY, BPF_MAP_TYPE_STACK_TRACE, BPF_MAP_TYPE_ARRAY_OF_MAPS, BPF_MAP_TYPE_HASH_OF_MAPS。</li>
</ul>
</div>
</div>

<div id="outline-container-org99561cf" class="outline-3">
<h3 id="org99561cf"><span class="section-number-3">1.4.</span> 对象的固定</h3>
<div class="outline-text-3" id="text-1-4">
<p>
当前，BPF的Map以及程序只能通过文件描述符访问，文件描述符又只存在于进程的生命周期，进程终止后则无法访问。例如，tc和XDP将程序加载到内核后，自行终止，此时无法再次访问对应文件描述符。 为了解决该问题，内核实现了一个迷你文件系统，用于将Map和程序对应的fd“钉”在该文件系统，并且提供了两个新指令，BPF_OBJ_PIN 和 BPF_OBJ_GET。
</p>

<p>
tc中会经常用到这种机制，例如在 ingress 和 egress 之间共享Map。
</p>
</div>
</div>


<div id="outline-container-orgcdcc2f0" class="outline-3">
<h3 id="orgcdcc2f0"><span class="section-number-3">1.5.</span> 尾调用</h3>
<div class="outline-text-3" id="text-1-5">
<p>
尾调用允许一个BPF程序调用其他的BPF程序，并且不会返回到之前的BPF程序中。尾调用相对于函数来说，开销很小，通过long jump的方式实现。
</p>

<p>
只有相同类型的BPF程序之间才可以执行尾调用，并且必须都是通过JIT编译执行，或者都是通过解释器执行。
</p>

<p>
执行尾调用涉及两部分内容：
</p>
<ol class="org-ol">
<li>初始化 BPF_MAP_TYPE_PROG_ARRAY 类型的MAP，用于存储用于尾调用的BPF程序的文件描述符。</li>
<li>调用 bpf_tail_call() 函数，并传递上下文以及尾调用BPF程序的查找key。</li>
</ol>

<p>
如果没有找到对应的尾调用程序时，执行流会返回到发起尾调用的下一条指令（原程序的bpf_tail_call()的下一条指令）。
</p>
</div>
</div>


<div id="outline-container-org6ebcb1c" class="outline-3">
<h3 id="org6ebcb1c"><span class="section-number-3">1.6.</span> BPF到BPF的调用</h3>
<div class="outline-text-3" id="text-1-6">
<p>
除了BPF辅助函数和尾调用，还实现了BPF到BPF的调用。
</p>

<p>
在没有引入该机制之前，要重用代码，则需要通过使用always_inline，编译器则会将所有代码展开：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">&lt;linux/bpf.h&gt;</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __section
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">__section</span>(<span style="color: #FF8C00;">NAME</span>)                  \
   <span style="color: #FF1493;">__attribute__</span>((section(NAME), used))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __inline
<span style="color: #FF1493;"># define</span> <span style="color: #FF8C00;">__inline</span>                         \
   <span style="color: #FF1493;">inline</span> <span style="color: #FF1493;">__attribute__</span>((always_inline))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">static</span> __inline <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">foo</span>(<span style="color: #5FD7FF;">void</span>)
{
    <span style="color: #FF1493;">return</span> XDP_DROP;
}

__section(<span style="color: #CDC673;">"prog"</span>)
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">xdp_drop</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">xdp_md</span> *<span style="color: #FF8C00;">ctx</span>)
{
    <span style="color: #FF1493;">return</span> foo();
}

<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">__license</span>[] __section(<span style="color: #CDC673;">"license"</span>) = <span style="color: #CDC673;">"GPL"</span>;
</pre>
</div>

<p>
之所以如此，是由于BPF加载器、验证器、JIT以及解释器都不支持函数调用。
</p>


<p>
从4.16内核和 LLVM 6.0开始，则不再需要使用always_inline。 例如：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">&lt;linux/bpf.h&gt;</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __section
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">__section</span>(<span style="color: #FF8C00;">NAME</span>)                  \
   <span style="color: #FF1493;">__attribute__</span>((section(NAME), used))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">foo</span>(<span style="color: #5FD7FF;">void</span>)
{
    <span style="color: #FF1493;">return</span> XDP_DROP;
}

__section(<span style="color: #CDC673;">"prog"</span>)
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">xdp_drop</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">xdp_md</span> *<span style="color: #FF8C00;">ctx</span>)
{
    <span style="color: #FF1493;">return</span> foo();
}

<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">__license</span>[] __section(<span style="color: #CDC673;">"license"</span>) = <span style="color: #CDC673;">"GPL"</span>;
</pre>
</div>

<p>
当前，x86_64和arm64的BPF JIT编译器已经支持BPF到BPF调用。这种机制大大减少了BPF代码大小，对于性能的优化以及CPU指令缓存都有重要意义。
</p>

<p>
每个调用帧允许最多8个BPF到BPF调用的嵌套。
</p>

<p>
BPF JIT 编译器为每个函数体生成单独的映像，在最终的JIT过程中再对函数体中的地址进行修复。
</p>

<p>
在Linux 5.10中，实现了bpf2bpf和尾调用的互相调用。由于互相调用存在堆栈溢出的风险，所以内核限制每个bpf2bpf调用可用的栈大小为256字节（内核检测到bpf2bpf调用时，也会将主函数视为bpf2bpf调用）。有了这个限制，BPF调用链最多消耗8KB的空间（256Bytes * 32尾调用）。
</p>
</div>
</div>


<div id="outline-container-org4d1bf74" class="outline-3">
<h3 id="org4d1bf74"><span class="section-number-3">1.7.</span> JIT</h3>
<div class="outline-text-3" id="text-1-7">
<p>
检测内核是否支持 eBPF JIT：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ git grep HAVE_EBPF_JIT arch/
arch/arm/Kconfig:       select HAVE_EBPF_JIT if <span style="color: #CDC673; font-weight: bold;">!</span>CPU_ENDIAN_BE32
arch/arm64/Kconfig:     select HAVE_EBPF_JIT
arch/loongarch/Kconfig: select HAVE_EBPF_JIT
arch/mips/Kconfig:      select HAVE_EBPF_JIT if <span style="color: #CDC673; font-weight: bold;">!</span>CPU_MICROMIPS
arch/parisc/Kconfig:    select HAVE_EBPF_JIT
arch/powerpc/Kconfig:   select HAVE_EBPF_JIT
arch/riscv/Kconfig:     select HAVE_EBPF_JIT if MMU
arch/s390/Kconfig:      select HAVE_EBPF_JIT if HAVE_MARCH_Z196_FEATURES
arch/sparc/Kconfig:     select HAVE_EBPF_JIT if SPARC64
arch/x86/Kconfig:       select HAVE_EBPF_JIT
</pre>
</div>

<p>
开启 BPF JIT：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo 1 &gt; /proc/sys/net/core/bpf_jit_enable</span>
</pre>
</div>

<p>
JIT 编译器的优势：
</p>
<ul class="org-ul">
<li>执行效率要比解释器高。</li>
<li>通常情况下所有指令都可以一对一的映射到本地指令。</li>
<li>生成的可执行映像更小，对CPU指令缓存更友好。</li>
</ul>
</div>
</div>

<div id="outline-container-org12d0b43" class="outline-3">
<h3 id="org12d0b43"><span class="section-number-3">1.8.</span> Hardening</h3>
<div class="outline-text-3" id="text-1-8">
<p>
在BPF程序的生命周期内，BPF会将解释器映像或者JIT编译的映像锁定为只读，防止代码被破坏。
</p>

<p>
检测不同的架构是否支持将BPF程序映像内存设置为只读：
</p>
<div class="org-src-container">
<pre class="src src-sh">  $ git grep ARCH_HAS_SET_MEMORY | grep select
arch/arm/Kconfig:       select ARCH_HAS_SET_MEMORY
arch/arm64/Kconfig:     select ARCH_HAS_SET_MEMORY
arch/powerpc/Kconfig:   select ARCH_HAS_SET_MEMORY
arch/riscv/Kconfig:     select ARCH_HAS_SET_MEMORY if MMU
arch/s390/Kconfig:      select ARCH_HAS_SET_MEMORY
arch/x86/Kconfig:       select ARCH_HAS_SET_MEMORY
</pre>
</div>

<p>
CONFIG_ARCH_HAS_SET_MEMORY选项不可配置，所以该保护总是生效的。
</p>

<p>
对于x86_64 JIT编译器，如果开启了CONFIG_RETPOLINE选项，JIT会使用retpoline实现尾调用发起的间接跳转。
</p>

<p>
<code>/proc/sys/net/core/bpf_jit_harden</code> 设置为1时，非特权用户的JIT编译会增加额外的强化步骤。这可以防止来自不受信任的用户的攻击，同时也会牺牲部分性能。
</p>

<p>
启用 <code>bpf_jit_harden</code> 后， JIT编译器会屏蔽BPF程序中的 32bit 或 64bit 常量，以防止 <code>JIT spraying attacks</code> （将本机操作码通过imm注入）。由于这些立即数驻留在内核的可执行内存中，如果由于内核错误导致跳转到立即数的起始位置后，将会执行这些操作码（imm）。
</p>

<p>
<code>JIT constant blinding</code> 会将指令中的常量随机化，也就是说，源操作数为立即数的操作指令 会被透明的重写为 源操作数为寄存器的操作指令。例如，实际的load操作被拆分为两步：
</p>
<ol class="org-ol">
<li>将imm与随机数进行 ‘^’ 操作后加载到寄存器</li>
<li>将寄存器和随机数再次执行 ‘^’ 操作后，将原先的imm恢复到寄存器中，用于后续操作。</li>
</ol>

<p>
关闭 <code>bpf_jit_harden</code> 时：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo 0 &gt; /proc/sys/net/core/bpf_jit_harden</span>

ffffffffa034f5e9 + &lt;x&gt;:
[...]
39:   mov    $<span style="color: #FF8C00;">0</span>xa8909090,%eax
3e:   mov    $<span style="color: #FF8C00;">0</span>xa8909090,%eax
43:   mov    $<span style="color: #FF8C00;">0</span>xa8ff3148,%eax
48:   mov    $<span style="color: #FF8C00;">0</span>xa89081b4,%eax
4d:   mov    $<span style="color: #FF8C00;">0</span>xa8900bb0,%eax
52:   mov    $<span style="color: #FF8C00;">0</span>xa810e0c1,%eax
57:   mov    $<span style="color: #FF8C00;">0</span>xa8908eb4,%eax
5c:   mov    $<span style="color: #FF8C00;">0</span>xa89020b0,%eax
[...]
</pre>
</div>

<p>
开启 <code>bpf_jit_harden</code> 后：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo 1 &gt; /proc/sys/net/core/bpf_jit_harden</span>

ffffffffa034f1e5 + &lt;x&gt;:
[...]
39:   mov    $<span style="color: #FF8C00;">0</span>xe1192563,%r10d
3f:   xor    $<span style="color: #FF8C00;">0</span>x4989b5f3,%r10d
46:   mov    %r10d,%eax
49:   mov    $<span style="color: #FF8C00;">0</span>xb8296d93,%r10d
4f:   xor    $<span style="color: #FF8C00;">0</span>x10b9fd03,%r10d
56:   mov    %r10d,%eax
59:   mov    $<span style="color: #FF8C00;">0</span>x8c381146,%r10d
5f:   xor    $<span style="color: #FF8C00;">0</span>x24c7200e,%r10d
66:   mov    %r10d,%eax
69:   mov    $<span style="color: #FF8C00;">0</span>xeb2a830e,%r10d
6f:   xor    $<span style="color: #FF8C00;">0</span>x43ba02ba,%r10d
76:   mov    %r10d,%eax
79:   mov    $<span style="color: #FF8C00;">0</span>xd9730af,%r10d
7f:   xor    $<span style="color: #FF8C00;">0</span>xa5073b1f,%r10d
86:   mov    %r10d,%eax
89:   mov    $<span style="color: #FF8C00;">0</span>x9a45662b,%r10d
8f:   xor    $<span style="color: #FF8C00;">0</span>x325586ea,%r10d
96:   mov    %r10d,%eax
[...]
</pre>
</div>

<p>
以上两个程序的语义都相同，但是原先的立即数在第二种情况下被隐藏了。
</p>

<p>
开启 <code>bpf_jit_harden</code> 后，特权用户的JIT的映像地址不再会暴露到 <code>JIT kallsyms</code> （/proc/kallsyms）中。
</p>

<p>
内核提供了 <code>CONFIG_BPF_JIT_ALWAYS_ON</code> 选项，用于移除BPF解释器，永久开启BPF JIT编译。
</p>

<p>
<code>/proc/sys/kernel/unprivileged_bpf_disabled</code> 选项可以用于禁止非特权用户使用 <code>bpf系统调用</code> 。此选项只能设置一次，设置为1后，无法再次设置为0，除非重启内核。
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo 1 &gt; /proc/sys/kernel/unprivileged_bpf_disabled</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7e63eab" class="outline-3">
<h3 id="org7e63eab"><span class="section-number-3">1.9.</span> Offload</h3>
<div class="outline-text-3" id="text-1-9">
<p>
当前 <code>Netronome</code> 的nfp驱动已经支持BPF卸载，通过JIT编译器将BPF指令转换为NIC支持的指令集， <code>BPF Map</code> 同样适用。
</p>
</div>
</div>

<div id="outline-container-org97c63f3" class="outline-3">
<h3 id="org97c63f3"><span class="section-number-3">1.10.</span> BPF sysctls</h3>
<div class="outline-text-3" id="text-1-10">
<p>
<code>/proc/sys/net/core/bpf_jit_enable</code> ：开启关闭 BPF JIT 编译器.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Value</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">关闭 JIT 编译，只使用解释器</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">开启 JIT compiler</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">开启 JIT compiler，并将debugging日志发送到内核日志</td>
</tr>
</tbody>
</table>

<p>
<code>bpf_jit_disasm</code>  工具可以用于处理degugging日志。
</p>

<p>
<code>/proc/sys/net/core/bpf_jit_harden</code> ：开启或关闭 BPF JIT 强化。开启后可以隐藏 BPF 程序中的立即数（只针对JIT），会有部分性能损耗。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Value</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">关闭 JIT hardening</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">针对非特权用户开启 JIT hardening</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">为所有用户开启JIT hardening</td>
</tr>
</tbody>
</table>

<p>
<code>/proc/sys/net/core/bpf_jit_kallsyms</code> ：控制是将JIT后的程序作为内核符号导出到 <code>/proc/kallsyms</code> ，以便perf之类的工具可以识别这些地址，从而可以解析堆栈。导出符号名称会包含程序tag（bpf_prog_&lt;tag&gt;），例如 <code>bpf_prog_6deef7357e7b4530_sd_fw_egress</code> 。
</p>

<p>
如果开启 <code>bpf_jit_harden</code> ， <code>bpf_jit_kallsyms</code> 会被关闭。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Value</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">关闭 JIT kallsyms 导出</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">（只对特权用户）开启 JIT kallsyms 导出</td>
</tr>
</tbody>
</table>

<p>
<code>/proc/sys/kernel/unprivileged_bpf_disabled</code> ：控制非特权用户是否可以使用 <code>bpf(2)</code> 系统调用。注意，一旦设置为1后，无法再次设置为0，除非重启内核。
</p>

<p>
该选项可以设置为 2 ，表示临时禁止非特权使用 <code>bpf()</code> 系统调用，后续可以设置为 0 或 1，该值在 Linux 5.13 内核中添加。编译内核时，如果开启 BPF_UNPRIV_DEFAULT_OFF 选项，则 <code>unprivileged_bpf_disabled</code> 默认值为2。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Value</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">允许非特权用户使用 <code>bpf()</code> 系统调用</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">禁止非特权用户使用 <code>bpf()</code> 系统调用，除非重启</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">临时禁止非特权用户使用 <code>bpf()</code> 系统调用</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-orgd1dabbd" class="outline-2">
<h2 id="orgd1dabbd"><span class="section-number-2">2.</span> 开发工具</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orge1de17e" class="outline-3">
<h3 id="orge1de17e"><span class="section-number-3">2.1.</span> 开发环境</h3>
<div class="outline-text-3" id="text-2-1">
<p>
debian:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ sudo apt-get install -y make gcc libssl-dev bc libelf-dev libcap-dev <span style="color: #CDC673; font-weight: bold;">\</span>
  clang gcc-multilib llvm libncurses5-dev git pkg-config libmnl-dev bison flex <span style="color: #CDC673; font-weight: bold;">\</span>
  graphviz
</pre>
</div>

<p>
Fedora:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ sudo dnf install -y git gcc ncurses-devel elfutils-libelf-devel bc <span style="color: #CDC673; font-weight: bold;">\</span>
  openssl-devel libcap-devel clang llvm graphviz bison flex glibc-static
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf7d96ce" class="outline-3">
<h3 id="orgf7d96ce"><span class="section-number-3">2.2.</span> 内核编译</h3>
<div class="outline-text-3" id="text-2-2">
<p>
编译内核: 新的BPF功能特性在 <code>net-next</code> git树，最新的BPF修复则在 <code>net</code> git树。
</p>
<div class="org-src-container">
<pre class="src src-sh">$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git
$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git
</pre>
</div>

<p>
构建内核时，确保生成的 <code>.config</code> 文件包含以下 <code>CONFIG_*</code> 配置项：
</p>
<ul class="org-ul">
<li>CONFIG_CGROUP_BPF=y</li>
<li>CONFIG_BPF=y</li>
<li>CONFIG_BPF_SYSCALL=y</li>
<li>CONFIG_NET_SCH_INGRESS=m</li>
<li>CONFIG_NET_CLS_BPF=m</li>
<li>CONFIG_NET_CLS_ACT=y</li>
<li>CONFIG_BPF_JIT=y</li>
<li>CONFIG_LWTUNNEL_BPF=y</li>
<li>CONFIG_HAVE_EBPF_JIT=y</li>
<li>CONFIG_BPF_EVENTS=y</li>
<li>CONFIG_TEST_BPF=m</li>
</ul>
</div>
</div>

<div id="outline-container-org7f3eb03" class="outline-3">
<h3 id="org7f3eb03"><span class="section-number-3">2.3.</span> 配置验证</h3>
<div class="outline-text-3" id="text-2-3">
<p>
使用新编译的内核启动后，执行BPF单元测试，以验证BPF功能。
</p>

<p>
测试步骤如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cd tools/testing/selftests/bpf/  <span style="color: #8B8878;"># </span><span style="color: #8B8878;">&#20869;&#26680;&#20195;&#30721;&#26641;</span>
$ make
$ sudo ./test_verifier
</pre>
</div>


<p>
执行所有BPF测试单元：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ sudo make run_tests
</pre>
</div>
</div>
</div>

<div id="outline-container-org0f88eca" class="outline-3">
<h3 id="org0f88eca"><span class="section-number-3">2.4.</span> 编译iproute2</h3>
<div class="outline-text-3" id="text-2-4">
<p>
iproute2 分为 <code>master</code> 和 <code>net-next</code> 树，分别和内核 <code>net</code> <code>net-next</code> 树对应。
</p>

<div class="org-src-container">
<pre class="src src-sh">$ git clone https://git.kernel.org/pub/scm/network/iproute2/iproute2.git
$ git clone -b net-next https://git.kernel.org/pub/scm/network/iproute2/iproute2.git
</pre>
</div>

<p>
构建步骤：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cd iproute2/
$ ./configure --prefix=/usr
TC schedulers
ATM    no

libc has setns: yes
SELinux support: yes
ELF support: yes
libmnl support: no
Berkeley DB: no

docs: latex: no
WARNING: no docs can be built from LaTeX files
sgml2html: no
WARNING: no HTML docs can be built from SGML
$ make
[...]
$ sudo make install
</pre>
</div>

<p>
确保 <code>configure</code> 脚本输出 <code>ELF support: yes</code> ，否则iproute2将无法处理 LLVM's BPF后端生成的 ELF 文件。
</p>
</div>
</div>

<div id="outline-container-orgc8238a4" class="outline-3">
<h3 id="orgc8238a4"><span class="section-number-3">2.5.</span> 编译bpftool</h3>
<div class="outline-text-3" id="text-2-5">
<p>
对于调试BPF程序以及BPF Map来说，bpftool 是必不可少的工具。bpftool位于内核代码的 <code>tools/bpf/bpftool/</code> 。
</p>

<p>
构建 bpftool：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cd &lt;kernel-tree&gt;/tools/bpf/bpftool/
$ make
Auto-detecting system features:
...                        libbfd: [ on  ]
...        disassembler-four-args: [ OFF ]

CC       xlated_dumper.o
CC       prog.o
CC       common.o
CC       cgroup.o
CC       main.o
CC       json_writer.o
CC       cfg.o
CC       map.o
CC       jit_disasm.o
CC       disasm.o
make[1]: Entering directory <span style="color: #CDC673;">'/home/foo/trees/net/tools/lib/bpf'</span>

Auto-detecting system features:
...                        libelf: [ on  ]
...                           bpf: [ on  ]

CC       libbpf.o
CC       bpf.o
CC       nlattr.o
LD       libbpf-in.o
LINK     libbpf.a
make[1]: Leaving directory <span style="color: #CDC673;">'/home/foo/trees/bpf/tools/lib/bpf'</span>
LINK     bpftool
$ sudo make install
</pre>
</div>
</div>
</div>

<div id="outline-container-org8021091" class="outline-3">
<h3 id="org8021091"><span class="section-number-3">2.6.</span> LLVM</h3>
<div class="outline-text-3" id="text-2-6">
<p>
目前只有LLVM可以作为BPF后端的编译套件，gcc暂不支持。
</p>

<p>
LLVM 从 3.7 版本开始，加入了BPF后端支持。
</p>

<p>
BPF程序的开发过程通常如下：
</p>
<ul class="org-ul">
<li>使用 C语言编写程序</li>
<li>使用LLVM编译为 object/ELF 文件</li>
<li>通过BPF ELF加载器（例如iproute2等）解析，并通过BPF系统调用加载到内核。</li>
<li>内核进行验证以及JIT，并返回该程序的文件描述符。该文件描述符可用来关联到其他子系统（例如网络）。</li>
<li>如果支持卸载到硬件，则子系统会将该程序卸载到硬件执行（e.g. NIC）。</li>
</ul>


<p>
检查LLVM是否支持 <code>BPF target</code> :
</p>
<div class="org-src-container">
<pre class="src src-sh">  $ llc --version
<span style="color: #87D700;">LLVM</span> (http://llvm.org/):
LLVM version 3.8.1
Optimized build.
Default target: x86_64-unknown-linux-gnu
Host CPU: skylake

Registered Targets:
  [...]
  bpf        - BPF (host endian)
  bpfeb      - BPF (big endian)
  bpfel      - BPF (little endian)
  [...]
</pre>
</div>

<p>
<code>bpf</code> 表示使用主机字节序
<code>bpfeb</code> 大端序
<code>bpfel</code> 小端序
</p>


<p>
简单的drop数据包的XDP程序：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">&lt;linux/bpf.h&gt;</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __section
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">__section</span>(<span style="color: #FF8C00;">NAME</span>)                  \
   <span style="color: #FF1493;">__attribute__</span>((section(NAME), used))
<span style="color: #FF1493;">#endif</span>

__section(<span style="color: #CDC673;">"prog"</span>)
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">xdp_drop</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">xdp_md</span> *<span style="color: #FF8C00;">ctx</span>)
{
    <span style="color: #FF1493;">return</span> XDP_DROP;
}

<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">__license</span>[] __section(<span style="color: #CDC673;">"license"</span>) = <span style="color: #CDC673;">"GPL"</span>;
</pre>
</div>

<p>
编译及加载：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ clang -O2 -Wall --target=bpf -c xdp-example.c -o xdp-example.o

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdp obj xdp-example.o</span>
</pre>
</div>

<p>
注意：debian环境可能提示找不到 “asm/types.h” ，可以通过 <code>apt install gcc-multilib</code> 解决，或者手动创建 “ams” 头文件路径。以上示例在Linux4.11上需要设备支持XDP，或者使用Linux4.12及以上版本。
</p>

<div class="org-src-container">
<pre class="src src-sh">$ file xdp-example.o
  xdp-example.o: ELF 64-bit LSB relocatable, eBPF, version 1 (SYSV), not stripped

$ readelf -Wa ./xdp-example.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2<span style="color: #CDC673;">'s complement, little endian</span>
<span style="color: #CDC673;">  Version:                           1 (current)</span>
<span style="color: #CDC673;">  OS/ABI:                            UNIX - System V</span>
<span style="color: #CDC673;">  ABI Version:                       0</span>
<span style="color: #CDC673;">  Type:                              REL (Relocatable file)</span>
<span style="color: #CDC673;">  Machine:                           Linux BPF</span>
<span style="color: #CDC673;">  Version:                           0x1</span>
<span style="color: #CDC673;">  Entry point address:               0x0</span>
<span style="color: #CDC673;">  Start of program headers:          0 (bytes into file)</span>
<span style="color: #CDC673;">  Start of section headers:          264 (bytes into file)</span>
<span style="color: #CDC673;">  Flags:                             0x0</span>
<span style="color: #CDC673;">  Size of this header:               64 (bytes)</span>
<span style="color: #CDC673;">  Size of program headers:           0 (bytes)</span>
<span style="color: #CDC673;">  Number of program headers:         0</span>
<span style="color: #CDC673;">  Size of section headers:           64 (bytes)</span>
<span style="color: #CDC673;">  Number of section headers:         7</span>
<span style="color: #CDC673;">  Section header string table index: 1</span>

<span style="color: #CDC673;">Section Headers:</span>
<span style="color: #CDC673;">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span>
<span style="color: #CDC673;">  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0</span>
<span style="color: #CDC673;">  [ 1] .strtab           STRTAB          0000000000000000 0000ba 00004b 00      0   0  1</span>
<span style="color: #CDC673;">  [ 2] .text             PROGBITS        0000000000000000 000040 000000 00  AX  0   0  4</span>
<span style="color: #CDC673;">  [ 3] prog              PROGBITS        0000000000000000 000040 000010 00  AX  0   0  8</span>
<span style="color: #CDC673;">  [ 4] license           PROGBITS        0000000000000000 000050 000004 00  WA  0   0  1</span>
<span style="color: #CDC673;">  [ 5] .llvm_addrsig     LOOS+0xfff4c03  0000000000000000 0000b8 000002 00   E  6   0  1</span>
<span style="color: #CDC673;">  [ 6] .symtab           SYMTAB          0000000000000000 000058 000060 18      1   2  8</span>
<span style="color: #CDC673;">Key to Flags:</span>
<span style="color: #CDC673;">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span>
<span style="color: #CDC673;">  L (link order), O (extra OS processing required), G (group), T (TLS),</span>
<span style="color: #CDC673;">  C (compressed), x (unknown), o (OS specific), E (exclude),</span>
<span style="color: #CDC673;">  D (mbind), p (processor specific)</span>


<span style="color: #CDC673;">  [...]</span>

<span style="color: #CDC673;">Symbol table '</span>.symtab<span style="color: #CDC673;">' contains 4 entries:</span>
<span style="color: #CDC673;">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span>
<span style="color: #CDC673;">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span>
<span style="color: #CDC673;">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS xdp-example.c</span>
<span style="color: #CDC673;">     2: 0000000000000000    16 FUNC    GLOBAL DEFAULT    3 xdp_drop</span>
<span style="color: #CDC673;">     3: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 __license</span>

<span style="color: #CDC673;">No version information found in this file.</span>
</pre>
</div>


<p>
如果需要编译llvm和clang，可以参考以下步骤：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ git clone https://github.com/llvm/llvm-project.git
$ cd llvm-project
$ mkdir build
$ cd build
$ cmake -DLLVM_ENABLE_PROJECTS=clang -DLLVM_TARGETS_TO_BUILD=<span style="color: #CDC673;">"BPF;X86"</span> -DBUILD_SHARED_LIBS=OFF -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_RUNTIME=OFF  -G <span style="color: #CDC673;">"Unix Makefiles"</span> ../llvm
$ make -j $(<span style="color: #AF87FF; font-weight: bold;">getconf _NPROCESSORS_ONLN</span>)
$ ./bin/llc --version
<span style="color: #87D700;">LLVM</span> (http://llvm.org/):
LLVM version x.y.zsvn
Optimized build.
Default target: x86_64-unknown-linux-gnu
Host CPU: skylake

Registered Targets:
  bpf    - BPF (host endian)
  bpfeb  - BPF (big endian)
  bpfel  - BPF (little endian)
  x86    - 32-bit X86: Pentium-Pro and above
  x86-64 - 64-bit X86: EM64T and AMD64

$ export <span style="color: #FF8C00;">PATH</span>=$<span style="color: #FF8C00;">PWD</span>/bin:$<span style="color: #FF8C00;">PATH</span>   <span style="color: #8B8878;"># </span><span style="color: #8B8878;">add to ~/.bashrc</span>
</pre>
</div>

<p>
确保 <code>--version</code> 的输出中包含 <code>Optimized build</code> ，否则使用带有debug模式的LLVM会导致编译程序的时间过长。
</p>

<p>
可以通过clang生成汇编用于调试：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ clang -O2 -S -Wall --target=bpf -c xdp-example.c -o xdp-example.S
$ cat xdp-example.S
        .text
        .file   <span style="color: #CDC673;">"xdp-example.c"</span>
        .section        prog,<span style="color: #CDC673;">"ax"</span>,@progbits
        .globl  xdp_drop                        <span style="color: #8B8878;"># </span><span style="color: #8B8878;">-- Begin function xdp_drop</span>
        .p2align        3
        .type   xdp_drop,@<span style="color: #FF1493;">function</span>
xdp_drop:                               <span style="color: #8B8878;"># </span><span style="color: #8B8878;">@xdp_drop</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">%bb.0:</span>
        r0 = 1
        <span style="color: #FF1493;">exit</span>
.Lfunc_end0:
        .size   xdp_drop, .Lfunc_end0-xdp_drop
                                        <span style="color: #8B8878;"># </span><span style="color: #8B8878;">-- End function</span>
        .type   __license,@object               <span style="color: #8B8878;"># </span><span style="color: #8B8878;">@__license</span>
        .section        license,<span style="color: #CDC673;">"aw"</span>,@progbits
        .globl  __license
__license:
        .asciz  <span style="color: #CDC673;">"GPL"</span>
        .size   __license, 4

        .addrsig
        .addrsig_sym xdp_drop
        .addrsig_sym __license
</pre>
</div>


<p>
LLVM 从 6.0 版本开始支持解析汇编语言，可以直接使用BPF汇编编写程序，然后通过 <code>llvm-mc</code> 生成目标文件。
</p>
<div class="org-src-container">
<pre class="src src-sh">$ llvm-mc -triple bpf -filetype=obj -o xdp-example.o xdp-example.S
</pre>
</div>

<p>
LLVM 从 4.0 版本开始，可以将dwarf格式的调试信息存储到目标文件，编译时，增加 <code>-g</code> 参数即可。
</p>
<div class="org-src-container">
<pre class="src src-sh">$ clang -O2 -g -Wall --target=bpf -c xdp-example.c -o xdp-example.o
$ llvm-objdump -S --no-show-raw-insn xdp-example.o
w-raw-insn xdp-example.o

xdp-example.o:  file format elf64-bpf

Disassembly of section prog:

0000000000000000 &lt;xdp_drop&gt;:
;     <span style="color: #FF1493;">return</span> XDP_DROP;
       0:       r0 = 1
       1:       exit
</pre>
</div>

<p>
通过 <code>llvm-objdump</code> 工具，可以将输出的汇编指令对应到原始的C代码。上述输出的行号  <code>0:</code> 和 <code>1:</code> 可以对应到内核验证器的日志输出，当验证器拒绝BPF程序加载时，可以借助lvm-objdump工具定位到原始的C代码位置。
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdp obj xdp-example.o verb</span>

Prog section <span style="color: #CDC673;">'prog'</span> loaded (5)<span style="color: #CDC673; font-weight: bold;">!</span>
 - Type:         6
 - Instructions: 2 (0 over limit)
 - License:      GPL

Verifier analysis:

0: (b7) r0 = 1
1: (95) <span style="color: #FF1493;">exit</span>
processed 2 insns
</pre>
</div>

<p>
不使用 <code>--no-show-raw-insn</code> 选项时，将会同时输出原始的 <code>struct bpf_insn</code> 字节码（16进制）：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ llvm-objdump -S xdp-example.o

xdp-example.o:        file format ELF64-BPF

Disassembly of section prog:
xdp_drop:
; {
   0:       b7 00 00 00 01 00 00 00     r0 = 1
; <span style="color: #FF1493;">return</span> foo();
   1:       95 00 00 00 00 00 00 00     exit
</pre>
</div>


<p>
如果需要 <code>LLVM IR</code> 调试，则先生成二进制的 <code>LLVM IR</code> 中间文件 xdp-example.bc，然后通过 <code>llc</code> 生成目标文件：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ clang -O2 -Wall --target=bpf -emit-llvm -c xdp-example.c -o xdp-example.bc
$ llc xdp-example.bc -march=bpf -filetype=obj -o xdp-example.o
</pre>
</div>

<p>
将 <code>LLVM IR</code> 中间文件输出为可读性更好的格式：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ clang -O2 -Wall -emit-llvm -S -c xdp-example.c -o -
</pre>
</div>

<p>
LLVM支持在生成的目标文件中附加调试信息，默认为 DWARF 格式。
</p>

<p>
BPF使用的BTF（BPF Type Format）格式。DWARF 可以转化为 BTF，然后经过 BPF 加载器加载到内核。内核验证器验证数据的正确性，并对BTF包含的数据类型进行跟踪。
</p>

<p>
BPF 映射同样可以借助BTF的 key和value 对导出的map数据类型进行注释，以便更好的自省、调试以及输出打印。 BTF 数据是一种通用的调试格式，任何 DWARF 都可以转化为 BTF 格式进行加载(例如内核的 vmlinux DWARF data)。
</p>

<p>
要从 DWARF 转换为 BTF，需要借助 elfutils (&gt;= 0.173) 工具集。 如果没有该工具，则需要在llc编译命令中添加 <code>-mattr=dwarfris</code> 选项：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ llc -march=bpf -mattr=help |&amp; grep dwarfris
  dwarfris - Disable MCAsmInfo DwarfUsesRelocationsAcrossSections.
  [...]
</pre>
</div>

<p>
elfutils (&gt;= 0.173)则实现了对BPF重定位的支持，因此不需要 <code>-mattr=dwarfris</code> 选项，所以可以将目标文件的结构通过DWARF或者BTF信息进行转储。
</p>

<p>
pahole（&gt;=1.12）可以将DWARF转为BTF，该工具可以直接安装或者通过源码编译:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ git clone https://git.kernel.org/pub/scm/devel/pahole/pahole.git
</pre>
</div>

<p>
pahole 使用 <code>-J</code> 选项来将 DWARF 转为 BTF。通过一下命令检测pahole是否支持BPF（pahole依赖llvm-objcopy工具):
</p>
<div class="org-src-container">
<pre class="src src-sh">$ pahole --help | grep BTF
-J, --btf_encode           Encode as BTF
</pre>
</div>

<p>
要生成调试信息，还需要在前端的clang命令行增加 <code>-g</code> 参数，以生成源码级的调试信息。
</p>
<div class="org-src-container">
<pre class="src src-sh">$ clang -O2 -g -Wall --target=bpf -emit-llvm -c xdp-example.c -o xdp-example.bc
$ llc xdp-example.bc -march=bpf -mattr=dwarfris -filetype=obj -o xdp-example.o
</pre>
</div>

<p>
也可以只使用 clang 来生成带有调试信息的BPF程序（elfutils支持BPF重定位时可以省略 <code>dwarfris</code> 选项）：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ clang --target=bpf -O2 -g -c -Xclang -target-feature -Xclang +dwarfris -c xdp-example.c -o xdp-example.o
</pre>
</div>

<p>
生成带有调试信息的目标文件后，通过 <code>pahole</code> 工具转储程序结构：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ pahole xdp-example.o
struct xdp_md {
    __u32                      data;                 /*     0     4 */
    __u32                      data_end;             /*     4     4 */
    __u32                      data_meta;            /*     8     4 */
    __u32                      ingress_ifindex;      /*    12     4 */
    __u32                      rx_queue_index;       /*    16     4 */
    __u32                      egress_ifindex;       /*    20     4 */

    /* size: 24, cachelines: 1, members: 6 */
    /* last cacheline: 24 bytes */
};
</pre>
</div>

<p>
使用pahole <code>-J</code> 选项，可以从目标文件的DWARF信息来生成BTF，生成后的目标文件的DWARF信息仍被保留，紧挨着BTF数据。
</p>
<div class="org-src-container">
<pre class="src src-sh">$ clang --target=bpf -O2 -Wall -g -c -Xclang -target-feature -Xclang +dwarfris -c xdp-example.c -o xdp-example.o
$ pahole -J xdp-example.o
</pre>
</div>

<p>
使用readelf可以查看目标文件中的 <code>.BTF</code> 段：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ readelf -WS xdp-example.o
[...]
  [11] .BTF              PROGBITS        0000000000000000 000388 000216 00      0   0  4
[...]
</pre>
</div>

<p>
BPF加载器（例如iproute2）会检测加载 BTF节，因此映射带有类型信息。
</p>

<p>
LLVM默认使用BPF基础指令集，使得生成的代码可以在其他内核运行。
</p>

<p>
可以通过LLVM <code>-mcpu</code> 指定BPF后端，来选择不同版本的BPF指令集，这些指令集是在基础BPF指令集上扩展，使得生成更加简洁高效的代码。
</p>

<p>
列出可用的 <code>-mcpu</code> 选项:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ llc -march bpf -mcpu=help
Available CPUs for this target:

  generic - Select the generic processor.
  probe   - Select the probe processor.
  v1      - Select the v1 processor.
  v2      - Select the v2 processor.
  v3      - Select the v3 processor.

Available features for this target:

  alu32    - Enable ALU32 instructions.
  dummy    - unused feature.
  dwarfris - Disable MCAsmInfo DwarfUsesRelocationsAcrossSections.

Use +feature to enable a feature, or -feature to disable it.
For example, llc -mcpu=mycpu -mattr=+feature1,-feature2
</pre>
</div>

<p>
默认选择 <code>generic</code> 。 当BPF程序的编译主机和运行主机不同时，可能用用到 v1、v2、v3选项。
</p>

<p>
建议使用 <code>-mcpu=probe</code> 选项（Cilium也使用该选项），表示LLVM BPF后端自主查询并选择内核所支持的扩展指令集。
</p>

<p>
使用 llc 的 <code>-mcpu=probe</code> 选项的完整示例：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ clang -O2 -Wall --target=bpf -emit-llvm -c xdp-example.c -o xdp-example.bc
$ llc xdp-example.bc -march=bpf -mcpu=probe -filetype=obj -o xdp-example.o
</pre>
</div>

<p>
通常生成的LLVM IR和体系结构无关。但是clang <code>--target=bpf</code> 选项比较特殊，不使用该选项时，clang选择的体系结构依赖于底层体系结构，例如 x86_64, arm64 或者其他，以下引用自内核 <code>Documentation/bpf/bpf_devel_QA.txt</code> ：
</p>
<ul class="org-ul">
<li>BPF程序会递归包含所有头文件时，如果引入了内联汇编代码，默认 <code>target</code> 可以正确处理，但是如果是 <code>bpf target</code> 时，BPF后端汇编器无法处理内联汇编。</li>

<li>使用默认的 <code>target</code> 时，编译不带 <code>-g</code> 仍然会生成额外的 elf节， 例如 <code>.eh_frame</code>  <code>.rela.eh_frame</code> ， <code>bpf target</code> 则不会生成。</li>

<li>使用默认的 <code>target</code> 时，C语言的 switch 会声明为 <code>switch table</code> 进行查找和跳转操作。 <code>switch table</code> 会放置在全局的只读的section，会导致bpf加载失败。 <code>bpf target</code> 则不支持 <code>switch table</code> 优化。clang的 <code>-fno-jump-tables</code> 可用来禁止生成 <code>switch table</code> 。</li>

<li>clang使用 <code>--target=bpf</code> 时，不管clang程序以及linux是多少位，都保证指针或者long/unsigned long类型为64bit。 然而如果clang使用默认target时，指针和long/unsigned long的长度都依赖底层的体系结构。 当底层体系结构为32位，BPF上下文中的结构会变为32位，LLVM后端仍按照64位操作.</li>
</ul>

<p>
在跟踪内核结构的 <code>pt_regs</code> 或者涉及CPU寄存器的其他内核结构时，大多需要默认 <code>target</code> 。其他情况则优先使用 <code>clang --target=bpf</code> 。
</p>

<p>
LLVM从7.0版本开始支持32位子寄存器和 BPF ALU32 指令。并增加了 <code>alu32</code> 代码生成属性。 开启 <code>alu32</code> 属性时，LLVM会尝试使用32位子寄存器。和ALU指令对应的32位寄存器的操作指令变为 ALU32。例如：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cat 32-bit-example.c
void cal(unsigned int *a, unsigned int *b, unsigned int *c)
{
    unsigned int sum = *a + *b;
    *c = sum;
}
</pre>
</div>

<p>
使用默认方式编译时，生成的指令如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ clang --target=bpf -emit-llvm -S 32-bit-example.c
$ llc -march=bpf 32-bit-example.ll
$ cat 32-bit-example.s
  cal:
      r1 = *(u32 *)(r1 + 0)
      r2 = *(u32 *)(r2 + 0)
      r2 += r1
      *(u32 *)(r3 + 0) = r2
      <span style="color: #FF1493;">exit</span>
</pre>
</div>

<p>
以上使用的64位寄存器，因此加法是64位的。
</p>

<p>
指定 <code>-mattr=+alu32</code> 选项开启32位子寄存器后，生成的汇编指令如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ llc -march=bpf -mattr=+alu32 32-bit-example.ll
$ cat 32-bit-example.s
    cal:
      w1 = *(u32 *)(r1 + 0)
      w2 = *(u32 *)(r2 + 0)
      w2 += w1
      *(u32 *)(r3 + 0) = w2
      <span style="color: #FF1493;">exit</span>
</pre>
</div>

<p>
<code>w</code> 寄存器表示32位子寄存器。
</p>


<p>
和编写普通的应用不同，在使用C语言编写BPF时，有一些注意事项：
</p>

<ol class="org-ol">
<li><p>
<b>不允许函数调用以及库函数调用，所有函数调用必须 <code>inline</code> 。</b>
</p>

<p>
BPF不能使用共享库，常用的库代码可以放置在头文件中，由主程序进行包含。在使用头文件包含时，只能使用其中的静态内联函数以及宏定义。
</p>

<p>
linux内核kernel 4.16+ 和 LLVM 6.0+ 后，开始支持 <code>BPF to BPF</code> 函数调用。如果不支持，则LLVM需要将整个代码编译及内联到一个给定的 <code>section</code> 中。最好的办法是为每个要使用的库函数添加 <code>__inline</code> 限定，由于编译器在遇到较大的代码段时，可能不会进行内联操作，因此推荐使用 <code>always_inline</code> 。
</p>

<p>
当使用 <code>__inline</code> 由于代码原因编译器并未进行内联时，会在ELF文件中产生重定位项，会导致BPF加载器（例如iproute2）由于无法解析产生错误，因为BPF加载器认为只有BPF的映射才是有效的重定位项。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">&lt;linux/bpf.h&gt;</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __section
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">__section</span>(<span style="color: #FF8C00;">NAME</span>)                  \
   <span style="color: #FF1493;">__attribute__</span>((section(NAME), used))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __inline
<span style="color: #FF1493;"># define</span> <span style="color: #FF8C00;">__inline</span>                         \
   <span style="color: #FF1493;">inline</span> <span style="color: #FF1493;">__attribute__</span>((always_inline))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">static</span> __inline <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">foo</span>(<span style="color: #5FD7FF;">void</span>)
{
    <span style="color: #FF1493;">return</span> XDP_DROP;
}

__section(<span style="color: #CDC673;">"prog"</span>)
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">xdp_drop</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">xdp_md</span> *<span style="color: #FF8C00;">ctx</span>)
{
    <span style="color: #FF1493;">return</span> foo();
}

<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">__license</span>[] __section(<span style="color: #CDC673;">"license"</span>) = <span style="color: #CDC673;">"GPL"</span>;
</pre>
</div></li>

<li><p>
<b>可以将多个程序放置一个C文件的不同 <code>section</code> 内。</b>
</p>

<p>
BPF的C程序中，经常使用 <code>section</code> 修饰，C文件通常被组织为3个或3个以上的 <code>section</code> 中。通过调用 <code>bpf()</code> 系统调用，BPF加载器通过section名称来加载BPF程序和map的相关信息。 例如：iproute2使用 <code>maps</code> 和 <code>license</code> 作为section名称来查找元数据，用于创建map和license。
</p>

<p>
程序创建时，license也会推送到内核，同时如果程序是GPL兼容的license，会公开一些GPL的辅助函数（例如bpf_ktime_get_ns(), bpf_probe_read()等）。
</p>

<p>
其余的section则为BPF程序代码。下面的代码示例包含两个 <code>program section</code> 分别为 ingress 和 egress，并且共享了map和静态inline函数（account_data()）。
</p>

<p>
以下代码tc-example.c经过编译后，可以通过tc 附加到 <code>netdevice</code> 的 ingress 和 egress hook。 主要功能为通过map（acc_map）统计传输的字节数，acc_map有两个槽位，一个是用于 ingress hook，一个是 egress hook。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">&lt;linux/bpf.h&gt;</span>
<span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">&lt;linux/pkt_cls.h&gt;</span>
<span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">&lt;stdint.h&gt;</span>
<span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">&lt;iproute2/bpf_elf.h&gt;</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __section
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">__section</span>(<span style="color: #FF8C00;">NAME</span>)                  \
   <span style="color: #FF1493;">__attribute__</span>((section(NAME), used))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __inline
<span style="color: #FF1493;"># define</span> <span style="color: #FF8C00;">__inline</span>                         \
   <span style="color: #FF1493;">inline</span> <span style="color: #FF1493;">__attribute__</span>((always_inline))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> lock_xadd
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">lock_xadd</span>(<span style="color: #FF8C00;">ptr</span>, <span style="color: #FF8C00;">val</span>)              \
   ((<span style="color: #5FD7FF;">void</span>)__sync_fetch_and_add(ptr, val))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> BPF_FUNC
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">BPF_FUNC</span>(<span style="color: #FF8C00;">NAME</span>, ...)              \
   (*NAME)(__VA_ARGS__) = (<span style="color: #5FD7FF;">void</span> *)BPF_FUNC_##NAME
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> *<span style="color: #87D700;">BPF_FUNC</span>(map_lookup_elem, <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">map</span>, <span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">key</span>);

<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">bpf_elf_map</span> <span style="color: #5FD7FF;">acc_map</span> <span style="color: #87D700;">__section</span>(<span style="color: #CDC673;">"maps"</span>) = {
    .type           = BPF_MAP_TYPE_ARRAY,
    .size_key       = <span style="color: #FF1493;">sizeof</span>(uint32_t),
    .size_value     = <span style="color: #FF1493;">sizeof</span>(uint32_t),
    .pinning        = PIN_GLOBAL_NS,
    .max_elem       = 2,
};

<span style="color: #FF1493;">static</span> __inline <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">account_data</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">__sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #5FD7FF;">uint32_t</span> <span style="color: #FF8C00;">dir</span>)
{
    <span style="color: #5FD7FF;">uint32_t</span> *<span style="color: #FF8C00;">bytes</span>;

    bytes = map_lookup_elem(&amp;acc_map, &amp;dir);
    <span style="color: #FF1493;">if</span> (bytes)
            lock_xadd(bytes, skb-&gt;len);

    <span style="color: #FF1493;">return</span> TC_ACT_OK;
}

__section(<span style="color: #CDC673;">"ingress"</span>)
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tc_ingress</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">__sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
    <span style="color: #FF1493;">return</span> account_data(skb, 0);
}

__section(<span style="color: #CDC673;">"egress"</span>)
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tc_egress</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">__sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
    <span style="color: #FF1493;">return</span> account_data(skb, 1);
}

<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">__license</span>[] __section(<span style="color: #CDC673;">"license"</span>) = <span style="color: #CDC673;">"GPL"</span>;
</pre>
</div>

<p>
代码中包含了内核头文件、标准C头文件以及iproute2中有关 <code>struct bpf_elf_map</code> 定义的头文件。iproute2 使用通用的BPF加载器，因此XDP 和 tc使用相同的 <code>struct bpf_elf_map</code> 结构定义。
</p>

<p>
程序中通过 <code>struct bpf_elf_map</code> 结构定义内部的映射，其中包含了要使用的所有相关信息（key/value 的大小）。该结构必须放置在 <code>maps</code> section中，才能被加载器找到。可以通过不同的变量名定义多个相同类型的map，但是必须使用 <code>__section("maps")</code> 进行标注。
</p>

<p>
不同的BPF加载器，其 <code>struct bpf_elf_map</code> 定义有所不同。iproute2保证 <code>struct bpf_elf_map</code> 定义向后兼容。Cilium 也采用 iproute2 的格式。
</p>

<p>
示例中展示了如何在C代码中使用BPF辅助函数（ <code>map_lookup_elem()</code> ）。首先将 <code>map_lookup_elem()</code> 函数映射到 <code>BPF_FUNC_map_lookup_elem</code> 枚举值（定义在uapi/linux/bpf.h中），之后加载到内核过程中验证器检查参数是否合法，并将指针重新指向实际的函数调用。
</p>

<p>
由于 <code>acc_map</code> 定义为全局属性，所以需要原子操作 <code>lock_xadd()</code> ，LLVM 内置 __sync_fetch_and_add() 函数，用于原子加法操作（字的加法： <code>BPF_STX | BPF_XADD | BPF_W</code> ）。
</p>

<p>
<code>acc_map</code> 定义中的 <code>PIN_GLOBAL_NS</code> 表示将该map固定为文件系统，默认路径为 <code>/sys/fs/bpf/tc/globals/acc_map</code> 。位于 <code>globals</code> 目录下的节点可以跨越多个对象文件，如果使用 <code>PIN_OBJECT_NS</code> 属性，则tc创建的map之应用于本对象文件。例如，不同的C文件定义了相同的 <code>acc_map</code> ，并指定了 <code>PIN_GLOBAL_NS</code> ，则 <code>acc_map</code> 将在不同的对象文件的多个BPF程序间共享。 <code>PIN_NONE</code> 表示map不会被放置在文件系统中，在tc退出后用户空间无法再访问该map。也就是说，示例中指定 <code>PIN_NONE</code> 时，tc会创建两个独立的map（每个程序一个）， 因为tc无法通过map名称检索到此前定义的map。
</p>

<p>
以上示例程序在加载 <code>ingress</code> 程序过程中，tc检查 <code>BPF file system</code> 不存在对应的map，然后新建map，创建成功后，固定到文件系统，以便 <code>egress</code> 程序加载，在 <code>egress</code> 加载时，tc发现 <code>BPF file system</code> 中存在对应的map，并直接重用。加载器在对比map时，除了对比名称，还包括 key/value的大小。
</p>

<p>
类似tc可以检索是否存在相同的map，应用程序也可以通过 <code>bpf()</code> 系统调用以及 <code>BPF_OBJ_GET</code> 命令查找map，并返回对应的文件描述符用于 lookup / update / delete 操作。
</p>

<p>
以上示例代码的编译和加载（已经过时）：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang -O2 -Wall --target=bpf -c tc-example.c -o tc-example.o

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc qdisc add dev em1 clsact</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter add dev em1 ingress bpf da obj tc-example.o sec ingress</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter add dev em1 egress bpf da obj tc-example.o sec egress</span>

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter show dev em1 ingress</span>
filter protocol all pref 49152 bpf
filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[ingress] direct-action id 1 tag c5f7825e5dac396f

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter show dev em1 egress</span>
filter protocol all pref 49152 bpf
filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[egress] direct-action id 2 tag b2fd5adc0f262714

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">mount | grep bpf</span>
sysfs on /sys/fs/bpf type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)
bpf on /sys/fs/bpf type bpf (rw,relatime,<span style="color: #FF8C00;">mode</span>=0700)

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tree /sys/fs/bpf/</span>
/sys/fs/bpf/
+-- ip -&gt; /sys/fs/bpf/tc/
+-- tc
|   +-- globals
|       +-- acc_map
+-- xdp -&gt; /sys/fs/bpf/tc/

4 directories, 1 file
</pre>
</div>

<p>
一旦数据包进入 em1 设备，BPF map 中的计数器就会被增加。
</p></li>

<li><p>
<b>不允许全局变量。</b>
</p>

<p>
For the reasons already mentioned in point 1, BPF cannot have global variables as often used in normal C programs.
</p>

<p>
可以通过创建 <code>BPF_MAP_TYPE_PERCPU_ARRAY</code> 类型的map，其中只有一个槽位。在执行过程中，内核保证不会抢占BPF程序，因此可以使用一个map条目作为临时缓冲区，还可以用于扩展堆栈目的，对与 <code>tail calls</code> 同样适用。
</p></li>

<li><p>
<b>不允许字符串常量和数组。</b>
</p>

<p>
BPF C程序中不能定义字符床常量以及数组，因为会在ELF文件中生成重定位 <code>section</code> ，由于加载器并不能识别这些重定位项，也无法修正这些重定位项。
</p>

<p>
<code>trace_printk()</code> 之类的辅助函数的使用：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">BPF_FUNC</span>(trace_printk, <span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">fmt</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">fmt_size</span>, ...);

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> printk
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">printk</span>(<span style="color: #FF8C00;">fmt</span>, ...)                                      \
    ({                                                         \
        <span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">____fmt</span>[] = fmt;                                  \
        trace_printk(____fmt, <span style="color: #FF1493;">sizeof</span>(____fmt), ##__VA_ARGS__); \
    })
<span style="color: #FF1493;">#endif</span>
</pre>
</div>

<p>
程序中可以使用 <code>printk("skb len:%u\n", skb-&gt;len);</code> ，内容被输出到 <code>trace pipe</code> ，通过执行 <code>tc exec bpf dbg</code> 可以获取输出内容。
</p>

<p>
<code>trace_printk()</code> 辅助函数有很多缺点，不建议在生产环境使用。每次函数调用，都会将常量字符串 <code>"skb len:%u\n"</code> 加载到BPF栈中，并且BPF辅助函数最多只允许5个参数，调用该函数时，实际只剩三个参数可用。
</p>

<p>
在网络程序中，为了更快的调试，建议使用 <code>skb_event_output()</code> 或者 <code>skb_event_output()</code> 函数，这两个函数都允许将BPF程序中自定义的struct结传递到perf event的环形缓冲区中，也可以传递数据包样本。Cilium的监控器就使用此机制来实现调试框架、网络策略违规通知等。
</p></li>

<li><p>
<b>使用LLVM内置的函数执行 <code>memset()/memcpy()/memmove()/memcmp()</code> 操作</b>
</p>

<p>
由于BPF程序无法执行函数调用，所有的BPF辅助函数、标准库都需要实现为inline函数。LLVM自身提供了一些内置指令，以用于执行固定大小的操作：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> memset
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">memset</span>(<span style="color: #FF8C00;">dest</span>, <span style="color: #FF8C00;">chr</span>, <span style="color: #FF8C00;">n</span>)   __builtin_memset((dest), (chr), (n))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> memcpy
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">memcpy</span>(<span style="color: #FF8C00;">dest</span>, <span style="color: #FF8C00;">src</span>, <span style="color: #FF8C00;">n</span>)   __builtin_memcpy((dest), (src), (n))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> memmove
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">memmove</span>(<span style="color: #FF8C00;">dest</span>, <span style="color: #FF8C00;">src</span>, <span style="color: #FF8C00;">n</span>)  __builtin_memmove((dest), (src), (n))
<span style="color: #FF1493;">#endif</span>
</pre>
</div>

<p>
由于LLVM后端的问题， <code>memcmp()</code> 一些场景下不会被内联，因此在修复前不建议使用。
</p></li>

<li><p>
<b>不允许循环</b>
</p>

<p>
内核中的BPF验证器会执行深度优先搜索，检查所有可能的程序路径是否包含循环，以确保程序一定会终止。
</p>

<p>
可用通过 <code>#pragma unroll</code> 指令，执行有边界的循环。例如：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#pragma</span> unroll
    <span style="color: #FF1493;">for</span> (i = 0; i &lt; IPV6_MAX_HEADERS; i++) {
        <span style="color: #FF1493;">switch</span> (nh) {
        <span style="color: #FF1493;">case</span> NEXTHDR_NONE:
            <span style="color: #FF1493;">return</span> DROP_INVALID_EXTHDR;
        <span style="color: #FF1493;">case</span> NEXTHDR_FRAGMENT:
            <span style="color: #FF1493;">return</span> DROP_FRAG_NOSUPPORT;
        <span style="color: #FF1493;">case</span> NEXTHDR_HOP:
        <span style="color: #FF1493;">case</span> NEXTHDR_ROUTING:
        <span style="color: #FF1493;">case</span> NEXTHDR_AUTH:
        <span style="color: #FF1493;">case</span> NEXTHDR_DEST:
            <span style="color: #FF1493;">if</span> (skb_load_bytes(skb, l3_off + len, &amp;opthdr, <span style="color: #FF1493;">sizeof</span>(opthdr)) &lt; 0)
                <span style="color: #FF1493;">return</span> DROP_INVALID;

            nh = opthdr.nexthdr;
            <span style="color: #FF1493;">if</span> (nh == NEXTHDR_AUTH)
                len += ipv6_authlen(&amp;opthdr);
            <span style="color: #FF1493;">else</span>
                len += ipv6_optlen(&amp;opthdr);
            <span style="color: #FF1493;">break</span>;
        <span style="color: #FF1493;">default</span>:
            *nexthdr = nh;
            <span style="color: #FF1493;">return</span> len;
        }
    }
</pre>
</div>

<p>
另一个可行的方法是使用尾调用（通过 <code>BPF_MAP_TYPE_PERCPU_ARRAY</code> 类型的映射实现）。尾调用实现循环时，最大支持34次的迭代（初始程序 + 33次尾调用）。
</p>

<p>
未来BPF可能会实现原生的有限制条件的循环。
</p></li>

<li><p>
<b>通过尾调用，将程序分块执行。</b>
</p>

<p>
尾调用非常灵活，可以在运行期间从一个程序跳转到另一个程序。为了能够选择下一个程序，尾调用通过 <code>BPF_MAP_TYPE_PROG_ARRAY</code> 类型的map存储程序数组，使用时，只需要将下一个程序的index传入即可。尾调用执行成功后，不会返回到原先的程序中，但是如果没有找到给定index的尾调用程序，则返回原先的程序继续执行。
</p>

<p>
尾调用可以用于实现解析器的不同阶段，并这些阶段可以被新实现解析功能更新。
</p>

<p>
尾调用还也可以用于事件通知。Cilium可以选择在丢包时进行通知，就是通过在尾调用程序中调用 <code>skb_event_output()</code> 。
</p>

<p>
以下是尾调用示例：
</p>
<div class="org-src-container">
<pre class="src src-c">[...]

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __stringify
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">__stringify</span>(<span style="color: #FF8C00;">X</span>)   #X
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __section
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">__section</span>(<span style="color: #FF8C00;">NAME</span>)                  \
   <span style="color: #FF1493;">__attribute__</span>((section(NAME), used))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __section_tail
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">__section_tail</span>(<span style="color: #FF8C00;">ID</span>, <span style="color: #FF8C00;">KEY</span>)          \
   __section(__stringify(ID) <span style="color: #CDC673;">"/"</span> __stringify(KEY))
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> BPF_FUNC
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">BPF_FUNC</span>(<span style="color: #FF8C00;">NAME</span>, ...)              \
   (*NAME)(__VA_ARGS__) = (<span style="color: #5FD7FF;">void</span> *)BPF_FUNC_##NAME
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">BPF_JMP_MAP_ID</span>   1

<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> BPF_FUNC(tail_call, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">__sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">map</span>,
                     <span style="color: #5FD7FF;">uint32_t</span> <span style="color: #FF8C00;">index</span>);

<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">bpf_elf_map</span> <span style="color: #5FD7FF;">jmp_map</span> <span style="color: #87D700;">__section</span>(<span style="color: #CDC673;">"maps"</span>) = {
    .type           = BPF_MAP_TYPE_PROG_ARRAY,
    .id             = BPF_JMP_MAP_ID,
    .size_key       = <span style="color: #FF1493;">sizeof</span>(uint32_t),
    .size_value     = <span style="color: #FF1493;">sizeof</span>(uint32_t),
    .pinning        = PIN_GLOBAL_NS,
    .max_elem       = 1,
};

<span style="color: #87D700;">__section_tail</span>(BPF_JMP_MAP_ID, 0)
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">looper</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">__sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
    printk(<span style="color: #CDC673;">"skb cb: %u\n"</span>, skb-&gt;cb[0]++);
    tail_call(skb, &amp;jmp_map, 0);
    <span style="color: #FF1493;">return</span> TC_ACT_OK;
}

__section(<span style="color: #CDC673;">"prog"</span>)
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">entry</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">__sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
    skb-&gt;cb[0] = 0;
    tail_call(skb, &amp;jmp_map, 0);
    <span style="color: #FF1493;">return</span> TC_ACT_OK;
}

<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">__license</span>[] __section(<span style="color: #CDC673;">"license"</span>) = <span style="color: #CDC673;">"GPL"</span>;
</pre>
</div>

<p>
上述程序被加载时，tc会创建程序数组 <code>jmp_map</code> ，并将其固定到BPF文件系统的全局命名空间（ <code>globals</code> ）下。iproute2的BPF ELF加载器会识别 <code>__section_tail()</code> 标记，其中包含了 <code>JMP_MAP_ID</code> 以及要放置在程序数组map中的下标。iproute2加载器会将所有的尾调用放置到map的对应位置。iproute2支持的所有程序类型都适用这个机制（tc、XDP、lwt）。
</p>

<p>
生成的elf文件的 <code>section headers</code> 中，有关于 <code>map id</code> 以及对应的条目的描述：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ llvm-objdump -S --no-show-raw-insn prog_array.o | less
prog_array.o:   file format ELF64-BPF

Disassembly of section 1/0:
looper:
       0:       r6 = r1
       1:       r2 = *(u32 *)(r6 + 48)
       2:       r1 = r2
       3:       r1 += 1
       4:       *(u32 *)(r6 + 48) = r1
       5:       r1 = 0 ll
       7:       call -1
       8:       r1 = r6
       9:       r2 = 0 ll
      11:       r3 = 0
      12:       call 12
      13:       r0 = 0
      14:       exit
Disassembly of section prog:
entry:
       0:       r2 = 0
       1:       *(u32 *)(r1 + 48) = r2
       2:       r2 = 0 ll
       4:       r3 = 0
       5:       call 12
       6:       r0 = 0
       7:       exi
</pre>
</div>

<p>
<code>section 1/0</code> 表示 <code>looper()</code> 函数位于map的第0槽位， map id 为1。
</p>

<p>
<code>jmp_map</code> 被固定到了文件系统，用户态应用可以通过该节点进行检索，tc自身也通过 <code>jmp_map</code> 节点来更新尾调用程序。更新过程是原子的。
</p>

<p>
tc执行尾调用更新的示例：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc exec bpf graft m:globals/jmp_map key 0 obj new.o sec foo</span>
</pre>
</div></li>

<li><p>
<b>最大512字节的栈空间</b>
</p>

<p>
可以通过 <code>BPF_MAP_TYPE_PERCPU_ARRAY</code> 创建只包含一项成员的映射，来扩大可使用的缓冲区空间。
</p></li>

<li><p>
<b>可以使用BPF内联汇编</b>
</p>

<p>
LLVM 从6.0版本，允许在BPF程序中使用内联汇编。以下是一个64位加操作的内联汇编示例。更多的使用方法可以参考LLVM源码中的 <code>lib/Target/BPF/BPFInstrInfo.td</code> 和 <code>test/CodeGen/BPF/</code> 。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">&lt;linux/bpf.h&gt;</span>

<span style="color: #FF1493;">#if</span><span style="color: #FF1493; font-weight: bold;">n</span><span style="color: #FF1493;">def</span> __section
<span style="color: #FF1493;"># define</span> <span style="color: #87D700;">__section</span>(<span style="color: #FF8C00;">NAME</span>)                  \
   <span style="color: #FF1493;">__attribute__</span>((section(NAME), used))
<span style="color: #FF1493;">#endif</span>

__section(<span style="color: #CDC673;">"prog"</span>)
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">xdp_test</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">xdp_md</span> *<span style="color: #FF8C00;">ctx</span>)
{
    <span style="color: #5FD7FF;">__u64</span> <span style="color: #FF8C00;">a</span> = 2, <span style="color: #FF8C00;">b</span> = 3, *<span style="color: #FF8C00;">c</span> = &amp;a;
    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">just a toy xadd example to show the syntax</span><span style="color: #8B8878;"> */</span>
    <span style="color: #FF1493;">asm</span> <span style="color: #FF1493;">volatile</span>(<span style="color: #CDC673;">"lock *(u64 *)(%0+0) += %1"</span> : <span style="color: #CDC673;">"=r"</span>(c) : <span style="color: #CDC673;">"r"</span>(b), <span style="color: #CDC673;">"0"</span>(c));
    <span style="color: #FF1493;">return</span> a;
}

<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">__license</span>[] __section(<span style="color: #CDC673;">"license"</span>) = <span style="color: #CDC673;">"GPL"</span>;
</pre>
</div>

<p>
以上程序经过编译后，生成下面的BPF指令序列：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87D700;">Verifier</span> <span style="color: #FF1493;">analysis</span>:
  <span style="color: #FF1493;">0</span>: (b7) r1 = 2
  <span style="color: #FF1493;">1</span>: (7b) *(u64 *)(r10 -8) = r1
  <span style="color: #FF1493;">2</span>: (b7) r1 = 3
  <span style="color: #FF1493;">3</span>: (bf) r2 = r10
  <span style="color: #FF1493;">4</span>: (07) r2 += -8
  <span style="color: #FF1493;">5</span>: (db) lock *(u64 *)(r2 +0) += r1
  <span style="color: #FF1493;">6</span>: (79) r0 = *(u64 *)(r10 -8)
  <span style="color: #FF1493;">7</span>: (95) exit
  <span style="color: #FF1493;">processed</span> 8 insns (limit 131072), stack depth 8
</pre>
</div></li>

<li><p>
<b>通过 #pragma pack 移除struct中为了对齐而填充的空间。</b>
</p>

<p>
现代编译器为了内存访问更加高效，会默认对数据结构进行对齐。结构体的成员会对齐到处理器的字大小（64位处理器8字节对齐，32位处理器4字节对齐），因此实际的结构体大小可能比实际定义的成员要大。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">called_info</span> {
    <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">start</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">8-byte</span>
    <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">end</span>;    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">8-byte</span>
    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">sector</span>; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">4-byte</span>
}; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">size of 20-byte ?</span>

printf(<span style="color: #CDC673;">"size of %d-byte\n"</span>, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">called_info</span>)); <span style="color: #8B8878;">// </span><span style="color: #8B8878;">size of 24-byte</span>

<span style="color: #8B8878;">// </span><span style="color: #8B8878;">Actual compiled composition of struct called_info</span>
<span style="color: #8B8878;">// </span><span style="color: #8B8878;">0x0(0)                   0x8(8)</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">&#8595;________________________&#8595;</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|        start (8)       |</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|________________________|</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|         end  (8)       |</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|________________________|</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|  sector(4) |  PADDING  | &lt;= address aligned to 8</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|____________|___________|     with 4-byte PADDING.</span>
</pre>
</div>

<p>
BPF验证器会检查栈的边界，确保程序不会访问到未初始化的栈空间。当map的value是带有padding的结构体时，会导致 <code>bpf_prog_load()</code> 加载失败，原因是访问了无效的栈空间。例如：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">called_info</span> {
    <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">start</span>;
    <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">end</span>;
    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">sector</span>;
};

<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">bpf_map_def</span> <span style="color: #87D700;">SEC</span>(<span style="color: #CDC673;">"maps"</span>) called_info_map = {
    .type = BPF_MAP_TYPE_HASH,
    .key_size = <span style="color: #FF1493;">sizeof</span>(<span style="color: #5FD7FF;">long</span>),
    .value_size = <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">called_info</span>),
    .max_entries = 4096,
};

SEC(<span style="color: #CDC673;">"kprobe/submit_bio"</span>)
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">submit_bio_entry</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">pt_regs</span> *<span style="color: #FF8C00;">ctx</span>)
{
    <span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">fmt</span>[] = <span style="color: #CDC673;">"submit_bio(bio=0x%lx) called: %llu\n"</span>;
    <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">start_time</span> = bpf_ktime_get_ns();
    <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">bio_ptr</span> = PT_REGS_PARM1(ctx);
    <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">called_info</span> <span style="color: #FF8C00;">called_info</span> = {
            .start = start_time,
            .end = 0,
            .sector = 0
    };

    bpf_map_update_elem(&amp;called_info_map, &amp;bio_ptr, &amp;called_info, BPF_ANY);
    bpf_trace_printk(fmt, <span style="color: #FF1493;">sizeof</span>(fmt), bio_ptr, start_time);
    <span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>

<p>
Corresponding output on <code>bpf_load_program()</code> 执行时对应的输出:
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87D700;">bpf_load_program</span>() err=13
<span style="color: #87D700;">0</span>: (bf) r6 = r1
...
<span style="color: #87D700;">19</span>: (b7) r1 = 0
<span style="color: #87D700;">20</span>: (7b) *(u64 *)(r10 -72) = r1
<span style="color: #87D700;">21</span>: (7b) *(u64 *)(r10 -80) = r7
<span style="color: #87D700;">22</span>: (63) *(u32 *)(r10 -64) = r1
...
<span style="color: #87D700;">30</span>: (85) call bpf_map_update_elem#2
<span style="color: #87D700;">invalid</span> <span style="color: #FF1493;">indirect</span> read from stack off -80+20 size 24
</pre>
</div>

<p>
<code>bpf_prog_load()</code> 中会调用 <code>bpf_check()</code> ，其中通过调用 <code>check_func_arg() -&gt; check_stack_boundary()</code> 检查栈边界。由于 <code>struct called_info</code> 编译后占24字节，而错误信息中描述的意思是从20字节之后的空间为无效的，不能读取（padding空间）。
</p>
<div class="org-src-container">
<pre class="src src-fundamental">// Actual compiled composition of struct called_info
// 0x10(16)    0x14(20)    0x18(24)
//  &#8595;____________&#8595;___________&#8595;
//  |  sector(4) |  PADDING  | &lt;= address aligned to 8
//  |____________|___________|     with 4-byte PADDING.
</pre>
</div>

<p>
<code>check_stack_boundary()</code> 函数从指针起始位置开始，检查24字节的空间是否被初始化，并且处于堆栈边界内，由于 padding 空间无法使用，所以导致 <code>‘invalid indirect read from stack’</code> 错误。如果要避免此类错误，可以从结构体移除 padding 空间， <code>#pragma pack(n)</code> 指令可以实现该功能：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#pragma</span> pack(4)
<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">called_info</span> {
    <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">start</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">8-byte</span>
    <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">end</span>;    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">8-byte</span>
    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">sector</span>; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">4-byte</span>
}; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">size of 20-byte ?</span>

printf(<span style="color: #CDC673;">"size of %d-byte\n"</span>, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">called_info</span>)); <span style="color: #8B8878;">// </span><span style="color: #8B8878;">size of 20-byte</span>

<span style="color: #8B8878;">// </span><span style="color: #8B8878;">Actual compiled composition of packed struct called_info</span>
<span style="color: #8B8878;">// </span><span style="color: #8B8878;">0x0(0)                   0x8(8)</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">&#8595;________________________&#8595;</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|        start (8)       |</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|________________________|</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|         end  (8)       |</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|________________________|</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|  sector(4) |             &lt;= address aligned to 4</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|____________|                 with no PADDING.</span>
</pre>
</div>

<p>
在 <code>struct called_info</code> 的定义前放置 <code>#pragma pack(4)</code> ，会使编译器按照最小成员的大小进行对齐。 上述示例中为4字节对齐。
</p>

<p>
移除 padding 也有缺点，编译器无法生成最优代码，并且由于移除 padding 后，处理器无法按照对齐方式访问结构体，导致性能下降（部分架构会拒绝未对齐的内存访问）。
</p>

<p>
还有一种方法：显示的增加成员，使得结构体无需 padding 就能对齐。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">called_info</span> {
    <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">start</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">8-byte</span>
    <span style="color: #5FD7FF;">u64</span> <span style="color: #FF8C00;">end</span>;    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">8-byte</span>
    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">sector</span>; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">4-byte</span>
    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">pad</span>;    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">4-byte</span>
}; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">size of 24-byte ?</span>

printf(<span style="color: #CDC673;">"size of %d-byte\n"</span>, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">called_info</span>)); <span style="color: #8B8878;">// </span><span style="color: #8B8878;">size of 24-byte</span>

<span style="color: #8B8878;">// </span><span style="color: #8B8878;">Actual compiled composition of struct called_info with explicit padding</span>
<span style="color: #8B8878;">// </span><span style="color: #8B8878;">0x0(0)                   0x8(8)</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">&#8595;________________________&#8595;</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|        start (8)       |</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|________________________|</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|         end  (8)       |</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|________________________|</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|  sector(4) |  pad (4)  | &lt;= address aligned to 8</span>
<span style="color: #8B8878;">//  </span><span style="color: #8B8878;">|____________|___________|     with explicit PADDING.</span>
</pre>
</div></li>

<li><p>
<b>通过无效的引用访问数据包</b>
</p>

<p>
在类似 <code>bpf_skb_store_bytes</code> 的网络辅助函数中，可能会修改数据包大小。由于验证器无法跟踪此类修改，验证器会将之前对数据包引用视为无效。因此在访问数据包前需要更新引用，避免被验证器拒绝。例如：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">ip4</span> = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *) skb-&gt;data + ETH_HLEN;

<span style="color: #87D700;">skb_store_bytes</span>(skb, l3_off + offsetof(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>, saddr), &amp;new_saddr, 4, 0);

<span style="color: #FF1493;">if</span> (ip4-&gt;protocol == IPPROTO_TCP) {
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">do something</span>
}
</pre>
</div>

<p>
验证器将 <code>ip4-&gt;protocol</code> 引用视作无效，并拒绝运行：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #87D700;">R1=pkt_end</span>(id=0,off=0,imm=0) R2=pkt(id=0,off=34,r=34,imm=0) R3=inv0
<span style="color: #87D700;">R6=ctx</span>(id=0,off=0,imm=0) R7=inv(id=0,umax_value=4294967295,var_off=(0x0<span style="color: #8B8878;">; </span><span style="color: #8B8878;">0xffffffff))</span>
<span style="color: #87D700;">R8=inv4294967162</span> <span style="color: #FF1493;">R9</span>=pkt(id=0,off=0,r=34,imm=0) R10=fp0,call_-1
...
<span style="color: #87D700;">18</span>: (85) call bpf_skb_store_bytes#9
<span style="color: #87D700;">19</span>: (7b) *(u64 *)(r10 -56) = r7
<span style="color: #87D700;">R0=inv</span>(id=0) R6=ctx(id=0,off=0,imm=0) R7=inv(id=0,umax_value=2,var_off=(0x0<span style="color: #8B8878;">; </span><span style="color: #8B8878;">0x3))</span>
<span style="color: #87D700;">R8=inv4294967162</span> <span style="color: #FF1493;">R9</span>=inv(id=0) R10=fp0,call_-1 fp-48=mmmm???? fp-56=mmmmmmmm
<span style="color: #87D700;">21</span>: (61) r1 = *(u32 *)(r9 +23)
<span style="color: #87D700;">R9</span> <span style="color: #FF1493;">invalid</span> mem access 'inv'
</pre>
</div>

<p>
要解决这个问题，则需要更新对 <code>ip4</code> 的引用：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">ip4</span> = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *) skb-&gt;data + ETH_HLEN;

<span style="color: #87D700;">skb_store_bytes</span>(skb, l3_off + offsetof(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>, saddr), &amp;new_saddr, 4, 0);

ip4 = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *) skb-&gt;data + ETH_HLEN;

<span style="color: #FF1493;">if</span> (ip4-&gt;protocol == IPPROTO_TCP) {
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">do something</span>
}
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-orge1b53d4" class="outline-3">
<h3 id="orge1b53d4"><span class="section-number-3">2.7.</span> iproute2</h3>
<div class="outline-text-3" id="text-2-7">
<p>
加载BPF的前端有许多，包括bcc、perf、iproute2等等。内核也提供了用户空间库 <code>tools/lib/bpf</code> ，主要由 perf 使用，用于加载BPF跟踪程序。bcc则为BPF提供了很多有用的程序，这些主要是用于跟踪的，这些程序可以由嵌入C代码的python接口临时加载。不同的前端，其BPF语法和语义各不相同。kernel源码树中也包含部分BPF代码示例，位于 <code>samples/bpf</code> 目录下，可以用于解析生成的对象文件，并通过系统调用接口直接加载。
</p>

<p>
iproute2支持的所有BPF程序类型都共享相同的加载逻辑，因为其后端使用的相同的库，该库由iproute2源码中的 <code>lib/bpf.c</code> 实现。
</p>

<p>
接下来主要介绍一些iproute2加载对象文件的示例，以及加载器的一些通用机制。
</p>

<ol class="org-ol">
<li><p>
<b>XDP BPF object 文件的加载</b>
</p>

<p>
通过 <code>ip</code> 加载BPF object 文件 <code>prog.o</code> ，该文件是为XDP编译：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdp obj prog.o</span>
</pre>
</div>
<p>
上述命令假设程序代码位于 <code>prog</code> section中，如果 section是其他名称，例如 <code>foobar</code> ，则使用以下命令加载：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdp obj prog.o sec foobar</span>
</pre>
</div>

<p>
也可以将程序代码放置到 <code>.text</code> section中进行加载（移除 <code>__section()</code> 修饰）。例如：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;">#</span><span style="color: #8B8878;">include &lt;linux/bpf.h&gt;</span>

<span style="color: #8B8878;">#</span><span style="color: #8B8878;">ifndef __section</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">define __section(NAME)                  \</span>
   __attribute__((section(NAME), used))
<span style="color: #8B8878;">#</span><span style="color: #8B8878;">endif</span>

int xdp_drop(struct xdp_md *ctx)
{
    <span style="color: #FF1493;">return</span> XDP_DROP;
}

char __license[] __section(<span style="color: #CDC673;">"license"</span>) = <span style="color: #CDC673;">"GPL"</span>;
</pre>
</div>
<p>
加载命令如下：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdp obj prog.o sec .text</span>
</pre>
</div>

<p>
默认情况下，如果对应的网络接口已经加载了XDP程序，再次加载时会返回错误，以防止不小心覆盖程序。如果确实需要替换现有程序，可以使用 <code>-force</code> 选项，例如：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdp obj prog.o</span>
</pre>
</div>

<p>
大多数支持XDP的驱动都支持原子的替换程序，并且不需要中断流量。出于性能的原因，一个XDP使能的驱动程序只能关联一个XDP程序。但是可以通过尾调用将程序进行分块，已达到类似加载多个程序的目的。
</p>

<p>
<code>ip link</code> 命令可以显示网络接口是否已经关联了XDP程序。 <code>ip link | grep xdp</code> 可以找出所有关联XDP程序的接口，然后通过 <code>ip -d link</code> 进一步查看详细信息。 <code>bpftool</code>  工具可以基于 <code>ip link</code> 的输出中的 <code>BPF program ID</code> ，获取关联的程序信息。
</p>

<p>
移除已经关联的XDP程序：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdp off</span>
</pre>
</div>

<p>
如果要将驱动程序的模式从 <code>non-XDP</code> 切换为 <code>XDP</code> 或者反向切换时，驱动程序通常需要重新配置其接收和发送 <code>ring</code> ，以确保接收的数据包被线性的组织在单个页内面内，供BPF读取。不过，只要该操作完成，大多数驱动程序只需要在要求替换BPF程序时执行原子替换。
</p>

<p>
XDP总共支持三种操作模式：xdpdrv、xdpoffload、xdpgeneric。
</p>

<p>
<code>xdpdrv</code> 代表原生XDP，也就是说，可以在驱动接收路径的最早位置（软件可处理）直接执行BPF程序。 这是标准的XDP模式，需要驱动实现XDP的支持，上游linux内核已经为所有主流的 10G/40G/+ 网络驱动提供了XDP支持。
</p>

<p>
xdpgeneric表示通用的XDP，主要是为一些不支持原生XDP的驱动程序提供实验测试平台，这种模式下XDP hook位置执行时，数据包已经作为 <code>skb</code> 进入了网络堆栈的主接收路径，其处理性能比 <code>xdpdrv</code> 模式低得多。因此 <code>xdpgeneric</code> 通常用于实验测试，很少用于生产环境。
</p>

<p>
<code>xdpoffload</code> 模式则由智能网卡（SmartNICs）实现，例如 Netronome’s的 nfp 驱动，能够将整个 BPF/XDP 程序卸载到硬件，因此程序对数据包的处理直接在网卡执行。此模式并不一定支持所有的程序类型，也不一定可以使用所有的辅助函数，但是相对于 <code>xdpdrv</code> 来说， <code>xdpoffload</code> 性能更高。当使用了不支持的程序类型或者辅助函数时，验证器会拒绝程序的执行，并提示哪部分不受支持。
</p>

<p>
当使用类似 <code>ip link set dev em1 xdp obj [...]</code> 的命令加载程序时，首先尝试 <code>xdpdrv</code> 模式，如果不支持，则尝试 <code>xdpgeneric</code> 模式。如果只使用 <code>xdpdrv</code> 模式，则可以显示指定 <code>xdpdrv</code> ，如果内核不支持，则加载失败。
</p>

<p>
强制使用 <code>xdpdrv</code> 模式以及卸载程序的示例：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpdrv obj prog.o</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link show</span>
[...]
6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdp qdisc mq state UP mode DORMANT group default qlen 1000
    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff
    prog/xdp id 1 tag 57cd311f2e27366b
[...]
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdpdrv off</span>
</pre>
</div>

<p>
强制 <code>xdpgeneric</code> 模式，并通过 <code>bpftool</code> 输出对应程序的BPF指令：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpgeneric obj prog.o</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link show</span>
[...]
6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpgeneric qdisc mq state UP mode DORMANT group default qlen 1000
    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff
    prog/xdp id 4 tag 57cd311f2e27366b                &lt;-- BPF program ID 4
[...]
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog dump xlated id 4                       &lt;-- Dump of instructions running on em1</span>
0: (b7) r0 = 1
1: (95) <span style="color: #FF1493;">exit</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdpgeneric off</span>
</pre>
</div>

<p>
使用 <code>xdpoffload</code> 模式，并通过 <code>bpftool</code> 输出程序信息：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpoffload obj prog.o</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link show</span>
[...]
6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpoffload qdisc mq state UP mode DORMANT group default qlen 1000
    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff
    prog/xdp id 8 tag 57cd311f2e27366b
[...]
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog show id 8</span>
8: xdp  tag 57cd311f2e27366b dev em1                  &lt;-- Also indicates a BPF program offloaded to em1
    loaded_at Apr 11/20:38  uid 0
    xlated 16B  not jited  memlock 4096B
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdpoffload off</span>
</pre>
</div>

<p>
注意： <code>xdpdrv</code> 、 <code>xdpgengric</code> 、 <code>xdpoffload</code> 不能够同时使用。
</p>

<p>
在模式之间切换时，不能进行原子操作，例如：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpgeneric obj prog.o</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpoffload obj prog.o</span>
RTNETLINK answers: File exists
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpdrv obj prog.o</span>
RTNETLINK answers: File exists
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpgeneric obj prog.o    &lt;-- Succeeds due to xdpgeneric</span>
<span style="color: #8B8878;">#</span>
</pre>
</div>

<p>
模式之间切换，只能够先离开该模式，然后进入新模式：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpgeneric obj prog.o</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpgeneric off</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpoffload obj prog.o</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip l</span>
[...]
6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpoffload qdisc mq state UP mode DORMANT group default qlen 1000
    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff
    prog/xdp id 17 tag 57cd311f2e27366b
[...]
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev em1 xdpoffload off</span>
</pre>
</div></li>

<li><p>
<b>tc BPF object 文件的加载</b>
</p>

<p>
加载为tc编译的 BPF object文件 <code>prog.o</code> ，使用tc命令加载到netdevice。tc加载时并不需要向XDP一样依赖驱动程序的支持。以下是将程序加载到 <code>em1</code> 设备的网络 <code>ingress</code> 路径：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc qdisc add dev em1 clsact</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter add dev em1 ingress bpf da obj prog.o</span>
</pre>
</div>

<p>
第一步首先创建一个 <code>clsact</code> 的qdisc(Linux queueing discipline)，clsact是一个虚拟的qdisc，和 <code>ingress</code> 的qdisc类似，其中只包含分类器和动作，但不执行实际的排队。bpf程序需要通过 <code>clsact</code> 关联bpf分类器。 <code>clsact</code> qdisc提供了两个特殊的hook <code>ingress</code> 和 <code>egress</code> ，分类器可以附加到该hook。 <code>ingress</code> 和 <code>egress</code> hook位于数据包接收和发送的核心路径，每个数据包都会从此处经过。 <code>ingress</code>  hook 的调用： <code>__netif_receive_skb_core() -&gt; sch_handle_ingress()</code> ， <code>egress</code> hook的调用： <code>__dev_queue_xmit() -&gt; sch_handle_egress()</code> 。
</p>

<p>
将程序关联到 <code>egress</code> hook：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter add dev em1 egress bpf da obj prog.o</span>
</pre>
</div>

<p>
<code>clsact</code> qdisc在 <code>ingress</code> 和 <code>egress</code> 方向的处理都是无锁的，并且可以关联到无队列的虚拟设备（连接容器的veth）。
</p>

<p>
<code>tc filter</code> 命令可以选择bpf使用 <code>da</code> 模式（direct-action）。 建议使用da模式，并且始终指定该模式。这也意味着bpf分类器不需要调用其他扩展的tc操作模块，所有数据包的修改、转发或者其他操作都可以在BPF程序内部执行，因此也更快。
</p>

<p>
指定特定的section（例如 <code>foobar</code> ）：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter add dev em1 egress bpf da obj prog.o sec foobar</span>
</pre>
</div>

<p>
列出已经关联的BPF程序：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter show dev em1 ingressn</span>
filter protocol all pref 49152 bpf
filter protocol all pref 49152 bpf handle 0x1 prog.o:[ingress] direct-action id 1 tag c5f7825e5dac396f

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter show dev em1 egress</span>
filter protocol all pref 49152 bpf
filter protocol all pref 49152 bpf handle 0x1 prog.o:[egress] direct-action id 2 tag b2fd5adc0f262714
</pre>
</div>

<p>
输出中的 <code>prog.o:[ingress]</code> 表示加载的程序 <code>prog.o</code> 中的 <code>ingress</code> section，并且bpf运行在 <code>direct-action</code> 模式。 <code>tag</code> 是指令流的函数值，和 <code>id</code> 配合，用于和object文件以及perf的堆栈跟踪报告相关联。  <code>id</code> 在整个系统内唯一， 和 <code>bpftool</code> 一起使用来检查和转储关联的 BPF 程序。
</p>

<p>
tc可以关联多个BPF程序，同时提供了各种分类器，这些分类器可以串联在一起。然而，由于 <code>da</code> 模式下所有的操作都可以包含在BPF程序中，所以只需要关联一个BPF程序就能够完全满足需求，也就是说BPF程序自身就可以返回tc的动作判决（例如 <code>TC_ACT_OK</code>, <code>TC_ACT_SHOT</code> 或者其他）。出于最佳性能和灵活性考虑，建议使用这种方式。
</p>

<p>
上述 <code>show</code> 命令的输出中，还显示了 <code>pref 49152</code> 和 <code>handle 0x1</code> ，这两个都是自动生成， <code>pref</code> 代表优先级， 关联多个分裂器时，依据 <b>递增的优先级</b> 执行， <code>handle</code> 标识符用于区分相同的分类器下加载相同的 <code>pref</code> 的多个实例。通常加载一个BPF程序就足够了，所以可以忽略 <code>pref</code> 和 <code>handle</code> 。
</p>

<p>
只有在需要原子的替换已经关联的程序时，才建议在初始加载时显示指定 <code>pref</code> 和 <code>handle</code> ，这样后续替换程序时，就不必查找操作：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter add dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar</span>

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter show dev em1 ingress</span>
filter protocol all pref 1 bpf
filter protocol all pref 1 bpf handle 0x1 prog.o:[foobar] direct-action id 1 tag c5f7825e5dac396f
</pre>
</div>

<p>
显示指定 <code>pref</code> 和 <code>handle</code> 执行原子替换：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter replace dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar</span>
</pre>
</div>

<p>
移除 <code>ingress</code> 和 <code>egress</code> hook 关联的所有BPF程序：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter del dev em1 ingress</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter del dev em1 egress</span>
</pre>
</div>

<p>
当从netdevice移除 <code>clsqct</code> qdisc时，会隐式的移除所有关联的BPF程序：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc qdisc del dev em1 clsact</span>
</pre>
</div>

<p>
如果驱动程序支持XDP BPF程序，也可以将tc BPF程序卸载到网卡执行：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc qdisc add dev em1 clsact</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o</span>
Error: TC offload is disabled on net device.
We have an error talking to the kernel
</pre>
</div>

<p>
以上错误表示，需要首先开启硬件的tc卸载：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ethtool -K em1 hw-tc-offload on</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc qdisc add dev em1 clsact</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter show dev em1 ingress</span>
filter protocol all pref 1 bpf
filter protocol all pref 1 bpf handle 0x1 prog.o:[classifier] direct-action skip_sw in_hw id 19 tag 57cd311f2e27366b
</pre>
</div>

<p>
<code>in_hw</code> 标志表示程序已经被卸载到网卡。
</p>

<p>
注意：BPF卸载时，不能同时指定 XDP 和 tc ，只能二选一。
</p></li>

<li><p>
<b>通过 <code>netdevsim</code> 驱动测试BPF卸载</b>
</p>

<p>
Linux内核提供了虚拟的 <code>netdevsim</code> 驱动，实现了XDP BPF程序和tc BPF程序卸载的方法和接口，用于测试内核变更，或者直接针对内核UAPI实现控制面的低级别用户空间程序。
</p>

<p>
创建 <code>netdevsim</code> 设备：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">modprobe netdevsim</span>
// [ID] [PORT_COUNT]
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo "1 1" &gt; /sys/bus/netdevsim/new_device</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">devlink dev</span>
netdevsim/netdevsim1
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">devlink port</span>
netdevsim/netdevsim1/0: type eth netdev eth0 flavour physical
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip l</span>
[...]
4: eth0: &lt;BROADCAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/ether 2a:d5:cd:08:d1:3f brd ff:ff:ff:ff:ff:ff
</pre>
</div>

<p>
创建后，就可以加载XDP BPF和tc BPF程序了：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev eth0 xdpoffload obj prog.o</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip l</span>
[...]
4: eth0: &lt;BROADCAST,NOARP,UP,LOWER_UP&gt; mtu 1500 xdpoffload qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/ether 2a:d5:cd:08:d1:3f brd ff:ff:ff:ff:ff:ff
    prog/xdp id 16 tag a04f5eef06a7f555
</pre>
</div></li>
</ol>



<p>
BPF加载器还有一些高级选项，对于XDP和tc都适用。
</p>

<ol class="org-ol">
<li><p>
<b>即使加载成功也输出详细日志</b>
</p>

<p>
<code>verb</code> 选项可以在没有错误时，也输出验证器日志。
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdp obj xdp-example.o verb</span>
Prog section <span style="color: #CDC673;">'prog'</span> loaded (5)<span style="color: #CDC673; font-weight: bold;">!</span>
 - Type:         6
 - Instructions: 2 (0 over limit)
 - License:      GPL

Verifier analysis:

0: (b7) r0 = 1
1: (95) <span style="color: #FF1493;">exit</span>
processed 2 insns
</pre>
</div></li>

<li><p>
<b>加载已经固定在BPF文件系统中的程序</b>
</p>

<p>
iproute2 可以从BPF文件系统获取程序，并将其加载到设备:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdp pinned /sys/fs/bpf/prog</span>
</pre>
</div>

<p>
iproute2也可以使用相对于BPF文件系统挂载点的简写形式：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip link set dev em1 xdp pinned m:prog</span>
</pre>
</div></li>
</ol>

<p>
加载BPF程序时，iproute2会自动检测已加载的文件系统实例，以便对节点进行 =pinning=。如果没有找到已加载的 BPF 文件系统实例，自动将其加载到 <i>sys/fs/bpf</i> 下。如果找到实例，则无需执行额外的挂载。
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">mkdir /var/run/bpf</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">mount --bind /var/run/bpf /var/run/bpf</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">mount -t bpf bpf /var/run/bpf</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter add dev em1 ingress bpf da obj tc-example.o sec prog</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tree /var/run/bpf</span>
/var/run/bpf
+-- ip -&gt; /run/bpf/tc/
+-- tc
|   +-- globals
|       +-- jmp_map
+-- xdp -&gt; /run/bpf/tc/

4 directories, 1 file
</pre>
</div>

<p>
默认情况下，tc 创建一个初始目录结构，所有子系统用户都将通过 <code>globals</code> 命名空间的符号链接指向同一位置，这样 iproute2 的各种 BPF 程序类型就能够重复使用固定的 BPF 映射。如果文件系统实例已经挂载，且现有结构已经存在，则 tc 不会覆盖它。This could be the case for separating lwt, tc and xdp maps in order to not share globals among all.
</p>

<p>
iproute2在安装时，会安装一个头文件，BPF程序可以包含该头文件：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">&lt;iproute2/bpf_elf.h&gt;</span>
</pre>
</div>
<p>
这个头文件提供了map相关的API，以及层序默认使用 <code>section</code> 名称。
</p>

<p>
iproute2 的map定义为 <code>struct bpf_elf_map</code> 。
</p>

<p>
在解析 BPF object文件时，iproute2加载器查看所有 ELF section。首先，获取 <code>map</code> 和 <code>license</code> 的section。对于 <code>map</code> ，检查 <code>struct bpf_elf_map</code> 数组的有效性，以及兼容性检查。随后，根据用户提供的信息创建所有 <code>map</code> 或者根据这些信息检索 pinned object。如果是新创建的，将其固定到 BPF 文件系统中。之后，加载器处理所有包含 ELF map重定位条目，这意味着将 <code>map</code> 文件描述符加载到寄存器的 BPF 指令会被重写，以便将相应的 <code>map</code> 文件描述符编码到指令的立即值中，内核稍后能将其转换为 <code>map</code> 的内核指针。之后，所有程序都将通过 BPF 系统调用创建，如果存在尾调用 <code>map</code> ，也将用程序的文件描述符进行更新。
</p>
</div>
</div>
</div>


<div id="outline-container-org8b1678a" class="outline-2">
<h2 id="org8b1678a"><span class="section-number-2">3.</span> 调试及测试</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgcc3de05" class="outline-3">
<h3 id="orgcc3de05"><span class="section-number-3">3.1.</span> bpftool</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<code>bpftool</code> 是主要的自省和调试工具，位于Linux内核源码的 <code>tools/bpf/bpftool/</code> 目录。
</p>

<p>
该工具可以输出当前系统中已经加载的所有BPF程序和map，并将程序和map进行关联。还允许打印map的所有key/value，执行查找、更新、删除等操作。这些操作需要基于 BPF程序，或者map ID，或者被固定到BPF文件系统中的程序或者map。还可以通过 <code>bpftool</code> 工具将程序或者map固定到BPF文件系统。
</p>

<p>
查看当前主机加载的 BPF programs ：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog</span>
398: sched_cls  tag 56207908be8ad877
   loaded_at Apr 09/16:24  uid 0
   xlated 8800B  jited 6184B  memlock 12288B  map_ids 18,5,17,14
399: sched_cls  tag abc95fb4835a6ec9
   loaded_at Apr 09/16:24  uid 0
   xlated 344B  jited 223B  memlock 4096B  map_ids 18
400: sched_cls  tag afd2e542b30ff3ec
   loaded_at Apr 09/16:24  uid 0
   xlated 1720B  jited 1001B  memlock 4096B  map_ids 17
401: sched_cls  tag 2dbbd74ee5d51cc8
   loaded_at Apr 09/16:24  uid 0
   xlated 3728B  jited 2099B  memlock 4096B  map_ids 17
[...]
</pre>
</div>

<p>
查看所有 maps：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool map</span>
5: hash  flags 0x0
    key 20B  value 112B  max_entries 65535  memlock 13111296B
6: hash  flags 0x0
    key 20B  value 20B  max_entries 65536  memlock 7344128B
7: hash  flags 0x0
    key 10B  value 16B  max_entries 8192  memlock 790528B
8: hash  flags 0x0
    key 22B  value 28B  max_entries 8192  memlock 987136B
9: hash  flags 0x0
    key 20B  value 8B  max_entries 512000  memlock 49352704B
[...]
</pre>
</div>


<p>
<code>bpftool</code> 支持输出json格式（ <code>--json</code> ），还可以增加 <code>--pretty</code> 参数，可读性更好。
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog --json --pretty</span>
</pre>
</div>

<p>
？？？ <code>For dumping the post-verifier BPF instruction image of a specific BPF program, one starting point could be to inspect a specific program, e.g. attached to the tc ingress hook:</code>
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter show dev cilium_host egress</span>
filter protocol all pref 1 bpf chain 0
filter protocol all pref 1 bpf chain 0 handle 0x1 bpf_host.o:[from-netdev] <span style="color: #CDC673; font-weight: bold;">\</span>
                    direct-action not_in_hw id 406 tag e0362f5bd9163a0a jited
</pre>
</div>
<p>
程序的对象文件为 <code>bpf_host.o</code> ，section名称为 <code>from-netdev</code> ，BPF program ID: 406。基于这些信息， <code>bpftool</code> 可以提供更高级别的元数据：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog show id 406</span>
406: sched_cls  tag e0362f5bd9163a0a
     loaded_at Apr 09/16:24  uid 0
     xlated 11144B  jited 7721B  memlock 12288B  map_ids 18,20,8,5,6,14
</pre>
</div>
<p>
该程序的类型为 <code>sched_cls (BPF_PROG_TYPE_SCHED_CLS)</code> ，tag为 e0362f5bd9163a0a （整成指令序列的hash）， 由root <code>uid 0</code> 用户加载，加载时间 <code>Apr 09/16:24</code> 。BPF指令序列为 11,144 bytes 长度，JITed 映像为 7,721 bytes。 程序自身占据 12,288 bytes（不包含map）。BPF program的所有 map IDs：18、20、8、5、614。 map IDs 可以用于输出该map自身的信息
。
</p>

<p>
转储程序运行的BPF指令：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog dump xlated id 406</span>
 0: (b7) r7 = 0
 1: (63) *(u32 *)(r1 +60) = r7
 2: (63) *(u32 *)(r1 +56) = r7
 3: (63) *(u32 *)(r1 +52) = r7
[...]
47: (bf) r4 = r10
48: (07) r4 += -40
49: (79) r6 = *(u64 *)(r10 -104)
50: (bf) r1 = r6
51: (18) r2 = map[id:18]                    &lt;-- BPF map id 18
53: (b7) r5 = 32
54: (85) call bpf_skb_event_output#5656112  &lt;-- BPF helper call
55: (69) r1 = *(u16 *)(r6 +192)
[...]
</pre>
</div>

<p>
如上所示， <code>bpftool</code> 可以将map ID关联到指令流、BPF辅助函数、其他BPF程序等。
</p>

<p>
<code>bpftool</code> 的 <code>dump</code> 指令重用了内核验证器的打印格式。由于程序JIT后执行的，因此会将上述 <code>xlated</code> 的指令生成实际的JIT映像来执行，转储实际的JIT映像：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog dump jited id 406</span>
 0:        push   %rbp
 1:        mov    %rsp,%rbp
 4:        sub    $<span style="color: #FF8C00;">0</span>x228,%rsp
 b:        sub    $<span style="color: #FF8C00;">0</span>x28,%rbp
 f:        mov    %rbx,0x0(%rbp)
13:        mov    %r13,0x8(%rbp)
17:        mov    %r14,0x10(%rbp)
1b:        mov    %r15,0x18(%rbp)
1f:        xor    %eax,%eax
21:        mov    %rax,0x20(%rbp)
25:        mov    0x80(%rdi),%r9d
[...]
</pre>
</div>

<p>
对于BPF JIT 开发者，可以通过 <code>opcodes</code> 选项, 输出本机操作码：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog dump jited id 406 opcodes</span>
 0:        push   %rbp
           55
 1:        mov    %rsp,%rbp
           48 89 e5
 4:        sub    $<span style="color: #FF8C00;">0</span>x228,%rsp
           48 81 ec 28 02 00 00
 b:        sub    $<span style="color: #FF8C00;">0</span>x28,%rbp
           48 83 ed 28
 f:        mov    %rbx,0x0(%rbp)
           48 89 5d 00
13:        mov    %r13,0x8(%rbp)
           4c 89 6d 08
17:        mov    %r14,0x10(%rbp)
           4c 89 75 10
1b:        mov    %r15,0x18(%rbp)
           4c 89 7d 18
[...]
</pre>
</div>

<p>
<code>opcodes</code> 也可以用于BPF标准指令：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog dump xlated id 406 opcodes</span>
 0: (b7) r7 = 0
    b7 07 00 00 00 00 00 00
 1: (63) *(u32 *)(r1 +60) = r7
    63 71 3c 00 00 00 00 00
 2: (63) *(u32 *)(r1 +56) = r7
    63 71 38 00 00 00 00 00
 3: (63) *(u32 *)(r1 +52) = r7
    63 71 34 00 00 00 00 00
 4: (63) *(u32 *)(r1 +48) = r7
    63 71 30 00 00 00 00 00
 5: (63) *(u32 *)(r1 +64) = r7
    63 71 40 00 00 00 00 00
 [...]
</pre>
</div>

<p>
<code>bpftool</code> 还提供了可视化的dump模式， 通过 <code>visual</code> 选项生成dot文件，然后借助 <code>graphviz</code> 的dot工具转换为png文件：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog dump xlated id 406 visual &amp;&gt; output.dot</span>
$ dot -Tpng output.dot -o output.png
</pre>
</div>
<p>
也可以使用 <code>dotty</code> 工具直接查看dot文件。
</p>

<p>
<code>xlated</code> 转储的指令是验证后的BPF指令映像，就如同被BPF解释器运行的指令。内核的验证器会对BPF加载器提供的原始指令进行重写。 <code>Note that the xlated instruction dump provides the post-verifier BPF instruction image which means that it dumps the instructions as if they were to be run through the BPF interpreter. In the kernel, the verifier performs various rewrites of the original instructions provided by the BPF loader.</code>
</p>

<p>
以下是重写重写示例，将辅助函数内联，以提高执行性能：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog dump xlated id 3</span>
 0: (b7) r1 = 2
 1: (63) *(u32 *)(r10 -4) = r1
 2: (bf) r2 = r10
 3: (07) r2 += -4
 4: (18) r1 = map[id:2]                      &lt;-- BPF map id 2
 6: (85) call __htab_map_lookup_elem#77408   &lt;-+ BPF helper inlined rewrite
 7: (15) <span style="color: #FF1493;">if</span> r0 == 0x0 goto pc+2                |
 8: (07) r0 += 56                              |
 9: (79) r0 = *(u64 *)(r0 +0)                &lt;-+
10: (15) <span style="color: #FF1493;">if</span> r0 == 0x0 goto pc+24
11: (bf) r2 = r10
12: (07) r2 += -4
[...]
</pre>
</div>

<p>
<code>bpftool</code> 会通过 <code>kallsyms</code> 关联所有的辅助函数调用，以及 <code>BPF to BPF</code> 调用。因此需要确保JIT的BPF程序会将其暴露到 <code>kallsyms</code> （bpf_jit_kallsyms）中，并且 <code>kallsyms</code> 中的地址没有被混淆过（否则会显示 <code>bpf_unspec#0</code> ）。
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo 0 &gt; /proc/sys/kernel/kptr_restrict</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo 1 &gt; /proc/sys/net/core/bpf_jit_kallsyms</span>
</pre>
</div>

<p>
<code>bpftool</code> 能够关联 <code>BPF to BPF</code> 的调用。 <code>pc+2</code> 调用目标和pc的相对偏移（子程序的位置）。解释执行时，调用目标显示为函数名，在JIT情况下，调用目标会显示子程序的tag。
</p>

<p>
解释器执行时：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog dump xlated id 1</span>
0: (85) call pc+2#__bpf_prog_run_args32
1: (b7) r0 = 1
2: (95) <span style="color: #FF1493;">exit</span>
3: (b7) r0 = 2
4: (95) <span style="color: #FF1493;">exit</span>
</pre>
</div>

<p>
JITed：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog dump xlated id 1</span>
0: (85) call pc+2#bpf_prog_3b185187f1855c4c_F
1: (b7) r0 = 1
2: (95) <span style="color: #FF1493;">exit</span>
3: (b7) r0 = 2
4: (95) <span style="color: #FF1493;">exit</span>
</pre>
</div>

<p>
如果是尾调用，内核会将其映射为单个内部指令。 <code>bpftool</code> 仍然可以将其关联，用于调试：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog dump xlated id 2</span>
[...]
10: (b7) r2 = 8
11: (85) call bpf_trace_printk#-41312
12: (bf) r1 = r6
13: (18) r2 = map[id:1]
15: (b7) r3 = 0
16: (85) call bpf_tail_call#12
17: (b7) r1 = 42
18: (6b) *(u16 *)(r6 +46) = r1
19: (b7) r0 = 0
20: (95) <span style="color: #FF1493;">exit</span>

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool map show id 1</span>
1: prog_array  flags 0x0
      key 4B  value 4B  max_entries 1  memlock 4096B
</pre>
</div>

<p>
<code>bpftool</code> 还支持对map进行变量，输出所有的 key/value 。
</p>

<p>
对应的map没有 <code>=BTF (BPF Type Format)</code> 信息时，其 key/value 采用十六进制的形式输出：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool map dump id 5</span>
key:
f0 0d 00 00 00 00 00 00  0a 66 00 00 00 00 8a d6
02 00 00 00
value:
00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
key:
0a 66 1c ee 00 00 00 00  00 00 00 00 00 00 00 00
01 00 00 00
value:
00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
[...]
Found 6 elements
</pre>
</div>


<p>
如果有 <code>BTF</code> ，则会根据BTF信息组织 key/value。下面提供一个示例， 带有BTF信息的BPF映射与 iproute2中的 <code>BPF_ANNOTATE_KV_PAIR()</code> 宏结合，产生如下输出（ <code>test_xdp_noinline.o</code> 来自内核的 <code>selftests</code> ）：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">cat tools/testing/selftests/bpf/test_xdp_noinline.c</span>
  [...]
   struct ctl_value {
         union {
                 __u64 value;
                 __u32 ifindex;
                 __u8 mac[6];
         };
   };

   struct bpf_map_def __attribute__ ((section(<span style="color: #CDC673;">"maps"</span>), used)) ctl_array = {
          .type            = BPF_MAP_TYPE_ARRAY,
          .key_size        = sizeof(__u32),
          .value_size      = sizeof(struct ctl_value),
          .max_entries     = 16,
          .map_flags       = 0,
   };
   BPF_ANNOTATE_KV_PAIR(ctl_array, __u32, struct ctl_value);

   [...]
</pre>
</div>

<p>
<code>BPF_ANNOTATE_KV_PAIR()</code> 宏会强制在map对应的ELF section中生成一条空的key/value，iproute2加载器会将BTF信息与之关联，之后就可以在加载map时根据BTF选择对应的类型。
</p>

<p>
使用LLVM编译后，通过 <code>pahole</code> 工具生成BTF信息：
</p>
<pre class="example">
# clang [...] -O2 --target=bpf -g -emit-llvm -c test_xdp_noinline.c -o - |
  llc -march=bpf -mcpu=probe -mattr=dwarfris -filetype=obj -o test_xdp_noinline.o
# pahole -J test_xdp_noinline.o
</pre>

<p>
然后将其加载到内核，并使用 <code>bpftool</code> 工具遍历map：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip -force link set dev lo xdp obj test_xdp_noinline.o sec xdp-test</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">ip a</span>
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 xdpgeneric/id:227 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
[...]
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog show id 227</span>
227: xdp  tag a85e060c275c5616  gpl
    loaded_at 2018-07-17T14:41:29+0000  uid 0
    xlated 8152B  not jited  memlock 12288B  map_ids 381,385,386,382,384,383
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool map dump id 386</span>
 [{
      <span style="color: #CDC673;">"key"</span>: 0,
      <span style="color: #CDC673;">"value"</span>: {
          <span style="color: #CDC673;">""</span>: {
              <span style="color: #CDC673;">"value"</span>: 0,
              <span style="color: #CDC673;">"ifindex"</span>: 0,
              <span style="color: #CDC673;">"mac"</span>: []
          }
      }
  },{
      <span style="color: #CDC673;">"key"</span>: 1,
      <span style="color: #CDC673;">"value"</span>: {
          <span style="color: #CDC673;">""</span>: {
              <span style="color: #CDC673;">"value"</span>: 0,
              <span style="color: #CDC673;">"ifindex"</span>: 0,
              <span style="color: #CDC673;">"mac"</span>: []
          }
      }
  },{
[...]
</pre>
</div>

<p>
<code>bpftoool</code> 还能根据指定的key进行 lookup、update、delete、‘get next key’等操作。
</p>

<p>
如果BPF程序包含了BTF调试信息，在使用 <code>prog show</code> 命令打印时，会显示btf信息 <code>btf_id</code>.
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool prog show id 72</span>
72: xdp  name balancer_ingres  tag acf44cabb48385ed  gpl
   loaded_at 2020-04-13T23:12:08+0900  uid 0
   xlated 19104B  jited 10732B  memlock 20480B  map_ids 126,130,131,127,129,128
   btf_id 60
</pre>
</div>

<p>
也可以通过 <code>btf show</code> 命令列出已经加载的所有BTF：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool btf show</span>
60: size 12243B  prog_ids 72  map_ids 126,130,131,127,129,128
</pre>
</div>

<p>
<code>btf dump</code> 命令也可以用来检查BTF中包含的调试信息，调试信息可以选择 ‘raw’ 或者 ‘c’ 格式，例如采用 ‘c’ 语言的格式输出：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">bpftool btf dump id 60 format c</span>
  [...]
   struct ctl_value {
         union {
                 __u64 value;
                 __u32 ifindex;
                 __u8 mac[6];
         };
   };

   typedef unsigned int u32;
   [...]
</pre>
</div>

<div class="info" id="org3ab0f12">
<p>
Video
</p>

<p>
To learn more about bpftool, check out <a href="https://www.youtube.com/watch?v=1EOLh3zzWP4&amp;t=650s">eCHO episode 11: Exploring bpftool</a> with Quentin Monnet, maintainer of bpftool.
</p>

</div>
</div>
</div>

<div id="outline-container-orga0ab273" class="outline-3">
<h3 id="orga0ab273"><span class="section-number-3">3.2.</span> 内核测试</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Linux内核中自带了单元测试，位于内核源码目录的 <code>tools/testing/selftests/bpf/</code> 。
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cd tools/testing/selftests/bpf/
$ make
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">make run_tests</span>
</pre>
</div>

<p>
测试涵盖了 BPF 验证器、程序 tags、BPF map接口和类型相关的测试。 还包含检查LLVM后端的C代码，以及测试内核解释器和JIT的eBPF和cBPF的汇编代码。
</p>
</div>
</div>

<div id="outline-container-org42fe0d6" class="outline-3">
<h3 id="org42fe0d6"><span class="section-number-3">3.3.</span> JIT调试</h3>
<div class="outline-text-3" id="text-3-3">
<p>
JIT开发者进行检查或者编写扩展时，都允许将编译生成的JIT映像输出到内核日志：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo 2 &gt; /proc/sys/net/core/bpf_jit_enable</span>
</pre>
</div>
<p>
之后，当加载新的BPF程序后，JIT编译器将会将JIT映像输出。可以通过 <code>dmesg</code> 命令检查输出：
</p>
<div class="org-src-container">
<pre class="src src-sh">[ 3389.935842] <span style="color: #FF8C00;">flen</span>=6 <span style="color: #FF8C00;">proglen</span>=70 <span style="color: #FF8C00;">pass</span>=3 <span style="color: #FF8C00;">image</span>=ffffffffa0069c8f <span style="color: #FF8C00;">from</span>=tcpdump <span style="color: #FF8C00;">pid</span>=20583
[ 3389.935847] JIT code: 00000000: 55 48 89 e5 48 83 ec 60 48 89 5d f8 44 8b 4f 68
[ 3389.935849] JIT code: 00000010: 44 2b 4f 6c 4c 8b 87 d8 00 00 00 be 0c 00 00 00
[ 3389.935850] JIT code: 00000020: e8 1d 94 ff e0 3d 00 08 00 00 75 16 be 17 00 00
[ 3389.935851] JIT code: 00000030: 00 e8 28 94 ff e0 83 f8 01 75 07 b8 ff ff 00 00
[ 3389.935852] JIT code: 00000040: eb 02 31 c0 c9 c3
</pre>
</div>

<ul class="org-ul">
<li>flen: 表示BPF program的长度(here, 6 BPF instructions),</li>
<li>proglen: JIT生成的操作码映像长度（此处为70字节）.</li>
<li>pass: 表示编译的优化等级</li>
<li>image: 生成JIT image的地址</li>
<li>from 和 pid:  表示触发编译行为的用户空间应用的应用名称和pid。</li>
</ul>

<p>
eBPF 和 cBPF JITs 采用相同的输出格式。
</p>


<p>
内核源码目录的 <code>tools/bpf/</code> 目录下包含了一个名为 <code>bpf_jit_disasm</code> 的工具。此工具可以读取内核日志中最新加载的JIT映像，并进行反汇编后输出：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">./bpf_jit_disasm</span>
70 bytes emitted from JIT compiler (pass:3, flen:6)
ffffffffa0069c8f + &lt;x&gt;:
   0:       push   %rbp
   1:       mov    %rsp,%rbp
   4:       sub    $<span style="color: #FF8C00;">0</span>x60,%rsp
   8:       mov    %rbx,-0x8(%rbp)
   c:       mov    0x68(%rdi),%r9d
  10:       sub    0x6c(%rdi),%r9d
  14:       mov    0xd8(%rdi),%r8
  1b:       mov    $<span style="color: #FF8C00;">0</span>xc,%esi
  20:       callq  0xffffffffe0ff9442
  25:       cmp    $<span style="color: #FF8C00;">0</span>x800,%eax
  2a:       jne    0x0000000000000042
  2c:       mov    $<span style="color: #FF8C00;">0</span>x17,%esi
  31:       callq  0xffffffffe0ff945e
  36:       cmp    $<span style="color: #FF8C00;">0</span>x1,%eax
  39:       jne    0x0000000000000042
  3b:       mov    $<span style="color: #FF8C00;">0</span>xffff,%eax
  40:       jmp    0x0000000000000044
  42:       xor    %eax,%eax
  44:       leaveq
  45:       retq
</pre>
</div>

<p>
还可以将反汇编后的指令对应的操作码一并输出：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">./bpf_jit_disasm -o</span>
70 bytes emitted from JIT compiler (pass:3, flen:6)
ffffffffa0069c8f + &lt;x&gt;:
   0:       push   %rbp
    55
   1:       mov    %rsp,%rbp
    48 89 e5
   4:       sub    $<span style="color: #FF8C00;">0</span>x60,%rsp
    48 83 ec 60
   8:       mov    %rbx,-0x8(%rbp)
    48 89 5d f8
   c:       mov    0x68(%rdi),%r9d
    44 8b 4f 68
  10:       sub    0x6c(%rdi),%r9d
    44 2b 4f 6c
  14:       mov    0xd8(%rdi),%r8
    4c 8b 87 d8 00 00 00
  1b:       mov    $<span style="color: #FF8C00;">0</span>xc,%esi
    be 0c 00 00 00
  20:       callq  0xffffffffe0ff9442
    e8 1d 94 ff e0
  25:       cmp    $<span style="color: #FF8C00;">0</span>x800,%eax
    3d 00 08 00 00
  2a:       jne    0x0000000000000042
    75 16
  2c:       mov    $<span style="color: #FF8C00;">0</span>x17,%esi
    be 17 00 00 00
  31:       callq  0xffffffffe0ff945e
    e8 28 94 ff e0
  36:       cmp    $<span style="color: #FF8C00;">0</span>x1,%eax
    83 f8 01
  39:       jne    0x0000000000000042
    75 07
  3b:       mov    $<span style="color: #FF8C00;">0</span>xffff,%eax
    b8 ff ff 00 00
  40:       jmp    0x0000000000000044
    eb 02
  42:       xor    %eax,%eax
    31 c0
  44:       leaveq
    c9
  45:       retq
    c3
</pre>
</div>

<p>
<code>bpftool</code> 工具也能够根据 <code>BPF program ID</code> 输出其BPF JIT映像（参考 bpftool 章节）。
</p>

<p>
对于JIT的 BPF programs来说，可以通过 <code>perf</code> 进行性能分析。perf分析前，需要JIT的程序将其基础结构导出到 <code>kallsyms</code> 。
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo 1 &gt; /proc/sys/net/core/bpf_jit_enable</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo 1 &gt; /proc/sys/net/core/bpf_jit_kallsyms</span>
</pre>
</div>

<p>
开启或者关闭 <code>bpf_jit_kallsyms</code> 不需要重启BPF程序。
</p>

<p>
以下是一个对BPF程序进行采样的示例：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc qdisc add dev em1 clsact</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter add dev em1 ingress bpf da obj prog.o sec main</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">tc filter show dev em1 ingress</span>
filter protocol all pref 49152 bpf
filter protocol all pref 49152 bpf handle 0x1 prog.o:[main] direct-action id 1 tag 8227addf251b7543

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">cat /proc/kallsyms</span>
[...]
ffffffffc00349e0 t fjes_hw_init_command_registers    [fjes]
ffffffffc003e2e0 d __tracepoint_fjes_hw_stop_debug_err    [fjes]
ffffffffc0036190 t fjes_hw_epbuf_tx_pkt_send    [fjes]
ffffffffc004b000 t bpf_prog_8227addf251b7543

<span style="color: #8B8878;"># </span><span style="color: #8B8878;">perf record -a -g -e skb:kfree_skb sleep 60</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">perf script --kallsyms=/proc/kallsyms</span>
[...]
ksoftirqd/0     6 [000]  1004.578402:    skb:kfree_skb: <span style="color: #FF8C00;">skbaddr</span>=0xffff9d4161f20a00 <span style="color: #FF8C00;">protocol</span>=2048 <span style="color: #FF8C00;">location</span>=0xffffffffc004b52c
   7fffb8745961 bpf_clone_redirect (/lib/modules/4.10.0+/build/vmlinux)
   7fffc004e52c bpf_prog_8227addf251b7543 (/lib/modules/4.10.0+/build/vmlinux)
   7fffc05b6283 cls_bpf_classify (/lib/modules/4.10.0+/build/vmlinux)
   7fffb875957a tc_classify (/lib/modules/4.10.0+/build/vmlinux)
   7fffb8729840 __netif_receive_skb_core (/lib/modules/4.10.0+/build/vmlinux)
   7fffb8729e38 __netif_receive_skb (/lib/modules/4.10.0+/build/vmlinux)
   7fffb872ae05 process_backlog (/lib/modules/4.10.0+/build/vmlinux)
   7fffb872a43e net_rx_action (/lib/modules/4.10.0+/build/vmlinux)
   7fffb886176c __do_softirq (/lib/modules/4.10.0+/build/vmlinux)
   7fffb80ac5b9 run_ksoftirqd (/lib/modules/4.10.0+/build/vmlinux)
   7fffb80ca7fa smpboot_thread_fn (/lib/modules/4.10.0+/build/vmlinux)
   7fffb80c6831 kthread (/lib/modules/4.10.0+/build/vmlinux)
   7fffb885e09c ret_from_fork (/lib/modules/4.10.0+/build/vmlinux)
</pre>
</div>

<p>
perf记录的堆栈中包含了 <code>bpf_prog_8227addf251b7543()</code> 符号，表示tag为 <code>8227addf251b7543</code> 的BPF程序和 <code>kfree_skb event</code> 事件相关。
</p>
</div>
</div>

<div id="outline-container-org634ab2f" class="outline-3">
<h3 id="org634ab2f"><span class="section-number-3">3.4.</span> Introspection</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Linux内核中包含许多BPF 和 XDP相关的跟踪点。例如BPF相关的跟踪点：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">perf list | grep bpf:</span>
bpf:bpf_map_create                                 [Tracepoint event]
bpf:bpf_map_delete_elem                            [Tracepoint event]
bpf:bpf_map_lookup_elem                            [Tracepoint event]
bpf:bpf_map_next_key                               [Tracepoint event]
bpf:bpf_map_update_elem                            [Tracepoint event]
bpf:bpf_obj_get_map                                [Tracepoint event]
bpf:bpf_obj_get_prog                               [Tracepoint event]
bpf:bpf_obj_pin_map                                [Tracepoint event]
bpf:bpf_obj_pin_prog                               [Tracepoint event]
bpf:bpf_prog_get_type                              [Tracepoint event]
bpf:bpf_prog_load                                  [Tracepoint event]
bpf:bpf_prog_put_rcu                               [Tracepoint event]
</pre>
</div>

<p>
perf使用跟踪点的示例：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">perf record -a -e bpf:* sleep 10</span>
<span style="color: #8B8878;"># </span><span style="color: #8B8878;">perf script</span>
sock_example  6197 [005]   283.980322:      bpf:bpf_map_create: map <span style="color: #FF8C00;">type</span>=ARRAY <span style="color: #FF8C00;">ufd</span>=4 <span style="color: #FF8C00;">key</span>=4 <span style="color: #FF8C00;">val</span>=8 <span style="color: #FF8C00;">max</span>=256 <span style="color: #FF8C00;">flags</span>=0
sock_example  6197 [005]   283.980721:       bpf:bpf_prog_load: <span style="color: #FF8C00;">prog</span>=a5ea8fa30ea6849c <span style="color: #FF8C00;">type</span>=SOCKET_FILTER <span style="color: #FF8C00;">ufd</span>=5
sock_example  6197 [005]   283.988423:   bpf:bpf_prog_get_type: <span style="color: #FF8C00;">prog</span>=a5ea8fa30ea6849c <span style="color: #FF8C00;">type</span>=SOCKET_FILTER
sock_example  6197 [005]   283.988443: bpf:bpf_map_lookup_elem: map <span style="color: #FF8C00;">type</span>=ARRAY <span style="color: #FF8C00;">ufd</span>=4 <span style="color: #FF8C00;">key</span>=[06 00 00 00] <span style="color: #FF8C00;">val</span>=[00 00 00 00 00 00 00 00]
[...]
sock_example  6197 [005]   288.990868: bpf:bpf_map_lookup_elem: map <span style="color: #FF8C00;">type</span>=ARRAY <span style="color: #FF8C00;">ufd</span>=4 <span style="color: #FF8C00;">key</span>=[01 00 00 00] <span style="color: #FF8C00;">val</span>=[14 00 00 00 00 00 00 00]
     swapper     0 [005]   289.338243:    bpf:bpf_prog_put_rcu: <span style="color: #FF8C00;">prog</span>=a5ea8fa30ea6849c <span style="color: #FF8C00;">type</span>=SOCKET_FILTER
</pre>
</div>

<p>
BPF 程序会单独显示程序tag  prog=&#x2026;&#x2026; 。
</p>

<p>
XDP有一个跟踪点 <code>xdp_exception</code> ，在出现异常时触发。
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">perf list | grep xdp:</span>
xdp:xdp_exception                                  [Tracepoint event]
</pre>
</div>

<p>
有以下几种情况会触发异常：
</p>
<ul class="org-ul">
<li>BPF程序返回无效的XDP action code。</li>
<li>BPF程序返回 XDP_ABORTED（表示异常退出）</li>
<li>BPF程序返回 XDP_TX，但是传输时出错（例如接口非ip状态、发送缓冲区以满、内存分配失败等）。</li>
</ul>

<p>
可以通过BPF程序关联到这些跟踪点，然后将收集到的信息保存到map，或者通过 <code>bpf_perf_event_output()</code> 辅助函数发送到用户空间。
</p>
</div>
</div>

<div id="outline-container-org89ae70c" class="outline-3">
<h3 id="org89ae70c"><span class="section-number-3">3.5.</span> Tracing pipe</h3>
<div class="outline-text-3" id="text-3-5">
<p>
当BPF程序调用 <code>bpf_trace_printk()</code> 时，会将输出发送到内核的 tracing pipe。之后在用户空间读取该文件获取输出：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">tail -f /sys/kernel/debug/tracing/trace_pipe</span>
...
</pre>
</div>
</div>
</div>

<div id="outline-container-org96ceaf3" class="outline-3">
<h3 id="org96ceaf3"><span class="section-number-3">3.6.</span> 其他</h3>
<div class="outline-text-3" id="text-3-6">
<p>
BPF程序和maps可使用的内存大小限制由 <code>RLIMIT_MEMLOCK</code> 指定。 通过 <code>ulimit -l</code> 检查当前可以被锁定到内存的系统页面数。更多详细信息可以查看 <code>setrlimit</code> 系统调用的man page。
</p>

<p>
当加载较为复杂的程序或较大的BPF映射时，默认限制通常不能够满足需求，此时 BPF 系统调用会返回错误，并将 <code>errno</code> 设为 <code>EPERM</code> 。这种情况可以使用 <code>ulimit -l unlimited</code> 命令解决，或将限制参数调大。
</p>
</div>
</div>
</div>


<div id="outline-container-orge705041" class="outline-2">
<h2 id="orge705041"><span class="section-number-2">4.</span> BPF程序类型</h2>
<div class="outline-text-2" id="text-4">
<p>
BPF中有许多可用的程序类型，本节主要介绍网络相关的类型（即XDP程序和tc程序）。这两种程序的示例已经在之前的LLVM、iproute2等章节介绍过。本节主要介绍相关的架构、概念、用户场景等。
</p>
</div>

<div id="outline-container-orgcc114d1" class="outline-3">
<h3 id="orgcc114d1"><span class="section-number-3">4.1.</span> XDP</h3>
<div class="outline-text-3" id="text-4-1">
<p>
XDP 全称 eXpress Data Path。XDP在内核内部提供了高性能数据包处理框架。可以在软件可处理的最早期执行（网络驱动程序刚接收数据包），此时，网络驱动刚刚从其rings中获取数据包，并未进行任何昂贵操作（比如分配 <code>skb</code> 推送到网络堆栈、交给GRO引擎等），这是CPU能够处理最早期阶段。
</p>

<p>
和大多数用户空间的网络处理框架不同，XDP不会绕过内核，而是和内核协同工作。这种处理方式有很多优势：
</p>
<ul class="org-ul">
<li>可以在BPF辅助函数中重用内核网络驱动、用户空间的工具、内核的基础设施（路由表、sockets等）</li>

<li>XDP位于内核空间，在访问硬件时，拥有和内核其他部分相同的安全模型。</li>

<li>不需要在内核和用户态切换，因为XDP本身就在内核中，可以灵活的转发数据包到内核其他部分（如容器、网络堆栈等）。 <code>This is particularly relevant in times of Meltdown and Spectre.</code></li>

<li>XDP可以重用内核网络堆栈，无需单独维护一套用户空间网络堆栈。</li>

<li>BPF和内核系统调用ABI一样，有稳定的的ABI，具有良好的可编程性。相对于内核模块，内核验证器使得BPF具有很好的安全性，使内核可以稳定运行。</li>

<li>XDP程序运行期间，可以进行原子替换，无需重启内核，也不会中断流量。</li>

<li>XDP允许灵活的构建，以更好的集成到内核的工作负载（例如XDP可以工作在 <code>busy polling</code> 和 <code>interrupt driven</code> 两种模式）。 XDP不需要专门指定CPU，也没有特别的硬件要求，也不依赖 <code>hugepages</code> 。</li>

<li>XDP不依赖第三方内核模块及许可。XDP有内核社区开发，属于内核的核心部分，是一个长期架构解决方案。</li>

<li>主流的Linux发行版，只要运行的内核在4.8及以上，都提供了XDP支持，并支持大部分的10G或更高的网络驱动。</li>
</ul>



<p>
XDP作为一个在驱动中运行BPF的框架，可以确保数据包以线性方式布局，并能够放入单个DMA页面，以便BPF程序进行读取和写入。XDP在数据包头部保留256字节的空间，以便使用 <code>bpf_xdp_adjust_head()</code> BPF辅助函数实现自定义封装头，或利用 <code>bpf_xdp_adjust_meta()</code> 函数在数据包前面添加自定义元数据。
</p>

<p>
XDP框架提供了 <code>action code</code> ，BPF程序返回不同的 <code>action code</code> ，驱动执行对应的数据包处理动作。
</p>

<p>
XDP是为高性能而设计：BPF允许直接访问数据包，也就是说，BPF程序可以直接在寄存器保存数据指针，加载数据内容到寄存器，从寄存器写入数据包。
</p>

<p>
The packet representation in XDP that is passed to the BPF program as the BPF context looks as follows:
XDP中使用 <code>struct xdp_buff</code> 作为BPF程序的上下文，其定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">xdp_buff</span> {
        <span style="color: #CDC673;">/** &#25351;&#21521;&#39029;&#38754;&#20869;&#30340;&#25968;&#25454;&#21253;&#20869;&#23481;&#30340;&#36215;&#22987;&#20301;&#32622; */</span>
        <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">data</span>;
        <span style="color: #CDC673;">/** &#25351;&#21521;&#25968;&#25454;&#21253;&#32467;&#23614; */</span>
        <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">data_end</span>;
        <span style="color: #CDC673;">/** &#25351;&#21521;&#33258;&#23450;&#20041;&#25968;&#25454;&#30340;&#36215;&#22987;&#20301;&#32622; */</span>
        <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">data_meta</span>;
        <span style="color: #CDC673;">/** &#25351;&#21521;&#39029;&#38754;&#20869;&#21487;&#29992;&#30340;&#22836;&#37096;&#31354;&#38388;&#26368;&#22823;&#20540;&#30340;&#36215;&#22987;&#20301;&#32622; */</span>
        <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">data_hard_start</span>;
        <span style="color: #CDC673;">/** &#25351;&#21521;&#27599;&#20010;&#25509;&#25910;&#38431;&#21015;&#38468;&#21152;&#30340;&#20803;&#25968;&#25454; */</span>
        <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">xdp_rxq_info</span> *<span style="color: #FF8C00;">rxq</span>;
};
</pre>
</div>
<ul class="org-ul">
<li><code>data</code></li>
<li><code>data_end</code> 指向数据包结尾</li>
<li>==</li>
</ul>

<p>
<code>bpf_xdp_adjust_head()</code> 函数可以用于对数据包进行封装，此时， <code>data</code> 指针向 <code>data_hard_start</code> 靠近。该函数也能用于对数据进行解封装，此时 <code>data</code> 指针远离 <code>data_hard_start</code> 。
</p>

<p>
<code>data_meta</code> 最初时和 <code>data</code> 指向相同位置。想要保存自定义数据时，通过 <code>but bpf_xdp_adjust_meta()</code> 函数来预留空间（ <code>data_meta</code> 靠近 <code>date_hard_start</code> ）。同样的，可以通过 <code>but bpf_xdp_adjust_meta()</code> 函数移除或者减小自定义数据空间（ <code>data_meta</code> 远离 <code>data_start_start</code> ）。 自定义数据对于内核网络堆栈不可见，对于tc BPF程序则是可见的。=data_meta= 还可以用来在尾调用之间传递状态（类似与 tc BPF程序通过 <code>skb-&gt;cb[]</code> 控制块传递状态）。
</p>

<p>
对于保存数据包xdp_buff结构，其指针总是满足该条件： <b>data_hard_start &lt;= data_meta &lt;= data &lt; data_end</b> 。
</p>

<p>
<code>rxq</code> 字段指向每个接收队列附加的元数据，这些数据在初始化 <code>ring</code> 的时候就已经被设置：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">xdp_rxq_info</span> {
    <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">dev</span>;
    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">queue_index</span>;
    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">reg_state</span>;
} <span style="color: #FF8C00;">____cacheline_aligned</span>;
</pre>
</div>

<p>
BPF程序可以从 <code>netdevice</code> 检索 <code>queue_index</code> 以及附加数据。
</p>
</div>

<div id="outline-container-org385ea4f" class="outline-4">
<h4 id="org385ea4f"><span class="section-number-4">4.1.1.</span> XDP程序的 <code>action code</code></h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
XDP BPF程序会返回 <code>action code</code> ，驱动根据返回值处理数据包。
</p>

<p>
<code>xdp_action</code> 定义在 <code>linux/bpf.h</code> 头文件：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">enum</span> <span style="color: #5FD7FF;">xdp_action</span> {
    <span style="color: #FF8C00;">XDP_ABORTED</span> = 0,
    <span style="color: #FF8C00;">XDP_DROP</span>,
    <span style="color: #FF8C00;">XDP_PASS</span>,
    <span style="color: #FF8C00;">XDP_TX</span>,
    <span style="color: #FF8C00;">XDP_REDIRECT</span>,
};
</pre>
</div>

<p>
<code>XDP_DROP</code> 表示直接在驱动级别丢弃数据包，避免数据包浪费更多资源。在通过BPF实现缓解DDoS攻击或者防火墙时，会经常使用。
</p>

<p>
<code>XDP_PASS</code> 表示允许将数据包上送给内核网络堆栈，也就意味着处理当前数据包的CPU会分配 <code>skb</code> 并进行填充，之后传递给 <code>GRO</code> 引擎。等同于没有XDP时的默认处理行为。
</p>

<p>
<code>XDP_TX</code> 使得BPF程序能够高效将数据包从其接收端口进行发送。当集群中的防火墙以及后续的负载均衡节点较少时，这种方法会比较有用，因为它可以充当 <code>hairpinned load balancer</code> ，在 XDP BPF 中重写数据包后直接转回给交换机。
</p>

<p>
<code>XDP_REDIRECT</code> 类似 <code>XDP_TX</code> ，也用于发送数据包，但是是通过其他接口发送（而不是数据包接收端口）。 <code>XDP_REDIRECT</code> 还有另一种处理方式，就是将数据包重定向到BPF cpumap，也就是说，当前在网卡队列接收数据包的CPU之从队列接收，并将数据包重定向到其他CPU，数据包后续的执行过程（内核网络堆栈的处理）则交给其他CPU处理。这有点类似 <code>XDP_PASS</code> ，不同之处是 <code>XDP_REDIRECT</code> 使得 XDP 可以处理较高的负载，因为只做数据包的重定向，而不会处理将数据包推送到上层的相关工作。
</p>

<p>
<code>XDP_ABORTED</code> 表示程序内部可能出现异常，数据包的处理方式和 <code>XDP_DROP</code> 一样，也是被丢弃，但是会调用 <code>trace_xdp_exception</code> 跟踪点。可以对该跟踪点进行监控，检测异常行为。
</p>
</div>
</div>


<div id="outline-container-org9b5c7c7" class="outline-4">
<h4 id="org9b5c7c7"><span class="section-number-4">4.1.2.</span> XDP用例</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>DDoS缓解、防火墙
XDP BPF程序中返回 <code>XDP_DROP</code> 时，可以使驱动在较早的阶段丢弃数据包，因此可以高效的执行网络策略且处理每个数据包的成本极低。这种方式很适合应对各种DDoS攻击，也可以用于执行各种防火墙策略，开销基本可以忽略。例如：作为独立设备时，使用 <code>XDP_TX</code> 过滤正常流量，如果是作为终端设备，则可以通过 <code>XDP_PASS</code> 或者 <code>cpumap XDP_REDIRECT</code> 来过滤合法流量。XDP offload 则可以将本来就已经很小的数据包负载转移到网卡（线速处理）。</li>

<li><p>
转发及负载均衡
另一个场景是使用 <code>XDP_TX</code> 或者 <code>XDP_REDIRECT</code> 动作来执行包转发和负载均衡。XDP BPF程序可以在XDP层随意修改数据包，并且可以使用BPF辅助函数对数据包的头部空间进行调整，以便进行数据包的封装和解封装，然后再次发送。
</p>

<p>
在实现负载均衡器时，可以 <code>XDP_TX</code> 将数据包推送到其接收端口，或者使用 <code>XDP_REDIRECT</code> 转发到另一个端口进行传输。 <code>XDP_REDIRECT</code> 可以和 BPF 的 <code>cpumap</code> 联合使用，以便将数据包转至其他CPU进行处理。
</p></li>

<li><p>
用于网络堆栈之前的过滤和处理
XDP还可用于加固内核网络堆栈，利用 <code>XDP_DROP</code> ，可以将与本地节点不相关的数据包较早的丢弃（网络堆栈之前）。例如本地节点只服务TCP流量，其他的UDP、SCTP或者其他四层流量都可以直接丢弃。这种方式的优点是，数据包无需进入GRO引擎、流解析等部分就可以确定是否丢弃，从而减少内核的攻击面。  另外，当内核网络堆栈的接收路径存在漏洞时，可以通过XDP直接丢弃数据包，而无需重启内核或者服务。
</p>

<p>
在网络堆栈之前处理的另一个场景：由于XDP BPF处理时，内核还没有为数据包分配 <code>skb</code> ，BPF程序可以随意修改数据包，之后将数据包送到堆栈。这可以用于实现自定义的数据包处理以及封装协议，但是在进入GRO聚合之前，需要对数据包解封装，否则GRO会由于不识别封装协议而无法进行聚合。XDP还允许在数据包之前保存元数据，这些数据对内核堆栈不可见 ，可以被 GRO 聚合，之后再和 tc ingress BPF 程序协同处理。
</p></li>

<li>流的采样、监控
XDP可以应用于数据包的监控、采样以及网络分析。对于复杂的数据包分析，XDP提供了高效机制，借助Linux perf为用户空间提供的缓冲区，可以高效的将网络数据包（截断后的或者完整payload）以及自定义的元数据推向该环形缓冲区，缓冲区实现为无锁的且每个CPU有自己的缓冲区。这也可以用于只对数据流的起始数据进行检测，一旦检测到流量合法，就可以绕过监控。</li>
</ul>

<p>
Facebook的SHIV和Droplet就使用的XDP实现，分别用于实现其四层负载均衡和DDoS防御。并且Facebook将其产品的基础设施从netfilter的IPVS迁移到XDP BPF后，获得的10倍以上的性能提升。
</p>
<div class="note" id="org1d265c3">
<ul class="org-ul">
<li>Slides: <a href="https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf">https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf</a></li>
<li>Video: <a href="https://youtu.be/YEU2ClcGqts">https://youtu.be/YEU2ClcGqts</a></li>
</ul>

</div>

<p>
Cloudflare也使用XDP来防御DDoS攻击。
</p>
<div class="note" id="org9b73061">
<ul class="org-ul">
<li>Slides: <a href="https://netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf">https://netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf</a></li>
<li>Video: <a href="https://youtu.be/7OuOukmuivg">https://youtu.be/7OuOukmuivg</a></li>
</ul>

</div>
</div>
</div>


<div id="outline-container-org489818e" class="outline-4">
<h4 id="org489818e"><span class="section-number-4">4.1.3.</span> XDP的执行模式</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
XDP有三种执行模式， <code>native</code> 是XDP的默认模式。
</p>

<ul class="org-ul">
<li>Native XDP
此模式为默认模式，该模式下，XDP运行在网络驱动接收数据包路径的的最早期。大部分的10G以及更高规格的网卡已经实现了该模式。</li>

<li>Offloaded XDP
该模式下，XDP被卸载到网卡执行，也就是将本来就不大的数据包处理开销转移到网卡，节省CPU成本，该模式相对于 <code>native XDP</code> 具有更高的处理性能。XDP卸载通常由智能网卡来实现，网卡包含多核多线程流处理器，由内核的JIT编译器将BPF指令转化为网卡本地指令。通常，支持 <code>offload XDP</code> 的驱动也支持 <code>native XDP</code> ，因为有可能某些BPF辅助函数还无法在 <code>offload XDP</code> 模式下运行，此时可以选择 <code>native XDP</code> 。</li>

<li>Generic XDP
对于没有实现 native 和 offload 模式的驱动，内核还提供了通用的XDP模式 <code>generic XDP</code> ，这种模式不需要驱动做任何修改，因为其运行在内核网络堆栈中的比较靠后的位置。对于想要利用内核的XDP API编写和测试BPF程序的开发者，并且不关心性能时，可以使用此模式。在生产环境上建议使用 <code>native</code> 或 <code>offload</code> 模式。</li>
</ul>
</div>
</div>

<div id="outline-container-orgadfdc0c" class="outline-4">
<h4 id="orgadfdc0c"><span class="section-number-4">4.1.4.</span> Driver支持情况</h4>
<div class="outline-text-4" id="text-4-1-4">
</div>
<div id="outline-container-org4e50091" class="outline-5">
<h5 id="org4e50091"><span class="section-number-5">4.1.4.1.</span> 支持 <code>native XDP</code> 的驱动</h5>
<div class="outline-text-5" id="text-4-1-4-1">
<p>
可以通过以下命令检测网卡的网络驱动：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">ethtool -i eth0</span>
driver: nfp
[...]
</pre>
</div>

<p>
下面的列表描述了支持 <code>native XDP</code> 的驱动程序：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Vendor</th>
<th scope="col" class="org-left">Driver</th>
<th scope="col" class="org-left">XDP Support</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Amazon</td>
<td class="org-left">ena</td>
<td class="org-left">&gt;= 5.6</td>
</tr>

<tr>
<td class="org-left">Broadcom</td>
<td class="org-left">bnxt_en</td>
<td class="org-left">&gt;= 4.11</td>
</tr>

<tr>
<td class="org-left">Cavium</td>
<td class="org-left">thunderx</td>
<td class="org-left">&gt;= 4.12</td>
</tr>

<tr>
<td class="org-left">Freescale</td>
<td class="org-left">dpaa2</td>
<td class="org-left">&gt;= 5.0</td>
</tr>

<tr>
<td class="org-left">Intel</td>
<td class="org-left">ixgbe</td>
<td class="org-left">&gt;= 4.12</td>
</tr>

<tr>
<td class="org-left">Intel</td>
<td class="org-left">ixgbevf</td>
<td class="org-left">&gt;= 4.17</td>
</tr>

<tr>
<td class="org-left">Intel</td>
<td class="org-left">i40e</td>
<td class="org-left">&gt;= 4.13</td>
</tr>

<tr>
<td class="org-left">Intel</td>
<td class="org-left">ice</td>
<td class="org-left">&gt;= 5.5</td>
</tr>

<tr>
<td class="org-left">Marvell</td>
<td class="org-left">mvneta</td>
<td class="org-left">&gt;= 5.5</td>
</tr>

<tr>
<td class="org-left">Mellanox</td>
<td class="org-left">mlx4</td>
<td class="org-left">&gt;= 4.8</td>
</tr>

<tr>
<td class="org-left">Mellanox</td>
<td class="org-left">mlx5</td>
<td class="org-left">&gt;= 4.9</td>
</tr>

<tr>
<td class="org-left">Microsoft</td>
<td class="org-left">hv_netvsc</td>
<td class="org-left">&gt;= 5.6</td>
</tr>

<tr>
<td class="org-left">Netronome</td>
<td class="org-left">nfp</td>
<td class="org-left">&gt;= 4.10</td>
</tr>

<tr>
<td class="org-left">Others</td>
<td class="org-left">virtio_net</td>
<td class="org-left">&gt;= 4.10</td>
</tr>

<tr>
<td class="org-left">Others</td>
<td class="org-left">tun/tap</td>
<td class="org-left">&gt;= 4.14</td>
</tr>

<tr>
<td class="org-left">Others</td>
<td class="org-left">bond</td>
<td class="org-left">&gt;= 5.15</td>
</tr>

<tr>
<td class="org-left">Qlogic</td>
<td class="org-left">qede</td>
<td class="org-left">&gt;= 4.10</td>
</tr>

<tr>
<td class="org-left">Socionext</td>
<td class="org-left">netsec</td>
<td class="org-left">&gt;= 5.3</td>
</tr>

<tr>
<td class="org-left">Solarflare</td>
<td class="org-left">sfc</td>
<td class="org-left">&gt;= 5.5</td>
</tr>

<tr>
<td class="org-left">Texas Instruments</td>
<td class="org-left">cpsw</td>
<td class="org-left">&gt;= 5.3</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgc4620f9" class="outline-4">
<h4 id="orgc4620f9"><span class="section-number-4">4.1.5.</span> 支持 <code>offloaded XDP</code> 的驱动</h4>
<div class="outline-text-4" id="text-4-1-5">
<p>
Netronome nfp
</p>

<div class="note" id="org0bcf13d">
<p>
有些BPF辅助函数不能在 <code>offload XDP</code> 模式下使用，例如检索当前CPU编号的辅助函数。
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org83cee3c" class="outline-3">
<h3 id="org83cee3c"><span class="section-number-3">4.2.</span> tc (traffic control)</h3>
<div class="outline-text-3" id="text-4-2">
<p>
BPF程序也能够运行在内核的 tc (traffic control) 层的网络数据路径中。
</p>

<p>
从高层次来看，tc BPF 和 XDP BPF对比存在三个主要差异：
</p>
<ul class="org-ul">
<li><p>
tc BPF的输入上下文是 <code>sk_buff</code> 而不是 <code>xdp_buff</code> 。驱动接收数据包，并经过XDP层后，开始由内核网络堆栈处理，首先会为数据包分配缓冲区用于存储其元数据，即 <code>sk_buff</code> 。 tc BPF程序使用 <code>sk_buff</code> 结构作为其上下文，因此可以使用 <code>sk_buff</code> 结构中的元数据。tc BPF程序虽然使用元数据很方便，但也有一定的代价，元数据的分配以及提取操作需要网络堆栈来介入处理，因此其性能比XDP差。
</p>

<p>
tc BPF程序能够读写 skb 结构中的 mark、ptk_type、protocol、priority、queue_mapping、napi_id、cb[]数组、hash、tc_classid、tc_index、vlan 元数据、XDP自定义的元数据以及其他信息。 <code>struct _sk_buff</code> 结构中能够被BPF使用的成员定义在 <code>linux/bpf.h</code> 头文件。
</p>

<p>
tc BPF程序使用 <code>sk_buff</code> 的优点是可以随意的修改元数据。同时也由于元数据中包含了大量协议相关的信息，从而不能够只通过修改数据包来达到切换协议的目的，因为网络堆栈对数据包的处理依赖于元数据，并不是每次都从数据包解析。因此BPF辅助函数还需要进行额外的操作。
</p>

<p>
对于 <code>xdp_buff</code> 来说，则不存在这个问题，因为XDP处理时，还没有分配 <code>sk_buff</code> ，因此可以改写为任意类型的数据包，但同时，XDP也无法利用元数据（没有元数据）。
</p>

<p>
tcp BPF和XDP BPF程序的优缺点可以互补，例如 XDP BPF程序可以将自定义的元数据传递给 tc BPF程序，通过tc BPF程序修改元数据。
</p></li>

<li><p>
tc BPF 程序可以在网络数据路径的ingress、egress进行处理，而XDP只能在 ingress 处理。
</p>

<p>
tc BPF程序的 ingress 和 egress 处理位置分别为 <code>sch_handle_ingress()</code> and <code>sch_handle_egress()</code> ，由 <code>__netif_receive_skb_core()</code> 和 <code>__dev_queue_xmit()</code> 函数触发，这两个函数是节点主要的接收和发送路径，因此所有进入节点和从节点发送出去的数据包都能够被tc BPF程序捕获。
</p></li>

<li><p>
tc BPF程序在网络堆栈通用层级的hook中运行，不需要驱动做修改，因此也可以附加到任何类型的网络设备上。
</p>

<p>
在 ingress 方向，tc BPF程序仍然运行在早期阶段，其位置位于GRO引擎之后，在任何协议处理、传统iptables的 <code>PREROUTING</code> 、nftables的 <code>ingress</code> hook之前。对于 egress 方向，则位于GSO引擎之前，在 iptables 的 <code>POSTROUTING</code> 之后。
</p>

<p>
有一种情况下需要修改驱动程序：tc BPF程序使用 <code>offload</code> 模式时，通常由智能网卡来实现，类似与XDP的 <code>offload</code> 模式，但是由于tc BPF 和XDP BPF的输入上下文不同（sk_buff和xdp_buff），其功能也不同。
</p></li>
</ul>


<p>
tc层的BPF程序是通过分类器 <code>cls_bpf</code> 来运行。虽然把 <code>cls_bpf</code> 成为分类器，但实际的功能不止如此，利用BPF可以在该分类器中实现可编程数据包处理，可以任意的修改元数据以及数据包内容，并且可以通过 <code>action code</code> 终止tc的处理。因此可以将 <code>cls_bpf</code> 视作管理和执行 tc BPF程序的独立实体。
</p>

<p>
cls_bpf可以包含多个BPF程序。在 <code>Cilium</code> 部署中，只会在给定hook上附加一个BPF程序，并且采用 <code>direct-action</code> 模式。 在传统tc方案中，分类器和动作模块是分离的，分类器上会附加一个或多个动作模块，一旦分类器匹配，则触发动作模块执行。 当下，这种传统模式已经不适合复杂的数据包处理。 鉴于 <code>cls_bpf</code> 的 tc BPF 程序是完全独立的，这能有效地将解析和操作过程融合为一个单元，利用 <code>cls_bpf</code> 的 <code>direct-action</code> 模式，直接返回 tc <code>action code</code> 执行判决，并立即终止处理流水线。 <code>cls_bpf</code> 是 tc 层中唯一能实现这种快速路径的 "分类器 "模块。
</p>

<p>
和XDP BPF程序一样，tc BPF程序也可以原子更新，且不需要重启服务或者中断流量。
</p>


<p>
许多qdisc可以附加到网络设备的 <code>egress</code> （例如sch_mq、sch_fq、sch_fq_codel、sch_htb），其中有些是属于可以包含子类的分类qdisc，因此需要一种分类机制来确定数据包如何分类。 分类的处理由函数 <code>tcf_classify()</code> 函数实现（在tc分类器中被调用）。 <code>cls_bpf</code> 也可以在此场景下使用，这种分类操作一般会在qdisc root lock的保护之下，可能会引起锁的竞争。而 <code>sch_clsact</code> 对应的 egress 的hook位置会早一些，所以不需要获取qdisc root lock。因此可以将像sch_htb这类分类器的分类工作转移到 sch_clsact 来执行分类，并设置skb-&gt;mark 和 skb-&gt;priority，以便 <code>sch_htb</code> 进行处理，如此可以避免 <code>sch_htb</code> 在Qdisc root lock下进行昂贵的包分类处理。
</p>

<p>
<code>cls_bpf</code> 也支持 <code>offload</code> BPF程序，BPF程序由智能网卡驱动进行JIT之后，加载到网卡运行。 <code>cls_bpf</code> 只支持在 <code>direct-action</code>  操作模式下 <code>offload</code> ，并且只支持 <code>ingress</code> hook，最多 <code>offload</code> 一个BPF程序。
</p>

<p>
单个 <code>cls_bpf</code> 实例中可以容纳多个tc BPF程序，这种情况下，程序返回 <code>TC_ACT_UNSPEC</code> 表示继续执行下一个tc BPF程序。这种方式有个缺点，就是多个BPF程序需要反复解析数据包，导致性能下降。
</p>
</div>

<div id="outline-container-org43d8b2f" class="outline-4">
<h4 id="org43d8b2f"><span class="section-number-4">4.2.1.</span> tc BPF程序返回值</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
tc BPF程序在 ingress 和 egress hook共用相同的 <code>action code</code> ，这些值定义在 <code>linux/pkt_cls.h</code> 系统头文件中：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">TC_ACT_UNSPEC</span>         (-1)
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">TC_ACT_OK</span>               0
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">TC_ACT_SHOT</span>             2
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">TC_ACT_STOLEN</span>           4
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">TC_ACT_REDIRECT</span>         7
</pre>
</div>

<p>
系统中还有其他类似 <code>TC_ACT_*</code> 的值可以用于 ingress 和 egress hook，但是这些值和上面列出的值都具有相同的含义，也就是说从BPF的角度看 <code>TC_ACT_OK</code> 和 <code>TC_ACT_RECLASSIFY</code> 具有相同的语义， TC_ACT_STOLEN、TC_ACT_QUEUED、TC_ACT_TRAP也具有相同的语义。
</p>

<p>
<code>TC_ACT_UNSPEC</code> 表示 “未指定操作”，可以在三种情况下使用：
</p>
<ol class="org-ol">
<li>挂载了 <code>offload</code> 的tc BPF程序后，在tc ingress hook 运行时， <code>cls_bpf</code> 代表 offload程序 返回 <code>TC_ACT_UNSPEC</code> 。</li>
<li><code>cls_bpf</code> 上关联多个tc BPF程序时，返回 <code>TC_ACT_UNSPEC</code> ，以执行下一个BPF程序。在同时关联 <code>offlaod</code> 的tc BPF程序和多个 <code>non-offload</code> 程序时， <code>TC_ACT_UNSPEC</code> 表示执行下一个 <code>non-offload</code> 程序。</li>
<li>只有单个 tc BPF程序时，返回 <code>TC_ACT_UNSPEC</code> 表示没有执行任何操作，让内核继续处理skb。</li>
</ol>


<p>
<code>TC_ACT_UNSPEC</code> 和 <code>TC_ACT_OK</code> 很类似，都是在 ingress 位置将skb传递给上层堆栈，或者在 egress 位置将skb传递给网络驱动程序传输，唯一的区别是 <code>TC_ACT_OK</code> 会基于tc BPF程序设置的 <code>classid</code> 来设置 <code>skb-&gt;tc_index</code> ， <code>classid</code> 来自于tc BPF程序的上下文 <code>skb-&gt;tc_classid</code> 。
</p>

<p>
<code>TC_ACT_SHOT</code> 指示内核丢弃数据包，上层堆栈不会接收到该数据包，并且也不会传递到 egress 发送。 <code>TC_ACT_SHOT</code> 和 <code>TC_ACT_STOLEN</code> 都会释放skb，但是 <code>TC_ACT_SHOT</code> 会指示内核调用 <code>kfree_skb()</code> 函数释放 skb，并立即向调用者返回 <code>NET_XMIT_DROP</code> 。 <code>TC_ACT_STOLEN</code> 则通过 <code>consume_skb()</code> 函数释放skb，但返回 <code>NET_XMIT_SUCCESS</code> ，欺骗上层堆栈skb已经被成功发送。因此，当perf通过 <code>kfree_skb()</code> 函数监控丢弃的数据包时，如果返回的是 <code>TC_ACT_STOLEN</code> ，则不会监控到任何丢弃行为。
</p>

<p>
<code>TC_ACT_REDIRECT</code> 表示执行数据包重定向，通过 <code>bpf_redirect()</code> 辅助函数能够将 skb 重定向到相同设备或其他设备的 ingress 或 egress 路径，这使得 BPF 的数据包转发更加灵活性。而且对目标网络设备没有要求，不需要在目标设备上运行另一个 cls_bpf 实例。
</p>
</div>
</div>


<div id="outline-container-org0275c63" class="outline-4">
<h4 id="org0275c63"><span class="section-number-4">4.2.2.</span> tc BPF FAQ</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>Question:  <code>act_bpf</code> tc action 模块是否还可以使用？</li>
<li>Answer: 对于tc BPF程序来说，虽然 <code>cls_bpf</code> 和 <code>act_bpf</code> 具有相同的功能，但是 <code>cls_bpf</code> 更加灵活，相当于 <code>act_bpf</code> 的超集。tc 的action模块需要附加到tc 分类器才可以工作， <code>act_bpf</code> 想要达到 <code>cls_bpf</code> 的灵活性，需要附加到 <code>cls_matchall</code> 分类器，此分类器会对每个数据包进行匹配，以便将数据包传递到所有附加的action模块进行处理。因此 <code>act_bpf</code> 相对于 <code>cls_bpf</code> 的 <code>direct-action</code> 模式来说，性能较差。 另外，当 <code>act_bpf</code> 附加到除了 <code>cls_bpf</code> 和 <code>cls_matchall</code> 之外的其他分类器时，性能会更差，因为这回导致数据包被线性处理（分类器A不匹配，则传递到分类器B，再次解析数据包）。因此不建议再使用 <code>act_bpf</code> ，并且 <code>act_bpf</code> 也没有提供 <code>offload</code> 接口。</li>
</ul>


<ul class="org-ul">
<li>Question: 是否建议使用 <code>cls_bpf</code> 的 <code>direct-action</code> 模式？</li>
<li>Answer: 不建议使用， <code>direct-action</code> 模式下，tc BPF程序已经可以高效的完成所有功能，不再需要其他的模式。</li>
</ul>


<ul class="org-ul">
<li>Question: <code>offload</code> cls_bpf 和 <code>offload</code> XDP 是否有性能差异？</li>
<li>Answer: 不会。两者都是经过相同内核的编译器进行JIT处理，加载机制也类似，因此程序会被转换为相同的目标指令集，以便在本地网卡上运行。但是两种类型的程序具有不同的功能，因此会根据情况选择二者之一。</li>
</ul>
</div>
</div>

<div id="outline-container-orgb764870" class="outline-4">
<h4 id="orgb764870"><span class="section-number-4">4.2.3.</span> tc BPF的用例</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
以下介绍一些tc BPF程序示例，鉴于tc BPF的可编程性和高效性，这些用例可以很容易的定制修改，以用于一些特定场景。tc BPF和XDP BPF的用例会有一些重叠，但两者在很多时候可以互补，也可以同时使用。
</p>

<ul class="org-ul">
<li><p>
容器的策略实施
</p>

<p>
tc BPF程序可以为容器或 <code>pod</code> 实现策略执行、自定义防火墙等类似的昂全机制。传统情况下，容器的网络隔离通过网络命名空间实现，通过将veth一端连接宿主机命名空间，另一端连接容器命名空间，由此在两个命名空间通信。来自容器的所有网络流量都必须通过宿主机的 veth 设备，因此可以在 veth 的 tc <code>ingress</code> 和 <code>egress</code> 钩子上附加 tc BPF 程序。进入容器的网络流量将通过主机的 veth 的 tc <code>egress</code> hook，而来自容器的网络流量将通过主机的 veth 的 tc <code>ingress</code> hook。
</p>

<p>
对于像 veth 这样虚拟设备来说，XDP不适用，因为这种情况下内核只作用与skb。同时 <code>generic XDP</code> 也有限制：无法操作克隆的 skb，因为TCP/IP 协议栈中大量使用克隆skb进行重传，这会绕过XDP hook。此外，由于 <code>generic XDP</code> 会对数据包进行线性化处理，会导致严重的性能下降。而 tc BPF则专门用于处理 skb，并且更加灵活。
</p></li>

<li><p>
转发和负载均衡
</p>

<p>
tc BPF和XDP类似，也可用于转发和负载均衡的场景，只是 tc BPF更加适合东西向的容器流量负载，并且XDP只能用于 <code>ingress</code> ，tc BPF则还适用于特定的 <code>egress</code> 场景。例如容器流量可以利用BPF在初始网络命名空间进行 NAT 和 负载均衡，整个过程对于容器透明，并且 <code>egress</code> 的流量已经是基于 <code>sk_buff</code> 结构的，因此 tc BPF很适合改写及重定向数据包。利用 <code>bpf_redirect()</code> 辅助函数， BPF 可以接管转发逻辑，将数据包推送到另一个网络设备的 <code>ingress</code> 或 <code>egress</code> 路径。因此，可以利用 tc BPF 替代任何类似网桥的设备。
</p></li>

<li><p>
流的采样、监控
</p>

<p>
和XDP一样，可以利用高性能的无锁的每CPU内存映射的 <code>perf ring buffer</code> 实现流的采样和监控，BPF程序可以利用该缓冲器将自定义数据以及完整或截断的数据包内容推送到用户空间。 在tc BPF程序中可以利用 <code>bpf_skb_event_output()</code> 辅助函数来实现该功能，该函数类似和 <code>bpf_xdp_event_output()</code> 类似。由于 tc BPF 程序可以附加到 <code>ingress</code> 和 <code>egress</code> hook，并且这两个 hook 位于（通用）网络堆栈的最底层，因此可以对来自特定节点的所有网络流量进行双向监控。这与tcpdump 和 Wireshark 使用的 cBPF有点类似，但tc BPF无需克隆 skb，而且在可编程性方面更加灵活，例如，BPF 已经可以在内核内执行数据包收集，而不是将所有内容推送到用户空间，还能对推送到环形缓冲区的数据包进行自定义注释。Cilium 中广泛使用了数据包的注释，丢弃的数据包可以通过注释，以便与容器标签和丢弃原因进行关联。
</p></li>
</ul>


<ul class="org-ul">
<li><p>
数据包调度器的预处理Packet scheduler pre-processing
</p>

<p>
<code>sch_handle_egress()</code> 是 <code>sch_clsact</code> 的 <code>egress</code> hook，并且在获取 qdisc root 锁之前运行。因此，tc BPF程序中适合执行一些繁重的数据包的分类和处理，而不是将其放置到真正的 qdisc （例如sch_htp）中处理。这可以有效的减少锁的争抢。
</p></li>
</ul>


<p>
Cilium 是一款开源软件，其中使用了 tc BPF，也使用 XDP BPF。Cilium可以用于加固一些基于Linux 容器管理平台（如 Docker 和 Kubernetes）部署的服务之间的网络连接，并在第 3/4 层或第 7 层运行。
</p>

<div class="info" id="orgafaeb69">
<p>
-* Slides: <a href="https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp">https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp</a>
</p>

<p>
-* Video: <a href="https://youtu.be/ilKlmTDdFgk">https://youtu.be/ilKlmTDdFgk</a>
</p>

<p>
-* Github: <a href="https://github.com/cilium/cilium">https://github.com/cilium/cilium</a>
</p>

</div>
</div>
</div>

<div id="outline-container-org3f37947" class="outline-4">
<h4 id="org3f37947"><span class="section-number-4">4.2.4.</span> Driver support</h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
由于tc BPF程序是由内核网络栈触发，而非驱动，因此不要求驱动做修改，可以运行在任何网络设备，但有一种情况例外：将tc BPF程序卸载到网卡执行时，需要启动程序的支持。
</p>

<p>
支持卸载tc BPF程序的驱动 Netronome的nfp驱动。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org30cf25d" class="outline-2">
<h2 id="org30cf25d"><span class="section-number-2">5.</span> 进一步阅读</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org026072a" class="outline-3">
<h3 id="org026072a"><span class="section-number-3">5.1.</span> Kernel Developer FAQ</h3>
<div class="outline-text-3" id="text-5-1">
<p>
内核 <code>Documentation/bpf/</code> 目录中，有两个针对BPF子系统和内核开发者的FAQ。
</p>

<ul class="org-ul">
<li><p>
BPF Devel FAQ: this document provides mostly information around patch submission process as well as BPF kernel tree, stable tree and bug reporting workflows, questions around BPF’s extensibility and interaction with LLVM and more.
</p>

<p>
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_devel_QA.rst">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_devel_QA.rst</a>
</p></li>

<li><p>
BPF Design FAQ: this document tries to answer frequently asked questions around BPF design decisions related to the instruction set, verifier, calling convention, JITs, etc.
</p>

<p>
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_design_QA.rst">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_design_QA.rst</a>
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgbbca3a2" class="outline-3">
<h3 id="orgbbca3a2"><span class="section-number-3">5.2.</span> Projects using BPF</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The following list includes a selection of open source projects making use of BPF respectively provide tooling for BPF. In this context the eBPF instruction set is specifically meant instead of projects utilizing the legacy cBPF:
</p>
</div>

<div id="outline-container-org7f0649a" class="outline-4">
<h4 id="org7f0649a"><span class="section-number-4">5.2.1.</span> Tracing</h4>
<div class="outline-text-4" id="text-5-2-1">
<ul class="org-ul">
<li><p>
BCC
</p>

<p>
BCC stands for BPF Compiler Collection and its key feature is to provide a set of easy to use and efficient kernel tracing utilities all based upon BPF programs hooking into kernel infrastructure based upon kprobes, kretprobes, tracepoints, uprobes, uretprobes as well as USDT probes. The collection provides close to hundred tools targeting different layers across the stack from applications, system libraries, to the various different kernel subsystems in order to analyze a system’s performance characteristics or problems. Additionally, BCC provides an API in order to be used as a library for other projects.
</p>

<p>
<a href="https://github.com/iovisor/bcc">https://github.com/iovisor/bcc</a>
</p></li>

<li><p>
bpftrace
</p>

<p>
bpftrace is a DTrace-style dynamic tracing tool for Linux and uses LLVM as a back end to compile scripts to BPF-bytecode and makes use of BCC for interacting with the kernel’s BPF tracing infrastructure. It provides a higher-level language for implementing tracing scripts compared to native BCC.
</p>

<p>
<a href="https://github.com/ajor/bpftrace">https://github.com/ajor/bpftrace</a>
</p></li>

<li><p>
perf
</p>

<p>
The perf tool which is developed by the Linux kernel community as part of the kernel source tree provides a way to load tracing BPF programs through the conventional perf record subcommand where the aggregated data from BPF can be retrieved and post processed in perf.data for example through perf script and other means.
</p>

<p>
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/perf">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/perf</a>
</p></li>

<li><p>
ply
</p>

<p>
ply is a tracing tool that follows the ‘Little Language’ approach of yore, and compiles ply scripts into Linux BPF programs that are attached to kprobes and tracepoints in the kernel. The scripts have a C-like syntax, heavily inspired by DTrace and by extension awk. ply keeps dependencies to very minimum and only requires flex and bison at build time, only libc at runtime.
</p>

<p>
<a href="https://github.com/wkz/ply">https://github.com/wkz/ply</a>
</p></li>

<li><p>
systemtap
</p>

<p>
systemtap is a scripting language and tool for extracting, filtering and summarizing data in order to diagnose and analyze performance or functional problems. It comes with a BPF back end called stapbpf which translates the script directly into BPF without the need of an additional compiler and injects the probe into the kernel. Thus, unlike stap’s kernel modules this does neither have external dependencies nor requires to load kernel modules.
</p>

<p>
<a href="https://sourceware.org/git/gitweb.cgi?p=systemtap.git;a=summary">https://sourceware.org/git/gitweb.cgi?p=systemtap.git;a=summary</a>
</p></li>

<li><p>
PCP
</p>

<p>
Performance Co-Pilot (PCP) is a system performance and analysis framework which is able to collect metrics through a variety of agents as well as analyze collected systems’ performance metrics in real-time or by using historical data. With pmdabcc, PCP has a BCC based performance metrics domain agent which extracts data from the kernel via BPF and BCC.
</p>

<p>
<a href="https://github.com/performancecopilot/pcp">https://github.com/performancecopilot/pcp</a>
</p></li>

<li><p>
Weave Scope
</p>

<p>
Weave Scope is a cloud monitoring tool collecting data about processes, networking connections or other system data by making use of BPF in combination with kprobes. Weave Scope works on top of the gobpf library in order to load BPF ELF files into the kernel, and comes with a tcptracer-bpf tool which monitors connect, accept and close calls in order to trace TCP events.
</p>

<p>
<a href="https://github.com/weaveworks/scope">https://github.com/weaveworks/scope</a>
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org49c2cbb" class="outline-4">
<h4 id="org49c2cbb"><span class="section-number-4">5.2.2.</span> Networking</h4>
<div class="outline-text-4" id="text-5-2-2">
<ul class="org-ul">
<li><p>
Cilium
</p>

<p>
Cilium provides and transparently secures network connectivity and load-balancing between application workloads such as application containers or processes. Cilium operates at Layer 3/4 to provide traditional networking and security services as well as Layer 7 to protect and secure use of modern application protocols such as HTTP, gRPC and Kafka. It is integrated into orchestration frameworks such as Kubernetes. BPF is the foundational part of Cilium that operates in the kernel’s networking data path.
</p>

<p>
<a href="https://github.com/cilium/cilium">https://github.com/cilium/cilium</a>
</p></li>

<li><p>
Suricata
</p>

<p>
Suricata is a network IDS, IPS and NSM engine, and utilizes BPF as well as XDP in three different areas, that is, as BPF filter in order to process or bypass certain packets, as a BPF based load balancer in order to allow for programmable load balancing and for XDP to implement a bypass or dropping mechanism at high packet rates.
</p>

<p>
<a href="https://suricata.readthedocs.io/en/suricata-5.0.2/capture-hardware/ebpf-xdp.html">https://suricata.readthedocs.io/en/suricata-5.0.2/capture-hardware/ebpf-xdp.html</a>
</p>

<p>
<a href="https://github.com/OISF/suricata">https://github.com/OISF/suricata</a>
</p></li>

<li><p>
systemd
</p>

<p>
systemd allows for IPv4/v6 accounting as well as implementing network access control for its systemd units based on BPF’s cgroup ingress and egress hooks. Accounting is based on packets / bytes, and ACLs can be specified as address prefixes for allow / deny rules. More information can be found at:
</p>

<p>
<a href="http://0pointer.net/blog/ip-accounting-and-access-lists-with-systemd.html">http://0pointer.net/blog/ip-accounting-and-access-lists-with-systemd.html</a>
</p>

<p>
<a href="https://github.com/systemd/systemd">https://github.com/systemd/systemd</a>
</p></li>

<li><p>
iproute2
</p>

<p>
iproute2 offers the ability to load BPF programs as LLVM generated ELF files into the kernel. iproute2 supports both, XDP BPF programs as well as tc BPF programs through a common BPF loader backend. The tc and ip command line utilities enable loader and introspection functionality for the user.
</p>

<p>
<a href="https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/">https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/</a>
</p></li>

<li><p>
p4c-xdp
</p>

<p>
p4c-xdp presents a P4 compiler backend targeting BPF and XDP. P4 is a domain specific language describing how packets are processed by the data plane of a programmable network element such as NICs, appliances or switches, and with the help of p4c-xdp P4 programs can be translated into BPF C programs which can be compiled by clang / LLVM and loaded as BPF programs into the kernel at XDP layer for high performance packet processing.
</p>

<p>
<a href="https://github.com/vmware/p4c-xdp">https://github.com/vmware/p4c-xdp</a>
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org3f32686" class="outline-4">
<h4 id="org3f32686"><span class="section-number-4">5.2.3.</span> Others</h4>
<div class="outline-text-4" id="text-5-2-3">
<ul class="org-ul">
<li><p>
LLVM
</p>

<p>
clang / LLVM provides the BPF back end in order to compile C BPF programs into BPF instructions contained in ELF files. The LLVM BPF back end is developed alongside with the BPF core infrastructure in the Linux kernel and maintained by the same community. clang / LLVM is a key part in the toolchain for developing BPF programs.
</p>

<p>
<a href="https://llvm.org/">https://llvm.org/</a>
</p></li>

<li><p>
libbpf
</p>

<p>
libbpf is a generic BPF library which is developed by the Linux kernel community as part of the kernel source tree and allows for loading and attaching BPF programs from LLVM generated ELF files into the kernel. The library is used by other kernel projects such as perf and bpftool.
</p>

<p>
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/lib/bpf">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/lib/bpf</a>
</p></li>

<li><p>
bpftool
</p>

<p>
bpftool is the main tool for introspecting and debugging BPF programs and BPF maps, and like libbpf is developed by the Linux kernel community. It allows for dumping all active BPF programs and maps in the system, dumping and disassembling BPF or JITed BPF instructions from a program as well as dumping and manipulating BPF maps in the system. bpftool supports interaction with the BPF filesystem, loading various program types from an object file into the kernel and much more.
</p>

<p>
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/bpf/bpftool">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/bpf/bpftool</a>
</p></li>

<li><p>
cilium/ebpf
</p>

<p>
cilium/ebpf (ebpf-go) is a pure Go library that provides utilities for loading, compiling, and debugging eBPF programs. It has minimal external dependencies and is intended to be used in long-running processes.
</p>

<p>
Its bpf2go utility automates away compiling eBPF C programs and embedding them into Go binaries.
</p>

<p>
It implements attaching programs to various kernel hooks, as well as kprobes and uprobes for tracing arbitrary kernel and user space functions. It also features a complete assembler that allows constructing eBPF programs at runtime using Go, or modifying them after they’ve been loaded from an ELF object.
</p>

<p>
<a href="https://github.com/cilium/ebpf">https://github.com/cilium/ebpf</a>
</p></li>

<li><p>
ebpf_asm
</p>

<p>
ebpf_asm provides an assembler for BPF programs written in an Intel-like assembly syntax, and therefore offers an alternative for writing BPF programs directly in assembly for cases where programs are rather small and simple without needing the clang / LLVM toolchain.
</p>

<p>
<a href="https://github.com/Xilinx-CNS/ebpf_asm">https://github.com/Xilinx-CNS/ebpf_asm</a>
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga696022" class="outline-3">
<h3 id="orga696022"><span class="section-number-3">5.3.</span> XDP Newbies</h3>
<div class="outline-text-3" id="text-5-3">
<p>
There are a couple of walk-through posts by David S. Miller to the xdp-newbies mailing list(<a href="http://vger.kernel.org/vger-lists.html#xdp-newbies">http://vger.kernel.org/vger-lists.html#xdp-newbies</a>), which explain various parts of XDP and BPF:
</p>

<dl class="org-dl">
<dt>4 May 2017,</dt><dd>BPF Verifier Overview, David S. Miller, <a href="https://www.spinics.net/lists/xdp-newbies/msg00185.html">https://www.spinics.net/lists/xdp-newbies/msg00185.html</a></dd>

<dt>3 May 2017,</dt><dd>Contextually speaking…, David S. Miller, <a href="https://www.spinics.net/lists/xdp-newbies/msg00181.html">https://www.spinics.net/lists/xdp-newbies/msg00181.html</a></dd>

<dt>2 May 2017,</dt><dd>bpf.h and you…, David S. Miller, <a href="https://www.spinics.net/lists/xdp-newbies/msg00179.html">https://www.spinics.net/lists/xdp-newbies/msg00179.html</a></dd>

<dt>1 Apr 2017,</dt><dd>XDP example of the day, David S. Miller, <a href="https://www.spinics.net/lists/xdp-newbies/msg00009.html">https://www.spinics.net/lists/xdp-newbies/msg00009.html</a></dd>
</dl>
</div>
</div>

<div id="outline-container-orgdef357e" class="outline-3">
<h3 id="orgdef357e"><span class="section-number-3">5.4.</span> BPF Newsletter</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Alexander Alemayhu initiated a newsletter around BPF roughly once per week covering latest developments around BPF in Linuxkernel land and its surrounding ecosystem in user space.
</p>

<p>
All BPF update newsletters (01 - 12) can be found here:
</p>

<p>
<a href="https://cilium.io/blog/categories/technology/5/">https://cilium.io/blog/categories/technology/5/</a>
</p>

<p>
And for the news on the latest resources and developments in the eBPF world, please refer to the link here:
</p>

<p>
<a href="https://ebpf.io/blog">https://ebpf.io/blog</a>
</p>
</div>
</div>

<div id="outline-container-orgf0d3cdb" class="outline-3">
<h3 id="orgf0d3cdb"><span class="section-number-3">5.5.</span> Podcasts</h3>
<div class="outline-text-3" id="text-5-5">
<p>
There have been a number of technical podcasts partially covering BPF. Incomplete list:
</p>

<dl class="org-dl">
<dt>5 Feb 2017,</dt><dd>Linux Networking Update from Netdev Conference, Thomas Graf, Software Gone Wild, Show 71, <a href="https://blog.ipspace.net/2017/02/linux-networking-update-from-netdev.html">https://blog.ipspace.net/2017/02/linux-networking-update-from-netdev.html</a>  <a href="https://www.ipspace.net/nuggets/podcast/Show_71-NetDev_Update.mp3">https://www.ipspace.net/nuggets/podcast/Show_71-NetDev_Update.mp3</a></dd>

<dt>4 Jan 2017,</dt><dd>The IO Visor Project, Brenden Blanco, OVS Orbit, Episode 23, <a href="https://ovsorbit.org/#e23">https://ovsorbit.org/#e23</a> <a href="https://ovsorbit.org/episode-23.mp3">https://ovsorbit.org/episode-23.mp3</a></dd>

<dt>3 Oct 2016,</dt><dd>Fast Linux Packet Forwarding, Thomas Graf, Software Gone Wild, Show 64, <a href="https://blog.ipspace.net/2016/10/fast-linux-packet-forwarding-with.html">https://blog.ipspace.net/2016/10/fast-linux-packet-forwarding-with.html</a> <a href="https://www.ipspace.net/nuggets/podcast/Show_64-Cilium_with_Thomas_Graf.mp3">https://www.ipspace.net/nuggets/podcast/Show_64-Cilium_with_Thomas_Graf.mp3</a></dd>

<dt>2 Aug 2016,</dt><dd>P4 on the Edge, John Fastabend, OVS Orbit, Episode 11, <a href="https://ovsorbit.org/#e11">https://ovsorbit.org/#e11</a> <a href="https://ovsorbit.org/episode-11.mp3">https://ovsorbit.org/episode-11.mp3</a></dd>

<dt>1 May 2016,</dt><dd>Cilium, Thomas Graf, OVS Orbit, Episode 4, <a href="https://ovsorbit.org/#e4">https://ovsorbit.org/#e4</a> <a href="https://ovsorbit.org/episode-4.mp3">https://ovsorbit.org/episode-4.mp3</a></dd>
</dl>
</div>
</div>

<div id="outline-container-orgab25612" class="outline-3">
<h3 id="orgab25612"><span class="section-number-3">5.6.</span> Blog posts</h3>
<div class="outline-text-3" id="text-5-6">
<p>
The following (incomplete) list includes blog posts around BPF, XDP and related projects:
</p>

<dl class="org-dl">
<dt>34 May 2017,</dt><dd>An entertaining eBPF XDP adventure, Suchakra Sharma, <a href="https://suchakra.wordpress.com/2017/05/23/an-entertaining-ebpf-xdp-adventure/">https://suchakra.wordpress.com/2017/05/23/an-entertaining-ebpf-xdp-adventure/</a></dd>

<dt>33 May 2017,</dt><dd>eBPF, part 2: Syscall and Map Types, Ferris Ellis, <a href="https://ferrisellis.com/posts/ebpf_syscall_and_maps/">https://ferrisellis.com/posts/ebpf_syscall_and_maps/</a></dd>

<dt>32 May 2017,</dt><dd>Monitoring the Control Plane, Gary Berger, <a href="https://www.firstclassfunc.com/2018/07/monitoring-the-control-plane/">https://www.firstclassfunc.com/2018/07/monitoring-the-control-plane/</a></dd>

<dt>31 Apr 2017,</dt><dd>USENIX/LISA 2016 Linux bcc/BPF Tools, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2017-04-29/usenix-lisa-2016-bcc-bpf-tools.html">http://www.brendangregg.com/blog/2017-04-29/usenix-lisa-2016-bcc-bpf-tools.html</a></dd>

<dt>30 Apr 2017,</dt><dd>Liveblog: Cilium for Network and Application Security with BPF and XDP, Scott Lowe, <a href="https://blog.scottlowe.org/2017/04/18/black-belt-cilium/">https://blog.scottlowe.org/2017/04/18/black-belt-cilium/</a></dd>

<dt>29 Apr 2017,</dt><dd>eBPF, part 1: Past, Present, and Future, Ferris Ellis, <a href="https://ferrisellis.com/posts/ebpf_past_present_future/">https://ferrisellis.com/posts/ebpf_past_present_future/</a></dd>

<dt>28 Mar 2017,</dt><dd>Analyzing KVM Hypercalls with eBPF Tracing, Suchakra Sharma, <a href="https://suchakra.wordpress.com/2017/03/31/analyzing-kvm-hypercalls-with-ebpf-tracing/">https://suchakra.wordpress.com/2017/03/31/analyzing-kvm-hypercalls-with-ebpf-tracing/</a></dd>

<dt>27 Jan 2017,</dt><dd>Golang bcc/BPF Function Tracing, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html">http://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html</a></dd>

<dt>26 Dec 2016,</dt><dd>Give me 15 minutes and I’ll change your view of Linux tracing, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-12-27/linux-tracing-in-15-minutes.html">http://www.brendangregg.com/blog/2016-12-27/linux-tracing-in-15-minutes.html</a></dd>

<dt>25 Nov 2016,</dt><dd>Cilium: Networking and security for containers with BPF and XDP, Daniel Borkmann, <a href="https://opensource.googleblog.com/2016/11/cilium-networking-and-security.html">https://opensource.googleblog.com/2016/11/cilium-networking-and-security.html</a></dd>

<dt>24 Nov 2016,</dt><dd>Linux bcc/BPF tcplife: TCP Lifespans, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-11-30/linux-bcc-tcplife.html">http://www.brendangregg.com/blog/2016-11-30/linux-bcc-tcplife.html</a></dd>

<dt>23 Oct 2016,</dt><dd>DTrace for Linux 2016, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-10-27/dtrace-for-linux-2016.html">http://www.brendangregg.com/blog/2016-10-27/dtrace-for-linux-2016.html</a></dd>

<dt>22 Oct 2016,</dt><dd>Linux 4.9’s Efficient BPF-based Profiler, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-10-21/linux-efficient-profiler.html">http://www.brendangregg.com/blog/2016-10-21/linux-efficient-profiler.html</a></dd>

<dt>21 Oct 2016,</dt><dd>Linux bcc tcptop, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-10-15/linux-bcc-tcptop.html">http://www.brendangregg.com/blog/2016-10-15/linux-bcc-tcptop.html</a></dd>

<dt>20 Oct 2016,</dt><dd>Linux bcc/BPF Node.js USDT Tracing, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-10-12/linux-bcc-nodejs-usdt.html">http://www.brendangregg.com/blog/2016-10-12/linux-bcc-nodejs-usdt.html</a></dd>

<dt>19 Oct 2016,</dt><dd>Linux bcc/BPF Run Queue (Scheduler) Latency, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-10-08/linux-bcc-runqlat.html">http://www.brendangregg.com/blog/2016-10-08/linux-bcc-runqlat.html</a></dd>

<dt>18 Oct 2016,</dt><dd>Linux bcc ext4 Latency Tracing, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-10-06/linux-bcc-ext4dist-ext4slower.html">http://www.brendangregg.com/blog/2016-10-06/linux-bcc-ext4dist-ext4slower.html</a></dd>

<dt>17 Oct 2016,</dt><dd>Linux MySQL Slow Query Tracing with bcc/BPF, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-10-04/linux-bcc-mysqld-qslower.html">http://www.brendangregg.com/blog/2016-10-04/linux-bcc-mysqld-qslower.html</a></dd>

<dt>16 Oct 2016,</dt><dd>Linux bcc Tracing Security Capabilities, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-10-01/linux-bcc-security-capabilities.html">http://www.brendangregg.com/blog/2016-10-01/linux-bcc-security-capabilities.html</a></dd>

<dt>15 Sep 2016,</dt><dd>Suricata bypass feature, Eric Leblond, <a href="https://www.stamus-networks.com/blog/2016/09/28/suricata-bypass-feature">https://www.stamus-networks.com/blog/2016/09/28/suricata-bypass-feature</a></dd>

<dt>14 Aug 2016,</dt><dd>Introducing the p0f BPF compiler, Gilberto Bertin, <a href="https://blog.cloudflare.com/introducing-the-p0f-bpf-compiler/">https://blog.cloudflare.com/introducing-the-p0f-bpf-compiler/</a></dd>

<dt>13 Jun 2016,</dt><dd>Ubuntu Xenial bcc/BPF, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-06-14/ubuntu-xenial-bcc-bpf.html">http://www.brendangregg.com/blog/2016-06-14/ubuntu-xenial-bcc-bpf.html</a></dd>

<dt>12 Mar 2016,</dt><dd>Linux BPF/bcc Road Ahead, March 2016, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-03-28/linux-bpf-bcc-road-ahead-2016.html">http://www.brendangregg.com/blog/2016-03-28/linux-bpf-bcc-road-ahead-2016.html</a></dd>

<dt>11 Mar 2016,</dt><dd>Linux BPF Superpowers, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-03-05/linux-bpf-superpowers.html">http://www.brendangregg.com/blog/2016-03-05/linux-bpf-superpowers.html</a></dd>

<dt>10 Feb 2016,</dt><dd>Linux eBPF/bcc uprobes, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-02-08/linux-ebpf-bcc-uprobes.html">http://www.brendangregg.com/blog/2016-02-08/linux-ebpf-bcc-uprobes.html</a></dd>

<dt>9 Feb 2016,</dt><dd>Who is waking the waker? (Linux chain graph prototype), Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-02-05/ebpf-chaingraph-prototype.html">http://www.brendangregg.com/blog/2016-02-05/ebpf-chaingraph-prototype.html</a></dd>

<dt>8 Feb 2016,</dt><dd>Linux Wakeup and Off-Wake Profiling, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-02-01/linux-wakeup-offwake-profiling.html">http://www.brendangregg.com/blog/2016-02-01/linux-wakeup-offwake-profiling.html</a></dd>

<dt>7 Jan 2016,</dt><dd>Linux eBPF Off-CPU Flame Graph, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-01-20/ebpf-offcpu-flame-graph.html">http://www.brendangregg.com/blog/2016-01-20/ebpf-offcpu-flame-graph.html</a></dd>

<dt>6 Jan 2016,</dt><dd>Linux eBPF Stack Trace Hack, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2016-01-18/ebpf-stack-trace-hack.html">http://www.brendangregg.com/blog/2016-01-18/ebpf-stack-trace-hack.html</a></dd>

<dt>1 Sep 2015,</dt><dd>Linux Networking, Tracing and IO Visor, a New Systems Performance Tool for a Distributed World, Suchakra Sharma, <a href="https://thenewstack.io/comparing-dtrace-iovisor-new-systems-performance-platform-advance-linux-networking-virtualization/">https://thenewstack.io/comparing-dtrace-iovisor-new-systems-performance-platform-advance-linux-networking-virtualization/</a></dd>

<dt>5 Aug 2015,</dt><dd>BPF Internals - II, Suchakra Sharma, <a href="https://suchakra.wordpress.com/2015/08/12/bpf-internals-ii/">https://suchakra.wordpress.com/2015/08/12/bpf-internals-ii/</a></dd>

<dt>4 May 2015,</dt><dd>eBPF: One Small Step, Brendan Gregg, <a href="http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html">http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html</a></dd>

<dt>3 May 2015,</dt><dd>BPF Internals - I, Suchakra Sharma, <a href="https://suchakra.wordpress.com/2015/05/18/bpf-internals-i/">https://suchakra.wordpress.com/2015/05/18/bpf-internals-i/</a></dd>

<dt>2 Jul 2014,</dt><dd>Introducing the BPF Tools, Marek Majkowski, <a href="https://blog.cloudflare.com/introducing-the-bpf-tools/">https://blog.cloudflare.com/introducing-the-bpf-tools/</a></dd>

<dt>1 May 2014,</dt><dd>BPF - the forgotten bytecode, Marek Majkowski, <a href="https://blog.cloudflare.com/bpf-the-forgotten-bytecode/">https://blog.cloudflare.com/bpf-the-forgotten-bytecode/</a></dd>
</dl>
</div>
</div>

<div id="outline-container-org4164127" class="outline-3">
<h3 id="org4164127"><span class="section-number-3">5.7.</span> Books</h3>
<div class="outline-text-3" id="text-5-7">
<p>
BPF Performance Tools (Gregg, Addison Wesley, 2019)
</p>
</div>
</div>

<div id="outline-container-orgc35bf12" class="outline-3">
<h3 id="orgc35bf12"><span class="section-number-3">5.8.</span> Talks</h3>
<div class="outline-text-3" id="text-5-8">
<p>
The following (incomplete) list includes talks and conference papers related to BPF and XDP:
</p>

<dl class="org-dl">
<dt>46 July 2021,</dt><dd>eBPF &amp; Cilium Office Hours episode 13: XDP Hands-on Tutorial, with Liz Rice, <a href="https://www.youtube.com/watch?v=YUI78vC4qSQ&amp;t=300s">https://www.youtube.com/watch?v=YUI78vC4qSQ&amp;t=300s</a></dd>

<dt>45 June 2021,</dt><dd>eBPF &amp; Cilium Office Hours episode 9: XDP and Load Balancing, with Daniel Borkmann, <a href="https://www.youtube.com/watch?v=OIyPm6K4ooY&amp;t=308s">https://www.youtube.com/watch?v=OIyPm6K4ooY&amp;t=308s</a></dd>

<dt>44 May 2017,</dt><dd>PyCon 2017, Portland, Executing python functions in the linux kernel by transpiling to bpf, Alex Gartrell, <a href="https://www.youtube.com/watch?v=CpqMroMBGP4">https://www.youtube.com/watch?v=CpqMroMBGP4</a></dd>

<dt>43 May 2017,</dt><dd>gluecon 2017, Denver, Cilium + BPF: Least Privilege Security on API Call Level for Microservices, Dan Wendlandt, <a href="http://gluecon.com/#agenda">http://gluecon.com/#agenda</a></dd>

<dt>42 May 2017,</dt><dd>Lund Linux Con, Lund, XDP - eXpress Data Path, Jesper Dangaard Brouer, <a href="http://people.netfilter.org/hawk/presentations/LLC2017/XDP_DDoS_protecting_LLC2017.pdf">http://people.netfilter.org/hawk/presentations/LLC2017/XDP_DDoS_protecting_LLC2017.pdf</a></dd>

<dt>41 May 2017,</dt><dd>Polytechnique Montreal, Trace Aggregation and Collection with eBPF, Suchakra Sharma, <a href="https://hsdm.dorsal.polymtl.ca/system/files/eBPF-5May2017%20(1).pdf">https://hsdm.dorsal.polymtl.ca/system/files/eBPF-5May2017%20(1).pdf</a></dd>

<dt>40 Apr 2017,</dt><dd>DockerCon, Austin, Cilium - Network and Application Security with BPF and XDP, Thomas Graf, <a href="https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp">https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp</a></dd>

<dt>39 Apr 2017,</dt><dd>NetDev 2.1, Montreal, XDP Mythbusters, David S. Miller, <a href="https://netdevconf.info/2.1/slides/apr7/miller-XDP-MythBusters.pdf">https://netdevconf.info/2.1/slides/apr7/miller-XDP-MythBusters.pdf</a></dd>

<dt>38 Apr 2017,</dt><dd>NetDev 2.1, Montreal, Droplet: DDoS countermeasures powered by BPF + XDP, Huapeng Zhou, Doug Porter, Ryan Tierney, Nikita Shirokov, <a href="https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf">https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf</a></dd>

<dt>37 Apr 2017,</dt><dd>NetDev 2.1, Montreal, XDP in practice: integrating XDP in our DDoS mitigation pipeline, Gilberto Bertin, <a href="https://netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf">https://netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf</a></dd>

<dt>36 Apr 2017,</dt><dd>NetDev 2.1, Montreal, XDP for the Rest of Us, Andy Gospodarek, Jesper Dangaard Brouer, <a href="https://netdevconf.info/2.1/slides/apr7/gospodarek-Netdev2.1-XDP-for-the-Rest-of-Us_Final.pdf">https://netdevconf.info/2.1/slides/apr7/gospodarek-Netdev2.1-XDP-for-the-Rest-of-Us_Final.pdf</a></dd>

<dt>35 Mar 2017,</dt><dd>SCALE15x, Pasadena, Linux 4.x Tracing: Performance Analysis with bcc/BPF, Brendan Gregg, <a href="https://www.slideshare.net/brendangregg/linux-4x-tracing-performance-analysis-with-bccbpf">https://www.slideshare.net/brendangregg/linux-4x-tracing-performance-analysis-with-bccbpf</a></dd>

<dt>34 Mar 2017,</dt><dd>XDP Inside and Out, David S. Miller, <a href="https://raw.githubusercontent.com/iovisor/bpf-docs/master/XDP_Inside_and_Out.pdf">https://raw.githubusercontent.com/iovisor/bpf-docs/master/XDP_Inside_and_Out.pdf</a></dd>

<dt>33 Mar 2017,</dt><dd>OpenSourceDays, Copenhagen, XDP - eXpress Data Path, Used for DDoS protection, Jesper Dangaard Brouer, <a href="http://people.netfilter.org/hawk/presentations/OpenSourceDays2017/XDP_DDoS_protecting_osd2017.pdf">http://people.netfilter.org/hawk/presentations/OpenSourceDays2017/XDP_DDoS_protecting_osd2017.pdf</a></dd>

<dt>32 Mar 2017,</dt><dd>source{d}, Infrastructure 2017, Madrid, High-performance Linux monitoring with eBPF, Alfonso Acosta, <a href="https://www.youtube.com/watch?v=k4jqTLtdrxQ">https://www.youtube.com/watch?v=k4jqTLtdrxQ</a></dd>

<dt>31 Feb 2017,</dt><dd>FOSDEM 2017, Brussels, Stateful packet processing with eBPF, an implementation of OpenState interface, Quentin Monnet, <a href="https://archive.fosdem.org/2017/schedule/event/stateful_ebpf/">https://archive.fosdem.org/2017/schedule/event/stateful_ebpf/</a></dd>

<dt>30 Feb 2017,</dt><dd>FOSDEM 2017, Brussels, eBPF and XDP walkthrough and recent updates, Daniel Borkmann, <a href="http://borkmann.ch/talks/2017_fosdem.pdf">http://borkmann.ch/talks/2017_fosdem.pdf</a></dd>

<dt>29 Feb 2017,</dt><dd>FOSDEM 2017, Brussels, Cilium - BPF &amp; XDP for containers, Thomas Graf, <a href="https://archive.fosdem.org/2017/schedule/event/cilium/">https://archive.fosdem.org/2017/schedule/event/cilium/</a></dd>

<dt>28 Jan 2017,</dt><dd>linuxconf.au, Hobart, BPF: Tracing and more, Brendan Gregg, <a href="https://www.slideshare.net/brendangregg/bpf-tracing-and-more">https://www.slideshare.net/brendangregg/bpf-tracing-and-more</a></dd>

<dt>27 Dec 2016,</dt><dd>USENIX LISA 2016, Boston, Linux 4.x Tracing Tools: Using BPF Superpowers, Brendan Gregg, <a href="https://www.slideshare.net/brendangregg/linux-4x-tracing-tools-using-bpf-superpowers">https://www.slideshare.net/brendangregg/linux-4x-tracing-tools-using-bpf-superpowers</a></dd>

<dt>26 Nov 2016,</dt><dd>Linux Plumbers, Santa Fe, Cilium: Networking &amp; Security for Containers with BPF &amp; XDP, Thomas Graf, <a href="https://www.slideshare.net/ThomasGraf5/clium-container-networking-with-bpf-xdp">https://www.slideshare.net/ThomasGraf5/clium-container-networking-with-bpf-xdp</a></dd>

<dt>25 Nov 2016,</dt><dd>OVS Conference, Santa Clara, Offloading OVS Flow Processing using eBPF, William (Cheng-Chun) Tu, <a href="http://www.openvswitch.org/support/ovscon2016/7/1120-tu.pdf">http://www.openvswitch.org/support/ovscon2016/7/1120-tu.pdf</a></dd>

<dt>24 Oct 2016,</dt><dd>One.com, Copenhagen, XDP - eXpress Data Path, Intro and future use-cases, Jesper Dangaard Brouer, <a href="http://people.netfilter.org/hawk/presentations/xdp2016/xdp_intro_and_use_cases_sep2016.pdf">http://people.netfilter.org/hawk/presentations/xdp2016/xdp_intro_and_use_cases_sep2016.pdf</a></dd>

<dt>23 Oct 2016,</dt><dd>Docker Distributed Systems Summit, Berlin, Cilium: Networking &amp; Security for Containers with BPF &amp; XDP, Thomas Graf, <a href="https://www.slideshare.net/Docker/cilium-bpf-xdp-for-containers-66969823">https://www.slideshare.net/Docker/cilium-bpf-xdp-for-containers-66969823</a></dd>

<dt>22 Oct 2016,</dt><dd>NetDev 1.2, Tokyo, Data center networking stack, Tom Herbert, <a href="https://netdevconf.info/1.2/session.html?tom-herbert">https://netdevconf.info/1.2/session.html?tom-herbert</a></dd>

<dt>21 Oct 2016,</dt><dd>NetDev 1.2, Tokyo, Fast Programmable Networks &amp; Encapsulated Protocols, David S. Miller, <a href="https://netdevconf.info/1.2/session.html?david-miller-keynote">https://netdevconf.info/1.2/session.html?david-miller-keynote</a></dd>

<dt>20 Oct 2016,</dt><dd>NetDev 1.2, Tokyo, XDP workshop - Introduction, experience, and future development, Tom Herbert, <a href="https://netdevconf.info/1.2/session.html?herbert-xdp-workshop">https://netdevconf.info/1.2/session.html?herbert-xdp-workshop</a></dd>

<dt>19 Oct 2016,</dt><dd>NetDev1.2, Tokyo, The adventures of a Suricate in eBPF land, Eric Leblond, <a href="https://netdevconf.info/1.2/slides/oct6/10_suricata_ebpf.pdf">https://netdevconf.info/1.2/slides/oct6/10_suricata_ebpf.pdf</a></dd>

<dt>18 Oct 2016,</dt><dd>NetDev1.2, Tokyo, cls_bpf/eBPF updates since netdev 1.1, Daniel Borkmann, <a href="http://borkmann.ch/talks/2016_tcws.pdf">http://borkmann.ch/talks/2016_tcws.pdf</a></dd>

<dt>17 Oct 2016,</dt><dd>NetDev1.2, Tokyo, Advanced programmability and recent updates with tc’s cls_bpf, Daniel Borkmann, <a href="http://borkmann.ch/talks/2016_netdev2.pdf">http://borkmann.ch/talks/2016_netdev2.pdf</a> <a href="https://netdevconf.info/1.2/papers/borkmann.pdf">https://netdevconf.info/1.2/papers/borkmann.pdf</a></dd>

<dt>16 Oct 2016,</dt><dd>NetDev 1.2, Tokyo, eBPF/XDP hardware offload to SmartNICs, Jakub Kicinski, Nic Viljoen, <a href="https://netdevconf.info/1.2/papers/eBPF_HW_OFFLOAD.pdf">https://netdevconf.info/1.2/papers/eBPF_HW_OFFLOAD.pdf</a></dd>

<dt>15 Aug 2016,</dt><dd>LinuxCon, Toronto, What Can BPF Do For You?, Brenden Blanco, <a href="https://events.static.linuxfound.org/sites/events/files/slides/iovisor-lc-bof-2016.pdf">https://events.static.linuxfound.org/sites/events/files/slides/iovisor-lc-bof-2016.pdf</a></dd>

<dt>14 Aug 2016,</dt><dd>LinuxCon, Toronto, Cilium - Fast IPv6 Container Networking with BPF and XDP, Thomas Graf, <a href="https://www.slideshare.net/ThomasGraf5/cilium-fast-ipv6-container-networking-with-bpf-and-xdp">https://www.slideshare.net/ThomasGraf5/cilium-fast-ipv6-container-networking-with-bpf-and-xdp</a></dd>

<dt>13 Aug 2016,</dt><dd>P4, EBPF and Linux TC Offload, Dinan Gunawardena, Jakub Kicinski, <a href="https://de.slideshare.net/Open-NFP/p4-epbf-and-linux-tc-offload">https://de.slideshare.net/Open-NFP/p4-epbf-and-linux-tc-offload</a></dd>

<dt>12 Jul 2016,</dt><dd>Linux Meetup, Santa Clara, eXpress Data Path, Brenden Blanco, <a href="https://www.slideshare.net/IOVisor/express-data-path-linux-meetup-santa-clara-july-2016">https://www.slideshare.net/IOVisor/express-data-path-linux-meetup-santa-clara-july-2016</a></dd>

<dt>11 Jul 2016,</dt><dd>Linux Meetup, Santa Clara, CETH for XDP, Yan Chan, Yunsong Lu, <a href="https://www.slideshare.net/IOVisor/ceth-for-xdp-linux-meetup-santa-clara-july-2016">https://www.slideshare.net/IOVisor/ceth-for-xdp-linux-meetup-santa-clara-july-2016</a></dd>

<dt>10 May 2016,</dt><dd>P4 workshop, Stanford, P4 on the Edge, John Fastabend, <a href="https://schd.ws/hosted_files/2016p4workshop/1d/Intel%20Fastabend-P4%20on%20the%20Edge.pdf">https://schd.ws/hosted_files/2016p4workshop/1d/Intel%20Fastabend-P4%20on%20the%20Edge.pdf</a></dd>

<dt>9 Mar 2016,</dt><dd>Performance @Scale 2016, Menlo Park, Linux BPF Superpowers, Brendan Gregg, <a href="https://www.slideshare.net/brendangregg/linux-bpf-superpowers">https://www.slideshare.net/brendangregg/linux-bpf-superpowers</a></dd>

<dt>8 Mar 2016,</dt><dd>eXpress Data Path, Tom Herbert, Alexei Starovoitov, <a href="https://raw.githubusercontent.com/iovisor/bpf-docs/master/Express_Data_Path.pdf">https://raw.githubusercontent.com/iovisor/bpf-docs/master/Express_Data_Path.pdf</a></dd>

<dt>7 Feb 2016,</dt><dd>NetDev1.1, Seville, On getting tc classifier fully programmable with cls_bpf, Daniel Borkmann, <a href="http://borkmann.ch/talks/2016_netdev.pdf">http://borkmann.ch/talks/2016_netdev.pdf</a> <a href="https://netdevconf.info/1.1/proceedings/papers/On-getting-tc-classifier-fully-programmable-with-cls-bpf.pdf">https://netdevconf.info/1.1/proceedings/papers/On-getting-tc-classifier-fully-programmable-with-cls-bpf.pdf</a></dd>

<dt>6 Jan 2016,</dt><dd>FOSDEM 2016, Brussels, Linux tc and eBPF, Daniel Borkmann, <a href="http://borkmann.ch/talks/2016_fosdem.pdf">http://borkmann.ch/talks/2016_fosdem.pdf</a></dd>

<dt>5 Oct 2015,</dt><dd>LinuxCon Europe, Dublin, eBPF on the Mainframe, Michael Holzheu, <a href="https://events.static.linuxfound.org/sites/events/files/slides/ebpf_on_the_mainframe_lcon_2015.pdf">https://events.static.linuxfound.org/sites/events/files/slides/ebpf_on_the_mainframe_lcon_2015.pdf</a></dd>

<dt>4 Aug 2015,</dt><dd>Tracing Summit, Seattle, LLTng’s Trace Filtering and beyond (with some eBPF goodness, of course!), Suchakra Sharma, <a href="https://raw.githubusercontent.com/iovisor/bpf-docs/master/ebpf_excerpt_20Aug2015.pdf">https://raw.githubusercontent.com/iovisor/bpf-docs/master/ebpf_excerpt_20Aug2015.pdf</a></dd>

<dt>3 Jun 2015,</dt><dd>LinuxCon Japan, Tokyo, Exciting Developments in Linux Tracing, Elena Zannoni, <a href="https://events.static.linuxfound.org/sites/events/files/slides/tracing-linux-ezannoni-linuxcon-ja-2015_0.pdf">https://events.static.linuxfound.org/sites/events/files/slides/tracing-linux-ezannoni-linuxcon-ja-2015_0.pdf</a></dd>

<dt>2 Feb 2015,</dt><dd>Collaboration Summit, Santa Rosa, BPF: In-kernel Virtual Machine, Alexei Starovoitov, <a href="https://events.static.linuxfound.org/sites/events/files/slides/bpf_collabsummit_2015feb20.pdf">https://events.static.linuxfound.org/sites/events/files/slides/bpf_collabsummit_2015feb20.pdf</a></dd>

<dt>1 Feb 2015,</dt><dd>NetDev 0.1, Ottawa, BPF: In-kernel Virtual Machine, Alexei Starovoitov, <a href="https://netdevconf.info/0.1/sessions/15.html">https://netdevconf.info/0.1/sessions/15.html</a></dd>

<dt>0 Feb 2014,</dt><dd>DevConf.cz, Brno, tc and cls_bpf: lightweight packet classifying with BPF, Daniel Borkmann, <a href="http://borkmann.ch/talks/2014_devconf.pdf">http://borkmann.ch/talks/2014_devconf.pdf</a></dd>
</dl>
</div>
</div>

<div id="outline-container-org1b3d5fd" class="outline-3">
<h3 id="org1b3d5fd"><span class="section-number-3">5.9.</span> Further Documents</h3>
<div class="outline-text-3" id="text-5-9">
<ul class="org-ul">
<li>Dive into BPF: a list of reading material, Quentin Monnet (<a href="https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/">https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/</a>)</li>

<li>XDP - eXpress Data Path, Jesper Dangaard Brouer (<a href="https://prototype-kernel.readthedocs.io/en/latest/networking/XDP/index.html">https://prototype-kernel.readthedocs.io/en/latest/networking/XDP/index.html</a>)</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:53</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
