<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>进程调度</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">进程调度</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgd97ea91">1. 调度器</a>
<ul>
<li><a href="#org2322519">1.1. 概览</a></li>
<li><a href="#org9ac91f7">1.2. 数据结构</a>
<ul>
<li><a href="#orgd486666">1.2.1. task_struct中的调度相关成员</a></li>
<li><a href="#org59949b7">1.2.2. 调度器类</a></li>
<li><a href="#orgb1f24ad">1.2.3. 就绪队列</a></li>
<li><a href="#org32eb4c7">1.2.4. 调度实体</a></li>
</ul>
</li>
<li><a href="#org8deb195">1.3. 处理优先级</a>
<ul>
<li><a href="#org9e090cd">1.3.1. 优先级的内核表示</a></li>
<li><a href="#org1307e4c">1.3.2. 优先级计算</a></li>
<li><a href="#orgb58c709">1.3.3. 计算负荷权重</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9825306">2. 核心调度器</a>
<ul>
<li><a href="#orgbdcc0f5">2.1. 周期性调度器</a></li>
<li><a href="#org1766f97">2.2. 主调度器</a></li>
<li><a href="#orgbd9a398">2.3. 与fork交互</a></li>
<li><a href="#org5490997">2.4. 上下文切换</a></li>
</ul>
</li>
<li><a href="#org0e1cf2c">3. 完全公平调度类</a>
<ul>
<li><a href="#org91f2986">3.1. CFS的就绪队列</a></li>
<li><a href="#orge74757e">3.2. CFS操作</a>
<ul>
<li><a href="#org2e0afd7">3.2.1. 虚拟时钟</a></li>
<li><a href="#org356bd2d">3.2.2. 延迟跟踪</a></li>
</ul>
</li>
<li><a href="#org5f998c1">3.3. 队列操作</a></li>
<li><a href="#org313f10b">3.4. 选择下一个进程</a></li>
<li><a href="#orgf282f7c">3.5. 处理周期性调度器</a></li>
<li><a href="#orge79cecf">3.6. 唤醒抢占</a></li>
<li><a href="#orga3faad0">3.7. 处理新进程</a></li>
</ul>
</li>
<li><a href="#org6b0b17e">4. 实时调度类</a>
<ul>
<li><a href="#orgfff1a71">4.1. 数据结构</a></li>
<li><a href="#orgf2df279">4.2. 调度器操作</a></li>
</ul>
</li>
<li><a href="#org72c62a9">5. 调度器增强</a>
<ul>
<li><a href="#org668caf1">5.1. SMP调度</a>
<ul>
<li><a href="#org2f3189d">5.1.1. 数据结构扩展</a></li>
<li><a href="#orgb989283">5.1.2. 迁移线程（migation_thread）</a></li>
</ul>
</li>
<li><a href="#orgf5eab6a">5.2. 调度域和控制组</a></li>
<li><a href="#orgb8404af">5.3. 内核抢占和低延迟相关工作</a>
<ul>
<li><a href="#orgf44415d">5.3.1. 内核抢占</a></li>
<li><a href="#org446dc68">5.3.2. cond_resched</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态，由一些对象值组成，包括通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构（例如描述地址空间的页表、包含当前进程信息的进程表，进程已打开文件的文件表）。
</p>

<p>
某一时刻，内核决定使用先前的一个被抢占的进程来抢占当前进程，这种决策叫调度。内核选择一个新的进程运行，称之为内核调度了这个进程。内核调度新进程运行后使用 <code>上下文切换</code> 的机制来将控制权转移到新的进程。上下文切换过程：
</p>
<ol class="org-ol">
<li>保存当前进程的上下文</li>
<li>恢复某个先前被抢占的进程的上下文</li>
<li>将控制权传递给新进程</li>
</ol>


<div id="outline-container-orgd97ea91" class="outline-2">
<h2 id="orgd97ea91"><span class="section-number-2">1.</span> 调度器</h2>
<div class="outline-text-2" id="text-1">
<p>
内核在内存中保存了所有进程的实例，每个进程之间通过一些结构互相连接。
</p>

<p>
调度器任务是使得所有进程共享CPU时间，创造并行执行的错觉。该任务分为两个不同部分：
</p>
<ul class="org-ul">
<li>一个涉及调度策略</li>
<li>另一个涉及上下文切换。</li>
</ul>
</div>

<div id="outline-container-org2322519" class="outline-3">
<h3 id="org2322519"><span class="section-number-3">1.1.</span> 概览</h3>
<div class="outline-text-3" id="text-1-1">
<p>
内核需要提供一种方法，在各个进程之间尽可能公平的共享CPU时间，同时还需要考虑进程的优先级。
</p>

<p>
schedule函数是理解调度操作的起点。经典的调度器对系统中的进程分别计算时间片，使进程运行直至时间片用尽。在所有进程的所有时间片都已经用尽时，则需要重新计算。相比之下，当前的调度器只考虑进程的等待时间，即进程在就绪队列（run-queue）中已经等待了多长时间。对CPU时间需求最严格的进程被调度执行。
</p>

<p>
调度器的一般原理是，按所能分配的计算能力，向系统中的每个进程提供最大的公正性。
</p>


<div id="orgb92e507" class="figure">
<p><img src="image/process/schedule-sort.png" alt="schedule-sort.png" />
</p>
</div>

<p>
如上图所示，所有的可运行进程都按其等待时间在一个红黑树中排序。 等待CPU时间最长的进程是最左侧的项，调度器下一次会考虑该进程。等待时间稍短的进程在该树上从左至右排序。
</p>

<p>
除了红黑树外，就绪队列还装备了虚拟时钟。 该时钟的时间流逝速度慢于实际的时钟，精确的速度依赖于当前等待调度器挑选的进程的数目。假定该队列上有4个进程，那么虚拟时钟将以实际时钟四分之一的速度运行。如果以完全公平的方式分享计算能力，那么该时钟是判断等待进程将获得多少CPU时间的基准。在就绪队列等待实际的20秒，相当于虚拟时间5秒。4个进程分别执行5秒，即可使CPU被实际占用20秒。
</p>

<p>
假定就绪队列的虚拟时间是 fair_clock ，而进程的等待时间为 wait_runtime 。为排序红黑树上的进程，内核使用差值 fair_clock - wait_runtime ，因此等待时间越长，越靠左。 fair_clock 是完全公平调度的情况下进程将会得到的CPU时间的度量，而 wait_runtime 直接度量了实际系统的不足造成的不公平。
</p>

<p>
当进程允许运行时，会从 wait_runtime 减去它已经运行的时间。这样，在按时间排序的树中它会向右移动，另一个进程将成为最左侧节点，下一次会被调度器选择。
</p>

<p>
注意：在进程运行时fair_clock 中的虚拟时钟会增加。 这实际上意味着，进程在完全公平的系统中接收的CPU时间份额，是推演自在实际的CPU上执行花费的时间。这减缓了削弱不公平状况的过程：减少 wait_runtime 等价于降低进程受到的不公平对待的数量，但内核无论如何不能忘记，用于降低不公平性的一部分时间，实际上属于处于完全公平世界中的进程。 <b>再次假定就绪队列上有4个进程，而一个进程实际上已经等待了20秒。现在它允许运行10秒：此后的 wait_runtime 是10，但由于该进程无论如何都会得到该时间段中的10/4 = 2秒，因此实际上只有8秒对该进程在就绪队列中的新位置起了作用。</b>
</p>

<p>
以上介绍的是完全公平调度器的原理，现在调度器实现已经变得很复杂：
</p>
<ul class="org-ul">
<li>需要考虑进程的不同优先级（即， nice 值），更重要的进程必须比次要进程更多的CPU时间份额。</li>
<li>进程不能切换得太频繁，如果切换太频繁时，过多时间花费在进程切换的过程中，而不是用于实际的工作。两次相邻的任务切换之间，时间也不能太长，否则会累积比较大的不公平值。</li>
</ul>


<ul class="org-ul">
<li><b>理解调度器</b>

<ul class="org-ul">
<li>理解调度决策的一个好方法是，在编译时激活调度器统计。这会在运行时生成文件 “/proc/sched_debug”，其中包含了调度器当前状态所有方面的信息。</li>

<li>Documentation/ 目录下包含了一些文件，涉及调度器的各个方面。</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org9ac91f7" class="outline-3">
<h3 id="org9ac91f7"><span class="section-number-3">1.2.</span> 数据结构</h3>
<div class="outline-text-3" id="text-1-2">
<p>
调度子系统各个组建的概览：
<img src="image/process/schedule-sys.png" alt="schedule-sys.png" />
</p>

<p>
激活调度器的两种方法：
</p>
<ul class="org-ul">
<li>进程睡眠，或者由于其他原因放弃cpu。</li>
<li>周期性的检测是否有必要进行进程切换。</li>
</ul>

<p>
核心调度器（主调度器和周期性调度器）与其他两个组件（CPU和调度器类）的交互：
</p>
<ul class="org-ul">
<li><p>
调度类用于判断接下来运行哪个进程。内核支持不同的调度策略（完全公平调度、实时调度、在无事可做时调度空闲进程），调度类使得能够以模块化方法实现这些策略，即一个类的代码不需要与其他类的代码交互。
</p>

<p>
在调度器被调用时，它会查询调度器类，得知接下来运行哪个进程。
</p></li>

<li><p>
在选中将要运行的进程之后，必须执行底层任务切换。这需要与CPU的紧密交互。
</p>

<p>
每个进程都刚好属于某一调度类，各个调度类负责管理所属的进程。通用调度器自身完全不涉及进程管理，其工作都委托给调度器类。
</p></li>
</ul>
</div>

<div id="outline-container-orgd486666" class="outline-4">
<h4 id="orgd486666"><span class="section-number-4">1.2.1.</span> task_struct中的调度相关成员</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> {
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">prio</span>, <span style="color: #FD971F;">static_prio</span>, <span style="color: #FD971F;">normal_prio</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">run_list</span>;
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_class</span> *<span style="color: #FD971F;">sched_class</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> <span style="color: #FD971F;">se</span>;

        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">policy</span>;
        <span style="color: #66D9EF;">cpumask_t</span> <span style="color: #FD971F;">cpus_allowed</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">time_slice</span>;

};
</pre>
</div>
<ul class="org-ul">
<li><p>
prio 和 normal_prio 表示动态优先级，static_prio 表示进程的静态优先级。 静态优先级是进程启动时分配的优先级。它可以用 nice和 sched_setscheduler 系统调用修改，否则在进程运行期间会一直保持恒定。normal_priority 表示基于进程的静态优先级和调度策略计算出的优先级。因此，即使普通进程和实时进程具有相同的静态优先级，其普通优先级也是不同的。进程分支时，子进程会继承普通优先级。
</p>

<p>
但调度器考虑的优先级则保存在 prio 。由于在某些情况下内核需要暂时提高进程的优先级，因此需要prio来表示。
</p></li>

<li>rt_priority 表示实时进程的优先级。该值不会代替先前讨论的那些值！最低的实时优先级为0，而最高的优先级是99。值越大，表明优先级越高。这里使用的惯例不同于 nice 值。</li>

<li>sched_class 表示该进程所属的调度器类。</li>

<li><p>
调度器不限于调度进程，还可以处理更大的实体。这可以用于实现组调度：可用的CPU时间可以首先在一般的进程组（例如，所有进程可以按所有者分组）之间分配，接下来分配的时间在组内再次分配。
</p>

<p>
由于调度器是处理调度实体，所以在task_struct中嵌入 sched_entity 实例，以供调度器操作。
</p></li>

<li>policy 保存了对该进程应用的调度策略。Linux支持5个可能的值。

<ul class="org-ul">
<li>SCHED_NORMAL 用于普通进程，我们主要讲述此类进程。它们通过完全公平调度器来处理。</li>

<li>SCHED_BATCH 和 SCHED_IDLE 也通过完全公平调度器来处理，不过可用于次要的进程。SCHED_BATCH 用于非交互、CPU使用密集的批处理进程。</li>

<li>SCHED_RR 和 SCHED_FIFO 用于实现软实时进程。 SCHED_RR 实现了一种循环方法，而 SCHED_FIFO 则使用先进先出机制。这些不是由完全公平调度器类处理，而是由实时调度器类处理。</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #75715E;">&#21028;&#26029;&#32473;&#20986;&#30340;&#35843;&#24230;&#31574;&#30053;&#26159;&#21542;&#23646;&#20110;&#23454;&#26102;&#31867;&#12290;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">rt_policy</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">policy</span>)
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21028;&#26029;&#32473;&#23450;&#36827;&#31243;&#30340;&#35843;&#24230;&#31574;&#30053;&#26159;&#21542;&#23646;&#20110;&#23454;&#26102;&#31867;&#12290;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">task_has_rt_policy</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>)
</pre>
</div>
<ul class="org-ul">
<li>cpus_allowed 是一个位域，在多处理器系统上使用，用来限制进程可以在哪些CPU上运行。</li>

<li>run_list 和 time_slice 是循环实时调度器所需要的，但不用于完全公平调度器。 run_list是一个表头，用于维护包含各进程的一个运行表，而 time_slice 则指定进程可使用CPU的剩余时间段。</li>
</ul>

<p>
如果活动进程设置了 TIF_NEED_RESCHED 标识，则调度器会将CPU从该进程回收，并授予新的进程。
</p>
</div>
</div>


<div id="outline-container-org59949b7" class="outline-4">
<h4 id="org59949b7"><span class="section-number-4">1.2.2.</span> 调度器类</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
对于各个调度器类，都必须提供 struct sched_class 的实例，其结构如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_class</span> {
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_class</span> *<span style="color: #FD971F;">next</span>;

        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">enqueue_task</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">wakeup</span>);
        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">dequeue_task</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">sleep</span>);
        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">yield_task</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>);

        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">check_preempt_curr</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>);

        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> * (*<span style="color: #A6E22E;">pick_next_task</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>);
        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">put_prev_task</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>);

<span style="color: #F92672;">#ifdef</span> CONFIG_SMP
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> (*<span style="color: #A6E22E;">load_balance</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">this_rq</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">this_cpu</span>,
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">busiest</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">max_load_move</span>,
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_domain</span> *<span style="color: #FD971F;">sd</span>, <span style="color: #F92672;">enum</span> <span style="color: #66D9EF;">cpu_idle_type</span> <span style="color: #FD971F;">idle</span>,
                        <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">all_pinned</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">this_best_prio</span>);

        <span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">move_one_task</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">this_rq</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">this_cpu</span>,
                              <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">busiest</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_domain</span> *<span style="color: #FD971F;">sd</span>,
                              <span style="color: #F92672;">enum</span> <span style="color: #66D9EF;">cpu_idle_type</span> <span style="color: #FD971F;">idle</span>);
<span style="color: #F92672;">#endif</span>

        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">set_curr_task</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>);
        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">task_tick</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>);
        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">task_new</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>);
};
</pre>
</div>

<ul class="org-ul">
<li>enqueue_task 向就绪队列添加一个新进程。在进程从睡眠状态变为可运行状态时，即发生该操作。</li>

<li><p>
dequeue_task 提供逆向操作，将一个进程从就绪队列去除。事实上，在进程从可运行状态切换到不可运行状态时，就会发生该操作。
</p>

<p>
内核有可能因为其他理由将进程从就绪队列去除，比如，进程的优先级可能需要改变。
</p>

<p>
就绪队列（run queue）在完全公平调度器中的结构为红黑树。
</p></li>

<li>通过 sched_yiele 系统调用，进程可以放弃对处理器的控制权，内核会调用调度器的 yield_task。</li>

<li>check_preempt_curr， 用一个新唤醒的进程来抢占当前进程。例如，在用 wake_up_new_task 唤醒新进程时，会调用该函数。</li>

<li>pick_next_task 用于选择下一个将要运行的进程，而 put_prev_task 则在用另一个进程代替当前运行的进程之前调用。</li>

<li>在进程的调度策略发生变化时，需要调用 set_curr_task 。</li>

<li>task_tick 在每次激活周期性调度器时，由周期性调度器调用。</li>

<li>new_task 用于建立 fork 系统调用和调度器之间的关联。每次新进程建立后，则用 new_task 通知调度器。</li>
</ul>

<p>
标准函数 activate_task 和 deactivate_task 调用前述的入队和出队函数，提供进程在就绪队列的入队和离队功能。
</p>
</div>
</div>


<div id="outline-container-orgb1f24ad" class="outline-4">
<h4 id="orgb1f24ad"><span class="section-number-4">1.2.3.</span> 就绪队列</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
各个CPU都有自身的就绪队列。活动进程只会出现在一个就绪队列中。当进程注册到就绪队列时，嵌入的 se（sched_entry）结构的 on_rq 置为 1，否则为0。
</p>

<p>
就绪队列是全局调度器许多操作的起点。但要注意，进程并不是由就绪队列的成员直接管理的！这是各个调度器类的职责，因此在各个就绪队列中嵌入了特定于调度器类的子就绪队列。
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> {
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">runqueue lock:</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">spinlock_t</span> <span style="color: #FD971F;">lock</span>;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * nr_running and cpu_load should be in the same cacheline because</span>
<span style="color: #75715E;">         * remote CPUs use both these fields when doing load calculation.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">nr_running</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#23450;&#20102;&#38431;&#21015;&#19978;&#21487;&#36816;&#34892;&#36827;&#31243;&#30340;&#25968;&#30446;&#65292;&#19981;&#32771;&#34385;&#20854;&#20248;&#20808;&#32423;&#25110;&#35843;&#24230;&#31867;&#12290;</span>
<span style="color: #F92672;">        #define</span> <span style="color: #FD971F;">CPU_LOAD_IDX_MAX</span> 5
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">cpu_load</span>[CPU_LOAD_IDX_MAX]; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#36319;&#36394;&#27492;&#21069;&#30340;&#36127;&#33655;&#29366;&#24577;&#12290;</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#23601;&#32490;&#38431;&#21015;&#30340;&#24403;&#21069;&#36127;&#33655;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">load_weight</span> <span style="color: #FD971F;">load</span>;

        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> <span style="color: #FD971F;">cfs</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23436;&#20840;&#20844;&#24179;&#35843;&#24230;&#22120;&#30340;&#23376;&#23601;&#32490;&#38431;&#21015;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rt_rq</span> <span style="color: #FD971F;">rt</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23454;&#26102;&#35843;&#24230;&#22120;&#30340;&#23376;&#23601;&#32490;&#38431;&#21015;</span>

        <span style="color: #75715E;">//</span><span style="color: #75715E;">curr&#25351;&#21521;&#24403;&#21069;&#36827;&#31243;&#30340;task_struct&#23454;&#20363;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">idle&#25351;&#21521;idle&#36827;&#31243;&#30340;task_struct&#23454;&#20363;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">curr</span>, *<span style="color: #FD971F;">idle</span>;
        <span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;">         *  clock &#21644; prev_raw_clock &#29992;&#20110;&#23454;&#29616;&#23601;&#32490;&#38431;&#21015;&#33258;&#36523;&#30340;&#26102;&#38047;&#12290;&#27599;&#27425;&#35843;&#29992;&#21608;&#26399;&#24615;&#35843;&#24230;&#22120;&#26102;&#65292;&#37117;&#20250;&#26356;</span>
<span style="color: #E6DB74;">         *  &#26032; clock &#30340;&#20540;&#12290;&#21478;&#22806;&#20869;&#26680;&#36824;&#25552;&#20379;&#20102;&#26631;&#20934;&#20989;&#25968; update_rq_clock &#65292;&#21487;&#22312;&#25805;&#20316;&#23601;&#32490;&#38431;&#21015;&#30340;&#35843;&#24230;&#22120;&#20013;</span>
<span style="color: #E6DB74;">         *  &#22810;&#22788;&#35843;&#29992;&#65292;&#20363;&#22914;&#65292;&#22312;&#29992; wakeup_new_task &#21796;&#37266;&#26032;&#36827;&#31243;&#26102;&#12290;</span>
<span style="color: #E6DB74;">         */</span>
        <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">clock</span>, <span style="color: #FD971F;">prev_clock_raw</span>;

};
</pre>
</div>

<p>
<b>系统的所有就绪队列都在 runqueues 数组中，该数组的每个元素分别对应于系统中的一个CPU。</b>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #A6E22E;">DEFINE_PER_CPU_SHARED_ALIGNED</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span>, runqueues);

<span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20869;&#26680;&#36824;&#23450;&#20041;&#20102;&#19968;&#20123;&#20415;&#25463;&#30340;&#23439;</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">cpu_rq</span>(<span style="color: #FD971F;">cpu</span>)             (&amp;per_cpu(runqueues, (cpu)))
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">this_rq</span>()                 (&amp;__get_cpu_var(runqueues))
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">task_rq</span>(<span style="color: #FD971F;">p</span>)              cpu_rq(task_cpu(p))
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">cpu_curr</span>(<span style="color: #FD971F;">cpu</span>)           (cpu_rq(cpu)-&gt;curr)
</pre>
</div>
</div>
</div>


<div id="outline-container-org32eb4c7" class="outline-4">
<h4 id="org32eb4c7"><span class="section-number-4">1.2.4.</span> 调度实体</h4>
<div class="outline-text-4" id="text-1-2-4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> {
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">load &#25351;&#23450;&#20102;&#26435;&#37325;&#65292;&#20915;&#23450;&#20102;&#21508;&#20010;&#23454;&#20307;&#21344;&#38431;&#21015;&#24635;&#36127;&#33655;&#30340;&#27604;&#20363;&#12290;&#35745;&#31639;&#36127;&#33655;&#26435;&#37325;&#26159;&#35843;&#24230;&#22120;&#30340;&#19968;&#39033;&#37325;&#20219;&#65292;&#22240;&#20026;CFS&#25152;&#38656;&#30340;&#34394;&#25311;&#26102;&#38047;&#30340;&#36895;&#24230;&#26368;&#32456;&#20381;&#36182;&#20110;&#36127;&#33655;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">load_weight</span>      <span style="color: #FD971F;">load</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">run_node &#26159;&#26631;&#20934;&#30340;&#26641;&#32467;&#28857;&#65292;&#20351;&#24471;&#23454;&#20307;&#21487;&#20197;&#22312;&#32418;&#40657;&#26641;&#19978;&#25490;&#24207;&#12290;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span>          <span style="color: #FD971F;">run_node</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35813;&#23454;&#20307;&#24403;&#21069;&#26159;&#21542;&#22312;&#23601;&#32490;&#38431;&#21015;&#19978;&#25509;&#21463;&#35843;&#24230;</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>            <span style="color: #FD971F;">on_rq</span>;

        <span style="color: #66D9EF;">u64</span>                     <span style="color: #FD971F;">exec_start</span>;
        <span style="color: #66D9EF;">u64</span>                     <span style="color: #FD971F;">sum_exec_runtime</span>;
        <span style="color: #66D9EF;">u64</span>                     <span style="color: #FD971F;">vruntime</span>;
        <span style="color: #66D9EF;">u64</span>                     <span style="color: #FD971F;">prev_sum_exec_runtime</span>;
};
</pre>
</div>

<ul class="org-ul">
<li><p>
在进程运行时，我们需要记录消耗的CPU时间，以用于完全公平调度器。 sum_exec_runtime即用于该目的。跟踪运行时间是由 update_curr 不断累积完成的。调度器中许多地方都会调用该函数，例如，新进程加入就绪队列时，或者周期性调度器中。每次调用时，会计算当前时间和 exec_start 之间的差值， exec_start 则更新到当前时间。差值则被加到 sum_exec_runtime 。
</p>

<p>
在进程执行期间虚拟时钟上流逝的时间数量由 vruntime 统计。
</p></li>

<li>在进程被撤销CPU时，其当前 sum_exec_runtime 值保存到 prev_exec_runtime 。此后，在进程抢占时又需要该数据。但请注意，在 prev_exec_runtime 中保存 sum_exec_runtime 的值，并不意味着重置 sum_exec_runtime ！原值保存下来，而 sum_exec_runtime 则持续单调增长。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8deb195" class="outline-3">
<h3 id="org8deb195"><span class="section-number-3">1.3.</span> 处理优先级</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org9e090cd" class="outline-4">
<h4 id="org9e090cd"><span class="section-number-4">1.3.1.</span> 优先级的内核表示</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
在用户空间中可以通过 <b>nice</b> 命令设置进程的静态优先级，系统内部通过 <b>nice系统调用</b> 来实现。
</p>
<div class="org-src-container">
<pre class="src src-shell">nice --help
Usage: nice [OPTION] [COMMAND [ARG]...]
Run COMMAND with an adjusted niceness, which affects process scheduling.
With no COMMAND, print the current niceness.  Niceness values range from
<span style="color: #A6E22E;">-20</span> (most favorable to the process) to 19 (least favorable to the process)<span style="color: #F92672;">.</span>

Mandatory arguments to long options are mandatory for short options too.
  -n, --adjustment=N   add integer N to the niceness (default 10)
      --help     display this help and exit
      --version  output version information and exit
</pre>
</div>

<p>
<b>进程的nice值在 -20 和 +19 之间， 值越低表示优先级越高。</b>
</p>

<p>
内核中使用 0-139 来表示内部优先级。值越低优先级越高。 0-99 的优先级由实时进程使用。 nice值的 [-20,+19] 映射到 100-139 ，实时进程的优先级总是比普通进程更高。
</p>



<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAX_USER_RT_PRIO</span>                100
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#23454;&#26102;&#36827;&#31243;&#26368;&#22823;&#20248;&#20808;&#32423;</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAX_RT_PRIO</span>                     MAX_USER_RT_PRIO
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26222;&#36890;&#36827;&#31243;&#26368;&#23567;&#20248;&#20808;&#32423;</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAX_PRIO</span>                        (MAX_RT_PRIO + 40)
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">DEFAULT_PRIO</span>                    (MAX_RT_PRIO + 20)

<span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">NICE_TO_PRIO</span>(<span style="color: #FD971F;">nice</span>)              (MAX_RT_PRIO + (nice) + 20)
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">PRIO_TO_NICE</span>(<span style="color: #FD971F;">prio</span>)              ((prio) - MAX_RT_PRIO - 20)
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">TASK_NICE</span>(<span style="color: #FD971F;">p</span>)                    PRIO_TO_NICE((p)-&gt;static_prio)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1307e4c" class="outline-4">
<h4 id="org1307e4c"><span class="section-number-4">1.3.2.</span> 优先级计算</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
优先级的计算需要考虑进程的 <b>动态优先级（task_struct-&gt;prio）</b> 、 <b>普通优先级（task_struct-&gt;normal_prio）</b> 和 <b>静态优先级（task_struct-&gt;static_prio）</b> 。
</p>

<p>
计算进程的优先级： <code>p-&gt;prio = effective_prio(p);</code>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#36827;&#31243;&#24403;&#21069;&#30340;&#20248;&#20808;&#32423;</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">effective_prio</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>)
{

        p-&gt;normal_prio = normal_prio(p);
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * &#22914;&#26524;&#26159;&#23454;&#26102;&#36827;&#31243;&#65292;&#25110;&#32773;&#25552;&#21319;&#21040;&#20102;&#23454;&#26102;&#36827;&#31243;&#65292;&#20445;&#25345;&#20248;&#20808;&#32423;&#19981;&#21464;&#12290;</span>
<span style="color: #75715E;">         * &#21542;&#21017;&#65292;&#36820;&#22238;&#26222;&#36890;&#20248;&#20808;&#32423;&#12290;</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>rt_prio(p-&gt;prio)) <span style="color: #75715E;">//</span><span style="color: #75715E;">rt_prio &#26816;&#27979;&#26222;&#36890;&#20248;&#20808;&#32423;&#26159;&#21542;&#22312;&#23454;&#26102;&#33539;&#22260;&#20013;</span>
                <span style="color: #F92672;">return</span> p-&gt;normal_prio;
        <span style="color: #F92672;">return</span> p-&gt;prio;
}

<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">normal_prio</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">prio</span>;


        <span style="color: #F92672;">if</span> (task_has_rt_policy(p))<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#36827;&#31243;&#20855;&#26377;&#23454;&#26102;&#35843;&#24230;&#31574;&#30053;</span>
                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                rt_priority&#30340;&#20540;&#36234;&#39640;&#65292;&#21017;&#20248;&#20808;&#32423;&#36234;&#39640;&#65292;&#32780;&#20869;&#26680;&#20013;&#20540;&#36234;&#20302;&#65292;&#20248;&#20808;&#32423;&#36234;&#39640;&#12290;</span>
<span style="color: #75715E;">                &#25152;&#20197;&#22522;&#20110;&#20197;&#19979;&#31639;&#27861;&#26469;&#35745;&#31639;&#20248;&#20808;&#32423;</span>
<span style="color: #75715E;">                */</span>
                prio = MAX_RT_PRIO-1 - p-&gt;rt_priority;
        <span style="color: #F92672;">else</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">__normal_prio&#21482;&#36866;&#29992;&#26222;&#36890;&#36827;&#31243;&#65292;&#36820;&#22238;&#36827;&#31243;&#30340;&#38745;&#24577;&#20248;&#20808;&#32423;&#12290;</span>
                prio = __normal_prio(p);
        <span style="color: #F92672;">return</span> prio;
}
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> 不同类型进程的优先级计算</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">进程类型/优先级</th>
<th scope="col" class="org-left">static_prio</th>
<th scope="col" class="org-left">normal_prio</th>
<th scope="col" class="org-left">prio</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">非实时进程</td>
<td class="org-left">static_prio</td>
<td class="org-left">static_prio</td>
<td class="org-left">static_prio</td>
</tr>

<tr>
<td class="org-left">优先级提高的非实时进程</td>
<td class="org-left">static_prio</td>
<td class="org-left">static_prio</td>
<td class="org-left">prio不变</td>
</tr>

<tr>
<td class="org-left">实时进程</td>
<td class="org-left">static_prio</td>
<td class="org-left">MAX_RT_PRIO-1-rt_priority</td>
<td class="org-left">prio不变</td>
</tr>
</tbody>
</table>

<p>
新创建的进程通过wake_up_new_task唤醒时，或者通过 nice系统调用 改变静态优先级时，使用上述方法计算进程的 p-&gt;prio 。
</p>

<p>
进程创建子进程时，子进程动态优先级（task_struct-&gt;prio）设置为父进程的普通优先级。
</p>
</div>
</div>

<div id="outline-container-orgb58c709" class="outline-4">
<h4 id="orgb58c709"><span class="section-number-4">1.3.3.</span> 计算负荷权重</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
进程的重要性除了考虑优先级外，还需考虑 task_struct-&gt;se.load 的负荷权重。 set_load_weight 负责根据进程类型及其静态优先级计算负荷权重。
</p>

<p>
负荷权重包含在数据结构 load_weight 中：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">load_weight</span> {
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">weight</span>, <span style="color: #FD971F;">inv_weight</span>;
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * &#36827;&#31243;&#27599;&#38477;&#20302;&#19968;&#20010;nice&#20540;&#65292;&#22810;&#33719;&#21462;10%&#30340;cpu&#26102;&#38388;&#65292;&#27599;&#21319;&#39640;&#19968;&#20010;nice&#20540;&#65292;&#25918;&#24323;10%&#30340;&#26102;&#38388;</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * &#25968;&#32452;&#39033;&#20013;&#30340;&#27599;&#20010;&#20540;&#37117;&#23545;&#24212;&#36827;&#31243;&#30340;[0, 39]&#20013;&#27599;&#20010;nice&#32423;&#21035;&#65292;&#25968;&#32452;&#30456;&#37051;&#39033;&#20043;&#38388;&#30340;&#20056;&#25968;&#22240;&#23376;&#32422;&#31561;&#20110;1.25</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * &#20363;&#22914;A&#12289;B&#36827;&#31243;&#30340;nice&#20540;&#20026;0&#65292;&#30001;&#19979;&#34920;&#24471;&#30693;&#20854;&#26435;&#37325;&#20026;1024&#65292;A&#36827;&#31243;&#20248;&#20808;&#32423;&#21152;1&#65292;&#20854;&#26435;&#37325;&#20026;&#65288;1024/1.25=820&#65289;</span>
<span style="color: #75715E;"> * &#27492;&#26102; A&#36827;&#31243;&#30340;CPU&#20221;&#39069;&#20026;&#65288;820/(820+1024)=0.45&#65289;&#65292;B&#36827;&#31243;CPU&#20221;&#39069;&#20026;&#65288;1024/(820+1024)=0.55&#65289;&#65292;&#22914;&#27492;</span>
<span style="color: #75715E;"> * &#23601;&#20135;&#29983;&#20102; 10% &#30340;&#24046;&#20540;</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">prio_to_weight</span>[40] = {
 <span style="color: #75715E;">/* </span><span style="color: #75715E;">-20</span><span style="color: #75715E;"> */</span>     88761,     71755,     56483,     46273,     36291,
 <span style="color: #75715E;">/* </span><span style="color: #75715E;">-15</span><span style="color: #75715E;"> */</span>     29154,     23254,     18705,     14949,     11916,
 <span style="color: #75715E;">/* </span><span style="color: #75715E;">-10</span><span style="color: #75715E;"> */</span>      9548,      7620,      6100,      4904,      3906,
 <span style="color: #75715E;">/*  </span><span style="color: #75715E;">-5</span><span style="color: #75715E;"> */</span>      3121,      2501,      1991,      1586,      1277,
 <span style="color: #75715E;">/*   </span><span style="color: #75715E;">0</span><span style="color: #75715E;"> */</span>      1024,       820,       655,       526,       423,
 <span style="color: #75715E;">/*   </span><span style="color: #75715E;">5</span><span style="color: #75715E;"> */</span>       335,       272,       215,       172,       137,
 <span style="color: #75715E;">/*  </span><span style="color: #75715E;">10</span><span style="color: #75715E;"> */</span>       110,        87,        70,        56,        45,
 <span style="color: #75715E;">/*  </span><span style="color: #75715E;">15</span><span style="color: #75715E;"> */</span>        36,        29,        23,        18,        15,
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">set_load_weight</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>)
{
        <span style="color: #F92672;">if</span> (task_has_rt_policy(p)) {
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23454;&#26102;&#36827;&#31243;&#30340;&#26435;&#37325;&#26159;&#26222;&#36890;&#36827;&#31243;&#30340;&#20004;&#20493;</span>
                p-&gt;se.load.weight = prio_to_weight[0] * 2;
                p-&gt;se.load.inv_weight = prio_to_wmult[0] &gt;&gt; 1;
                <span style="color: #F92672;">return</span>;
        }

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * SCHED_IDLE &#36827;&#31243;&#30340;&#26435;&#37325;&#26368;&#23567;&#12290;</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (p-&gt;policy == SCHED_IDLE) {
                p-&gt;se.load.weight = WEIGHT_IDLEPRIO;
                p-&gt;se.load.inv_weight = WMULT_IDLEPRIO;
                <span style="color: #F92672;">return</span>;
        }

        p-&gt;se.load.weight = prio_to_weight[p-&gt;static_prio - MAX_RT_PRIO];
        p-&gt;se.load.inv_weight = prio_to_wmult[p-&gt;static_prio - MAX_RT_PRIO];
}

</pre>
</div>

<p>
就绪队列也关联了一个负荷权重，每次进程添加到就绪队列时，内核会调用 inc_nr_running，以确保就绪队列能够跟踪记录多少进程在运行，并将进程的权重添加到就绪队列权重中。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">update_load_add</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">load_weight</span> *<span style="color: #FD971F;">lw</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">inc</span>)
{
        lw-&gt;weight += inc;
}
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">inc_load</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>)
{
        update_load_add(&amp;rq-&gt;load, p-&gt;se.load.weight);
}

<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">inc_nr_running</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>)
{
        rq-&gt;nr_running++;
        inc_load(rq, p);
}
</pre>
</div>

<p>
进程从就绪队列移除时，会调用对应的函数，dec_nr_running、dec_load、update_load_sub。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org9825306" class="outline-2">
<h2 id="org9825306"><span class="section-number-2">2.</span> 核心调度器</h2>
<div class="outline-text-2" id="text-2">
<p>
如前所述，调度器的实现基于两个函数：周期性调度器函数和主调度器函数。这些函数根据现有进程的优先级分配CPU时间。
</p>
</div>

<div id="outline-container-orgbdcc0f5" class="outline-3">
<h3 id="orgbdcc0f5"><span class="section-number-3">2.1.</span> 周期性调度器</h3>
<div class="outline-text-3" id="text-2-1">
<p>
周期性调度器由 scheduler_tick 函数实现，内核按照频率HZ自动调用该函数。
</p>

<p>
scheduler_tick主要任务：
</p>
<ol class="org-ol">
<li>管理内核中与整个系统和各个进程的调度相关的统计量。</li>
<li>激活负责当前进程的调度类的周期性调度方法。</li>
</ol>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * &#35813;&#20989;&#25968;&#34987;&#23450;&#26102;&#22120;&#25353;&#29031;&#39057;&#29575;HZ&#36827;&#34892;&#35843;&#29992;&#65292;&#35843;&#29992;&#26102;&#20851;&#38381;&#20013;&#26029;&#12290;</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * &#24403;fork&#23376;&#36827;&#31243;&#26102;&#65292;&#20462;&#25913;&#29238;&#36827;&#31243;&#26102;&#38388;&#29255;&#26102;&#20063;&#20250;&#35843;&#29992;&#12290;</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">scheduler_tick</span>(<span style="color: #66D9EF;">void</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cpu</span> = smp_processor_id();
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span> = cpu_rq(cpu);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">curr</span> = rq-&gt;curr;
        <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">next_tick</span> = rq-&gt;tick_timestamp + TICK_NSEC;

        spin_lock(&amp;rq-&gt;lock);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;&#23601;&#32490;&#38431;&#21015;&#26102;&#38047;&#30340;&#26356;&#26032;&#65292;&#21363;&#22686;&#21152;srtuct rq&#30340;&#24403;&#21069;&#23454;&#20363;&#30340;&#26102;&#38047;&#26102;&#38388;&#25139;</span>
        __update_rq_clock(rq);
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * Let rq-&gt;clock advance by at least TICK_NSEC:</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (unlikely(rq-&gt;clock &lt; next_tick))
                rq-&gt;clock = next_tick;
        rq-&gt;tick_timestamp = rq-&gt;clock;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#23601;&#32490;&#38431;&#21015;&#30340;cpu_load[]&#25968;&#32452;&#12290;</span>
        update_cpu_load(rq);
        <span style="color: #F92672;">if</span> (curr != rq-&gt;idle)
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#29305;&#23450;&#35843;&#24230;&#22120;&#31867;&#30340;&#26041;&#27861;</span>
                curr-&gt;sched_class-&gt;task_tick(rq, curr);
        spin_unlock(&amp;rq-&gt;lock);

<span style="color: #F92672;">#ifdef</span> CONFIG_SMP
        rq-&gt;idle_at_tick = idle_cpu(cpu);
        trigger_load_balance(rq, cpu);
<span style="color: #F92672;">#endif</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1766f97" class="outline-3">
<h3 id="org1766f97"><span class="section-number-3">2.2.</span> 主调度器</h3>
<div class="outline-text-3" id="text-2-2">
<p>
在内核中的许多地方，如果要将CPU分配给另一个进程，都会直接调用主调度器函数（ schedule ）。在从系统调用返回之后，内核也会检查当前进程是否设置了重调度标志（TIF_NEED_RESCHED）。如果设置，则内核会调用 schedule 。
</p>

<p>
注意：  <b>__sched 前缀用于可能调用 schedule 的函数</b> ，包括 schedule 自身，使用__sched前缀后，相关函数的代码编译之后，会放到目标文件的一个特定的段中（.sched.text）。该信息使得内核在显示栈转储或类似信息时，忽略所有与调度有关的调用。由于调度器函数调用不是普通代码流程的一部分，因此在这种情况下是没有意义的。
</p>


<p>
声明方式如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">__sched</span> some_function(...) {
...
schedule();
...
}
</pre>
</div>

<p>
该函数首先确定当前就绪队列，并在 prev 中保存一个
指向（仍然）活动进程的 task_struct 的指针。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * schedule() is the main scheduler function.</span>
<span style="color: #75715E;"> */</span>
asmlinkage <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">__sched</span> schedule(<span style="color: #66D9EF;">void</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">prev</span>, *<span style="color: #FD971F;">next</span>;
        <span style="color: #66D9EF;">long</span> *<span style="color: #FD971F;">switch_count</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cpu</span>;

<span style="color: #AE81FF;">need_resched</span>:
        preempt_disable();
        cpu = smp_processor_id();
        rq = cpu_rq(cpu);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30830;&#23450;&#24403;&#21069;&#23601;&#32490;&#38431;&#21015;</span>
        rcu_qsctr_inc(cpu);
        prev = rq-&gt;curr; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#21521;&#24403;&#21069;&#27963;&#21160;&#36827;&#31243;</span>
        switch_count = &amp;prev-&gt;nivcsw;

        release_kernel_lock(prev);
<span style="color: #AE81FF;">need_resched_nonpreemptible</span>:

        schedule_debug(prev);

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * Do the rq-clock update outside the rq lock:</span>
<span style="color: #75715E;">         */</span>
        local_irq_disable();
        __update_rq_clock(rq); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#23601;&#32490;&#38431;&#21015;&#26102;&#38047;</span>
        spin_lock(&amp;rq-&gt;lock);
        clear_tsk_need_resched(prev);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28165;&#38500;&#37325;&#26032;&#35843;&#24230;&#26631;&#24535; TIF_NEED_RESCHED</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#24403;&#21069;&#36827;&#31243;&#21407;&#20808;&#22788;&#20110;&#21487;&#32456;&#31471;&#30561;&#30496;&#29366;&#24577;</span>
        <span style="color: #F92672;">if</span> (prev-&gt;state &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>(preempt_count() &amp; PREEMPT_ACTIVE)) {
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#25910;&#21040;&#20102;&#20449;&#21495;&#65292;&#20877;&#27425;&#25552;&#21319;&#20026;&#36816;&#34892;&#36827;&#31243;&#12290;</span>
                <span style="color: #F92672;">if</span> (unlikely((prev-&gt;state &amp; TASK_INTERRUPTIBLE) &amp;&amp;
                                unlikely(signal_pending(prev)))) {
                        prev-&gt;state = TASK_RUNNING;
                } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21542;&#21017;&#20351;&#36827;&#31243;&#20572;&#27490;&#27963;&#21160;&#12290;</span>
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#23545;&#24212;&#35843;&#24230;&#22120;&#30340; sched_class-&gt;dequeue_task &#26041;&#27861;</span>
                        deactivate_task(rq, prev, 1);
                }
                switch_count = &amp;prev-&gt;nvcsw;
        }

        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>rq-&gt;nr_running))
                idle_balance(cpu, rq);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#30693;&#35843;&#24230;&#22120;&#65292;&#24403;&#21069;&#36827;&#31243;&#23558;&#34987;&#21478;&#19968;&#20010;&#36827;&#31243;&#26367;&#20195;&#65288;&#19981;&#31561;&#20215;&#20110;&#23558;&#36827;&#31243;&#20174;&#23601;&#32490;&#38431;&#21015;&#31227;&#38500;&#65289;</span>
        prev-&gt;sched_class-&gt;put_prev_task(rq, prev);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36873;&#25321;&#19979;&#19968;&#20010;&#25191;&#34892;&#36827;&#31243;</span>
        next = pick_next_task(rq, prev);

        sched_info_switch(prev, next);

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36873;&#25321;&#20102;&#26032;&#36827;&#31243;</span>
        <span style="color: #F92672;">if</span> (likely(prev != next)) {
                rq-&gt;nr_switches++;
                rq-&gt;curr = next;
                ++*switch_count;

                context_switch(rq, prev, next); <span style="color: #75715E;">/* </span><span style="color: #75715E;">unlocks the rq</span><span style="color: #75715E;"> */</span>
        } <span style="color: #F92672;">else</span><span style="color: #75715E;">//</span><span style="color: #75715E;">&#26377;&#21487;&#33021;&#20854;&#20182;&#36827;&#31243;&#37117;&#22312;&#30561;&#30496;&#65292;&#24403;&#21069;&#36827;&#31243;&#34987;&#30041;&#22312;CPU</span>
                spin_unlock_irq(&amp;rq-&gt;lock);

        <span style="color: #F92672;">if</span> (unlikely(reacquire_kernel_lock(current) &lt; 0)) {
                cpu = smp_processor_id();
                rq = cpu_rq(cpu);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">need_resched_nonpreemptible</span>;
        }
        preempt_enable_no_resched();
        <span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;">         * &#27880;&#24847;&#65292;&#20197;&#19979;&#20195;&#30721;&#29255;&#27573;&#21487;&#33021;&#22312;&#20004;&#20010;&#19981;&#21516;&#30340;&#19978;&#19979;&#25991;&#20013;&#25191;&#34892;&#12290;</span>
<span style="color: #E6DB74;">         * &#22312;&#27809;&#26377;&#25191;&#34892;&#19978;&#19979;&#25991;&#20999;&#25442;&#26102;&#65292;&#23427;&#22312;schedule &#20989;&#25968;&#30340;&#26411;&#23614;&#30452;&#25509;&#25191;&#34892;&#12290;</span>
<span style="color: #E6DB74;">         * &#20294;&#22914;&#26524;&#24050;&#32463;&#25191;&#34892;&#20102;&#19978;&#19979;&#25991;&#20999;&#25442;&#65292;&#24403;&#21069;&#36827;&#31243;&#20250;&#27491;&#22909;&#22312;&#36825;&#20197;&#21069;&#20572;&#27490;&#36816;&#34892;&#65292;&#26032;&#36827;&#31243;&#24050;&#32463;&#25509;&#31649;&#20102;CPU&#12290;</span>
<span style="color: #E6DB74;">         * &#20294;&#31245;&#21518;&#22312;&#21069;&#19968;&#36827;&#31243;&#34987;&#20877;&#27425;&#36873;&#25321;&#36816;&#34892;&#26102;&#65292;&#23427;&#20250;&#21018;&#22909;&#22312;&#36825;&#19968;&#28857;&#19978;&#24674;&#22797;&#25191;&#34892;&#12290;&#22312;&#36825;&#31181;&#24773;&#20917;&#19979;&#65292;</span>
<span style="color: #E6DB74;">         * &#30001;&#20110; prev &#19981;&#20250;&#25351;&#21521;&#27491;&#30830;&#30340;&#36827;&#31243;&#65292;&#25152;&#20197;&#38656;&#35201;&#36890;&#36807;test_thread_flag &#25214;&#21040;&#24403;&#21069;&#32447;&#31243;&#65292;</span>
<span style="color: #E6DB74;">         * test_thread_flag&#20511;&#21161;</span><span style="color: #AE81FF;">current_thread_info()</span><span style="color: #E6DB74;">&#25214;&#21040;&#24403;&#21069;&#36827;&#31243;&#12290;</span>
<span style="color: #E6DB74;">         **/</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#24403;&#21069;&#36827;&#31243;&#30340;&#37325;&#35843;&#24230;&#20301;&#35774;&#32622;&#65292;&#36339;&#36716;&#21040;need_resched&#65292;&#37325;&#26032;&#24320;&#22987;&#25628;&#32034;&#19968;&#20010;&#26032;&#36827;&#31243;</span>
        <span style="color: #F92672;">if</span> (unlikely(test_thread_flag(TIF_NEED_RESCHED)))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">need_resched</span>;

}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd9a398" class="outline-3">
<h3 id="orgbd9a398"><span class="section-number-3">2.3.</span> 与fork交互</h3>
<div class="outline-text-3" id="text-2-3">
<p>
当使用 fork 系统调用或其变体之一创建新进程时，调度器用 sched_fork 函数挂钩到该进程。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #75715E;">fork()/clone()&#26102;&#30340;&#35774;&#32622;</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">sched_fork</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">clone_flags</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cpu</span> = get_cpu();
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#26032;&#36827;&#31243;&#35843;&#24230;&#30456;&#20851;&#30340;&#23383;&#27573;</span>
        __sched_fork(p);

<span style="color: #F92672;">#ifdef</span> CONFIG_SMP
        cpu = sched_balance_self(cpu, SD_BALANCE_FORK);
<span style="color: #F92672;">#endif</span>
        set_task_cpu(p, cpu);

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30830;&#20445;&#27809;&#26377;&#23558;&#25552;&#39640;&#30340;&#20248;&#20808;&#32423;&#20256;&#36882;&#21040;&#23376;&#36827;&#31243;</span>
        p-&gt;prio = current-&gt;normal_prio; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20351;&#29992;&#29238;&#36827;&#31243;&#30340;&#26222;&#36890;&#20248;&#20808;&#32423;&#20316;&#20026;&#23376;&#36827;&#31243;&#30340;&#21160;&#24577;&#20248;&#20808;&#32423;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>rt_prio(p-&gt;prio))
                p-&gt;sched_class = &amp;fair_sched_class;

<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span>(CONFIG_SCHEDSTATS) || <span style="color: #F92672;">defined</span>(CONFIG_TASK_DELAY_ACCT)
        <span style="color: #F92672;">if</span> (likely(sched_info_on()))
                memset(&amp;p-&gt;sched_info, 0, <span style="color: #F92672;">sizeof</span>(p-&gt;sched_info));
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span>(CONFIG_SMP) &amp;&amp; <span style="color: #F92672;">defined</span>(__ARCH_WANT_UNLOCKED_CTXSW)
        p-&gt;oncpu = 0;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_PREEMPT
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Want to start with kernel preemption disabled.</span><span style="color: #75715E;"> */</span>
        task_thread_info(p)-&gt;preempt_count = 1;
<span style="color: #F92672;">#endif</span>
        put_cpu();
}
</pre>
</div>

<p>
<b>在使用 wake_up_new_task 唤醒新进程时，内核会调用调度类的 task_new 函数，将新进程加入到相应类的就绪队列中。</b>
</p>
</div>
</div>

<div id="outline-container-org5490997" class="outline-3">
<h3 id="org5490997"><span class="section-number-3">2.4.</span> 上下文切换</h3>
<div class="outline-text-3" id="text-2-4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #75715E;">&#20999;&#25442;&#21040;&#26032;&#36827;&#31243;&#30340;&#20869;&#23384;&#31649;&#29702;&#19978;&#19979;&#25991;&#21644;&#23492;&#23384;&#22120;&#29366;&#24577;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span>
<span style="color: #A6E22E;">context_switch</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">prev</span>,
               <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">next</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mm_struct</span> *<span style="color: #FD971F;">mm</span>, *<span style="color: #FD971F;">oldmm</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27599;&#20010;&#20307;&#31995;&#32467;&#26500;&#37117;&#20250;&#23450;&#20041;prepare_task_switch&#20989;&#25968;&#65292;&#35813;&#20989;&#25968;&#20026;&#20999;&#25442;&#20570;&#21069;&#26399;&#39044;&#22791;&#24037;&#20316;</span>
        <span style="color: #A6E22E;">prepare_task_switch</span>(<span style="color: #66D9EF;">rq</span>, prev, next);
        mm = next-&gt;mm;
        oldmm = prev-&gt;active_mm;

        <span style="color: #A6E22E;">arch_enter_lazy_cpu_mode</span>();

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20869;&#26680;&#32447;&#31243;&#27809;&#26377;&#33258;&#36523;&#30340;&#29992;&#25143;&#31354;&#38388;&#20869;&#23384;&#19978;&#19979;&#25991;(mm==NULL)&#65292;&#21487;&#33021;&#22312;&#26576;&#20010;&#38543;&#26426;&#36827;&#31243;&#22320;&#22336;&#31354;&#38388;&#30340;&#19978;&#37096;&#25191;&#34892;&#12290;</span>
        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>mm)) {
                next-&gt;active_mm = oldmm; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20511;&#29992;&#24403;&#21069;&#36827;&#31243;&#30340;&#22320;&#22336;&#31354;&#38388;&#65292;&#20445;&#23384;&#22312;active_mm&#20013;&#12290;</span>
                atomic_inc(&amp;oldmm-&gt;mm_count);
                enter_lazy_tlb(oldmm, next); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#30693;&#24213;&#23618;&#20307;&#31995;&#32467;&#26500;&#19981;&#38656;&#35201;&#20999;&#25442;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#30340;&#29992;&#25143;&#31354;&#38388;&#37096;&#20998;</span>
        } <span style="color: #F92672;">else</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#25442;&#20869;&#23384;&#31649;&#29702;&#19978;&#19979;&#25991;&#65292;&#20363;&#22914;&#21152;&#36733;&#39029;&#34920;&#65292;&#21047;&#20986;&#37096;&#20998;&#25110;&#20840;&#37096;TLB......</span>
                switch_mm(oldmm, mm, next);

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#21069;&#19968;&#36827;&#31243;&#26159;&#20869;&#26680;&#32447;&#31243;(prev-&gt;mm&#20026;NULL)&#65292;&#21017;&#20854;active_mm&#25351;&#38024;&#24517;&#39035;&#37325;&#32622;&#20026;NULL &#65292;&#26029;&#24320;&#19982;&#20511;&#29992;&#30340;&#22320;&#22336;&#31354;&#38388;&#30340;&#32852;&#31995;</span>
        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>prev-&gt;mm)) {
                prev-&gt;active_mm = <span style="color: #AE81FF;">NULL</span>;
                rq-&gt;prev_mm = oldmm;
        }
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * Since the runqueue lock will be released by the next</span>
<span style="color: #75715E;">         * task (which is an invalid locking op but in the case</span>
<span style="color: #75715E;">         * of the scheduler it's an obvious special-case), so we</span>
<span style="color: #75715E;">         * do an early lockdep release here:</span>
<span style="color: #75715E;">         */</span>
<span style="color: #F92672;">#if</span><span style="color: #F92672; font-weight: bold;">n</span><span style="color: #F92672;">def</span> __ARCH_WANT_UNLOCKED_CTXSW
        spin_release(&amp;rq-&gt;lock.dep_map, 1, _THIS_IP_);
<span style="color: #F92672;">#endif</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20999;&#25442;&#22788;&#29702;&#22120;&#23492;&#23384;&#22120;&#20869;&#23481;&#21644;&#20869;&#26680;&#26632;&#65292;&#26032;&#36827;&#31243;&#22312;&#35813;&#35843;&#29992;&#21518;&#24320;&#22987;&#25191;&#34892;</span><span style="color: #75715E;"> */</span>
        <span style="color: #A6E22E;">switch_to</span>(prev, next, prev);

        <span style="color: #E6DB74;">/** switch_to &#20043;&#21518;&#30340;&#20195;&#30721;&#21482;&#26377;&#22312;&#24403;&#21069;&#36827;&#31243;&#19979;&#19968;&#27425;&#34987;&#36873;&#25321;&#36816;&#34892;&#26102;&#25165;&#20250;&#25191;&#34892;&#12290;**/</span>

        <span style="color: #75715E;">//</span><span style="color: #75715E;">barrier &#35821;&#21477;&#26159;&#19968;&#20010;&#32534;&#35793;&#22120;&#25351;&#20196;&#65292;&#30830;&#20445; switch_to &#21644; finish_task_switch &#35821;&#21477;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30340;&#25191;&#34892;&#39034;&#24207;&#19981;&#20250;&#22240;&#20026;&#20219;&#20309;&#21487;&#33021;&#30340;&#20248;&#21270;&#32780;&#25913;&#21464;&#12290;</span>
        <span style="color: #A6E22E;">barrier</span>();
        <span style="color: #75715E;">//</span><span style="color: #75715E;">this_rq&#24517;&#39035;&#37325;&#26032;&#35745;&#31639;&#65292;&#22240;&#20026;&#22312;&#35843;&#29992;schedule()&#20043;&#21518;prev&#21487;&#33021;&#24050;&#32463;&#31227;&#21160;&#21040;&#20854;&#20182;CPU&#65292;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22240;&#27492;&#20854;&#26632;&#24103;&#19978;&#30340;rq&#21487;&#33021;&#26159;&#26080;&#25928;&#30340;&#12290;</span>
        <span style="color: #A6E22E;">finish_task_switch</span>(<span style="color: #66D9EF;">this_rq</span>(), prev);
}

</pre>
</div>

<ul class="org-ul">
<li><b>switch_to</b></li>
</ul>

<p>
finish_task_switch函数执行时，调度过程可能选择了另一个新进程，finish_task_switch是针对此前的活动进程。注意，这不是发起上下文切换的那个进程，而是系统中随机的某个其他进程！内核必须想办法使得该进程能够与 context_switch 例程通信，这可以通过 switch_to 宏实现。
</p>

<p>
每个体系结构都必须实现switch_to，switch_to 通过3个参数传递两个变量，如下图所示：
<img src="image/process/switch-to.png" alt="switch-to.png" />
</p>

<p>
当再次调度到A时，需要让A进程知道上次运行的进程是C。
为了让A进程知道是从C进程切换过来的，使用switch_to宏，可以理解为switch_to是带有两个参数的宏，返回一个指向此前运行进程的指针。本质上等于： prev = switch_to(prev, next);
</p>
</div>
</div>
</div>


<div id="outline-container-org0e1cf2c" class="outline-2">
<h2 id="org0e1cf2c"><span class="section-number-2">3.</span> 完全公平调度类</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #F92672;">static</span> <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_class</span> <span style="color: #FD971F;">fair_sched_class</span> = {
        .next                   = &amp;idle_sched_class,
        .enqueue_task           = enqueue_task_fair,
        .dequeue_task           = dequeue_task_fair,
        .yield_task             = yield_task_fair,

        .check_preempt_curr     = check_preempt_wakeup,

        .pick_next_task         = pick_next_task_fair,
        .put_prev_task          = put_prev_task_fair,

<span style="color: #F92672;">#ifdef</span> CONFIG_SMP
        .load_balance           = load_balance_fair,
        .move_one_task          = move_one_task_fair,
<span style="color: #F92672;">#endif</span>

        .set_curr_task          = set_curr_task_fair,
        .task_tick          = task_tick_fair,
        .task_new               = task_new_fair,
};
</pre>
</div>
</div>

<div id="outline-container-org91f2986" class="outline-3">
<h3 id="org91f2986"><span class="section-number-3">3.1.</span> CFS的就绪队列</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">load_weight</span> <span style="color: #FD971F;">load</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">load &#32500;&#25252;&#20102;&#38431;&#21015;&#25152;&#26377;&#36827;&#31243;&#30340;&#32047;&#31215;&#36127;&#33655;&#20540;</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">nr_running</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">nr_running &#35745;&#31639;&#20102;&#38431;&#21015;&#19978;&#21487;&#36816;&#34892;&#36827;&#31243;&#30340;&#25968;&#30446;</span>

        <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">exec_clock</span>;
        <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">min_vruntime</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36319;&#36394;&#35760;&#24405;&#38431;&#21015;&#19978;&#25152;&#26377;&#36827;&#31243;&#30340;&#26368;&#23567;&#34394;&#25311;&#36816;&#34892;&#26102;&#38388;</span>

        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_root</span> <span style="color: #FD971F;">tasks_timeline</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#22312;&#25353;&#26102;&#38388;&#25490;&#24207;&#30340;&#32418;&#40657;&#26641;&#20013;&#31649;&#29702;&#25152;&#26377;&#36827;&#31243;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span> *<span style="color: #FD971F;">rb_leftmost</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#21521;&#32418;&#40657;&#26641;&#26368;&#24038;&#36793;&#30340;&#32467;&#28857;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span> *<span style="color: #FD971F;">rb_load_balance_curr</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">'curr' points to currently running entity on this cfs_rq.</span>
<span style="color: #75715E;">         * It is set to NULL otherwise (i.e when none are currently running).</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">curr</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;&#25191;&#34892;&#36827;&#31243;&#30340;&#21487;&#35843;&#24230;&#23454;&#20307;</span>

        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">nr_spread_over</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orge74757e" class="outline-3">
<h3 id="orge74757e"><span class="section-number-3">3.2.</span> CFS操作</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org2e0afd7" class="outline-4">
<h4 id="org2e0afd7"><span class="section-number-4">3.2.1.</span> 虚拟时钟</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
完全公平调度算法依赖于虚拟时钟，虚拟时钟用以度量等待进程在完全公平系统中所能得到的CPU时间。
</p>

<p>
虚拟时钟可以根据现存的实际时钟和与每个进程相关的负荷权重推算出来。所有与虚拟时钟有关的计算都在 update_curr中执行，该函数在系统中各个不同地方调用，包括周期性调度器之内。
</p>
<div class="org-src-container">
<pre class="src src-fundamental">update_curr
        __update_curr
                &#26356;&#26032;&#36827;&#31243;&#30340;&#29289;&#29702;&#36816;&#34892;&#26102;&#38388;&#21644;&#34394;&#25311;&#36816;&#34892;&#26102;&#38388;
                &#23545;CFS&#38431;&#21015;&#26356;&#26032;min_vruntime
        &#35774;&#32622;rq-&gt;exec_start
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">update_curr</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">curr</span> = cfs_rq-&gt;curr; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#23601;&#32490;&#38431;&#21015;&#30340;&#24403;&#21069;&#25191;&#34892;&#36827;&#31243;</span>
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">          rq_of &#26159;&#19968;&#20010;&#36741;&#21161;&#20989;&#25968;&#65292;&#29992;&#20110;&#30830;&#23450;&#19982;CFS&#23601;&#32490;&#38431;&#21015;&#30456;&#20851;&#30340; struct rq &#23454;&#20363;</span>
<span style="color: #75715E;">          &#27492;&#22788;&#33719;&#21462;&#20027;&#35843;&#24230;&#22120;&#23601;&#32490;&#38431;&#21015;&#30340;&#23454;&#38469;&#26102;&#38047;&#20540;&#65292;&#35813;&#20540;&#22312;&#27599;&#20010;&#35843;&#24230;&#21608;&#26399;&#37117;&#20250;&#26356;&#26032;</span>
<span style="color: #75715E;">        */</span>
        <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">now</span> = rq_of(cfs_rq)-&gt;clock;  <span style="color: #75715E;">//</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delta_exec</span>;

        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>curr))
                <span style="color: #F92672;">return</span>;

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#36827;&#31243;&#24403;&#21069;&#21644;&#19978;&#27425;&#26356;&#26032;&#36127;&#33655;&#32479;&#35745;&#37327;&#26102;&#30340;&#26102;&#38388;&#24046;&#12290;</span>
        delta_exec = (<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>)(now - curr-&gt;exec_start);

        __update_curr(cfs_rq, curr, delta_exec);
        curr-&gt;exec_start = now;

        <span style="color: #F92672;">if</span> (entity_is_task(curr)) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">curtask</span> = task_of(curr);

                cpuacct_charge(curtask, delta_exec);
        }
}

<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span>
<span style="color: #A6E22E;">__update_curr</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">curr</span>,
              <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delta_exec</span>)
{
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delta_exec_weighted</span>;
        <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">vruntime</span>;

        schedstat_set(curr-&gt;exec_max, max((<span style="color: #66D9EF;">u64</span>)delta_exec, curr-&gt;exec_max));
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#36827;&#31243;&#30340;&#29289;&#29702;&#36816;&#34892;&#26102;&#38388;</span>
        curr-&gt;sum_exec_runtime += delta_exec;
        schedstat_add(cfs_rq, exec_clock, delta_exec);
        delta_exec_weighted = delta_exec;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">NICE 0&#32423;&#21035;&#30340;&#36827;&#31243;&#65292;&#34394;&#25311;&#26102;&#38388;&#21644;&#29289;&#29702;&#26102;&#38388;&#30456;&#31561;&#12290;</span>
        <span style="color: #F92672;">if</span> (unlikely(curr-&gt;load.weight != NICE_0_LOAD)) {
                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                 * &#20854;&#20182;&#20248;&#20808;&#32423;&#26102;&#65292;&#38656;&#35201;&#26681;&#25454;&#36827;&#31243;&#30340;&#31526;&#21512;&#26435;&#37325;&#37325;&#26032;&#34913;&#23450;&#26102;&#38388;</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 * calc_delta_fair &#23454;&#38469;&#25191;&#34892;&#30340;&#35745;&#31639;&#20844;&#24335;&#22914;&#19979;&#65306;</span>
<span style="color: #75715E;">                 *      delta_exec_weighted = delta x (NICE_0_LOAD/curr-&gt;load.weight)</span>
<span style="color: #75715E;">                 */</span>
                delta_exec_weighted = calc_delta_fair(delta_exec_weighted,
                                                        &amp;curr-&gt;load);
        }
        curr-&gt;vruntime += delta_exec_weighted; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#36827;&#31243;&#30340;&#34394;&#25311;&#26102;&#38388;</span>

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * &#36319;&#36394;&#26641;&#20013;&#26368;&#24038;&#36793;&#30340;&#32467;&#28857;&#30340;vruntime&#65292;&#32500;&#25252;cfs_rq-&gt;min_vruntime&#30340;&#21333;&#35843;&#36882;&#22686;</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         * first_fair&#26816;&#27979;&#26641;&#26159;&#21542;&#26377;&#26368;&#24038;&#20391;&#32467;&#28857;&#65288;&#26159;&#21542;&#26377;&#36827;&#31243;&#22312;&#26641;&#19978;&#31561;&#24453;&#35843;&#24230;&#65289;&#12290;</span>
<span style="color: #75715E;">         *   1. &#22914;&#26524;&#26377;&#65292;&#21462;&#26368;&#24038;&#20391;&#36827;&#31243;&#30340;vruntime&#65288;&#26641;&#20013;&#32467;&#28857;&#30340;&#26368;&#23567;vruntime&#65289;&#12290;</span>
<span style="color: #75715E;">         *   2. &#27809;&#26377;&#65292;&#21462;&#24403;&#21069;&#36827;&#31243;&#30340;vruntime&#12290;</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (first_fair(cfs_rq)) {
                vruntime = min_vruntime(curr-&gt;vruntime,
                                __pick_next_entity(cfs_rq)-&gt;vruntime);
        } <span style="color: #F92672;">else</span>
                vruntime = curr-&gt;vruntime;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * &#20026;&#20445;&#35777;min_vruntime&#26159;&#21333;&#35843;&#36882;&#22686;&#65292;&#21462;&#38431;&#21015;&#30340;min_vruntime&#21644; vruntime&#30340;&#36739;&#22823;&#20540;&#65292;</span>
<span style="color: #75715E;">         * &#22240;&#27492;&#65292;&#21482;&#26377;&#24403;&#26641;&#20013;&#30340;&#26576;&#20010;&#32467;&#28857;&#30340;vruntime&#36229;&#36807;&#38431;&#21015;&#30340; min_vruntime &#26102;&#25165;&#26356;&#26032;&#12290;</span>
<span style="color: #75715E;">         */</span>
        cfs_rq-&gt;min_vruntime =
                max_vruntime(cfs_rq-&gt;min_vruntime, vruntime);
}
</pre>
</div>

<p>
<b>完全公平调度器中，就绪队列红黑树的排序依据的键值使用 <code>entity_key</code> 函数来计算：</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">s64</span> <span style="color: #A6E22E;">entity_key</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">se</span>)
{
        <span style="color: #F92672;">return</span> se-&gt;vruntime - cfs_rq-&gt;min_vruntime;
}
</pre>
</div>

<p>
键值较小的结点，排序位置就更靠左，因此会被更快地调度。
</p>

<ul class="org-ul">
<li>在进程运行时，其 vruntime 稳定地增加，它在红黑树中总是向右移动的。
因为越重要的进程 vruntime 增加越慢，因此它们向右移动的速度也越慢，这样其被调度的机会要大于次要进程，这刚好是我们需要的。</li>

<li>如果进程进入睡眠，则其 vruntime 保持不变。但是每个队列 min_vruntime 会增加，那么睡眠进程醒来后，在红黑树中的位置会更靠左，因为其键值变得更小了。</li>
</ul>
</div>
</div>

<div id="outline-container-org356bd2d" class="outline-4">
<h4 id="org356bd2d"><span class="section-number-4">3.2.2.</span> 延迟跟踪</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
延迟跟踪：保证每个可运行的进程在某个时间间隔内至少运行一次。
</p>

<p>
延迟跟踪的两个配置参数：
</p>
<ul class="org-ul">
<li><b>sysctl_sched_latency</b> : 延迟周期，可通过/proc/sys/kernel/sched_latency_ns 配置，默认值为20 000 000纳秒或20毫秒。</li>
<li><b>sched_nr_latency</b> : 一个延迟周期中处理最大活动进程数目，可通过/proc/sys/kernel/sched_min_granularity_ns配置。如果活动进程的数目超出该上限，则延迟周期也成比例地线性扩展。默认值是4 000 000纳秒，即4毫秒。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org5f998c1" class="outline-3">
<h3 id="org5f998c1"><span class="section-number-3">3.3.</span> 队列操作</h3>
<div class="outline-text-3" id="text-3-3">
<p>
完全公平调度器中， enqueue_task_fair 和 dequeue_task_fair 用来增删就绪队列的成员。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">// </span><span style="color: #75715E;">wakeup &#20195;&#34920;&#36827;&#31243;&#26159;&#21542;&#21018;&#34987;&#21796;&#37266;&#24182;&#36716;&#20026;&#36816;&#34892;&#29366;&#24577;</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">enqueue_task_fair</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">wakeup</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">se</span> = &amp;p-&gt;se;

        for_each_sched_entity(se) {
                <span style="color: #F92672;">if</span> (se-&gt;on_rq) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24050;&#32463;&#22312;&#23601;&#32490;&#38431;&#21015;</span>
                        <span style="color: #F92672;">break</span>;
                cfs_rq = cfs_rq_of(se);
                enqueue_entity(cfs_rq, se, wakeup);
                wakeup = 1;
        }
}
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span>
<span style="color: #A6E22E;">enqueue_entity</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">se</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">wakeup</span>)
{
        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#26356;&#26032;&#24403;&#21069;&#36827;&#31243;&#30340;&#36816;&#34892;&#26102;&#38388;&#32479;&#35745;&#37327;</span>
        update_curr(cfs_rq);

        <span style="color: #F92672;">if</span> (wakeup) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36827;&#31243;&#27492;&#21069;&#22312;&#30561;&#30496;</span>
                place_entity(cfs_rq, se, 0);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#25972;&#36827;&#31243;&#30340;&#34394;&#25311;&#36816;&#34892;&#26102;&#38388;</span>
                enqueue_sleeper(cfs_rq, se);
        }

        update_stats_enqueue(cfs_rq, se);
        check_spread(cfs_rq, se);
        <span style="color: #F92672;">if</span> (se != cfs_rq-&gt;curr)
                __enqueue_entity(cfs_rq, se); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#36827;&#31243;&#28155;&#21152;&#21040;&#32418;&#40657;&#26641;&#20013;</span>
        account_entity_enqueue(cfs_rq, se);
}

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;">initial &#20026;1&#20195;&#34920;&#26032;&#36827;&#31243;&#34987;&#21152;&#21040;&#31995;&#32479;&#20013;&#65292;&#21542;&#21017;&#20026;0</span>
<span style="color: #E6DB74;">**/</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span>
<span style="color: #A6E22E;">place_entity</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">se</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">initial</span>)
{
        <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">vruntime</span>;

        vruntime = cfs_rq-&gt;min_vruntime;

        <span style="color: #F92672;">if</span> (sched_feat(TREE_AVG)) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">last</span> = __pick_last_entity(cfs_rq);
                <span style="color: #F92672;">if</span> (last) {
                        vruntime += last-&gt;vruntime;
                        vruntime &gt;&gt;= 1;
                }
        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (sched_feat(APPROX_AVG) &amp;&amp; cfs_rq-&gt;nr_running)
                vruntime += sched_vslice(cfs_rq)/2;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#26032;&#21019;&#24314;&#30340;&#23376;&#36827;&#31243;&#65292;&#21017;&#30830;&#23450;&#22120;&#22312;&#24310;&#36831;&#21608;&#26399;&#20013;&#25152;&#21344;&#30340;&#20221;&#39069;&#12290;</span>
        <span style="color: #F92672;">if</span> (initial &amp;&amp; sched_feat(START_DEBIT))
                vruntime += sched_vslice_add(cfs_rq, se);

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>initial) {
                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                 * &#20869;&#26680;&#24050;&#32463;&#25215;&#35834;&#22312;&#24403;&#21069;&#30340;&#24310;&#36831;&#21608;&#26399;&#20869;&#20351;&#25152;&#26377;&#27963;&#21160;&#36827;&#31243;&#37117;&#33267;&#23569;&#36816;&#34892;&#19968;&#27425;&#65292;</span>
<span style="color: #75715E;">                 * &#20351;&#29992;&#38431;&#21015;&#30340; min_vruntime &#20316;&#20026;&#22522;&#20934;&#34394;&#25311;&#26102;&#38388;&#65292;&#20943;&#21435; sysctl_sched_latency&#65292;</span>
<span style="color: #75715E;">                 * &#21017;&#21487;&#20197;&#30830;&#20445;&#26032;&#21796;&#37266;&#30340;&#36827;&#31243;&#21482;&#26377;&#22312;&#24403;&#21069;&#24310;&#36831;&#21608;&#26399;&#32467;&#26463;&#21518;&#25165;&#33021;&#36816;&#34892;&#12290;</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #F92672;">if</span> (sched_feat(NEW_FAIR_SLEEPERS) &amp;&amp; entity_is_task(se))
                        vruntime -= sysctl_sched_latency;

                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                 * &#22914;&#26524;&#36827;&#31243;&#32047;&#35745;&#20102;&#36739;&#22823;&#19981;&#20844;&#24179;&#20540;&#65288;&#36827;&#31243;&#30340;se-&gt;vruntime&#36739;&#22823;&#65289;&#65292;</span>
<span style="color: #75715E;">                 * &#21017;&#23558;&#20854;&#20316;&#20026;&#36827;&#31243;&#30340; vruntime&#65292;&#22914;&#27492;&#65292;&#36827;&#31243;&#22312;&#32418;&#40657;&#26641;&#30340;&#20301;&#32622;&#26356;&#38752;&#24038;&#65288;&#36739;&#22823;&#30340;</span>
<span style="color: #75715E;">                 * vruntime&#20540;&#30340;&#36827;&#31243;&#21487;&#20197;&#26356;&#26089;&#30340;&#35843;&#24230;&#25191;&#34892;&#65289;</span>
<span style="color: #75715E;">                 */</span>
                vruntime = max_vruntime(se-&gt;vruntime, vruntime);
        }
        se-&gt;vruntime = vruntime;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org313f10b" class="outline-3">
<h3 id="org313f10b"><span class="section-number-3">3.4.</span> 选择下一个进程</h3>
<div class="outline-text-3" id="text-3-4">
<p>
pick_next_task_fair 函数选择下一个要运行的进程：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #A6E22E;">pick_next_task_fair</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span> = &amp;rq-&gt;cfs;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">se</span>;

        <span style="color: #75715E;">// </span><span style="color: #75715E;">nr_running&#35745;&#25968;&#22120;&#20026;0&#65292;&#21363;&#24403;&#21069;&#38431;&#21015;&#19978;&#27809;&#26377;&#21487;&#36816;&#34892;&#36827;&#31243;&#12290;</span>
        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>cfs_rq-&gt;nr_running))
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;

        <span style="color: #F92672;">do</span> {
                se = pick_next_entity(cfs_rq);
                cfs_rq = group_cfs_rq(se);
        } <span style="color: #F92672;">while</span> (cfs_rq);

        <span style="color: #F92672;">return</span> task_of(se);
}

<span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #A6E22E;">pick_next_entity</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">se</span> = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #F92672;">if</span> (first_fair(cfs_rq)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">first_fair &#36820;&#22238;&#38431;&#21015;&#20013;&#26368;&#24038;&#36793;&#36827;&#31243;</span>
                se = __pick_next_entity(cfs_rq); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#26368;&#24038;&#20391;&#36827;&#31243;&#30340;&#35843;&#24230;&#23454;&#20307;&#32467;&#26500;</span>
                set_next_entity(cfs_rq, se); <span style="color: #75715E;">//</span>
        }

        <span style="color: #F92672;">return</span> se;
}



<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span>
<span style="color: #A6E22E;">set_next_entity</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">se</span>)
{
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">se&#26159;&#21542;&#22312;&#35843;&#24230;&#38431;&#21015;&#19978;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (se-&gt;on_rq) {
                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                 * &#20219;&#20309;&#36827;&#31243;&#37117;&#24517;&#39035;&#20808;&#20837;&#38431;&#21040;&#23601;&#32490;&#38431;&#21015;&#65292;&#25165;&#33021;&#22312;CPU&#25191;&#34892;&#12290;</span>
<span style="color: #75715E;">                 * &#25152;&#20197;&#38656;&#35201;&#26356;&#26032;&#20854;&#22312;&#23601;&#32490;&#38431;&#21015;&#33457;&#36153;&#30340;&#26102;&#38388;</span>
<span style="color: #75715E;">                 */</span>
                update_stats_wait_end(cfs_rq, se);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#23454;&#20363;&#20174;&#26641;&#20013;&#31227;&#38500;</span>
                __dequeue_entity(cfs_rq, se);
        }

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36873;&#25321;&#26032;&#36827;&#31243;&#25191;&#34892;&#65292;&#38656;&#35201;&#26356;&#26032;&#20854;&#32479;&#35745;&#37327;</span>
        update_stats_curr_start(cfs_rq, se);
        cfs_rq-&gt;curr = se;
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * &#24403;&#21069;&#36827;&#31243;&#20026;&#27963;&#21160;&#36827;&#31243;&#65292;&#20854;&#33457;&#36153;&#30340;CPU&#26102;&#38388;&#20250;&#35760;&#24405;&#22312; sum_exec_runtime&#65292;</span>
<span style="color: #75715E;">         * &#25152;&#20197;&#39318;&#20808;&#23558; sum_exec_runtime&#20445;&#23384;&#21040;prev_sum_exec_runtime&#12290;</span>
<span style="color: #75715E;">         * sum_exec_runtime - prev_sum_exec_runtime &#21363;&#34920;&#31034;&#36827;&#31243;&#22312;CPU&#19978;&#25191;&#34892;&#30340;&#26102;&#38388;&#12290;</span>
<span style="color: #75715E;">         */</span>
        se-&gt;prev_sum_exec_runtime = se-&gt;sum_exec_runtime;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf282f7c" class="outline-3">
<h3 id="orgf282f7c"><span class="section-number-3">3.5.</span> 处理周期性调度器</h3>
<div class="outline-text-3" id="text-3-5">
<p>
周期性调度的工作由 task_tisk_fair 负责，实际工作由 entity_tick 完成。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">entity_tick</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">curr</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#32479;&#35745;&#37327;</span>
        update_curr(cfs_rq);
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * &#22914;&#26524;&#23601;&#32490;&#38431;&#21015;&#36827;&#31243;&#21482;&#26377;1&#20010;&#65292;&#21017;&#20160;&#20040;&#37117;&#19981;&#20570;&#12290;</span>
<span style="color: #75715E;">         * &#21542;&#21017;&#65292;&#26816;&#26597;&#26159;&#21542;&#26377;&#36827;&#31243;&#36827;&#34892;&#25250;&#21344;</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (cfs_rq-&gt;nr_running &gt; 1 || <span style="color: #E6DB74; font-weight: bold;">!</span>sched_feat(WAKEUP_PREEMPT))
                check_preempt_tick(cfs_rq, curr);
}

<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#38656;&#35201;&#65292;&#20351;&#29992;&#26032;&#21796;&#37266;&#30340;&#36827;&#31243;&#25250;&#21344;&#24403;&#21069;&#36827;&#31243;</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span>
<span style="color: #A6E22E;">check_preempt_tick</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">curr</span>)
{
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">ideal_runtime</span>, <span style="color: #FD971F;">delta_exec</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#35813;&#36827;&#31243;&#22312;&#24310;&#36831;&#21608;&#26399;&#20013;&#30830;&#23450;&#30340;&#26102;&#38388;&#20221;&#39069;</span>
        ideal_runtime = sched_slice(cfs_rq, curr);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;&#36827;&#31243;&#22312;cpu&#36816;&#34892;&#30340;&#26102;&#38388;</span>
        delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#24403;&#21069;&#36827;&#31243;&#36816;&#34892;&#30340;&#26102;&#38388;&#27604;&#26399;&#26395;&#26102;&#38388;&#38271;&#65292;&#21017;&#21457;&#36215;&#37325;&#26032;&#35843;&#24230;&#35831;&#27714;&#12290;</span>
        <span style="color: #F92672;">if</span> (delta_exec &gt; ideal_runtime)
                <span style="color: #75715E;">//</span><span style="color: #75715E;">resched_task&#20250;&#35774;&#32622;TIF_NEED_RESCHED&#26631;&#24535;&#65292;&#26680;&#24515;&#35843;&#24230;&#22120;&#20250;&#22312;&#19979;&#19968;&#20010;&#36866;&#24403;&#26102;&#26426;&#21457;&#36215;&#37325;&#35843;&#24230;&#12290;</span>
                resched_task(rq_of(cfs_rq)-&gt;curr);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge79cecf" class="outline-3">
<h3 id="orge79cecf"><span class="section-number-3">3.6.</span> 唤醒抢占</h3>
<div class="outline-text-3" id="text-3-6">
<p>
当使用 try_to_wake_up 和 wake_up_new_task 中唤醒进程时，内核使用check_preempt_curr检查是否有新进程可以抢占当前运行的进程，对于完全公平调度器，是使用 check_preempt_wakeup 函数。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">check_preempt_curr</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>)
{
        rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p);
}
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#38656;&#35201;&#65292;&#20351;&#29992;&#26032;&#21796;&#37266;&#30340;&#36827;&#31243;&#25250;&#21344;&#24403;&#21069;&#36827;&#31243;</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">check_preempt_wakeup</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">curr</span> = rq-&gt;curr;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span> = task_cfs_rq(curr);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">se</span> = &amp;curr-&gt;se, *<span style="color: #FD971F;">pse</span> = &amp;p-&gt;se;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">gran</span>;

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26032;&#36827;&#31243;&#26159;&#23454;&#26102;&#36827;&#31243;&#65292;&#31435;&#21363;&#35831;&#27714;&#37325;&#26032;&#35843;&#24230;&#65292;&#23454;&#26102;&#36827;&#31243;&#24635;&#26159;&#20250;&#25250;&#21344;CFS&#36827;&#31243;</span>
        <span style="color: #F92672;">if</span> (unlikely(rt_prio(p-&gt;prio))) {
                update_rq_clock(rq);
                update_curr(cfs_rq);
                resched_task(curr);
                <span style="color: #F92672;">return</span>;
        }

        <span style="color: #75715E;">// </span><span style="color: #75715E;">Batch&#36827;&#31243;&#19981;&#20250;&#25250;&#21344;&#20854;&#20182;&#36827;&#31243;</span>
        <span style="color: #F92672;">if</span> (unlikely(p-&gt;policy == SCHED_BATCH))
                <span style="color: #F92672;">return</span>;

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sched_feat(WAKEUP_PREEMPT))
                <span style="color: #F92672;">return</span>;

        <span style="color: #F92672;">while</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>is_same_group(se, pse)) {
                se = parent_entity(se);
                pse = parent_entity(pse);
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26032;&#36827;&#31243;&#25250;&#21344;&#24403;&#21069;&#36827;&#31243;&#26102;&#65292;&#30830;&#20445;&#24403;&#21069;&#36827;&#31243;&#33267;&#23569;&#36816;&#34892;&#26576;&#19968;&#20010;&#26368;&#23567;&#26102;&#38388;&#20221;&#39069;&#65292;&#35813;&#20540;&#20445;&#23384;&#22312;sysctl_sched_wakeup_granularity</span>
        gran = sysctl_sched_wakeup_granularity;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">NICE_0_LOAD&#30340;&#36827;&#31243;&#65292;&#34394;&#25311;&#26102;&#38388;&#21644;&#29289;&#29702;&#26102;&#38388;&#30456;&#31561;</span>
        <span style="color: #F92672;">if</span> (unlikely(se-&gt;load.weight != NICE_0_LOAD))
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;nice 0&#31867;&#22411;&#30340;&#36827;&#31243;&#65292;&#38656;&#35201;&#35745;&#31639;&#22120;&#34394;&#25311;&#26102;&#38388;</span>
                gran = calc_delta_fair(gran, &amp;se-&gt;load);
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * &#22914;&#26524;&#26032;&#36827;&#31243;&#30340;&#34394;&#25311;&#36816;&#34892;&#26102;&#38388;&#21152;&#19978;&#26368;&#23567;&#26102;&#38388;&#20221;&#39069;&#65292;&#20173;&#23567;&#20110;&#24403;&#21069;&#36827;&#31243;&#30340;&#34394;&#25311;&#36816;&#34892;&#26102;&#38388;&#65292;</span>
<span style="color: #75715E;">         * &#21017;&#35831;&#27714;&#37325;&#26032;&#35843;&#24230;&#12290; &#36825;&#21487;&#20197;&#30830;&#20445;&#36827;&#31243;&#19981;&#33267;&#20110;&#20999;&#25442;&#30340;&#22826;&#39057;&#32321;&#65292;&#36991;&#20813;&#22826;&#22810;&#26102;&#38388;&#33457;&#36153;&#22312;&#19978;&#19979;&#25991;&#20999;&#25442;&#19978;&#12290;</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (pse-&gt;vruntime + gran &lt; se-&gt;vruntime)
                <span style="color: #A6E22E;">resched_task</span>(curr);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga3faad0" class="outline-3">
<h3 id="orga3faad0"><span class="section-number-3">3.7.</span> 处理新进程</h3>
<div class="outline-text-3" id="text-3-7">
<p>
完全公平调度器在创建新进程时调用的挂钩函数： task_new_fair ，该函数的行为可使用参数 sysctl_sched_child_runs_first 控制，用于判断新建子进程是否应该在父进程之前运行。该参数的默认设置是1，设置为1通常是有益处的，尤其是子进程随后执行exec系统调用的情况。该参数可以通过 /proc/sys/kernel/sched_child_runs_first 修改。
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * Share the fairness runtime between parent and child, thus the</span>
<span style="color: #75715E;"> * total amount of pressure for CPU stays equal - new tasks</span>
<span style="color: #75715E;"> * get a chance to run but frequent forkers are not allowed to</span>
<span style="color: #75715E;"> * monopolize the CPU. Note: the parent runqueue is locked,</span>
<span style="color: #75715E;"> * the child is not running yet.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">task_new_fair</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span> = task_cfs_rq(p);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">se</span> = &amp;p-&gt;se, *<span style="color: #FD971F;">curr</span> = cfs_rq-&gt;curr;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">this_cpu</span> = smp_processor_id();

        <span style="color: #A6E22E;">sched_info_queued</span>(p);

        <span style="color: #A6E22E;">update_curr</span>(<span style="color: #66D9EF;">cfs_rq</span>);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#32479;&#35745;&#37327;</span>
        <span style="color: #A6E22E;">place_entity</span>(<span style="color: #66D9EF;">cfs_rq</span>, se, 1);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#27492;&#26102;&#31532;&#19977;&#20010;&#21442;&#25968;&#35774;&#32622;&#20026;1&#65292;&#34920;&#31034;&#26032;&#21019;&#24314;&#36827;&#31243;</span>

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#23376;&#36827;&#31243;&#23646;&#20110;&#19981;&#21516;&#30340;&#35843;&#24230;&#32452;&#65292;&#21017;curr&#20026;NULL&#12290;</span>
        <span style="color: #F92672;">if</span> (sysctl_sched_child_runs_first &amp;&amp; this_cpu == task_cpu(p) &amp;&amp;
                        curr &amp;&amp; curr-&gt;vruntime &lt; se-&gt;vruntime) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#29238;&#36827;&#31243;&#30340;vruntime&#23567;&#20110;&#23376;&#36827;&#31243;&#65292;&#21017;&#29238;&#36827;&#31243;&#22312;&#23376;&#36827;&#31243;&#20043;&#21069;&#36816;&#34892;&#12290;</span>
                swap(curr-&gt;vruntime, se-&gt;vruntime);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#38656;&#35201;&#20132;&#25442;&#29238;&#23376;&#36827;&#31243;&#30340;vruntime</span>
        }

        <span style="color: #A6E22E;">enqueue_task_fair</span>(<span style="color: #66D9EF;">rq</span>, p, 0);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23376;&#36827;&#31243;&#21152;&#20837;&#23601;&#32490;&#38431;&#21015;</span>
        <span style="color: #A6E22E;">resched_task</span>(rq-&gt;curr); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36215;&#37325;&#26032;&#35843;&#24230;</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6b0b17e" class="outline-2">
<h2 id="org6b0b17e"><span class="section-number-2">4.</span> 实时调度类</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li><b>实时进程与普通进程有一个根本的不同之处：如果系统中有一个实时进程且可运行，那么调度器总是会选中它运行，除非有另一个优先级更高的实时进程。</b></li>
</ul>

<p>
有两种实时类：
</p>

<ul class="org-ul">
<li>循环进程（ SCHED_RR ）有时间片，其值在进程运行时会减少，在所有的时间段都到期后，则该值重置为初始值，而进程则置于队列的末尾。这确保了在有几个优先级相同的 SCHED_RR 进程的情况下，它们总是依次执行。</li>

<li>先进先出进程（ SCHED_FIFO ）没有时间片，在被调度器选择执行后，可以运行任意长时间。如果实时进程编写得比较差，系统可能变得无法使用。只要写一个无限循环，循环体内不进入睡眠即可。</li>
</ul>
</div>

<div id="outline-container-orgfff1a71" class="outline-3">
<h3 id="orgfff1a71"><span class="section-number-3">4.1.</span> 数据结构</h3>
<div class="outline-text-3" id="text-4-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_class</span> <span style="color: #FD971F;">rt_sched_class</span> = {
        .next                   = &amp;fair_sched_class,
        .enqueue_task           = enqueue_task_rt,
        .dequeue_task           = dequeue_task_rt,
        .yield_task             = yield_task_rt,

        .check_preempt_curr     = check_preempt_curr_rt,

        .pick_next_task         = pick_next_task_rt,
        .put_prev_task          = put_prev_task_rt,

<span style="color: #F92672;">#ifdef</span> CONFIG_SMP
        .load_balance           = load_balance_rt,
        .move_one_task          = move_one_task_rt,
<span style="color: #F92672;">#endif</span>

        .set_curr_task          = set_curr_task_rt,
        .task_tick              = task_tick_rt,
};

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> {
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26680;&#24515;&#35843;&#24230;&#22120;&#30340;&#23601;&#32490;&#38431;&#21015;&#21253;&#21547;&#20102;&#23454;&#26102;&#36827;&#31243;&#30340;&#23376;&#23601;&#32490;&#38431;&#21015;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rt_rq</span> <span style="color: #FD971F;">rt</span>;
};
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rt_rq</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rt_prio_array</span> <span style="color: #FD971F;">active</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">rt_load_balance_idx</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">rt_load_balance_head</span>, *<span style="color: #FD971F;">rt_load_balance_curr</span>;
};
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#23454;&#26102;&#35843;&#24230;&#31867;&#30340;&#20248;&#20808;&#32423;&#38431;&#21015;&#25968;&#25454;&#32467;&#26500;</span>
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#30456;&#21516;&#20248;&#20808;&#32423;&#30340;&#25152;&#26377;&#23454;&#26102;&#36827;&#31243;&#20445;&#23384;&#22312;&#19968;&#20010;&#38142;&#34920;&#65292;&#34920;&#22836;&#20026; queue[prio]&#12290;</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rt_prio_array</span> {
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27599;&#20010;&#27604;&#29305;&#20301;&#23545;&#24212;&#19968;&#20010;&#38142;&#34920;&#65292;&#22914;&#26524;&#38142;&#34920;&#21253;&#21547;&#36827;&#31243;&#65292;&#21017;&#27604;&#29305;&#20301;&#32622;&#20301;</span>
        <span style="color: #A6E22E;">DECLARE_BITMAP</span>(bitmap, MAX_RT_PRIO+1); <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22810;&#19968;&#20010;&#27604;&#29305;&#20301;&#65292;&#29992;&#20110;&#38388;&#38548;&#31526;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">queue</span>[MAX_RT_PRIO];
};
</pre>
</div>


<p>
实时调度器类中更新统计量使用 update_curr_rt ，该函数将当前进程在CPU上执行花费的时间记录在 sum_exec_runtime。实时调度类中使用实际时间，不需要虚拟时间。
</p>
</div>
</div>

<div id="outline-container-orgf2df279" class="outline-3">
<h3 id="orgf2df279"><span class="section-number-3">4.2.</span> 调度器操作</h3>
<div class="outline-text-3" id="text-4-2">
<p>
进程的入队和离队操作，只需以 p-&gt;prio 为索引访问 queue 数组 queue[p-&gt;prio] ，即可获得正确的链表，将进程加入链表或从链表删除即可。如果队列中至少有一个进程，则将位图中对应的比特位置位；如果队列中没有进程，则清除位图中对应的比特位。请注意，新进程总是排列在每个链表的末尾。
</p>

<p>
<b>pick_next_task_rt</b> 函数选择下一个进程。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #A6E22E;">pick_next_task_rt</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rt_prio_array</span> *<span style="color: #FD971F;">array</span> = &amp;rq-&gt;rt.active;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">next</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">queue</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">idx</span>;
        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#25214;&#21040;active-&gt;bitmap&#20013;&#31532;&#19968;&#20010;&#32622;&#20301;&#30340;&#27604;&#29305;&#20301;&#65292;&#23454;&#26102;&#20248;&#20808;&#32423;&#39640;&#23545;&#24212;&#30340;&#20869;&#26680;&#20248;&#20808;&#32423;&#30340;&#20302;&#20540;&#65292;&#25152;&#20197;&#20248;&#20808;&#32423;&#39640;&#30340;&#36827;&#31243;&#20250;&#20248;&#20808;&#22788;&#29702;&#12290;</span>
        idx = sched_find_first_bit(array-&gt;bitmap);
        <span style="color: #F92672;">if</span> (idx &gt;= MAX_RT_PRIO)
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;

        queue = array-&gt;queue + idx;
        next = list_entry(queue-&gt;next, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span>, run_list);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#36873;&#25321;&#30340;&#36827;&#31243;&#30340;&#25191;&#34892;&#26102;&#38388;&#35774;&#32622;&#20026;&#23601;&#32490;&#38431;&#21015;&#30340;&#24403;&#21069;&#26102;&#38047;&#20540;&#12290;</span>
        next-&gt;se.exec_start = rq-&gt;clock;
        <span style="color: #F92672;">return</span> next;
}
</pre>
</div>

<p>
<b>周期调度器</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">task_tick_rt</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>)
{
        <span style="color: #A6E22E;">update_curr_rt</span>(<span style="color: #66D9EF;">rq</span>);
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * &#24490;&#29615;&#36827;&#31243;&#38656;&#35201;&#29305;&#27530;&#24418;&#24335;&#30340;&#26102;&#38388;&#29255;&#31649;&#29702;</span>
<span style="color: #75715E;">         * &#20808;&#36827;&#20808;&#20986;&#36827;&#31243;&#27809;&#26377;&#26102;&#38388;&#29255;</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (p-&gt;policy != SCHED_RR)
                <span style="color: #F92672;">return</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24490;&#29615;&#36827;&#31243;&#26410;&#36229;&#20986;&#26102;&#38388;&#29255;&#65292;&#30452;&#25509;&#36820;&#22238;</span>
        <span style="color: #F92672;">if</span> (--p-&gt;time_slice)
                <span style="color: #F92672;">return</span>;

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26102;&#38388;&#29255;&#29992;&#23436;&#65292;&#37325;&#26032;&#21021;&#22987;&#21270;&#20026;DEF_TIMESLICE&#65292;&#21363;100 * HZ / 1000 &#65292;100&#27627;&#31186;&#12290;</span>
        p-&gt;time_slice = DEF_TIMESLICE;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35813;&#36827;&#31243;&#19981;&#26159;&#38142;&#34920;&#20013;&#30340;&#21807;&#19968;&#36827;&#31243;&#65292;&#21017;&#25490;&#38431;&#21040;&#26411;&#23614;&#12290;</span>
        <span style="color: #F92672;">if</span> (p-&gt;run_list.prev != p-&gt;run_list.next) {
                requeue_task_rt(rq, p);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;TIF_NEED_RESCHED&#65292;&#35831;&#27714;&#37325;&#26032;&#35843;&#24230;</span>
                set_tsk_need_resched(p);
        }
}
</pre>
</div>

<p>
为将进程转换为实时进程，必须使用 sched_setscheduler 系统调用，该函数执行了下列简单任务：
</p>
<ul class="org-ul">
<li>使用 deactivate_task 将进程从当前队列移除。</li>
<li>在 task_struct 中设置实时优先级和调度类。</li>
<li>重新激活进程。</li>
</ul>

<p>
如果进程此前不在任何就绪队列上，那么只需要设置调度类和新的优先级数值。停止进程活动和重激活则是不必要的。
</p>

<p>
注意：只有具有root权限（或等价于 CAP_SYS_NICE ）的进程执行了 sched_setscheduler 系统调用，才能修改调度器类或优先级。否则只能遵循一下规则：
</p>
<ul class="org-ul">
<li>调度类只能从 SCHED_NORMAL 改为 SCHED_BATCH ，或反过来。改为 SCHED_FIFO 是不可能的。</li>
<li>只有目标进程的UID或EUID与调用者进程的EUID相同时，才能修改目标进程的优先级。此外，优先级只能降低，不能提升。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org72c62a9" class="outline-2">
<h2 id="org72c62a9"><span class="section-number-2">5.</span> 调度器增强</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org668caf1" class="outline-3">
<h3 id="org668caf1"><span class="section-number-3">5.1.</span> SMP调度</h3>
<div class="outline-text-3" id="text-5-1">
<p>
多处理器系统上，内核必须考虑几个额外的问题，以确保良好的调度。
</p>
<ul class="org-ul">
<li>CPU负荷必须尽可能公平地在所有的处理器上共享。如果一个处理器负责3个并发的应用程序，而另一个只能处理空闲进程，那是没有意义的。</li>
<li>进程与系统中某些处理器的亲合性（affinity）必须是可设置的。例如在4个CPU系统中，可以将计算密集型应用程序绑定到前3个CPU，而剩余的（交互式）进程则在第4个CPU上运行。</li>
<li>内核必须能够将进程从一个CPU迁移到另一个。但该选项必须谨慎使用，因为它会严重危害性能。在小型SMP系统上CPU高速缓存是最大的问题。对于真正大型系统，CPU与迁移进程此前使用的物理内存距离可能有若干米，因此对该进程内存的访问代价高昂。</li>
</ul>

<p>
进程对特定CPU的亲合性，定义在task_struct的cpus_allowed成员中。Linux提供了sched_setaffinity 系统调用，可修改进程与CPU的现有分配关系。
</p>
</div>

<div id="outline-container-org2f3189d" class="outline-4">
<h4 id="org2f3189d"><span class="section-number-4">5.1.1.</span> 数据结构扩展</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
在SMP系统上，每个调度器类的调度方法必须增加两个额外的函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_class</span> {
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> (*<span style="color: #A6E22E;">load_balance</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">this_rq</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">this_cpu</span>,
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">busiest</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">max_load_move</span>,
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_domain</span> *<span style="color: #FD971F;">sd</span>, <span style="color: #F92672;">enum</span> <span style="color: #66D9EF;">cpu_idle_type</span> <span style="color: #FD971F;">idle</span>,
                        <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">all_pinned</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">this_best_prio</span>);

        <span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">move_one_task</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">this_rq</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">this_cpu</span>,
                              <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">busiest</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_domain</span> *<span style="color: #FD971F;">sd</span>,
                              <span style="color: #F92672;">enum</span> <span style="color: #66D9EF;">cpu_idle_type</span> <span style="color: #FD971F;">idle</span>);
</pre>
</div>

<p>
load_balance 并不直接负责处理负载均衡。每当内核认为有必要重新均衡时，核心调度器代码都会调用这些函数。特定于调度器类的函数接下来建立一个迭代器，使得核心调度器能够遍历所有可能迁移到另一个队列的备选进程，但各个调度器类的内部结构不能因为迭代器而暴露给核心调度器。
</p>

<p>
load_balance 函数指针采用了一般性的函数 load_balance ，而 move_one_task 则使用了 iter_move_one_task 。
</p>
<ul class="org-ul">
<li>iter_move_one_task 从最忙碌的就绪队列移出一个进程，迁移到当前CPU的就绪队列。</li>
<li>load_balance 则允许从最忙的就绪队列分配多个进程到当前CPU，但移动的负荷不能比max_load_move 更多。</li>
</ul>

<p>
<b>负载均衡处理过程是如何发起的？</b>
</p>

<p>
在SMP系统上，周期性调度器函数 scheduler_tick 按上文所述完成所有系统都需要的任务之后，会调用 trigger_load_balance 函数。这会引发 SCHEDULE_SOFTIRQ 软中断softIRQ，该中断确保会在适当的时机执行 run_rebalance_domains 。该函数最终对当前CPU调用 rebalance_domains ，实现负载均衡。时序如下图：
<img src="image/process/smp-loadbalance.png" alt="smp-loadbalance.png" />
</p>

<p>
为执行重新均衡的操作，内核需要更多信息。因此在SMP系统上，就绪队列增加了额外的字段：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_domain</span> *<span style="color: #FD971F;">sd</span>;

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#20027;&#21160;&#22343;&#34913;</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">active_balance</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">push_cpu</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35813;&#23601;&#32490;&#38431;&#21015;&#30340;cpu</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cpu</span>;

        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">migration_thread</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">migration_queue</span>;
};
</pre>
</div>

<ul class="org-ul">
<li>就绪队列是特定于CPU的，因此 cpu 表示了该就绪队列所属的处理器。</li>
<li>内核为每个就绪队列提供了一个迁移线程，可以接收迁移请求，这些请求保存在链表 migration_queue 中。这样的请求通常发源于调度器自身，但如果进程被限制在某一特定的CPU集合上，而不能在当前执行的CPU上继续运行时，也可能出现这样的请求。</li>
</ul>

<p>
内核试图周期性地均衡就绪队列，但如果对某个就绪队列效果不佳，则必须使用主动均衡（active balancing）。如果需要主动均衡，则将 active_balance 设置为非零值，而 cpu 则记录了从哪个处理器发起的主动均衡请求。
</p>

<p>
所有的就绪队列组织为调度域（scheduling domain）。这可以将物理上邻近或共享高速缓存的CPU群集起来，应优先选择在这些CPU之间迁移进程。但在“普通”的SMP系统上，所有的处理器都包含在一个调度域中。
</p>

<p>
调度域使用 struct sched_domain 结构的实例来表示，该结构包含的大量参数，可以通过 /proc/sys/kernel/cpuX/domainY 设置，其中包括了发起负载均衡的 最大/最小 时间间隔，导致队列需要重新均衡的最小不平衡值，等等。此外该结构还管理一些字段，可以在运行时设置，使得内核能够跟踪记录上一次均衡操作在何时执行，下一次将在何时执行。
</p>

<p>
<b>load_balance函数</b> 会检测在上一次重新均衡操作之后是否已经过去了足够的时间，在必要的情况下通过调用 load_balance 发起一轮新的重新均衡操作。
</p>
<div class="org-src-container">
<pre class="src src-fundamental">load_balance

        find_busiest_group

        find_busiest_queue

        &#26368;&#24537;&#30340;&#38431;&#21015;&#19978;&#36827;&#31243;&#26159;&#21542;&#22823;&#20110;1

                move_tasks    -&gt;     class-&gt;load_balance

        &#22343;&#34913;&#25805;&#20316;&#22833;&#36133;   -&gt;  &#21796;&#37266;&#36801;&#31227;&#32447;&#31243;
</pre>
</div>
<p>
注意，在选择被迁移的进程时，内核必须确保被迁移的进程：
</p>
<ul class="org-ul">
<li>目前没有运行或刚结束运行，因为对运行进程而言，CPU高速缓存充满了进程的数据，迁移该进程则完全抵消了高速缓存带来的好处；</li>
<li>根据其CPU亲合性，可以在与当前队列关联的处理器上执行。</li>
</ul>

<p>
如果均衡操作失败（例如，远程队列上所有进程都有较高的内核内部优先级值，即较低的 nice值），则唤醒负责对应就绪队列的迁移线程。为确保主动负载均衡执行的更积极， load_balance 会设置最忙的就绪队列的 active_balance 标志，并将发起请求的CPU记录到rq-&gt;cpu 。
</p>
</div>
</div>

<div id="outline-container-orgb989283" class="outline-4">
<h4 id="orgb989283"><span class="section-number-4">5.1.2.</span> 迁移线程（migation_thread）</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
迁移线程用于两个目的：一个是用于完成发自调度器的迁移请求，另外一个是用于实现主动均衡。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * migration_thread - this is a highprio system thread that performs</span>
<span style="color: #75715E;"> * thread migration by bumping thread off CPU then 'pushing' onto</span>
<span style="color: #75715E;"> * another runqueue.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">migration_thread</span>(<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">data</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cpu</span> = (<span style="color: #66D9EF;">long</span>)data;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>;
        rq = cpu_rq(cpu);
        set_current_state(TASK_INTERRUPTIBLE);
        <span style="color: #F92672;">while</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>kthread_should_stop()) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">migration_req</span> *<span style="color: #FD971F;">req</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span>;

                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22312;load_balance&#20013;&#65292;&#20026;&#30830;&#20445;&#20027;&#21160;&#36127;&#36733;&#22343;&#34913;&#25191;&#34892;&#30340;&#26356;&#31215;&#26497;&#65292;&#20250;&#35774;&#32622;&#35813;&#26631;&#24535;</span>
                <span style="color: #F92672;">if</span> (rq-&gt;active_balance) {
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36215;&#20027;&#21160;&#22343;&#34913;</span>
                        active_load_balance(rq, cpu);
                        rq-&gt;active_balance = 0;
                }

                head = &amp;rq-&gt;migration_queue;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#36801;&#31227;&#35831;&#27714;</span>
                <span style="color: #F92672;">if</span> (list_empty(head)) {
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36215;&#37325;&#26032;&#35843;&#24230;</span>
                        schedule();
                        set_current_state(TASK_INTERRUPTIBLE);
                        <span style="color: #F92672;">continue</span>;
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#36801;&#31227;&#35831;&#27714;</span>
                req = list_entry(head-&gt;next, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">migration_req</span>, list);
                list_del_init(head-&gt;next);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36801;&#31227;&#23545;&#24212;&#30340;&#36827;&#31243;</span>
                __migrate_task(req-&gt;task, cpu, req-&gt;dest_cpu);
                local_irq_enable();

                complete(&amp;req-&gt;done);
        }
        __set_current_state(TASK_RUNNING);
        <span style="color: #F92672;">return</span> 0;

<span style="color: #AE81FF;">wait_to_die</span>:
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Wait for kthread_stop</span><span style="color: #75715E;"> */</span>
        set_current_state(TASK_INTERRUPTIBLE);
        <span style="color: #F92672;">while</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>kthread_should_stop()) {
                schedule();
                set_current_state(TASK_INTERRUPTIBLE);
        }
        __set_current_state(TASK_RUNNING);
        <span style="color: #F92672;">return</span> 0;
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf5eab6a" class="outline-3">
<h3 id="orgf5eab6a"><span class="section-number-3">5.2.</span> 调度域和控制组</h3>
<div class="outline-text-3" id="text-5-2">
<p>
调度器处理时，并不直接和进程进行交互，而是处理调度实体。
</p>

<p>
<b>组调度:</b> 进程置于不同的组中，调度器首先在这些组之间保证公平，然后在组中的所有进程之间保证公平。
</p>

<p>
<b>控制组（cgroup）：</b> 通过特殊文件系统 cgroups 可以创建任意的进程集合，可以分为多个层次。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> {
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#25903;&#25345;&#35843;&#24230;&#23618;&#27425;&#32467;&#26500;&#30340;&#25104;&#21592;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span>     *<span style="color: #FD971F;">parent</span>;

}

<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">enqueue_task_fair</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">wakeup</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">se</span> = &amp;p-&gt;se;

        for_each_sched_entity(se) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36941;&#21382;sched_entity&#32467;&#26500;&#30340;parent&#25104;&#21592;&#23450;&#20041;&#30340;&#35843;&#24230;&#23618;&#27425;&#26426;&#26500;</span>
                <span style="color: #F92672;">if</span> (se-&gt;on_rq)
                        <span style="color: #F92672;">break</span>;
                cfs_rq = cfs_rq_of(se);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21152;&#20837;&#21040;&#23601;&#32490;&#38431;&#21015;</span>
                enqueue_entity(cfs_rq, se, wakeup);
                wakeup = 1;
        }
}

</pre>
</div>
</div>
</div>
<div id="outline-container-orgb8404af" class="outline-3">
<h3 id="orgb8404af"><span class="section-number-3">5.3.</span> 内核抢占和低延迟相关工作</h3>
<div class="outline-text-3" id="text-5-3">
</div>
<div id="outline-container-orgf44415d" class="outline-4">
<h4 id="orgf44415d"><span class="section-number-4">5.3.1.</span> 内核抢占</h4>
<div class="outline-text-4" id="text-5-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #75715E;">&#25250;&#21344;&#35745;&#25968;&#22120;</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">thread_info</span> {
...
        <span style="color: #66D9EF;">int</span> preempt_count; <span style="color: #75715E;">/* </span><span style="color: #75715E;">0 =&gt; &#21487;&#25250;&#21344;, &lt;0 =&gt; BUG</span><span style="color: #75715E;"> */</span>
...
};
</pre>
</div>

<p>
成员preempt_count值为0，可以被抢占，否则不行。 操作该值只能通过 dec_preempt_count 和 inc_preempt_count 函数。 每次内核进入重要区域，需要禁止抢占时，都会调用 inc_preempt_count 。在退出该区域时，则调用 dec_preempt_count 将抢占计数器的值减1。
</p>

<p>
由于内核可能通过不同路线进入某些重要的区域，特别是嵌套的路线，因此 preempt_count 使用简单的布尔变量是不够的。在陆续进入多个临界区时，在内核再次启用抢占之前，必须确认已经离开所有的临界区。
</p>

<p>
一些有关抢占处理的例程：
</p>
<ul class="org-ul">
<li>preempt_disable 通过调用 inc_preempt_count 停用抢占。此外，会指示编译器避免某些内存优化，以免导致某些与抢占机制相关的问题。</li>
<li>preempt_check_resched 会检测是否有必要进行调度，如有必要则进行。</li>
<li>preempt_enable 启用内核抢占，然后用 preempt_check_resched 检测是否有必要重调度。</li>
<li>preempt_disable_no_resched 停用抢占，但不进行重调度。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">preempt_check_resched</span>() \
<span style="color: #F92672;">do</span> { \
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#26597;&#26159;&#21542;&#35774;&#32622;&#20102;&#37325;&#26032;&#35843;&#24230;&#26631;&#24535;</span>
        <span style="color: #F92672;">if</span> (unlikely(test_thread_flag(TIF_NEED_RESCHED))) \
                <span style="color: #A6E22E;">preempt_schedule</span>(); \
} <span style="color: #F92672;">while</span> (0)
</pre>
</div>

<p>
即使设置了TIF_NEED_RESCHED标志，并不代表可以抢占内核，内核有可能正处于临界区，不能被干扰，preempt_reschedule 可以用来检查是否处于临界区：
</p>
<div class="org-src-container">
<pre class="src src-c">asmlinkage <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">__sched</span> preempt_schedule(<span style="color: #66D9EF;">void</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">thread_info</span> *<span style="color: #FD971F;">ti</span> = current_thread_info();
<span style="color: #F92672;">#ifdef</span> CONFIG_PREEMPT_BKL
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">task</span> = current;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">saved_lock_depth</span>;
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * preempt_count &#19981;&#20026;&#38646; &#25110;&#32773; &#20572;&#29992;&#20013;&#26029;&#65292;&#30452;&#25509;&#36820;&#22238;</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (likely(ti-&gt;preempt_count || irqs_disabled()))
                <span style="color: #F92672;">return</span>;

        <span style="color: #F92672;">do</span> {
                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                   &#36825;&#27493;&#25805;&#20316;&#20250;&#32473;preempt_count&#35774;&#32622;&#19968;&#20010;&#26631;&#24535;&#20301;&#65292;&#20351;&#20854;&#26377;&#24456;&#22823;&#30340;&#20540;&#65292;</span>
<span style="color: #75715E;">                   &#36825;&#21487;&#20197;&#21521; schedule &#20989;&#25968;&#34920;&#26126;&#65292;&#35843;&#24230;&#19981;&#26159;&#20197;&#26222;&#36890;&#26041;&#24335;&#24341;&#21457;&#30340;&#65292;&#32780;&#26159;&#30001;&#20110;&#20869;&#26680;&#25250;&#21344;&#12290;</span>
<span style="color: #75715E;">                   &#22312;&#20869;&#26680;&#37325;&#35843;&#24230;&#20043;&#21518;&#65292;&#20195;&#30721;&#27969;&#31243;&#22238;&#21040;&#24403;&#21069;&#36827;&#31243;&#12290;&#27492;&#26102;&#26631;&#24535;&#20301;&#24050;&#32463;&#20877;&#27425;&#31227;&#38500;&#65292;</span>
<span style="color: #75715E;">                   &#36825;&#21487;&#33021;&#26159;&#22312;&#19968;&#27573;&#26102;&#38388;&#20043;&#21518;&#65292;&#27492;&#38388;&#30340;&#36825;&#27573;&#26102;&#38388;&#20379;&#25250;&#20808;&#30340;&#36827;&#31243;&#25191;&#34892;&#12290;</span>
<span style="color: #75715E;">                */</span>
                add_preempt_count(PREEMPT_ACTIVE);
                schedule();
                sub_preempt_count(PREEMPT_ACTIVE);
        } <span style="color: #F92672;">while</span> (unlikely(test_thread_flag(TIF_NEED_RESCHED)));
}

<span style="color: #75715E;">//</span><span style="color: #75715E;">schedule &#20989;&#25968;&#20013;&#20250;&#21028;&#26029;&#26159;&#21542;&#20026;&#20869;&#26680;&#25250;&#21344;</span>
asmlinkage <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">__sched</span> schedule(<span style="color: #66D9EF;">void</span>)
{
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">          &#22914;&#26524;&#24403;&#21069;&#36827;&#31243;&#30446;&#21069;&#22788;&#20110;&#19981;&#21487;&#36816;&#34892;&#29366;&#24577;&#65292;&#24182;&#19988;&#19981;&#26159;&#30001;&#20110;&#20869;&#26680;&#25250;&#21344;&#21457;&#36215;&#30340;&#35843;&#24230;&#65292;</span>
<span style="color: #75715E;">          &#21017;&#25165;&#20250;&#35843;&#29992;deactive_task&#26469;&#20572;&#27490;&#36827;&#31243;&#27963;&#21160;&#12290;</span>

<span style="color: #75715E;">          &#22914;&#26524;&#26159;&#30001;&#20110;&#20869;&#26680;&#25250;&#21344;&#26426;&#21046;&#21457;&#36215;&#65292;&#21017;&#20250;&#36339;&#36807;&#35813;&#25805;&#20316;&#12290;</span>
<span style="color: #75715E;">        */</span>
        <span style="color: #F92672;">if</span> (prev-&gt;state &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>(preempt_count() &amp; PREEMPT_ACTIVE)) {
                <span style="color: #F92672;">if</span> (unlikely((prev-&gt;state &amp; TASK_INTERRUPTIBLE) &amp;&amp;
                                unlikely(signal_pending(prev)))) {
                        prev-&gt;state = TASK_RUNNING;
                } <span style="color: #F92672;">else</span> {
                        deactivate_task(rq, prev, 1);
                }
                switch_count = &amp;prev-&gt;nvcsw;
        }

}
</pre>
</div>
</div>
</div>

<div id="outline-container-org446dc68" class="outline-4">
<h4 id="org446dc68"><span class="section-number-4">5.3.2.</span> cond_resched</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
cond_resched 用于发起有条件重新调度：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">__sched</span> cond_resched(<span style="color: #66D9EF;">void</span>)
{
        <span style="color: #F92672;">if</span> (need_resched() &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#35774;&#32622;TIF_NEED_RESCHED&#26631;&#24535;</span>
            <span style="color: #E6DB74; font-weight: bold;">!</span>(preempt_count() &amp; PREEMPT_ACTIVE) &amp;&amp;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#26159;&#20869;&#26680;&#25250;&#21344;</span>
            system_state == SYSTEM_RUNNING) {
                __cond_resched();
                <span style="color: #F92672;">return</span> 1;
        }
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>

<p>
<b>如何使用 cond_resched？</b>
  例如：内核读取与给定内存映射关联的内存页的情况。这可以通过无限循环完成，直至所有需要的数据读取完毕：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">for</span> (;;)
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35835;&#20837;&#25968;&#25454;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (exit_condition)
                countinue;
</pre>
</div>

<p>
上述过程中，如果需要大量读取操作，可能耗时会很长。由于进程运行在内核空间中，调度器无法象在用户空间那样撤销其CPU，假定也没有启用内核抢占。通过在每个循环迭代中调用 cond_resched ，即可改进此种情况。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">for</span> (;;)
        <span style="color: #A6E22E;">cond_resched</span>();
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35835;&#20837;&#25968;&#25454;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (exit_condition)
                <span style="color: #F92672;">continue</span>;
</pre>
</div>

<p>
调度器相关的文档目录： Documentation/scheduler/
</p>

<p>
有关实时组调度的文档： Documentation/scheduler/sched-rt-group.txt
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:54</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
