<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>进程以及进程管理</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">进程以及进程管理</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2e569f4">1. 进程</a>
<ul>
<li><a href="#org491e5dc">1.1. 进程的优先级</a></li>
<li><a href="#orgba77725">1.2. 进程状态</a></li>
<li><a href="#org323310a">1.3. 内核抢占</a></li>
<li><a href="#orgad10411">1.4. 标识进程</a></li>
<li><a href="#org59fa966">1.5. 进程描述符</a></li>
<li><a href="#org58b96b3">1.6. 进程的参数、环境变量和用户栈</a></li>
</ul>
</li>
<li><a href="#org92fa94d">2. 进程命名空间</a>
<ul>
<li><a href="#org02fd954">2.1. 创建方法</a></li>
<li><a href="#org5b0506a">2.2. 实现</a></li>
<li><a href="#org07065a0">2.3. 进程ID号</a>
<ul>
<li><a href="#org5e35fb7">2.3.1. 进程ID</a></li>
<li><a href="#orga3685d6">2.3.2. 管理PID</a>
<ul>
<li><a href="#orge8e3ce1">2.3.2.1. 数据结构</a></li>
<li><a href="#org44f5e56">2.3.2.2. 函数</a></li>
</ul>
</li>
<li><a href="#org2aa895b">2.3.3. 生成PID</a></li>
</ul>
</li>
<li><a href="#org29c9e12">2.4. 进程关系</a></li>
</ul>
</li>
<li><a href="#org8f1c08c">3. 进程管理相关系统调用</a>
<ul>
<li><a href="#org0d306d9">3.1. 进程复制</a>
<ul>
<li><a href="#org7f845ae">3.1.1. 写时复制</a></li>
<li><a href="#orgaaa4f22">3.1.2. 执行系统调用</a></li>
<li><a href="#org7c9c662">3.1.3. do_fork实现</a></li>
</ul>
</li>
<li><a href="#org39aec84">3.2. 进程的创建</a>
<ul>
<li><a href="#org9f31875">3.2.1. 进程的写时复制</a></li>
<li><a href="#org5f56534">3.2.2. fork</a>
<ul>
<li><a href="#org65bb284">3.2.2.1. do_fork</a></li>
<li><a href="#orgd997326">3.2.2.2. 复制进程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org18ab5c9">3.3. 内核线程</a></li>
<li><a href="#org1ff1d66">3.4. 启动新程序（execve）</a></li>
<li><a href="#org936f77f">3.5. 退出进程</a></li>
</ul>
</li>
<li><a href="#orgf51144c">4. 操作进程的工具</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2e569f4" class="outline-2">
<h2 id="org2e569f4"><span class="section-number-2">1.</span> 进程</h2>
<div class="outline-text-2" id="text-1">
<p>
进程是程序执行的一个实例，从内核的观点来看，进程用来充当系统分配资源的实体。
</p>

<p>
现代操作系统都可以同时运行若干个进程，但这只是计算机给我们的错觉，如果系统中只有一个处理器，则某一时刻，只有一个进程可以执行。多处理器中，可以同时运行进程的个数取决于处理器的数量。
</p>

<p>
内核和处理器给我们建立了多任务同时运行的错觉，本质上是通过在短时间内，对多个进程进行切换而实现的，由于时间较短，我们无法注意到操作系统中的进程切换导致的短暂停滞，所以看起来像是多个任务同时运行。
</p>

<div class="org-src-container">
<pre class="src src-fundamental">&#36827;&#31243;&#21644;&#31243;&#24207;&#30340;&#21306;&#21035;&#65306;
    &#31243;&#24207;&#26102;&#19968;&#22534;&#20195;&#30721;&#21644;&#25968;&#25454;&#65292;&#21487;&#20197;&#20316;&#20026;&#30446;&#26631;&#25991;&#20214;&#23384;&#22312;&#19982;&#30913;&#30424;&#19978;&#65292;&#25110;&#32773;&#20316;&#20026;&#27573;&#23384;&#22312;&#20110;&#22320;&#22336;&#31354;&#38388;&#20013;&#12290;

    &#36827;&#31243;&#26159;&#31243;&#24207;&#25191;&#34892;&#30340;&#19968;&#20010;&#20855;&#20307;&#30340;&#23454;&#20363;&#65292;&#31243;&#24207;&#24635;&#26159;&#36816;&#34892;&#22312;&#26576;&#20010;&#36827;&#31243;&#30340;&#19978;&#19979;&#25991;&#20013;&#12290;
</pre>
</div>
</div>

<div id="outline-container-org491e5dc" class="outline-3">
<h3 id="org491e5dc"><span class="section-number-3">1.1.</span> 进程的优先级</h3>
<div class="outline-text-3" id="text-1-1">
<dl class="org-dl">
<dt>硬实时进程</dt><dd>对时间有严格的限制，必须在指定的时间限内完成。例如飞机的飞行控制命令。</dd>

<dt>软实时进程</dt><dd>硬实时进程的一种弱化形式，虽然也需要尽快得到结果，但是稍晚一点，不会造成重大事故。例如CD的写如，必须保证某一速率，否则，会导致CD不可用。</dd>

<dt>普通进程</dt><dd>没有特定的时间约束，但是仍可以根据重要性来分配优先级。例如编译进程和交互式进程。</dd>
</dl>
</div>
</div>

<div id="outline-container-orgba77725" class="outline-3">
<h3 id="orgba77725"><span class="section-number-3">1.2.</span> 进程状态</h3>
<div class="outline-text-3" id="text-1-2">
<p>
进程并不总是可以立即运行，而是需要等待外部的信号或者事件，例如在文本编辑器中等待键盘输入。
</p>

<dl class="org-dl">
<dt>可运行状态（TASK_RUNNING）</dt><dd>进程要么在CPU上执行，要么准备执行（等待CPU调度）。</dd>

<dt>可中断等待状态（TASK_INTERRUPTIBLE）</dt><dd>进程被挂起，直到某个条件变为真。硬件中断，释放进程等待的系统资源，或者传递信号都是可以唤醒该状态下进程的条件。</dd>

<dt>不可中断的等待状态（TASK_UNINTERRUPTIBLE）</dt><dd>与可中断等待状态类似，但是向其传递信号不能改变进程状态。</dd>

<dt>暂停状态（TASK_STOPPED）</dt><dd>进程被暂停，当进程受到SIGSTOP、SIGTSTP、SIGTTIN或者SIGTTOU信号后，进入暂停状态。</dd>
<dt>跟踪状态（TASK_TRACED）</dt><dd>进程的执行被debbugger程序暂停。当一个进程被另一个进程监控（debugger执行ptrace系统调用监控一个测试程序），任何信号都可以把这个进程置为TASK_TRACED状态。</dd>

<dt>僵死状态（TASK_ZOMBIE）</dt><dd>进程的执行被终止，但是父进程没有通过wait4()或者waitpid()系统调用来返回进程死亡的信息。在发布wait()类系统调用前，内核不能丢弃进程描述符的数据，父进程可能还需要此数据。</dd>

<dt>僵死撤销状态（EXIT_DEAD）</dt><dd>最终状态：父进程刚发出wait4()或waitpid()系统调用，之后进程被系统删除。</dd>
</dl>



<div id="org7042955" class="figure">
<p><img src="./dot/process/pro_trans.png" alt="pro_trans.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org323310a" class="outline-3">
<h3 id="org323310a"><span class="section-number-3">1.3.</span> 内核抢占</h3>
<div class="outline-text-3" id="text-1-3">
<p>
linux进程管理结构中还需要另外两种进程状态：内核态和用户态。这反映出现代CPU至少有两种不同的执行状态，一个具有全部的权限，另一个会受到很多限制。
</p>

<p>
进程通常处于用户态，只能访问自身数据，无法干扰其他进程。
</p>

<p>
如果进程想要访问系统数据或者功能，则必须切换到内核态，可以通过系统调用或者中断实现。系统调用是由程序有意调用的，中断则不同，其发生是不可预测的。处理中断的操作通常与中断发生时执行的进无关。例如，在块设备向内存传输完数据会引发中断网卡的网络数据引发的中断，此时可能执行任意进程。
</p>

<p>
内核的抢占调度模型建立了一个层次结构，用于判断哪些进程状态可以由其他进程状态抢占。
</p>
<ul class="org-ul">
<li>普通进程总是可以被抢占。当一个重要进程变为可运行时，调度器可以决定是否立即执行该进程。</li>
<li>如果系统处于核心态执行系统调用，系统中的其他进程无法夺取其CPU时间。调度器必须等到系统调用执行结束，才可以选择其他进程执行，但是中断可以中止系统调用。</li>
<li>中断可以暂停处于用户态和核心态的进程。由于中断触发后需要尽快处理，所以中断具有最高的优先级。</li>
</ul>

<p>
<b>内核抢占</b> 功能允许紧急情况下切换到另一个进程，甚至当前是处于核心态执行系统调用（中断处理时不行）。
</p>
</div>
</div>

<div id="outline-container-orgad10411" class="outline-3">
<h3 id="orgad10411"><span class="section-number-3">1.4.</span> 标识进程</h3>
<div class="outline-text-3" id="text-1-4">
<p>
操作系统使用PID（进程ID）来标识进程，PID存放在进程描述符的pid字段。
</p>

<p>
通过/proc/sys/kernel/pid_max可以查看当前PID的最大值，可以通过向文件写入值来更改PID最大值。
</p>

<p>
POSIX标准规定一个多线程应用中的所有线程都必须由相同的PID，linux中一个线程组中的所有线程使用和该线程组的领头线程相同的PID，它被存入进程描述符的tgid字段，getpid()系统调用返回当前进程的tgid值，因此多线程应用的所有线程共享相同的PID。
</p>
</div>
</div>

<div id="outline-container-org59fa966" class="outline-3">
<h3 id="org59fa966"><span class="section-number-3">1.5.</span> 进程描述符</h3>
<div class="outline-text-3" id="text-1-5">
<p>
进程描述符中包含的数据能完整的描述一个正在执行的程序：其打开的文件，进程的地址空间，挂起的信号，进程的状态等等。
</p>

<pre class="example">

</pre>
</div>
</div>
<div id="outline-container-org58b96b3" class="outline-3">
<h3 id="org58b96b3"><span class="section-number-3">1.6.</span> 进程的参数、环境变量和用户栈</h3>
<div class="outline-text-3" id="text-1-6">

<div id="org76a00b7" class="figure">
<p><img src="./dot/process/argv.png" alt="argv.png" />
</p>
</div>


<div id="org87ee121" class="figure">
<p><img src="./dot/process/envp.png" alt="envp.png" />
</p>
</div>


<div id="orgdbb8956" class="figure">
<p><img src="./dot/process/stack.png" alt="stack.png" />
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-org92fa94d" class="outline-2">
<h2 id="org92fa94d"><span class="section-number-2">2.</span> 进程命名空间</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org02fd954" class="outline-3">
<h3 id="org02fd954"><span class="section-number-3">2.1.</span> 创建方法</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>在用fork或者clone系统调用创建进程时，通过特定选项控制是否和父进程共享命名空间，还是建立新的命名空间。</li>

<li>通过unshare将进程的某些部分从父进程分离，其中包括命名空间。</li>
</ul>
</div>
</div>

<div id="outline-container-org5b0506a" class="outline-3">
<h3 id="org5b0506a"><span class="section-number-3">2.2.</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
每个进程结构都包含了指向命名空间结构的指针。
</p>


<div id="org80e140c" class="figure">
<p><img src="./image/process/proc-ns.png" alt="proc-ns.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org07065a0" class="outline-3">
<h3 id="org07065a0"><span class="section-number-3">2.3.</span> 进程ID号</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org5e35fb7" class="outline-4">
<h4 id="org5e35fb7"><span class="section-number-4">2.3.1.</span> 进程ID</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
进程ID用来标识一个进程，fork或者clone时，都会为进程分配一个进程ID。
</p>

<p>
进程除了进程ID还有其他类型的ID。
</p>

<ul class="org-ul">
<li>线程组ID （CLONE_THREAD），即TGID。 如果进程没有线程，则PID和TGID相同。</li>
<li>进程组ID</li>
<li>会话ID</li>
</ul>

<p>
由于命名空间的特性，进程需要区分全局ID和局部ID（命名空间内）。
</p>
</div>
</div>

<div id="outline-container-orga3685d6" class="outline-4">
<h4 id="orga3685d6"><span class="section-number-4">2.3.2.</span> 管理PID</h4>
<div class="outline-text-4" id="text-2-3-2">
</div>
<div id="outline-container-orge8e3ce1" class="outline-5">
<h5 id="orge8e3ce1"><span class="section-number-5">2.3.2.1.</span> 数据结构</h5>
<div class="outline-text-5" id="text-2-3-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">PID&#21629;&#21517;&#31354;&#38388;&#30340;&#34920;&#31034;&#26041;&#24335;</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kref</span> <span style="color: #FD971F;">kref</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pidmap</span> <span style="color: #FD971F;">pidmap</span>[PIDMAP_ENTRIES];
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">last_pid</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#25351;&#21521;&#21629;&#21517;&#31354;&#38388;&#20869;&#30340; init&#36827;&#31243;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">child_reaper</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kmem_cache</span> *<span style="color: #FD971F;">pid_cachep</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#24403;&#21069;ns&#22312;ns&#23618;&#27425;&#32467;&#26500;&#20013;&#30340;&#28145;&#24230;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">level</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#25351;&#21521;&#29238;&#21629;&#21517;&#31354;&#38388;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">parent</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vfsmount</span> *<span style="color: #FD971F;">proc_mnt</span>;
};

<span style="color: #75715E;">/* </span><span style="color: #75715E;">&#29305;&#23450;&#21629;&#21517;&#31354;&#38388;&#20013;&#21487;&#35265;&#30340;&#20449;&#24687;</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">upid</span> {
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26631;&#35782;ID&#25968;&#20540;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">nr</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">nr&#25152;&#23646;&#30340;&#21629;&#21517;&#31354;&#38388;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">ns</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_node</span> <span style="color: #FD971F;">pid_chain</span>;
};


<span style="color: #F92672;">enum</span> <span style="color: #66D9EF;">pid_type</span>
{
        <span style="color: #FD971F;">PIDTYPE_PID</span>,
        <span style="color: #FD971F;">PIDTYPE_PGID</span>,
        <span style="color: #FD971F;">PIDTYPE_SID</span>,
        <span style="color: #FD971F;">PIDTYPE_MAX</span>
};

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> {
        <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">count</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#27599;&#31181;ID&#31867;&#22411;&#30340;&#25955;&#21015;&#34920;&#34920;&#22836;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span> <span style="color: #FD971F;">tasks</span>[PIDTYPE_MAX];
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rcu_head</span> <span style="color: #FD971F;">rcu</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">level</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#27599;&#39033;&#37117;&#20195;&#34920;&#19968;&#20010;&#21629;&#21517;&#31354;&#38388;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">upid</span> <span style="color: #FD971F;">numbers</span>[1];
};
</pre>
</div>


<div id="org918bdf6" class="figure">
<p><img src="./image/process/proc-pid-ns-st.png" alt="proc-pid-ns-st.png" />
</p>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_link</span> {
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#29992;&#20316;&#25955;&#21015;&#34920;&#20803;&#32032;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_node</span> <span style="color: #FD971F;">node</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#25351;&#21521;&#36827;&#31243;&#25152;&#23646;&#30340;pid&#32467;&#26500;&#23454;&#20363;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> *<span style="color: #FD971F;">pid</span>;
};

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> {
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">PID/PID hash table linkage.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_link</span> <span style="color: #FD971F;">pids</span>[PIDTYPE_MAX];
};
</pre>
</div>


<p>
pid实例和task_struct结构的关联：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">fastcall</span> attach_pid(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">task</span>, <span style="color: #F92672;">enum</span> <span style="color: #66D9EF;">pid_type</span> <span style="color: #FD971F;">type</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> *<span style="color: #FD971F;">pid</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_link</span> *<span style="color: #FD971F;">link</span>;
        link = &amp;task-&gt;pids[type];
        link-&gt;pid = pid;
        hlist_add_head_rcu(&amp;link-&gt;node, &amp;pid-&gt;tasks[type]);
}
<span style="color: #75715E;">/*</span>

<span style="color: #75715E;">task_struct &#33021;&#22815;&#36890;&#36807;task_struct-&gt;pids[type]-&gt;pid&#35775;&#38382;pid&#23454;&#20363;&#12290;</span>
<span style="color: #75715E;">pid&#23454;&#20363;&#21487;&#20197;&#36890;&#36807;pid-&gt;tasks[type]&#25214;&#21040;task_struct&#12290;</span>

<span style="color: #75715E;">*/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org44f5e56" class="outline-5">
<h5 id="org44f5e56"><span class="section-number-5">2.3.2.2.</span> 函数</h5>
<div class="outline-text-5" id="text-2-3-2-2">
<p>
为了能够通过给定的命名空间和PID数值来查找pid实例，内核提供了一个散列表：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span> *<span style="color: #FD971F;">pid_hash</span>;
</pre>
</div>

<ul class="org-ul">
<li>获取和task_struct关联的pid实例</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> *<span style="color: #A6E22E;">task_pid</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">task</span>);
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> *<span style="color: #A6E22E;">task_tgid</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">task</span>);
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> *<span style="color: #A6E22E;">task_pgrp</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">task</span>);
</pre>
</div>

<ul class="org-ul">
<li>获取到pid实例后，获取upid</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">pid_t</span> <span style="color: #A6E22E;">pid_nr_ns</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> *<span style="color: #FD971F;">pid</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">ns</span>);
</pre>
</div>

<ul class="org-ul">
<li>通过task_struct和ns获取upid的辅助函数</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">pid_t</span> <span style="color: #A6E22E;">task_pid_nr_ns</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">tsk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">ns</span>)
<span style="color: #66D9EF;">pid_t</span> <span style="color: #A6E22E;">task_tgid_nr_ns</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">tsk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">ns</span>)
<span style="color: #66D9EF;">pid_t</span> <span style="color: #A6E22E;">task_pgrp_nr_ns</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">tsk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">ns</span>)
<span style="color: #66D9EF;">pid_t</span> <span style="color: #A6E22E;">task_session_nr_ns</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">tsk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">ns</span>)
</pre>
</div>


<ul class="org-ul">
<li>通过数字PID和命名空间，获取pid实例</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;">upid&#30340;&#23454;&#20363;&#37117;&#20445;&#23384;&#22312;pid_hash&#25955;&#21015;&#34920;&#20013;&#65292;&#36890;&#36807;&#21629;&#21517;&#31354;&#38388;&#30340;pid nr&#21644;ns&#65292;&#35745;&#31639;hash&#20301;&#32622;&#65292;&#23601;&#33021;&#25214;&#21040;upid&#23454;&#20363;&#65292;</span>
<span style="color: #75715E;">&#22312;&#36890;&#36807;container_of &#21644;&#21629;&#21517;&#31354;&#38388;&#30340;&#28145;&#24230;&#65288;level&#65289;&#65292; &#23601;&#33021;&#36716;&#25442;&#24471;&#21040;pid&#23454;&#20363;&#12290;</span>
<span style="color: #75715E;">*/</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> * <span style="color: #A6E22E;">fastcall</span> find_pid_ns(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">nr</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">ns</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_node</span> *<span style="color: #FD971F;">elem</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">upid</span> *<span style="color: #FD971F;">pnr</span>;

        hlist_for_each_entry_rcu(pnr, elem,
                        &amp;pid_hash[pid_hashfn(nr, ns)], pid_chain)
                <span style="color: #F92672;">if</span> (pnr-&gt;nr == nr &amp;&amp; pnr-&gt;ns == ns)
                        <span style="color: #F92672;">return</span> container_of(pnr, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span>,
                                        numbers[ns-&gt;level]);

        <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
}
</pre>
</div>

<ul class="org-ul">
<li>通过数字PID和命名空间，以及PID类型，获取task_struct实例</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;">&#39318;&#20808;&#36890;&#36807;find_pid_ns&#33719;&#21462;pid&#23454;&#20363;&#12290;</span>
<span style="color: #75715E;">&#36890;&#36807;pid-&gt;tasks[type]&#21462;&#20986;task_struct&#23454;&#20363;&#12290;</span>
<span style="color: #75715E;">*/</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #A6E22E;">find_task_by_pid_type_ns</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">type</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">nr</span>,
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">ns</span>)
{
        <span style="color: #F92672;">return</span> pid_task(find_pid_ns(nr, ns), type);
}
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> * <span style="color: #A6E22E;">fastcall</span> pid_task(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> *<span style="color: #FD971F;">pid</span>, <span style="color: #F92672;">enum</span> <span style="color: #66D9EF;">pid_type</span> <span style="color: #FD971F;">type</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">result</span> = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #F92672;">if</span> (pid) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_node</span> *<span style="color: #FD971F;">first</span>;
                first = rcu_dereference(pid-&gt;tasks[type].first);
                <span style="color: #F92672;">if</span> (first)
                        result = hlist_entry(first, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span>, pids[(type)].node);
        }
        <span style="color: #F92672;">return</span> result;
}

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2aa895b" class="outline-4">
<h4 id="org2aa895b"><span class="section-number-4">2.3.3.</span> 生成PID</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
内核使用位图来分配PID，每个命名空间都有一个pid位图。
</p>

<p>
分配函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> *<span style="color: #A6E22E;">alloc_pid</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">ns</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> *<span style="color: #FD971F;">pid</span>;
        <span style="color: #F92672;">enum</span> <span style="color: #66D9EF;">pid_type</span> <span style="color: #FD971F;">type</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>, <span style="color: #FD971F;">nr</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_namespace</span> *<span style="color: #FD971F;">tmp</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">upid</span> *<span style="color: #FD971F;">upid</span>;
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">...</span><span style="color: #75715E;">*/</span>
        tmp = ns;
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">        &#20174;&#21019;&#24314;&#30340;&#21629;&#21517;&#31354;&#38388;&#24320;&#22987;&#65292;&#21040;&#20840;&#23616;&#21629;&#21517;&#31354;&#38388;&#65292;&#20998;&#21035;&#20998;&#37197;&#23545;&#24212;&#30340;PID&#65292;</span>
<span style="color: #75715E;">        &#24182;&#26356;&#26032;&#23545;&#24212;&#30340;upid&#23454;&#20363;&#65288;numbers&#65289;&#12290;</span>
<span style="color: #75715E;">        */</span>
        <span style="color: #F92672;">for</span> (i = ns-&gt;level; i &gt;= 0; i--) {
                nr = alloc_pidmap(tmp);
                pid-&gt;numbers[i].nr = nr;
                pid-&gt;numbers[i].ns = tmp;
                tmp = tmp-&gt;parent;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#23558;upid&#21152;&#20837;pid_hash&#25955;&#21015;&#34920;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">for</span> (i = ns-&gt;level; i &gt;= 0; i--) {
                upid = &amp;pid-&gt;numbers[i];
                hlist_add_head_rcu(&amp;upid-&gt;pid_chain,
                                &amp;pid_hash[pid_hashfn(upid-&gt;nr, upid-&gt;ns)]);
        }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org29c9e12" class="outline-3">
<h3 id="org29c9e12"><span class="section-number-3">2.4.</span> 进程关系</h3>
<div class="outline-text-3" id="text-2-4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> {
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20445;&#23384;&#23376;&#36827;&#31243;&#30340;&#38142;&#34920;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">children</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#23558;&#20804;&#24351;&#36827;&#31243;&#24444;&#27492;&#38142;&#25509;&#65292;&#20854;&#29238;&#36827;&#31243;&#30340;children&#25351;&#21521;&#35813;&#38142;&#34920;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">sibling</span>;
};
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org8f1c08c" class="outline-2">
<h2 id="org8f1c08c"><span class="section-number-2">3.</span> 进程管理相关系统调用</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org0d306d9" class="outline-3">
<h3 id="org0d306d9"><span class="section-number-3">3.1.</span> 进程复制</h3>
<div class="outline-text-3" id="text-3-1">
<p>
linux上的复制进程的3个系统调用: fork 、vfork、 clone。
</p>

<ul class="org-ul">
<li>fork 是个重量级调用，建立父进程的完整副本。为了减少该调用的工作量，linux使用写时复制机制。</li>
<li>vfork类似于fork，但是并不创建父进程数据的副本，父子进程之间共享数据。   vfork的设计用于子进程形成后，立即执行execve系统调用加载新程序的情形。在子进程退出或者开始新程序之前，内核保证父进程处于阻塞状态。</li>
<li>clone 用于产生线程，可以对父子进程之间的共享、复制进行精确控制。</li>
</ul>
</div>

<div id="outline-container-org7f845ae" class="outline-4">
<h4 id="org7f845ae"><span class="section-number-4">3.1.1.</span> 写时复制</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
如果在fork时复制父进程的所有数据，需要大量的内存，并且耗时较长。如果子进程复制后，立即使用exec加载新程序，则之前的复制操作都是多余的，因为新进程的地址空间会重新初始化。
</p>

<p>
基于以上原因，linux在fork时，只复制父进程的页表，也就是说，fork后，父子进程指向相同的物理内存页。 此时父子进程会将页表的页标记为只读。
</p>

<p>
当父子进程的一个进程试图向复制的内存页写入数据时，会引发缺页异常。内核然后查看额外的内存管理数据结构，检查该页是否可以用读写模式访问（例如COW页），还是只能以只读模式访问（引发段错误）。
</p>

<p>
COW机制使得内核尽可能延迟内存页的复制，而且很多情况下不需要复制。
</p>
</div>
</div>

<div id="outline-container-orgaaa4f22" class="outline-4">
<h4 id="orgaaa4f22"><span class="section-number-4">3.1.2.</span> 执行系统调用</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
fork、vfork、clone系统调用的入口点分别是sys_fork、sys_vfork、sys_clone函数。这几个系统调用会处理器寄存器提取用户空间提供的信息，然后调用与体系结构无关的do_fork函数，来复制进程。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">do_fork</span>(<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">clone_flags</span>,
              <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">stack_start</span>,
              <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> *<span style="color: #FD971F;">regs</span>,
              <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">stack_size</span>,
              <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *parent_tidptr,
              <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *child_tidptr)
</pre>
</div>
<ul class="org-ul">
<li>clone_flags是标志集合，用来指定控制复制过程的一些属性。 最低字节指定了子进程终止时发送给父进程的信号。其他高位字节保存了各种常数。</li>
<li>stack_start 用户状态下的栈的起始地址。</li>
<li>regs 是指向寄存器集合的指针，其中以原始形式保存了调用参数。该参数类型为特定于体系结构的struct pt_regs，按照系统调用执行时寄存器在内核栈上测存储顺序，保存了所有寄存器。</li>
<li>stack_size 用户状态下栈的大小。（通常不需要，设置为0）</li>
<li>parent_tidptr和child_tidptr 是指向用户空间中地址的指针，分别指向父子进程的PID。 NPTL库的线程实现需要该参数。</li>
</ul>

<p>
典型的fork调用实现方式：
</p>
<div class="org-src-container">
<pre class="src src-c">asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">sys_fork</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> *<span style="color: #FD971F;">regs</span>)
{
        <span style="color: #F92672;">return</span> do_fork(SIGCHLD, regs-&gt;rsp, regs, 0, <span style="color: #AE81FF;">NULL</span>, <span style="color: #AE81FF;">NULL</span>);
}

asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">sys_vfork</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> *<span style="color: #FD971F;">regs</span>)
{
        <span style="color: #F92672;">return</span> do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs-&gt;rsp, regs, 0,
                    <span style="color: #AE81FF;">NULL</span>, <span style="color: #AE81FF;">NULL</span>);
}

asmlinkage <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">sys_clone</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> <span style="color: #FD971F;">regs</span>)
{
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">clone_flags</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">newsp</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *parent_tidptr, *<span style="color: #FD971F;">child_tidptr</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#36890;&#36807;&#23492;&#23384;&#22120;&#25552;&#21462;&#21442;&#25968;</span><span style="color: #75715E;"> */</span>
        clone_flags = regs.ebx;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#25552;&#21462;&#20256;&#20837;&#30340;&#26632;&#22320;&#22336;</span><span style="color: #75715E;"> */</span>
        newsp = regs.ecx;
        parent_tidptr = (<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *)regs.edx;
        child_tidptr = (<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *)regs.edi;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>newsp)
                newsp = regs.esp;
        <span style="color: #F92672;">return</span> do_fork(clone_flags, newsp, &amp;regs, 0, parent_tidptr, child_tidptr);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org7c9c662" class="outline-4">
<h4 id="org7c9c662"><span class="section-number-4">3.1.3.</span> do_fork实现</h4>
</div>
</div>

<div id="outline-container-org39aec84" class="outline-3">
<h3 id="org39aec84"><span class="section-number-3">3.2.</span> 进程的创建</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org9f31875" class="outline-4">
<h4 id="org9f31875"><span class="section-number-4">3.2.1.</span> 进程的写时复制</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
在使用fork创建子进程时，子进程和父进程共享地址空间，当父进程或者子进程需要写入的时候，才会复制数据。这么做可以避免一些不必要的复制，而且很多时候，在fork之后，会立即执行exec，之前的拷贝都是无用功。
</p>
</div>
</div>

<div id="outline-container-org5f56534" class="outline-4">
<h4 id="org5f56534"><span class="section-number-4">3.2.2.</span> fork</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
fork调用最终是通过do_fork函数来实现的， do_fork又会调用copy_process()函数。
</p>
</div>

<div id="outline-container-org65bb284" class="outline-5">
<h5 id="org65bb284"><span class="section-number-5">3.2.2.1.</span> do_fork</h5>
<div class="outline-text-5" id="text-3-2-2-1">

<div id="orgeeed178" class="figure">
<p><img src="plantuml/process/do_fork.png" alt="do_fork.png" />
</p>
</div>

<ul class="org-ul">
<li><p>
由于fork需要返回子进程的pid，所以需要获取PID。如果指定创建新的PID命名空间，则需要调用task_pid_nr_ns获取在父命名空间中为新进程选择的PID，即发出fork调用的命名空间。
</p>
<div class="org-src-container">
<pre class="src src-c">nr = (clone_flags &amp; CLONE_NEWPID) ? task_pid_nr_ns(p, current-&gt;nsproxy-&gt;pid_ns) : task_pid_vnr(p);
</pre>
</div></li>
<li>如果要使用Ptrace监控新进程，那么在创建新进程后会立即向其发送SIGSTOP信号。</li>

<li>通过wake_up_new_task唤醒子进程，也就是直接将子进程的task_struct添加到调度队列。</li>

<li>如果使用了vfork，必须启用子进程的completions机制，通过task_struct的vfork_done成员来实现，父进程在该变量上睡眠，直到子进程退出。 通过这种方法，可以确保使用vfork生成的子进程的父进程一直处于不活动的状态，直至子进程退出，或者执行一个新的程序。父进程的临时睡眠状态，也确保两个进程不会彼此干扰或操作对方的地址空间。</li>
</ul>
</div>
</div>

<div id="outline-container-orgd997326" class="outline-5">
<h5 id="orgd997326"><span class="section-number-5">3.2.2.2.</span> 复制进程</h5>
<div class="outline-text-5" id="text-3-2-2-2">
<p>
do_fork中大多数的工作由copy_process函数完成。
</p>


<div id="org04db8ea" class="figure">
<p><img src="plantuml/process/copy_process.png" alt="copy_process.png" />
</p>
</div>

<ul class="org-ul">
<li>首先内核会检测一些没有意义的标志组合，例如既要创建一个新的命名空间（CLONE_NEWNS），同时又要与父进程共享所有的文件系统信息（CLONE_FS）。</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #A6E22E;">copy_process</span>(<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">clone_flags</span>,
                                        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">stack_start</span>,
                                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> *<span style="color: #FD971F;">regs</span>,
                                        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">stack_size</span>,
                                        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *child_tidptr,
                                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid</span> *<span style="color: #FD971F;">pid</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">retval</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">p</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cgroup_callbacks_done</span> = 0;

        <span style="color: #F92672;">if</span> ((clone_flags &amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
                <span style="color: #F92672;">return</span> ERR_PTR(-EINVAL);
</pre>
</div>

<p>
此处注意，linux有时候在函数执行成功时，返回指针，错误时返回错误吗。 但是由于C语言函数只有一个固定类型的返回值，因此所有错误码都必须编码到指针中。 linux虚拟地址空间中有一个从0到至少4KB的区域，该区域没有任何有意义的信息，内核重用该地址空间来编码错误码。  ERR_PTR是一个辅助宏，用于将数值编码为指针。
</p>

<ul class="org-ul">
<li>再用CLONE_THREAD创建线程时，必须用CLONE_SIGHAND激活信号共享。通常，一个信号无法发送到线程组的各个线程。</li>

<li>只有父子进程共享虚拟地址空间时（CLONE_VM），才能提供共享的信号处理程序。</li>
</ul>

<p>
<b>dup_task_struct</b>
</p>

<p>
内核通过dup_task_struct来拷贝父进程的task_struct，创建新的task_struct。 父子进程的task_struct实例只有一个成员不同：新进程分配了新的核心态栈，即 task_struct-&gt;stack。 通常和thread_info一同保存在一个联合中，thread_info保存了线程所需的所有特定与处理器的底层信息。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">union</span> <span style="color: #66D9EF;">thread_union</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">thread_info</span> <span style="color: #FD971F;">thread_info</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">stack</span>[THREAD_SIZE/<span style="color: #F92672;">sizeof</span>(<span style="color: #66D9EF;">long</span>)];
};
</pre>
</div>

<p>
大多数体系结构上，使用一两个内存页来保存 thread_union 的实例。在IA-32上，两个内存页是默认设置，因此可用的内核栈长度略小于8 KiB，其中一部分被 thread_info 实例占据。
</p>

<p>
注意： 配置选项 4KSTACKS 会将栈长度降低到4 KiB，即一页。如果系统上有许多进程在运行，比较有利的，每个进程可以节省一个页面。但是，对于经常趋向于使用过多栈空间的外部驱动程序来说，可能会有问题。标准发布版所提供的内核，其所有核心部分都已经设计为能够在4KiB栈长度配置下运转流畅。
</p>

<p>
thread_info 保存了特定于体系结构的汇编语言代码需要访问的那部分进程数据。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">thread_info</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span>      *<span style="color: #FD971F;">task</span>;          <span style="color: #75715E;">/* </span><span style="color: #75715E;">main task structure</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">exec_domain</span>      *<span style="color: #FD971F;">exec_domain</span>;   <span style="color: #75715E;">/* </span><span style="color: #75715E;">execution domain</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">__u32</span>                   <span style="color: #FD971F;">flags</span>;          <span style="color: #75715E;">/* </span><span style="color: #75715E;">low level flags</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">__u32</span>                   <span style="color: #FD971F;">status</span>;         <span style="color: #75715E;">/* </span><span style="color: #75715E;">thread synchronous flags</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">__u32</span>                   <span style="color: #FD971F;">cpu</span>;            <span style="color: #75715E;">/* </span><span style="color: #75715E;">current CPU</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">int</span>                     <span style="color: #FD971F;">preempt_count</span>;  <span style="color: #75715E;">/* </span><span style="color: #75715E;">0 =&gt; preemptable, &lt;0 =&gt; BUG</span><span style="color: #75715E;"> */</span>

        <span style="color: #66D9EF;">mm_segment_t</span>            <span style="color: #FD971F;">addr_limit</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">restart_block</span>    <span style="color: #FD971F;">restart_block</span>;
};
</pre>
</div>

<ul class="org-ul">
<li>task指向进程task_struct实例的指针。</li>
<li>exec_domain 用于实现执行区间 （execution domain）。 执行区间用于在一类计算机上实现多种的ABI（Application Binary Interface，应用程序二进制接口）。例如，在AMD64系统的64bit模式下运行32bit应用程序。</li>
<li>flags 可以保存各种特定于进程的标志。 例如： TIF_SIGPENDING（进程有待决信号时置位）， TIF_NEED_RESCHED（表示该进程需要调度器选择另一个进程执行）。</li>
<li>cpu 表示进程执行的cpu。</li>
<li>preempt_count 用于实现内核抢占。</li>
<li>addr_limit 指定了进程可以使用的虚拟地址上限。适用于普通进程。</li>
<li>restart_block 用于实现信号机制。</li>
</ul>

<p>
下图说明了task_struct、thread_info和内核栈的关系。 如果内核的某个组件使用过多的栈空间时，内核栈可能溢出到thread_info部分。另外在紧急情况下输出调用栈回溯时将会导致错误信息的出现，因此内核提供了 kstack_end 函数，用于判断给出的地址是否位于栈的有效部分之内。
</p>


<div id="orge5bfddf" class="figure">
<p><img src="image/process/task-thread.png" alt="task-thread.png" />
</p>
</div>


<p>
dup_task_struct会复制副进程的task_struct和thread_info实例的内容，但新进程会分配新的thread_info实例，并将task-&gt;stack 指向该thread_info实例。 此时父子进程的task_struct除了栈指针之外，完全相同。
</p>

<p>
所有体系结构都将两个名为current和current_thread_info符号定义为宏或函数：
</p>
<ul class="org-ul">
<li>current_thread_info 可以获得指向当前执行进程的thread_info实例的指针。其地址可以根据内核栈指针确定，thread_info实例总是位于栈顶。 每个进程分别使用各自的内核栈，所以进程到栈的映射是唯一的。</li>
<li>current 给出当前进程的task_struct实例的指针， current = current_thread_info()-&gt;task 。</li>
</ul>


<p>
此后，内核检查资源限制，是否超过用户允许创建的最大进程数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">user-&gt;processes &#20445;&#23384;&#29992;&#25143;&#24403;&#21069;&#30340;&#36827;&#31243;&#25968;&#37327;</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">if</span> (atomic_read(&amp;p-&gt;user-&gt;processes) &gt;=
                p-&gt;signal-&gt;rlim[RLIMIT_NPROC].rlim_cur) {
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#36229;&#36807;&#21518;&#65292;&#26816;&#26597;&#26159;&#21542;&#26159;root &#25110;&#32773;&#20998;&#37197;&#20102;&#29305;&#21035;&#26435;&#38480;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>capable(CAP_SYS_ADMIN) &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>capable(CAP_SYS_RESOURCE) &amp;&amp;
            p-&gt;user != current-&gt;nsproxy-&gt;user_ns-&gt;root_user)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">bad_fork_free</span>;
}
</pre>
</div>


<p>
如果没有超过资源限制，则调用 sched_fork，使得调度器有机会对新进程设置。 本质上，scked_fork初始化一些统计字段，如果是多处理器，可能会在各个CPU之间对可用进程重新均衡，还将进程的状态设置为TASK_RUNNING。 注意：此时还没有运行，只是为防止内核其他部分将进程状态改为运行并调度。
</p>

<p>
接下来会通过一系列的 <code>copy_xyz</code> 例程来复制或者共享内核子系统的资源。如果设置了某个CLONE_XYZ标志，则父子进程会共享对应的资源，否则会创建对应资源的副本。 通常，CLONE标志设置的越多，需要完成的工作越少，父子进程更有机会操作彼此的数据结构。
</p>

<ul class="org-ul">
<li>如果 COPY_SYSVSEM 置位，则 copy_semundo 使用父进程的System V信号量。</li>

<li>如果 CLONE_FILES 置位，则 copy_files 使用父进程的文件描述符；否则创建新的 files 结构，其中包含的信息与父进程相同。</li>

<li>如果 CLONE_FS 置位，则 copy_files 使用父进程的文件系统上下文（ task_struct-&gt;fs ）。这是一个fs_struct类型的结构，包含了诸如根目录、进程的当前工作目录之类的信息。</li>

<li>如果 CLONE_SIGHAND 或 CLONE_THREAD 置位，则 copy_sighand 使用父进程的信号处理程序。</li>

<li>如果 CLONE_THREAD 置位，则 copy_signal 与父进程共同使用信号处理中不特定于处理程序的部分（task_struct-&gt;signal）。</li>

<li>如果 CLONE_VM 置位，则 copy_mm 使父子进程共享同一地址空间。在这种情况下，两个进程使用同一个 mm_struct 实例， task_struct-&gt;mm 指针即指向该实例。</li>
<li>如果 CLONE_VM 没有置位，并不意味着需要复制父进程的整个地址空间。内核只会创建页表，但并不复制页的实际内容（COW机制）。</li>

<li>copy_namespace 比较特殊， 用于建立子进程的命名空间。控制是否与父进程共享命名空间的标志为 CLONE_NEWxyz 格式。 如果没有指定对应的标志，则代表与父进程共享对应的命名空间；如果指定了CLONE_NEWxyz标志，则代表创建一个新的命名空间。</li>

<li>copy_thread是一个特定于体系结构的函数，用于复制进程中特定于线程的数据（task_struct-&gt;thread）。</li>
</ul>

<p>
<b>接下来继续讨论 copy_process 函数：</b>
</p>

<p>
<code>分支进程：调用fork或者clone的进程</code>
</p>
<div class="org-src-container">
<pre class="src src-c">
p-&gt;pid = pid_nr(pid); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;pid</span>
p-&gt;tgid = p-&gt;pid;
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#32447;&#31243;&#65292;&#21017;&#32447;&#31243;&#32452;ID&#21644;&#20998;&#25903;&#36827;&#31243;&#65288;&#35843;&#29992;fork&#25110;&#32773;clone&#30340;&#36827;&#31243;&#65289;&#30456;&#21516;</span>
<span style="color: #F92672;">if</span> (clone_flags &amp; CLONE_THREAD)
        p-&gt;tgid = current-&gt;tgid;

</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">CLONE_PARENT re-uses the old parent</span><span style="color: #75715E;"> */</span>
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#32447;&#31243;&#65292;&#29238;&#36827;&#31243;&#24212;&#35813;&#26159;&#20998;&#25903;&#36827;&#31243;&#30340;&#29238;&#36827;&#31243;&#65292;&#38750;&#32447;&#31243;&#30340;&#26222;&#36890;&#36827;&#31243;&#21487;&#20197;&#36890;&#36807;&#35774;&#32622;CLONE_PARENT&#26631;&#24535;&#26469;&#36798;&#21040;&#21516;&#26679;&#30340;&#30446;&#30340;</span>
<span style="color: #F92672;">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD))
        p-&gt;real_parent = current-&gt;real_parent;
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#26222;&#36890;&#36827;&#31243;&#65292;&#29238;&#36827;&#31243;&#20026;&#20998;&#25903;&#36827;&#31243;</span>
<span style="color: #F92672;">else</span>
        p-&gt;real_parent = current;
p-&gt;parent = p-&gt;real_parent;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c">p-&gt;group_leader = p;
......
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#32447;&#31243;&#65292;&#20854;&#32452;&#38271;&#26159;&#24403;&#21069;&#36827;&#31243;&#30340;&#32452;&#38271;&#12290;</span>
<span style="color: #F92672;">if</span> (clone_flags &amp; CLONE_THREAD) {
        p-&gt;group_leader = current-&gt;group_leader;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#36807;&#29238;&#36827;&#31243;children&#38142;&#34920;&#19982;&#29238;&#36827;&#31243;&#38142;&#25509;</span>
<span style="color: #A6E22E;">add_parent</span>(p);

<span style="color: #75715E;">/*</span>
<span style="color: #75715E;">thread_group_leader&#26816;&#26597;&#26032;&#36827;&#31243;&#30340; pid &#21644; tgid &#26159;&#21542;&#30456;&#21516;&#12290;</span>
<span style="color: #75715E;">&#30456;&#21516;&#65292;&#21017;&#35813;&#36827;&#31243;&#26159;&#32447;&#31243;&#32452;&#32452;&#38271;&#65292;&#27492;&#26102;&#38656;&#35201;&#23436;&#25104;&#26356;&#22810;&#24037;&#20316;&#65306;</span>
<span style="color: #75715E;">  - &#22914;&#26524;&#36890;&#36807;CLONE_NEWPID&#21019;&#24314;&#26032;&#30340;&#21629;&#21517;&#31354;&#38388;&#65292;&#21017;&#24403;&#21069;&#36827;&#31243;&#24212;&#24403;&#20316;&#20026;&#21629;&#21517;&#31354;&#38388;&#30340;init&#36827;&#31243;&#12290;</span>
<span style="color: #75715E;">  - &#26032;&#36827;&#31243;&#24517;&#39035;&#28155;&#21152;&#21040;&#24403;&#21069;&#36827;&#31243;&#32452;&#21644;&#20250;&#35805;&#12290;</span>
<span style="color: #75715E;">*/</span>
<span style="color: #F92672;">if</span> (thread_group_leader(p)) {
        <span style="color: #F92672;">if</span> (clone_flags &amp; CLONE_NEWPID)
                p-&gt;nsproxy-&gt;pid_ns-&gt;child_reaper = p;

        p-&gt;signal-&gt;tty = current-&gt;signal-&gt;tty;
        set_task_pgrp(p, task_pgrp_nr(current));
        set_task_session(p, task_session_nr(current));
        attach_pid(p, PIDTYPE_PGID, task_pgrp(current));
        attach_pid(p, PIDTYPE_SID, task_session(current));
        list_add_tail_rcu(&amp;p-&gt;tasks, &amp;init_task.tasks);
        __get_cpu_var(process_counts)++;
}
<span style="color: #A6E22E;">attach_pid</span>(p, PIDTYPE_PID, pid);
......
<span style="color: #F92672;">return</span> p;
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org18ab5c9" class="outline-3">
<h3 id="org18ab5c9"><span class="section-number-3">3.3.</span> 内核线程</h3>
<div class="outline-text-3" id="text-3-3">
<p>
内核线程是直接有内核本身启动的进程。内核线程实际上是将内核函数委托给独立的进程，与系统中的其他进程一起运行。内核线程通常成为内核守护进程。
</p>

<p>
内核线程一般用于执行以下任务：
</p>
<ul class="org-ul">
<li>周期性的将修改过的内存页和页的来源块设备同步（例如mmap的文件映射）。</li>
<li>如果内存页较少使用，将其写入交换分区。</li>
<li>管理延时操作。</li>
<li>实现文件系统的事物日志。</li>
</ul>

<p>
内核线程可以分为两种类型：
</p>
<ul class="org-ul">
<li>线程启动后一直等待，直到内核请求线程执行某一个特定操作。</li>
<li>线程启动后周期性的间隔运行，检测特定资源的使用，在超出或者地狱预设的限制时，执行操作。</li>
</ul>

<p>
内核线程的创建函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">fn&#26159;&#29992;&#20110;&#32447;&#31243;&#25191;&#34892;&#30340;&#20989;&#25968;&#65292; flags&#21487;&#20197;&#25351;&#23450;CLONE&#26631;&#24535;&#12290;</span><span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">kernel_thread</span>(<span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">fn</span>)(<span style="color: #66D9EF;">void</span> *), <span style="color: #66D9EF;">void</span> * <span style="color: #FD971F;">arg</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> <span style="color: #FD971F;">regs</span>;

        memset(&amp;regs, 0, <span style="color: #F92672;">sizeof</span>(regs));
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26500;&#24314;pt_regs &#23492;&#23384;&#22120;&#23454;&#20363;</span><span style="color: #75715E;"> */</span>
        regs.ebx = (<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>) fn;
        regs.edx = (<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>) arg;

        regs.xds = __USER_DS;
        regs.xes = __USER_DS;
        regs.xfs = __KERNEL_PERCPU;
        regs.orig_eax = -1;
        regs.eip = (<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>) kernel_thread_helper;
        regs.xcs = __KERNEL_CS | get_kernel_rpl();
        regs.eflags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | 0x2;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Ok, create the new process..</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">return</span> do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &amp;regs, 0, <span style="color: #AE81FF;">NULL</span>, <span style="color: #AE81FF;">NULL</span>);
}
</pre>
</div>

<p>
注意：
</p>
<ul class="org-ul">
<li>内核线程在内核态执行，而非用户态。</li>
<li>只能访问虚拟地址空间的内核部分，不能访问用户虚拟地址空间。</li>
</ul>

<p>
当用户进程在内核态执行时（例如系统调用），虚拟地址空间的用户空间部分由 mm 指向的mm_struct实例描述。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> {
...
        <span style="color: #F92672;">struct</span> mm_struct *mm, *active_mm;
...
}
</pre>
</div>

<p>
由于内核线程不与任何特定的用户层进程相关，所以不需要倒换虚拟地址空间的用户层部分，所以会遵循 <b>惰性TLB处理</b> 。 由于内核线程运行之前可能是任意用户层进程在执行，内核线程不能修改其内容，所以会将mm设置为空指针，但是由于内核必须知道当前用户空间包含的内容，所以将active_mm中保存指向mm_struct实例的指针。
</p>

<p>
假如在内核线程之后，运行的进程与之前是同一个进程，此时内核并不需要修改用户空间地址表，TLB的信息仍然有效，只有在内核线程之后运行的进程和之前不同时，才需要切换（并清除TLB）。
</p>

<p>
<b>看一下代码比较直观：</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span>
<span style="color: #A6E22E;">context_switch</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rq</span> *<span style="color: #FD971F;">rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">prev</span>,
               <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">next</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mm_struct</span> *<span style="color: #FD971F;">mm</span>, *<span style="color: #FD971F;">oldmm</span>;

        <span style="color: #A6E22E;">prepare_task_switch</span>(<span style="color: #66D9EF;">rq</span>, prev, next);
        mm = next-&gt;mm;
        oldmm = prev-&gt;active_mm;
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * For paravirt, this is coupled with an exit in switch_to to</span>
<span style="color: #75715E;">         * combine the page table reload and the switch backend into</span>
<span style="color: #75715E;">         * one hypercall.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #A6E22E;">arch_enter_lazy_cpu_mode</span>();

        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>mm)) {
                next-&gt;active_mm = oldmm;
                atomic_inc(&amp;oldmm-&gt;mm_count);
                enter_lazy_tlb(oldmm, next);
        } <span style="color: #F92672;">else</span>
                switch_mm(oldmm, mm, next);

        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>prev-&gt;mm)) {
                prev-&gt;active_mm = <span style="color: #AE81FF;">NULL</span>;
                rq-&gt;prev_mm = oldmm;
        }
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * Since the runqueue lock will be released by the next</span>
<span style="color: #75715E;">         * task (which is an invalid locking op but in the case</span>
<span style="color: #75715E;">         * of the scheduler it's an obvious special-case), so we</span>
<span style="color: #75715E;">         * do an early lockdep release here:</span>
<span style="color: #75715E;">         */</span>
<span style="color: #F92672;">#if</span><span style="color: #F92672; font-weight: bold;">n</span><span style="color: #F92672;">def</span> __ARCH_WANT_UNLOCKED_CTXSW
        spin_release(&amp;rq-&gt;lock.dep_map, 1, _THIS_IP_);
<span style="color: #F92672;">#endif</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Here we just switch the register state and the stack.</span><span style="color: #75715E;"> */</span>
        <span style="color: #A6E22E;">switch_to</span>(prev, next, prev);

        <span style="color: #A6E22E;">barrier</span>();
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * this_rq must be evaluated again because prev may have moved</span>
<span style="color: #75715E;">         * CPUs since it called schedule(), thus the 'rq' on its stack</span>
<span style="color: #75715E;">         * frame will be invalid.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #A6E22E;">finish_task_switch</span>(<span style="color: #66D9EF;">this_rq</span>(), prev);
}

</pre>
</div>


<p>
<b>使用kthread_create创建内核线程：</b>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * &#22312;&#24403;&#21069;node&#21019;&#24314;&#20869;&#26680;&#32447;&#31243;</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@threadfn</span><span style="color: #E6DB74;">: &#20869;&#26680;&#32447;&#31243;&#23558;&#35201;&#25191;&#34892;&#30340;&#20989;&#25968;</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@data</span><span style="color: #E6DB74;">: &#20256;&#36882;&#32473; </span><span style="color: #AE81FF;">@</span><span style="color: #AE81FF;">threadfn</span><span style="color: #AE81FF;">()</span><span style="color: #E6DB74;">&#20989;&#25968;&#30340;&#21442;&#25968;&#25351;&#38024;</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@namefmt</span><span style="color: #E6DB74;">: &#20869;&#26680;&#32447;&#31243;&#30340;&#21517;&#31216;&#26684;&#24335;</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@arg</span><span style="color: #E6DB74;">...:  </span><span style="color: #AE81FF;">@namefmt</span><span style="color: #E6DB74;">&#30340;&#21442;&#25968;</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * &#35813;&#20989;&#25968;&#21019;&#24314;&#20869;&#26680;&#32447;&#31243;&#21518;&#65292;&#19981;&#20250;&#31435;&#21363;&#36816;&#34892;&#65292;&#38656;&#35201;&#36890;&#36807;wake_up_process&#20989;&#25968;&#21551;&#21160;&#12290;</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">kthread_create</span>(<span style="color: #FD971F;">threadfn</span>, <span style="color: #FD971F;">data</span>, <span style="color: #FD971F;">namefmt</span>, <span style="color: #FD971F;">arg</span>...) \
        kthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * &#21019;&#24314;&#20869;&#26680;&#32447;&#31243;&#24182;&#36816;&#34892;</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@threadfn</span><span style="color: #E6DB74;">: &#23558;&#35201;&#36816;&#34892;&#30340;&#20989;&#25968;&#65292;&#30452;&#21040;&#34987;signal_pending(current)&#32456;&#27490;.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@data</span><span style="color: #E6DB74;">: </span><span style="color: #AE81FF;">@threadfn</span><span style="color: #E6DB74;">&#21442;&#25968;&#25351;&#38024;</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@namefmt</span><span style="color: #E6DB74;">: &#32447;&#31243;&#21517;&#31216;&#26684;&#24335;</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">kthread_run</span>(<span style="color: #FD971F;">threadfn</span>, <span style="color: #FD971F;">data</span>, <span style="color: #FD971F;">namefmt</span>, ...)                          \
({                                                                         \
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">__k</span>                                            \
                = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>IS_ERR(__k))                                                  \
                wake_up_process(__k);                                      \
        __k;                                                               \
})
</pre>
</div>
</div>
</div>

<div id="outline-container-org1ff1d66" class="outline-3">
<h3 id="org1ff1d66"><span class="section-number-3">3.4.</span> 启动新程序（execve）</h3>
<div class="outline-text-3" id="text-3-4">
<p>
execve系统调用入口点 sys_execve
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">do_execve</span>(<span style="color: #66D9EF;">char</span> * <span style="color: #FD971F;">filename</span>,
              <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *__user *argv,
              <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *__user *envp,
              <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> * <span style="color: #FD971F;">regs</span>)
</pre>
</div>


<div id="orga36ce54" class="figure">
<p><img src="plantuml/process/do_execve.png" alt="do_execve.png" />
</p>
</div>

<p>
Linux可以支持不同格式的可执行文件格式，标准格式是ELF。
</p>

<p>
通常二进制格式处理程序需要执行一下操作：
</p>
<ul class="org-ul">
<li>释放原进程使用的所有资源。</li>
<li>将应用程序映射到虚拟地址空间中。需要考虑下列段的处理：
<ul class="org-ul">
<li>text段包含程序的可执行代码。 start_code 和 end_code 指定该段在地址空间中驻留的区域。</li>
<li>预先初始化的数据（在编译时间指定了具体值的变量）位于 start_data 和 end_data 之间，映射自可执行文件的对应段。</li>
<li>堆（heap）用于动态内存分配，亦置于虚拟地址空间中。 start_brk 和 brk 指定了其边界。</li>
<li>栈的位置由 start_stack 定义。几乎所有的计算机上栈都是自动地向下增长。</li>
<li>程序的参数和环境也映射到虚拟地址空间中，分别位于 arg_start 和 arg_end 之间，以及env_start 和 env_end 之间。</li>
</ul></li>
<li>设置进程的指令指针和其他特定于体系结构的寄存器，以便在调度器选择该进程时开始执行程序的main函数。</li>
</ul>



<p>
<b>二进制格式</b>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">linux_binfmt</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">lh</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">module</span> *<span style="color: #FD971F;">module</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">load_binary &#29992;&#20110;&#21152;&#36733;&#26222;&#36890;&#31243;&#24207;&#12290;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">load_binary</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">linux_binprm</span> *, <span style="color: #F92672;">struct</span>  <span style="color: #66D9EF;">pt_regs</span> * <span style="color: #FD971F;">regs</span>);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">load_shlib &#29992;&#20110;&#21152;&#36733;&#20849;&#20139;&#24211;&#65292;&#21363;&#21160;&#24577;&#24211;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">load_shlib</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">core_dump &#29992;&#20110;&#22312;&#31243;&#24207;&#38169;&#35823;&#30340;&#24773;&#20917;&#19979;&#36755;&#20986;&#20869;&#23384;&#36716;&#20648;&#12290;&#35813;&#36716;&#20648;&#38543;&#21518;&#21487;&#20351;&#29992;&#35843;&#35797;&#22120;&#65288;&#20363;&#22914;&#65292; gdb &#65289;&#20998;&#26512;&#65292;&#20197;&#20415;&#35299;&#20915;&#38382;&#39064;&#12290; min_coredump &#26159;&#29983;&#25104;&#20869;&#23384;&#36716;&#20648;&#26102;&#65292;&#20869;&#23384;&#36716;&#20648;&#25991;&#20214;&#38271;&#24230;&#30340;&#19979;&#30028;&#65288;&#36890;&#24120;&#65292;&#36825;&#26159;&#19968;&#20010;&#20869;&#23384;&#39029;&#30340;&#38271;&#24230;&#65289;&#12290;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">core_dump</span>)(<span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">signr</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> *<span style="color: #FD971F;">regs</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">file</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">limit</span>);
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">min_coredump</span>;     <span style="color: #75715E;">/* </span><span style="color: #75715E;">minimal dump size</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hasvdso</span>;
};
</pre>
</div>

<p>
每种二进制格式首先必须使用 register_binfmt 向内核注册。该函数的目的是向一个链表增加一种新的二进制格式，该链表的表头是 fs/exec.c 中的全局变量 formats 。 linux_binfmt 实例通过其 next 成员彼此连接起来。
</p>
</div>
</div>

<div id="outline-container-org936f77f" class="outline-3">
<h3 id="org936f77f"><span class="section-number-3">3.5.</span> 退出进程</h3>
<div class="outline-text-3" id="text-3-5">
<p>
exit -&gt; sys_exit -&gt;  do_exit
</p>
</div>
</div>
</div>


<div id="outline-container-orgf51144c" class="outline-2">
<h2 id="orgf51144c"><span class="section-number-2">4.</span> 操作进程的工具</h2>
<div class="outline-text-2" id="text-4">
<dl class="org-dl">
<dt>STRACE</dt><dd>打印一个正在运行的进程和它的子进程调用的每个系统调用的轨迹。使用 <code>-static</code> 编译程序会的高一个更加干净的、不带有大量动态库的输出轨迹。</dd>
<dt>PS</dt><dd>列出当前系统中的进程</dd>
<dt>TOP</dt><dd>打印出关于当前进程资源的使用信息</dd>
<dt>PMAP</dt><dd>显示进程的内存映射</dd>
<dt>/proc</dt><dd>虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户可以读取这些内容。</dd>
</dl>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:54</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
