<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2021-12-02 Thu 23:07 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Memory</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="nandfan" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
	     margin-bottom: .2em; }
  .subtitle { text-align: center;
	      font-size: medium;
	      font-weight: bold;
	      margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
	    padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Memory</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge4726b6">1. 概览</a></li>
<li><a href="#org11f40b0">2. UMA和NUMA的内存组织</a>
<ul>
<li><a href="#orgb43d4b2">2.1. 概述</a>
<ul>
<li><a href="#orgbf0a1a9">2.1.1. 结点</a></li>
<li><a href="#org2409a0d">2.1.2. 内存域</a></li>
</ul>
</li>
<li><a href="#org3e35701">2.2. 内存结构</a>
<ul>
<li><a href="#org2069e38">2.2.1. 结点管理</a></li>
<li><a href="#org8c3f467">2.2.2. 内存域</a></li>
<li><a href="#org55ed46f">2.2.3. 内存域水印</a></li>
<li><a href="#orge40b6bd">2.2.4. 页帧</a>
<ul>
<li><a href="#org599e84d">2.2.4.1. 体系结构无关的页标志</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org678b03e">3. 页表</a>
<ul>
<li><a href="#orgdcccefc">3.1. 数据结构</a>
<ul>
<li><a href="#org9d7a3b1">3.1.1. 内存地址的分解</a></li>
<li><a href="#orgacd7829">3.1.2. 页表格式</a></li>
<li><a href="#org2d16750">3.1.3. 特定与PTE的信息</a></li>
</ul>
</li>
<li><a href="#orga3378a7">3.2. 页表项的创建和操作</a></li>
</ul>
</li>
<li><a href="#orgf755005">4. 初始化内存管理</a>
<ul>
<li><a href="#orge79ce3c">4.1. 建立数据结构</a>
<ul>
<li><a href="#org8dfdbca">4.1.1. 系统启动</a></li>
<li><a href="#orgdf37cc8">4.1.2. 节点和内存域初始化</a></li>
</ul>
</li>
<li><a href="#org17e1857">4.2. 特定于体系结构的设置</a>
<ul>
<li><a href="#org827dedc">4.2.1. 内核在内存中的布局</a></li>
<li><a href="#org9ce1c45">4.2.2. 初始化步骤</a></li>
<li><a href="#org2bf4551">4.2.3. 分页机制的初始化</a>
<ul>
<li><a href="#org8be8b1c">4.2.3.1. 内核地址空间的划分</a></li>
<li><a href="#orgca056e2">4.2.3.2. 划分虚拟地址空间</a></li>
<li><a href="#org0972275">4.2.3.3. 冷热缓存的初始化</a></li>
</ul>
</li>
<li><a href="#orga1fcad3">4.2.4. 注册活动内存区</a>
<ul>
<li><a href="#org7544277">4.2.4.1. IA-32上注册内存区</a></li>
<li><a href="#org400e8ac">4.2.4.2. AMD64上注册内存区</a></li>
</ul>
</li>
<li><a href="#orgcd7d107">4.2.5. AMD64地址空间的设置</a></li>
</ul>
</li>
<li><a href="#org26bfc49">4.3. 启动过程中的内存管理</a>
<ul>
<li><a href="#org608484e">4.3.1. 数据结构</a></li>
<li><a href="#orgb6dbd96">4.3.2. 初始化</a></li>
<li><a href="#org8462234">4.3.3. 对内核的接口</a>
<ul>
<li><a href="#orgaac515c">4.3.3.1. 分配内存</a></li>
<li><a href="#org8da601a">4.3.3.2. 释放内存</a></li>
</ul>
</li>
<li><a href="#org2f2b197">4.3.4. 停用bootmem分配器</a></li>
<li><a href="#orgd155ea5">4.3.5. 释放初始化数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdd10159">5. 物理内存的管理</a>
<ul>
<li><a href="#org11a3d42">5.1. 伙伴系统结构</a></li>
<li><a href="#orgd106985">5.2. 避免碎片</a>
<ul>
<li><a href="#org46134fb">5.2.1. 依据可移动性组织页</a>
<ul>
<li><a href="#org480ae0e">5.2.1.1. 数据结构</a></li>
<li><a href="#org36e4f6a">5.2.1.2. 全局变量和辅助函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge22dfca">5.3. 初始化内存域和节点数据结构</a>
<ul>
<li><a href="#org346a149">5.3.1. 创建管理数据结构</a></li>
<li><a href="#org4a0d1cd">5.3.2. 对各个结点创建数据结构</a></li>
</ul>
</li>
<li><a href="#orge04a9a9">5.4. 分配器API</a>
<ul>
<li><a href="#org3292f27">5.4.1. 分配掩码</a></li>
<li><a href="#org80141d9">5.4.2. 内存分配宏</a></li>
</ul>
</li>
<li><a href="#orgca2a204">5.5. 分配页</a>
<ul>
<li><a href="#orgc689daa">5.5.1. 选择页</a>
<ul>
<li><a href="#org2b36845">5.5.1.1. 辅助函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org76e2628">5.6. 释放页</a></li>
<li><a href="#org0a4d8e6">5.7. 内核中不连续页的分配</a></li>
<li><a href="#orgf882117">5.8. 内核映射</a></li>
</ul>
</li>
<li><a href="#org592ca10">6. slab分配器</a></li>
<li><a href="#org3cfb9c9">7. 处理器高速缓存和TLB控制</a></li>
<li><a href="#org844cad0">8. ？？</a>
<ul>
<li><a href="#org586b6f9">8.1. Linux kernel 64位地址空间分配</a>
<ul>
<li><a href="#orgd7dae1c">8.1.1. 具有四级页表的虚拟地址空间</a></li>
<li><a href="#org516227e">8.1.2. 具有五级页表的虚拟地址空间</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orge4726b6" class="outline-2">
<h2 id="orge4726b6"><span class="section-number-2">1</span> 概览</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>内存管理涵盖的领域
<ul class="org-ul">
<li>内存中的物理内存页的管理</li>
<li>分配大块内存的伙伴系统</li>
<li>分配较小块内存的slab、slub和slob分配器</li>
<li>分配非连续内存块的vmalloc机制</li>
<li>进程的地址空间</li>
</ul></li>

<li>两种不同类型计算机的内存管理
<ul class="org-ul">
<li>UMA计算机: 一致内存访问，uniform memory access。将可用内存以连续方式组织起来。</li>
<li>NUMA计算机: 非一致性内存访问，non-uniform memory access。多处理器计算机。系统各个CPU都有本地内存，各个处理器通过总线连接，以支持访问其他cpu的本地内存。cpu访问本地内存较快，访问其他cpu本地内存稍慢。</li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-org11f40b0" class="outline-2">
<h2 id="org11f40b0"><span class="section-number-2">2</span> UMA和NUMA的内存组织</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgb43d4b2" class="outline-3">
<h3 id="orgb43d4b2"><span class="section-number-3">2.1</span> 概述</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-orgbf0a1a9" class="outline-4">
<h4 id="orgbf0a1a9"><span class="section-number-4">2.1.1</span> 结点</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
首先，内存划分为结点。每个结点关联一个处理器。在内核中使用 <b>pg_data_t</b> 结构的实例来表示。
</p>
</div>
</div>

<div id="outline-container-org2409a0d" class="outline-4">
<h4 id="org2409a0d"><span class="section-number-4">2.1.2</span> 内存域</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
各个结点又划分为内存域，是内存的进一步细分。
</p>

<p>
内核使用下列常量来枚举系统中的所有内存域：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">enum</span> <span style="color: #5FD7FF;">zone_type</span> {
<span style="color: #FF1493;">#ifdef</span> CONFIG_ZONE_DMA
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         * ZONE_DMA is used when there are devices that are not able</span>
<span style="color: #8B8878;">         * to do DMA to all of addressable memory (ZONE_NORMAL). Then we</span>
<span style="color: #8B8878;">         * carve out the portion of memory that is needed for these devices.</span>
<span style="color: #8B8878;">         * The range is arch specific.</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         * Some examples</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         * Architecture         Limit</span>
<span style="color: #8B8878;">         * ---------------------------</span>
<span style="color: #8B8878;">         * parisc, ia64, sparc  &lt;4G</span>
<span style="color: #8B8878;">         * s390                 &lt;2G</span>
<span style="color: #8B8878;">         * arm                  Various</span>
<span style="color: #8B8878;">         * alpha                Unlimited or 0-16MB.</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         * i386, x86_64 and multiple other arches</span>
<span style="color: #8B8878;">         *                      &lt;16M.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF8C00;">ZONE_DMA</span>,
<span style="color: #FF1493;">#endif</span>
<span style="color: #FF1493;">#ifdef</span> CONFIG_ZONE_DMA32
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         * x86_64 needs two ZONE_DMAs because it supports devices that are</span>
<span style="color: #8B8878;">         * only able to do DMA to the lower 16M but also 32 bit devices that</span>
<span style="color: #8B8878;">         * can only do DMA areas below 4G.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF8C00;">ZONE_DMA32</span>,
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span>
<span style="color: #8B8878;">         * performed on pages in ZONE_NORMAL if the DMA devices support</span>
<span style="color: #8B8878;">         * transfers to all addressable memory.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF8C00;">ZONE_NORMAL</span>,
<span style="color: #FF1493;">#ifdef</span> CONFIG_HIGHMEM
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         * A memory area that is only addressable by the kernel through</span>
<span style="color: #8B8878;">         * mapping portions into its own address space. This is for example</span>
<span style="color: #8B8878;">         * used by i386 to allow the kernel to address the memory beyond</span>
<span style="color: #8B8878;">         * 900MB. The kernel will set up special mappings (page</span>
<span style="color: #8B8878;">         * table entries on i386) for each page that the kernel needs to</span>
<span style="color: #8B8878;">         * access.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF8C00;">ZONE_HIGHMEM</span>,
<span style="color: #FF1493;">#endif</span>
	<span style="color: #FF8C00;">ZONE_MOVABLE</span>,
	<span style="color: #FF8C00;">MAX_NR_ZONES</span>
};
</pre>
</div>

<ul class="org-ul">
<li>ZONE_DMA : 标记适合DMA的内存域</li>
<li>ZONE_DMA32 : 标记了使用32为地址寻址、适合DMA的内存域(32位计算机为空)</li>
<li>ZONE_NORMAL : 可以直接映射内核段的普通内存域</li>
<li>ZONE_HIGHMEM : 超出内核段的物理内存</li>
<li>ZONE_MOVABLE : 在防止物理内存碎片时使用</li>
</ul>

<p>
每个内存域都会关联一个数组，用来组织属于该内存域的物理内存页（页帧），每个页帧分配了一个 struct page实例。
</p>
</div>
</div>
</div>

<div id="outline-container-org3e35701" class="outline-3">
<h3 id="org3e35701"><span class="section-number-3">2.2</span> 内存结构</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org2069e38" class="outline-4">
<h4 id="org2069e38"><span class="section-number-4">2.2.1</span> 结点管理</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
在NUMA体系结构中, 每个NUMA节点都会有一个pg_data_t结构, 用来描述其内存布局. UMA体系结构上, 用单个pg_data_t结构来描述所有内存。内存的统计信息和页替换信息以zone为基础进行维护.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">typedef</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">pglist_data</span> {
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21253;&#21547;&#20102;&#32467;&#28857;&#20013;&#21508;&#20010;&#20869;&#23384;&#22495;&#30340;&#25968;&#25454;&#32467;&#26500;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> <span style="color: #FF8C00;">node_zones</span>[MAX_NR_ZONES];
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25351;&#23450;&#20102;&#22791;&#29992;&#32467;&#28857;&#20197;&#21450;&#20854;&#20869;&#23384;&#22495;&#30340;&#21015;&#34920;&#65292;&#29992;&#20197;&#22312;&#24403;&#21069;&#32467;&#28857;&#27809;&#26377;&#20869;&#23384;&#26102;&#65292;&#20174;&#22791;&#29992;&#32467;&#28857;&#20998;&#37197;&#20869;&#23384;</span><span style="color: #8B8878;">  */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zonelist</span> <span style="color: #FF8C00;">node_zonelists</span>[MAX_ZONELISTS];
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nr_zones</span>; <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#32467;&#28857;&#20013;&#30340;&#20869;&#23384;&#22495;&#30340;&#25968;&#37327;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25351;&#21521;page&#23454;&#20363;&#25968;&#32452;&#30340;&#25351;&#38024;, &#29992;&#26469;&#25551;&#36848;&#32467;&#28857;&#30340;&#25152;&#26377;&#29289;&#29702;&#20869;&#23384;&#39029;&#65292;&#21253;&#21547;&#20102;&#32467;&#28857;&#20013;&#25152;&#26377;&#30340;&#20869;&#23384;&#22495;&#30340;&#39029;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> *<span style="color: #FF8C00;">node_mem_map</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#33258;&#20030;&#20869;&#23384;&#20998;&#37197;&#22120;&#65288;boot memory allocator&#65289;&#12290;&#29992;&#20110;&#31995;&#32479;&#21551;&#21160;&#26399;&#38388;&#65292;&#20869;&#23384;&#31649;&#29702;&#23376;&#31995;&#32479;&#21021;&#22987;&#21270;&#20043;&#21069;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">bootmem_data</span> *<span style="color: #FF8C00;">bdata</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">NUMA&#32467;&#28857;&#30340;&#31532;&#19968;&#20010;&#39029;&#24103;&#30340;&#36923;&#36753;&#39029;&#21495;&#12290;&#31995;&#32479;&#20013;&#25152;&#26377;&#32467;&#28857;&#30340;&#39029;&#24103;&#26159;&#20381;&#27425;&#32534;&#21495;&#30340;&#12290;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">node_start_pfn</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#32467;&#28857;&#30340;&#39029;&#24103;&#30340;&#25968;&#37327;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">node_present_pages</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#32467;&#28857;&#20869;&#20197;&#39029;&#24103;&#20026;&#21333;&#20301;&#35745;&#31639;&#30340;&#38271;&#24230;&#65288;&#21487;&#33021;&#21253;&#21547;&#31354;&#27934;&#65289;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">node_spanned_pages</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">node_id</span>; <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20840;&#23616;&#32467;&#28857;id</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">swap daemon &#30340;&#31561;&#24453;&#38431;&#21015;, &#22312;&#23558;&#39029;&#24103;&#25442;&#20986;&#26102;&#20351;&#29992;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">wait_queue_head_t</span> <span style="color: #FF8C00;">kswapd_wait</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25351;&#21521;&#36127;&#36131;&#35813;&#32467;&#28857;&#30340;&#39029;&#20132;&#25442;&#30340;&#36827;&#31243;&#25968;&#25454;&#32467;&#26500;(task_struct)</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">task_struct</span> *<span style="color: #FF8C00;">kswapd</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#29992;&#20110;&#39029;&#20132;&#25442;&#23376;&#31995;&#32479;&#30340;&#23454;&#29616; &#29992;&#26469;&#23450;&#20041;&#38656;&#35201;&#37322;&#25918;&#21306;&#22495;&#30340;&#38271;&#24230;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">kswapd_order</span>;
} <span style="color: #5FD7FF;">pg_data_t</span>;

</pre>
</div>
</div>
</div>

<div id="outline-container-org8c3f467" class="outline-4">
<h4 id="org8c3f467"><span class="section-number-4">2.2.2</span> 内存域</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li>内存域zone结构</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> {
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36890;&#24120;&#30001;&#20063;&#20998;&#37197;&#22120;&#35775;&#38382;&#30340;&#23383;&#27573;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">pages_min</span>, <span style="color: #FF8C00;">pages_low</span>, <span style="color: #FF8C00;">pages_high</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">lowmem_reserve</span>[MAX_NR_ZONES];

	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">per_cpu_pageset</span>  <span style="color: #FF8C00;">pageset</span>[NR_CPUS];

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#19981;&#21516;&#38271;&#24230;&#30340;&#31354;&#38386;&#21306;&#22495;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">spinlock_t</span>              <span style="color: #FF8C00;">lock</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">free_area</span>        <span style="color: #FF8C00;">free_area</span>[MAX_ORDER];

	<span style="color: #87D700;">ZONE_PADDING</span>(_pad1_)

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36890;&#24120;&#30001;&#39029;&#38754;&#22238;&#25910;&#25195;&#25551;&#31243;&#24207;&#35775;&#38382;&#30340;&#23383;&#27573;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">spinlock_t</span>              <span style="color: #FF8C00;">lru_lock</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">list_head</span>        <span style="color: #FF8C00;">active_list</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">list_head</span>        <span style="color: #FF8C00;">inactive_list</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">nr_scan_active</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">nr_scan_inactive</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">pages_scanned</span>;     <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">since last reclaim</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">flags</span>;             <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">zone flags, see below</span><span style="color: #8B8878;"> */</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20869;&#23384;&#22495;&#32479;&#35745;&#37327;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">atomic_long_t</span>           <span style="color: #FF8C00;">vm_stat</span>[NR_VM_ZONE_STAT_ITEMS];

	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">prev_priority</span>;

	<span style="color: #87D700;">ZONE_PADDING</span>(_pad2_)

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#24456;&#23569;&#20351;&#29992;&#65292;&#25110;&#32773;&#22823;&#22810;&#25968;&#24773;&#20917;&#19979;&#21482;&#35835;&#30340;&#23383;&#27573;</span><span style="color: #8B8878;"> */</span>

	<span style="color: #5FD7FF;">wait_queue_head_t</span>       * <span style="color: #FF8C00;">wait_table</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">wait_table_hash_nr_entries</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">wait_table_bits</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#29992;&#20110;&#25903;&#25345;&#19981;&#36830;&#32493;&#20869;&#23384;&#27169;&#22411;&#30340;&#23383;&#27573;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">pglist_data</span>      *<span style="color: #FF8C00;">zone_pgdat</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">zone_start_pfn</span>;

	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">spanned_pages</span>;  <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#24635;&#38271;&#24230;&#65288;&#21253;&#21547;&#31354;&#27934;&#65289;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">present_pages</span>;  <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20869;&#23384;&#24635;&#37327;&#65288;&#19981;&#21253;&#21547;&#31354;&#27934;&#65289;</span><span style="color: #8B8878;"> */</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#24456;&#23569;&#20351;&#29992;&#30340;&#23383;&#27573;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">char</span>              *<span style="color: #FF8C00;">name</span>;
} <span style="color: #FF8C00;">____cacheline_internodealigned_in_smp</span>;

</pre>
</div>

<p>
该结构中通过ZONE_PADDING分割为几个部分，由于内核对该结构的访问很频繁，所以或经常获取该结构的两个自旋锁（lock和lru_lock）。通过ZONE_PADDING可以生成填充字段，加入到结构中，将每个自旋锁处于自身的缓存行中。
</p>

<p>
第二个ZONE_PADDING的目的是将数据保持在一个缓存行中，便于快速访问。
</p>

<ul class="org-ul">
<li>pages_min、pages_high、pages_low是页换出时使用的“水印”。如果内存不足，可以将页写入硬盘
<ul class="org-ul">
<li>如果空闲页大于page_high，则内存域处于理想状态;</li>
<li>如果空闲页低于pages_low，则内核开始将页换出到硬盘。</li>
<li>如果空闲页低于pages_min，则页回收工作的压力较大，因为内存域中急需空闲页。</li>
</ul></li>

<li>lowmem_reserve[MAX_NR_ZONES]分别为内存域指定了若干页，用于一些不能失败的关键性内存分配。</li>

<li>pageset[NR_CPUS] 用于实现每个CPU的冷/热页帧列表。</li>

<li>free_area[MAX_ORDER] 用于实现伙伴系统。每个元素表示某种固定长度的一些连续内存区。</li>

<li>第二部分的结构成员
<ul class="org-ul">
<li>active_list 是活动页集合，inactive_list是不活动页的集合。（page实例）</li>
<li>nr_scan_active和nr_scan_inactive 指定在回收内存时需要扫描的活动和不活动页的数目。</li>
<li>pages_scaned指定了上次换出一页以来，有多少页未能成功扫描（没有换出的页数量）。</li>
<li><p>
flags描述内存域的当前状态。允许使用下列标志：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">typedef</span> <span style="color: #FF1493;">enum</span> {
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">          &#20363;&#22914;&#65292;&#24403;&#29992;&#25143;&#31354;&#38388;&#24212;&#29992;&#31243;&#24207;&#20351;&#29992;mlock&#31995;&#32479;&#35843;&#29992;&#36890;&#30693;&#20869;&#26680;&#39029;&#19981;&#33021;&#20174;&#29289;&#29702;&#20869;&#23384;&#31227;&#20986;&#65288;&#25442;&#20986;&#21040;&#30913;&#30424;&#65289;&#65292;</span>
<span style="color: #8B8878;">          &#21363;&#35774;&#32622;&#35813;&#26631;&#24535;&#12290;</span>
<span style="color: #8B8878;">        */</span>
	<span style="color: #FF8C00;">ZONE_ALL_UNRECLAIMABLE</span>,         <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">all pages pinned</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">          &#35813;&#26631;&#24535;&#21487;&#20197;&#38450;&#27490;&#22810;CPU&#35797;&#22270;&#24182;&#21457;&#30340;&#22238;&#25910;&#19968;&#20010;&#20869;&#23384;&#22495;&#12290;</span>
<span style="color: #8B8878;">        */</span>
	<span style="color: #FF8C00;">ZONE_RECLAIM_LOCKED</span>,            <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">prevents concurrent reclaim</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">          &#22914;&#26524;&#36827;&#31243;&#28040;&#32791;&#20102;&#22823;&#37327;&#20869;&#23384;&#65292;&#33268;&#20351;&#24517;&#35201;&#30340;&#25805;&#20316;&#37117;&#26080;&#27861;&#23436;&#25104;&#65292;&#21017;&#20869;&#26680;&#20250;&#35797;&#22270;&#26432;&#27515;&#28040;&#32791;&#20869;&#23384;&#26368;&#22810;&#30340;&#36827;&#31243;&#65292;</span>
<span style="color: #8B8878;">          &#35813;&#26631;&#24535;&#21487;&#20197;&#38450;&#27490;&#22810;&#20010;cpu&#21516;&#26102;&#36827;&#34892;&#36825;&#31181;&#25805;&#20316;&#12290;</span>
<span style="color: #8B8878;">        */</span>
	<span style="color: #FF8C00;">ZONE_OOM_LOCKED</span>,                <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">zone is in OOM killer zonelist</span><span style="color: #8B8878;"> */</span>
} <span style="color: #5FD7FF;">zone_flags_t</span>;

<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25805;&#20316;&#20197;&#19978;&#26631;&#24535;&#30340;&#36741;&#21161;&#20989;&#25968;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">zone_set_flag</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> *<span style="color: #FF8C00;">zone</span>, <span style="color: #5FD7FF;">zone_flags_t</span> <span style="color: #FF8C00;">flag</span>)
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">zone_test_and_set_flag</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> *<span style="color: #FF8C00;">zone</span>, <span style="color: #5FD7FF;">zone_flags_t</span> <span style="color: #FF8C00;">flag</span>)
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">zone_clear_flag</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> *<span style="color: #FF8C00;">zone</span>, <span style="color: #5FD7FF;">zone_flags_t</span> <span style="color: #FF8C00;">flag</span>)
</pre>
</div></li>
<li>vm_stat[NR_VM_ZONE_STAT_ITEMS] 维护了大量有关该内存域的统计信息。</li>
<li>prev_priority 存储上次扫描该内存域的优先级。扫描操作是由try_to_free_pages进行的，直至释放足够的页帧。</li>
<li>wait_table wait_table_hash_nr_entries wait_table_bits 共同实现了一个等待队列，可供进程等待某页变为可用。</li>
<li>zone_pgdat 建立内存域和父结点之间的关联，指向对应的pglist_data实例。</li>
<li>zone_start_pfn 是内存域以一个页帧的索引。</li>
<li>name 保存内存域的名称</li>
<li>spanned_pages 指定内存域中页的总数，包含空洞， present_pages则给出实际可用的页数。</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org55ed46f" class="outline-4">
<h4 id="org55ed46f"><span class="section-number-4">2.2.3</span> 内存域水印</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
首先，内核需要确定需要为关键性分配保留的内存空间的最小值，该值保存在全局变量min_free_kbytes中m，用户态可通过 /proc/sys/vm/min_free_kbytes 文件来读取和修改。该值最小 128k，最大 64MB
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">主内存</th>
<th scope="col" class="org-left">关键性内存分配最小值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">16MB</td>
<td class="org-left">512k</td>
</tr>

<tr>
<td class="org-left">32MB</td>
<td class="org-left">724k</td>
</tr>

<tr>
<td class="org-left">64MB</td>
<td class="org-left">1024k</td>
</tr>

<tr>
<td class="org-left">128MB</td>
<td class="org-left">1448k</td>
</tr>

<tr>
<td class="org-left">256MB</td>
<td class="org-left">2048k</td>
</tr>

<tr>
<td class="org-left">512MB</td>
<td class="org-left">2896k</td>
</tr>

<tr>
<td class="org-left">1024MB</td>
<td class="org-left">4096k</td>
</tr>

<tr>
<td class="org-left">2048MB</td>
<td class="org-left">5792k</td>
</tr>

<tr>
<td class="org-left">4096MB</td>
<td class="org-left">8192k</td>
</tr>

<tr>
<td class="org-left">8192MB</td>
<td class="org-left">11584k</td>
</tr>

<tr>
<td class="org-left">16384MB</td>
<td class="org-left">16384k</td>
</tr>
</tbody>
</table>

<p>
水印的填充由 init_per_zone_pages_min 来处理，该函数由内核在启动期间调用，无需显示调用。
</p>
<div class="org-src-container">
<pre class="src src-fundamental">init_per_zone_pages_min
	setup_per_zone_pages_min
	setup_per_zone_lowmem_reserve
</pre>
</div>


<ul class="org-ul">
<li>冷热页 （pageset[NR_CPUS]）</li>
</ul>
<p>
struct zone 的 pageset成员用于实现冷热页分配器. 热页代表页在高速缓存中, 冷页不在高速缓存中。在多处理器上每个CPU都有一个或多个高速缓存，哥哥cpu的管理必须是独立的。
</p>

<p>
NR_CPUS是系统能够容纳的CPU数目最大值。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">per_cpu_pageset</span> {
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">per_cpu_pages</span> <span style="color: #FF8C00;">pcp</span>[2];    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">0: hot.  1: cold</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#endif</span>
} <span style="color: #FF8C00;">____cacheline_aligned_in_smp</span>;

<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">per_cpu_pages</span> {
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">count</span>;              <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21015;&#34920;&#20013;&#30340;&#39029;&#25968;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">high</span>;                 <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#39029;&#25968;&#19978;&#38480;&#27700;&#21360;&#65292; &#22312;&#38656;&#35201;&#26102;&#28165;&#31354;&#21015;&#34920;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">batch</span>;              <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#28155;&#21152;&#25110;&#32773;&#21024;&#38500;&#22810;&#20010;&#39029;&#22359;&#26102;&#65292;&#22359;&#30340;&#22823;&#23567;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">list_head</span> <span style="color: #FF8C00;">list</span>;  <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#39029;&#30340;&#38142;&#34920;</span><span style="color: #8B8878;"> */</span>
};
</pre>
</div>

<p>
count记录与列表相关的页的数量，high是一个水印，如果count超过high，则表明列表中的页数过多。list是双向列表，保存了当前cpu的冷页或者热页。   当CPU的高速缓存可以使用多个页填充时，batch作为每次批量添加的一个参考值。
</p>
</div>
</div>

<div id="outline-container-orge40b6bd" class="outline-4">
<h4 id="orge40b6bd"><span class="section-number-4">2.2.4</span> 页帧</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
内存中的每个页都会创建struct page实例。由于页的数目较大，所以保持page结构尽可能的小。
</p>

<p>
页可以用于不同的用途，例如，内核的某个部分依赖struct page提供的特定信息，但该信息对于其他部分完全无用，因此可以使用联合结构来定义page中的许多字段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> {
	<span style="color: #FF1493;">union</span> {
		<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                  &#20869;&#23384;&#31649;&#29702;&#23376;&#31995;&#32479;&#20013;&#26144;&#23556;&#30340;&#39029;&#34920;&#39033;&#35745;&#25968;&#65292;</span>
<span style="color: #8B8878;">                  &#29992;&#20110;&#34920;&#31034;&#39029;&#26159;&#21542;&#24050;&#32463;&#26144;&#23556;&#65292;&#36824;&#29992;&#20110;&#38480;&#21046;&#36870;&#21521;&#26144;&#23556;&#25628;&#32034;&#12290;</span>
<span style="color: #8B8878;">                */</span>
		<span style="color: #5FD7FF;">atomic_t</span> <span style="color: #FF8C00;">_mapcount</span>;
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#29992;&#20110;SLUB&#20998;&#37197;&#22120;&#65306;&#23545;&#35937;&#30340;&#25968;&#30446;</span><span style="color: #8B8878;"> */</span>
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">inuse</span>;
	};
};
</pre>
</div>

<p>
page的定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> {
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">flags</span>;
	<span style="color: #5FD7FF;">atomic_t</span> <span style="color: #FF8C00;">_count</span>;
	<span style="color: #FF1493;">union</span> {
		<span style="color: #5FD7FF;">atomic_t</span> <span style="color: #FF8C00;">_mapcount</span>;
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">inuse</span>;
	};
	<span style="color: #FF1493;">union</span> {
	    <span style="color: #FF1493;">struct</span> {
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">private</span>;
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">address_space</span> *<span style="color: #FF8C00;">mapping</span>;
	    };
	    <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">kmem_cache</span> *<span style="color: #FF8C00;">slab</span>;    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">SLUB: &#25351;&#21521;slab&#30340;&#25351;&#38024;</span><span style="color: #8B8878;"> */</span>
	    <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> *<span style="color: #FF8C00;">first_page</span>;    <span style="color: #8B8878;">/*   */</span>
	};
	<span style="color: #FF1493;">union</span> {
		<span style="color: #5FD7FF;">pgoff_t</span> <span style="color: #FF8C00;">index</span>;
		<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">freelist</span>;
	};
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25442;&#20986;&#39029;&#21015;&#34920;&#65292;&#20363;&#22914;&#30001;zone-&gt;lru_lock&#20445;&#25252;&#30340;active_list</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">list_head</span> <span style="color: #FF8C00;">lru</span>;
<span style="color: #FF1493;">#if</span> <span style="color: #FF1493;">defined</span>(WANT_PAGE_VIRTUAL)
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20869;&#26680;&#34394;&#25311;&#22320;&#22336;&#65288;&#22914;&#26524;&#27809;&#26377;&#26144;&#23556;&#21017;&#20026;NULL&#65292; &#21363;&#39640;&#31471;&#20869;&#23384;&#65289;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">virtual</span>;
<span style="color: #FF1493;">#endif</span> <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">WANT_PAGE_VIRTUAL</span><span style="color: #8B8878;"> */</span>
};
</pre>
</div>

<p>
slab、freelist和inuse成员用于slub分配器。
</p>

<ul class="org-ul">
<li>flags 存储了体系结构无关的标志，用于描述页的属性。</li>
<li>_count 是一个使用计数，表示内核中引用该页的次数。当为0时，则可以删除。</li>
<li>_mapcount 表示页表中有多少项指向该页。</li>
<li>lru 是一个表头，用于在各种链表上维护该页，以便将页按不同类别分组，最重要的是活动页和不活动页。</li>
<li>内核可以将多个毗连的页合并为较大的复合页。分组中的第一个页成为首页，所有的其余页称作尾页。尾页对应的page实例中，将first_page指向首页。</li>
<li>mapping 指定了页帧所在的地址空间。 index是页帧在映射内部的偏移量。</li>
<li>private 指向私有数据的指针。</li>
<li>virtual用于高端内存区域中的页，virtual存储了该页的虚拟地址。</li>
</ul>
</div>


<div id="outline-container-org599e84d" class="outline-5">
<h5 id="org599e84d"><span class="section-number-5">2.2.4.1</span> 体系结构无关的页标志</h5>
<div class="outline-text-5" id="text-2-2-4-1">
<ul class="org-ul">
<li>PG_locked 指定页是否锁定。如果设置，则不允许内核其他部分访问该页。</li>
<li>PG_error 如果在该页的I/O操作期间发生错误，则设置。</li>
<li>PG_referenced和PG_active控制系统使用该页的活跃程度，页交换子系统选择换出页时或使用该信息。</li>
<li>PG_uptodate表示页的数据已经从块设备读取。</li>
<li>PG_dirty 表示页的内容和硬盘的数据不同。</li>
<li>PG_lru 有助于实现页面回收和切换。内核使用两个最近最少使用链表来区别活动和不活动页。如果页在其中一个链表，则设置该比特位。</li>
<li>PG_highmem 表示页在高端内存中，无法持久映射到内核内存中。</li>
<li>PG_writeback 表示正在将页的内容回写到块设备中。</li>
<li>PG_slab 表示页是slab分配器的一部分。</li>
<li>PG_swapcache 表示页处于交换缓存。</li>
<li>PG_reclaim 当可用内存数量表少时，内核试图周期性的回收页，即剔除不活动、未用的页，在内核决定回收某特特定的页后，设置该标志。</li>
<li>PG_buddy 表示页空闲且包含在伙伴系统的列表中。</li>
<li>PG_compound 表示该页属于一个更大的复合页，复合页由多个毗连的普通页组成。</li>
</ul>

<p>
检查或者操作上述标志位的宏：
</p>
<ul class="org-ul">
<li>PageXXX(page) 检查页是否设置了相应的标志。</li>
<li>SetPageXXX 相应的标志位未设置时设置标志位，且返回原值。</li>
<li>ClearPageXXX 清除对应的标志位。</li>
<li>TestClearPageXXX 清除某个设置的标志位，且返回原值。</li>
</ul>
<p>
辅助函数：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#31561;&#24453;&#39029;&#38754;&#34987;&#35299;&#38145;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">wait_on_page_locked</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> *<span style="color: #FF8C00;">page</span>)
<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#31561;&#24453;&#39029;&#38754;&#30456;&#20851;&#30340;&#25152;&#26377;&#24453;&#20915;&#22238;&#20889;&#25805;&#20316;&#32467;&#26463;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">wait_on_page_writeback</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> *<span style="color: #FF8C00;">page</span>)
</pre>
</div>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org678b03e" class="outline-2">
<h2 id="org678b03e"><span class="section-number-2">3</span> 页表</h2>
<div class="outline-text-2" id="text-3">
<p>
linux上使用四级页表
</p>
</div>
<div id="outline-container-orgdcccefc" class="outline-3">
<h3 id="orgdcccefc"><span class="section-number-3">3.1</span> 数据结构</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org9d7a3b1" class="outline-4">
<h4 id="org9d7a3b1"><span class="section-number-4">3.1.1</span> 内存地址的分解</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
虚拟内存地址划分为5个部分, 四个表项用于选择页, 一个索引表示页内偏移.
</p>

<div class="org-src-container">
<pre class="src src-text">| &lt;------------- BITS_PER_LONG ------------&gt; |
|  PGD  |  PUD  |  PMD  |  PTE  |   Offset   |
				| PAGE_SHIFT |
			| &lt;---PMD_SHIFT ---&gt; |
		| &lt;------- PUD_SHIFT ------&gt; |
	| &lt;--------- PGDIR_SHIFT ----------&gt; |

</pre>
</div>

<p>
指针末端的几个比特位，用于指定所选页帧内部的位置。比特位数目由PAGE_SHIFT指定。
</p>

<p>
PMD_SHIFT 指定了页内偏移量和最后一级页表项所需比特位的总数。PMD_SHIFT - PAGE_SHIFT就能得到最后一级页表项的比特位数目。也表明了中间层页表管理的地址空间大小 2<sup>PMD_SHIFT</sup>。
</p>

<p>
PUD_SHIFT由PMD_SHIFT加上中间层页表索引所需的比特位长度。
PGDIR_SHIFT由PUD_SHIFT加上上层页表索引所需的比特位长度。
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * PGDIR_SHIFT determines what a top-level page table entry can map</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">PGDIR_SHIFT</span>     39
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">PTRS_PER_PGD</span>    512

<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * 3rd level page</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">PUD_SHIFT</span>       30
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">PTRS_PER_PUD</span>    512

<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * PMD_SHIFT determines the size of the area a middle-level</span>
<span style="color: #8B8878;"> * page table can map</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">PMD_SHIFT</span>       21
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">PTRS_PER_PMD</span>    512

<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * entries per page directory level</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">PTRS_PER_PTE</span>    512

</pre>
</div>
<ul class="org-ul">
<li>PTRS_PER_PGD 全局页目录中的项数</li>
<li>PTRS_PER_PUD 上层页目录中的项数</li>
<li>PTRS_PER_PMD 中间页目录中的项数</li>
<li>PTRS_PER_PTE 页表中的项数</li>
</ul>

<p>
两级页表的体系结构会将 PERS_PER_PMD 和 PTRS_PER_PUD 定义为1.
</p>
</div>
</div>


<div id="outline-container-orgacd7829" class="outline-4">
<h4 id="orgacd7829"><span class="section-number-4">3.1.2</span> 页表格式</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>pgd_t 全局页目录项</li>
<li>pud_t 上层页目录项</li>
<li>pmd_t 中间页目录项</li>
<li>pte_t 页表项</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23558;pte_t&#31561;&#31867;&#22411;&#30340;&#21464;&#37327;&#36716;&#25442;&#20026;unsigned long&#25972;&#25968;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pte_val</span>(<span style="color: #FF8C00;">x</span>)      ((x).pte)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pmd_val</span>(<span style="color: #FF8C00;">x</span>)      ((x).pmd)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pud_val</span>(<span style="color: #FF8C00;">x</span>)      ((x).pud)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pgd_val</span>(<span style="color: #FF8C00;">x</span>)      ((x).pgd)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pgprot_val</span>(<span style="color: #FF8C00;">x</span>)   ((x).pgprot)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23558;unsigned long&#25972;&#25968;&#36716;&#25442;&#20301;pgd_t&#31561;&#31867;&#22411;&#30340;&#21464;&#37327;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">__pte</span>(<span style="color: #FF8C00;">x</span>) ((pte_t) { (x) } )
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">__pmd</span>(<span style="color: #FF8C00;">x</span>) ((pmd_t) { (x) } )
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">__pud</span>(<span style="color: #FF8C00;">x</span>) ((pud_t) { (x) } )
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">__pgd</span>(<span style="color: #FF8C00;">x</span>) ((pgd_t) { (x) } )
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">__pgprot</span>(<span style="color: #FF8C00;">x</span>)     ((pgprot_t) { (x) } )
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20174;&#20869;&#23384;&#25351;&#38024;&#21644;&#39029;&#34920;&#39033;&#33719;&#24471;&#19979;&#19968;&#32423;&#39029;&#34920;&#30340;&#22320;&#22336;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pgd_index</span>(<span style="color: #FF8C00;">address</span>) (((address) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pud_index</span>(<span style="color: #FF8C00;">address</span>) (((address) &gt;&gt; PUD_SHIFT) &amp; (PTRS_PER_PUD-1))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pmd_index</span>(<span style="color: #FF8C00;">address</span>) (((address) &gt;&gt; PMD_SHIFT) &amp; (PTRS_PER_PMD-1))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pte_index</span>(<span style="color: #FF8C00;">address</span>) (((address) &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26816;&#26597;&#23545;&#24212;&#39033;&#30340;_PRESENT&#20301;&#26159;&#21542;&#35774;&#32622;&#12290;&#22914;&#26524;&#35813;&#39033;&#23545;&#24212;&#30340;&#39029;&#34920;&#25110;&#39029;&#22312;&#20869;&#23384;&#20013;&#65292;&#21017;&#20250;&#32622;&#20301;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pgd_present</span>(<span style="color: #FF8C00;">pgd</span>) (pgd_val(pgd) &amp; _PAGE_PRESENT)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pud_present</span>(<span style="color: #FF8C00;">pud</span>) (pud_val(pud) &amp; _PAGE_PRESENT)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pmd_present</span>(<span style="color: #FF8C00;">x</span>)  (pmd_val(x) &amp; _PAGE_PRESENT)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pte_present</span>(<span style="color: #FF8C00;">x</span>)  (pte_val(x) &amp; (_PAGE_PRESENT | _PAGE_PROTNONE))

</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23545;xxx_present&#20989;&#25968;&#30340;&#20540;&#36923;&#36753;&#21462;&#36820;&#12290;&#22914;&#26524;&#36820;&#22238;true&#65292;&#21017;&#26816;&#26597;&#30340;&#39029;&#19981;&#22312;&#20869;&#23384;&#20013;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pgd_none</span>(<span style="color: #FF8C00;">x</span>)     (<span style="color: #CDC673; font-weight: bold;">!</span>pgd_val(x))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pud_none</span>(<span style="color: #FF8C00;">x</span>)     (<span style="color: #CDC673; font-weight: bold;">!</span>pud_val(x))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pmd_none</span>(<span style="color: #FF8C00;">x</span>)     (<span style="color: #CDC673; font-weight: bold;">!</span>pmd_val(x))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pte_none</span>(<span style="color: #FF8C00;">x</span>)     (<span style="color: #CDC673; font-weight: bold;">!</span>pte_val(x))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21024;&#38500;&#20256;&#36882;&#30340;&#39029;&#34920;&#39033;&#12290; &#36890;&#24120;&#26159;&#23558;&#20854;&#35774;&#32622;&#20026;&#38646;&#12290;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">pgd_clear</span> (<span style="color: #5FD7FF;">pgd_t</span> * <span style="color: #FF8C00;">pgd</span>)
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">pud_clear</span> (<span style="color: #5FD7FF;">pud_t</span> *<span style="color: #FF8C00;">pud</span>)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pmd_clear</span>(<span style="color: #FF8C00;">xp</span>)   <span style="color: #FF1493;">do</span> { set_pmd(xp, __pmd(0)); } <span style="color: #FF1493;">while</span> (0)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pte_clear</span>(<span style="color: #FF8C00;">mm</span>,<span style="color: #FF8C00;">addr</span>,<span style="color: #FF8C00;">xp</span>)   <span style="color: #FF1493;">do</span> { set_pte_at(mm, addr, xp, __pte(0)); } <span style="color: #FF1493;">while</span> (0)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26816;&#26597;&#20013;&#38388;&#23618;&#39029;&#34920;&#12289;&#19978;&#23618;&#39029;&#34920;&#12289;&#20840;&#23616;&#39029;&#34920;&#30340;&#39033;&#26159;&#21542;&#26080;&#25928;&#12290;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #87D700;">pgd_bad</span>(<span style="color: #5FD7FF;">pgd_t</span> <span style="color: #FF8C00;">pgd</span>)
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #87D700;">pud_bad</span>(<span style="color: #5FD7FF;">pud_t</span> <span style="color: #FF8C00;">pud</span>)
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #87D700;">pmd_bad</span>(<span style="color: #5FD7FF;">pmd_t</span> <span style="color: #FF8C00;">pmd</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36820;&#22238;&#20445;&#23384;&#39029;&#25968;&#25454;&#30340;page&#32467;&#26500;&#25110;&#20013;&#38388;&#39029;&#30446;&#24405;&#30340;&#39033;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pmd_page</span>(<span style="color: #FF8C00;">pmd</span>)           (pfn_to_page(pmd_val(pmd) &gt;&gt; PAGE_SHIFT))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pgd_page</span>(<span style="color: #FF8C00;">pgd</span>)           (pfn_to_page(pgd_val(pgd) &gt;&gt; PAGE_SHIFT))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pud_page</span>(<span style="color: #FF8C00;">pud</span>)           (pfn_to_page(pud_val(pud) &gt;&gt; PAGE_SHIFT))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pgd_offset</span>(<span style="color: #FF8C00;">mm</span>, <span style="color: #FF8C00;">addr</span>) ((mm)-&gt;pgd + pgd_index(addr))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pud_offset</span>(<span style="color: #FF8C00;">pgd</span>, <span style="color: #FF8C00;">address</span>) ((<span style="color: #5FD7FF;">pud_t</span> *) pgd_page_vaddr(*(pgd)) + pud_index(address))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">pmd_offset</span>(<span style="color: #FF8C00;">dir</span>, <span style="color: #FF8C00;">address</span>) ((<span style="color: #5FD7FF;">pmd_t</span> *) pud_page_vaddr(*(dir)) + pmd_index(address))
</pre>
</div>


<p>
页表项只有一个成员，使用unsigned long类型表示。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">typedef</span> <span style="color: #FF1493;">struct</span> { <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">pte</span>; } <span style="color: #5FD7FF;">pte_t</span>;
<span style="color: #FF1493;">typedef</span> <span style="color: #FF1493;">struct</span> { <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">pmd</span>; } <span style="color: #5FD7FF;">pmd_t</span>;
<span style="color: #FF1493;">typedef</span> <span style="color: #FF1493;">struct</span> { <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">pud</span>; } <span style="color: #5FD7FF;">pud_t</span>;
<span style="color: #FF1493;">typedef</span> <span style="color: #FF1493;">struct</span> { <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">pgd</span>; } <span style="color: #5FD7FF;">pgd_t</span>;
</pre>
</div>
</div>
</div>


<div id="outline-container-org2d16750" class="outline-4">
<h4 id="org2d16750"><span class="section-number-4">3.1.3</span> 特定与PTE的信息</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
最后一级页表的页表项不仅包含了指向页内存位置的指针, 还在其多余的比特位上包含了与页有关的附加信息，提供了一些页的访问控制信息。
</p>

<ul class="org-ul">
<li>_PAGE_PRESENT 指定虚拟内存页是否在内存中(可能被换出到交换区&#x2026;)</li>
<li>_PAGE_ACCESSED cpu访问页或读写页时自动设置(标识页的活跃程度)</li>
<li>_PAGE_DIRTY 脏页,需要回写</li>
<li>_PAGE_USER 允许用户空间访问该页,否则只有内核可以访问</li>
<li>_PAGE_READ、_PAGE_WRITE、_PAGE_EXECUTE 指定普通用户进程读、写、执行页中内容</li>
<li>_PAGE_BIT_NX(IA-32和AMD64) 将页标记为不可执行(可用于防止执行栈页上的代码)</li>
</ul>

<p>
内核定义了一些函数，用于查询和设置内存页与体系结构相关的状态：
</p>
<ul class="org-ul">
<li>pte_present</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">函数</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">pte_present</td>
<td class="org-left">页是否在内存中</td>
</tr>

<tr>
<td class="org-left">pte_read</td>
<td class="org-left">是否可以从用户空间读取该页</td>
</tr>

<tr>
<td class="org-left">pte_write</td>
<td class="org-left">是否可以写入到该页</td>
</tr>

<tr>
<td class="org-left">pte_exec</td>
<td class="org-left">页的数据是否可以作为二进制代码执行</td>
</tr>

<tr>
<td class="org-left">pte_dirty</td>
<td class="org-left">是否是脏页</td>
</tr>

<tr>
<td class="org-left">pte_file</td>
<td class="org-left">页表项是否属于非线性映射</td>
</tr>

<tr>
<td class="org-left">pte_young</td>
<td class="org-left">访问位（_PAGE_ACCESS）是否设置</td>
</tr>

<tr>
<td class="org-left">pte_rdprotect</td>
<td class="org-left">清除该页的读权限</td>
</tr>

<tr>
<td class="org-left">pte_wrprotect</td>
<td class="org-left">清除该页的写权限</td>
</tr>

<tr>
<td class="org-left">pte_exprotect</td>
<td class="org-left">清除该页的执行权限</td>
</tr>

<tr>
<td class="org-left">pte_mkread</td>
<td class="org-left">设置读权限</td>
</tr>

<tr>
<td class="org-left">pte_mkwrite</td>
<td class="org-left">设置写权限</td>
</tr>

<tr>
<td class="org-left">pte_mkexec</td>
<td class="org-left">设置页的执行权限</td>
</tr>

<tr>
<td class="org-left">pte_dirty</td>
<td class="org-left">将页标记为脏页</td>
</tr>

<tr>
<td class="org-left">pte_mkclean</td>
<td class="org-left">清除_PAGE_DIRTY位</td>
</tr>

<tr>
<td class="org-left">pte_mkyoung</td>
<td class="org-left">设置访问位（通常是 _PAGE_ASCCESSED）</td>
</tr>

<tr>
<td class="org-left">pte_mkold</td>
<td class="org-left">清除访问位</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orga3378a7" class="outline-3">
<h3 id="orga3378a7"><span class="section-number-3">3.2</span> 页表项的创建和操作</h3>
<div class="outline-text-3" id="text-3-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">函数</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">mk_pte</td>
<td class="org-left">创建一个页表项，必须将page实例和所需的页访问权限作为参数传递</td>
</tr>

<tr>
<td class="org-left">pgd_alloc</td>
<td class="org-left">获得页表项描述的页对应的page实例地址</td>
</tr>

<tr>
<td class="org-left">pud_alloc</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">pmd_alloc</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">pte_alloc</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">pgd_free</td>
<td class="org-left">释放页表占据的内存</td>
</tr>

<tr>
<td class="org-left">pud_free</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">pmd_free</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">pte_free</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">set_pgd</td>
<td class="org-left">设置页表中某项的值</td>
</tr>

<tr>
<td class="org-left">set_pud</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">set_pmd</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">set_pte</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-orgf755005" class="outline-2">
<h2 id="orgf755005"><span class="section-number-2">4</span> 初始化内存管理</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orge79ce3c" class="outline-3">
<h3 id="orge79ce3c"><span class="section-number-3">4.1</span> 建立数据结构</h3>
<div class="outline-text-3" id="text-4-1">
<p>
内核中用pgdata_t实例来表示内存结点，其中保存了结点的内存数量以及内存在各个内存域之间分配情况的信息。
</p>

<p>
所有平台上都实现了特定于体系结构的NODE_DATA宏，用于通过结点编号查询NUMA结点相关的pgdata_t实例。
</p>
</div>

<div id="outline-container-org8dfdbca" class="outline-4">
<h4 id="org8dfdbca"><span class="section-number-4">4.1.1</span> 系统启动</h4>
<div class="outline-text-4" id="text-4-1-1">
<div class="org-src-container">
<pre class="src src-text">start_kernel

	1. setup_arch

	2. setup_per_cpu_areas

	3. build_all_aonelists

	4. mem_init

	5. kmem_cache_init

	6. setup_per_cpu_pageset

1. &#29305;&#23450;&#20110;&#20307;&#31995;&#32467;&#26500;&#30340;&#35774;&#32622;&#20989;&#25968;, &#20854;&#20013;&#26377;&#19968;&#39033;&#36127;&#36131;&#21021;&#22987;&#21270;&#33258;&#20030;&#20998;&#37197;&#22120;
2. &#20026;&#31995;&#32479;&#20013;&#30340;&#21508;&#20010;cpu&#21019;&#24314;&#27599;cpu&#21464;&#37327;&#30340;&#21103;&#26412;
3. &#24314;&#31435;&#33410;&#28857;&#21644;&#20869;&#23384;&#22495;&#30340;&#25968;&#25454;&#32467;&#26500;
4. &#20572;&#29992;bootmem&#20998;&#37197;&#22120;&#24182;&#36801;&#31227;&#21040;&#23454;&#38469;&#30340;&#20869;&#23384;&#31649;&#29702;&#20989;&#25968;(&#29305;&#23450;&#20307;&#31995;&#32467;&#26500;&#30340;&#20989;&#25968;)
5. &#21021;&#22987;&#21270;&#20869;&#26680;&#20869;&#37096;&#29992;&#20110;&#23567;&#22359;&#20869;&#23384;&#21306;&#30340;&#20998;&#37197;&#22120;
6. &#20026; zone &#32467;&#26500;&#20013;&#30340;pageset&#25968;&#32452;&#30340;&#31532;&#19968;&#20010;&#25968;&#32452;&#20803;&#32032;&#20998;&#37197;&#20869;&#23384;(&#20026;&#31995;&#32479;&#31532;&#19968;&#20010;&#22788;&#29702;&#22120;&#20998;&#37197;&#20869;&#23384;)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdf37cc8" class="outline-4">
<h4 id="orgdf37cc8"><span class="section-number-4">4.1.2</span> 节点和内存域初始化</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
build_all_zonelists建立管理节点及其内存域所需的数据结构.
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">return values int ....just for stop_machine_run()</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">__build_all_zonelists</span>(<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">dummy</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nid</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36941;&#21382;&#31995;&#32479;&#20013;&#25152;&#26377;&#27963;&#21160;&#33410;&#28857;&#12290;</span><span style="color: #8B8878;"> */</span>
	for_each_online_node(nid) {
		<span style="color: #5FD7FF;">pg_data_t</span> *<span style="color: #FF8C00;">pgdat</span> = NODE_DATA(nid);

		build_zonelists(pgdat);
		build_zonelist_cache(pgdat);
	}
	<span style="color: #FF1493;">return</span> 0;
}

</pre>
</div>

<p>
build_zonelists 需要一个指向 pgdata_t 实例的指针作为参数, 此函数在当前处理节点和系统中其他节点的内存域之间建立一种等级次序(内存域的次序和节点之间的次序), 用于内存分配次序。
</p>

<p>
例如，当内核想要分配高端内存，首先在当前结点的高端内存域分配；如果失败，则从当前结点的普通内存域分配；如果还是失败，则试图在该结点DMA内存域分配；如果都失败了，则以上建立的列表继续查找。
</p>

<p>
内核使用pg_data_t中的zonelist数组，来表示上面描述的层次结构：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">typedef</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">pglist_data</span> {
......
	<span style="color: #FF1493;">struct</span> zonelist node_zonelists[MAX_ZONELISTS]; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20869;&#23384;&#22495;&#31867;&#22411;&#21015;&#34920;</span>
......
} <span style="color: #5FD7FF;">pg_data_t</span>;

<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">MAX_ZONES_PER_ZONELIST</span> (MAX_NUMNODES * MAX_NR_ZONES)

<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zonelist</span> {
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21253;&#21547;&#20840;&#37096;&#32467;&#28857;&#30340;&#20869;&#23384;&#22495;&#30340;&#21015;&#34920;&#65292; &#20197;NULL&#32467;&#26463;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> *<span style="color: #FF8C00;">zones</span>[MAX_ZONES_PER_ZONELIST + 1];      <span style="color: #8B8878;">// </span><span style="color: #8B8878;">NULL delimited</span>
};
</pre>
</div>

<p>
build_zonelists 用来创建内存域的备用层次结构：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">build_zonelists</span>(<span style="color: #5FD7FF;">pg_data_t</span> *<span style="color: #FF8C00;">pgdat</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">node</span>, <span style="color: #FF8C00;">local_node</span>;
	<span style="color: #FF1493;">enum</span> <span style="color: #5FD7FF;">zone_type</span> <span style="color: #FF8C00;">i</span>,<span style="color: #FF8C00;">j</span>;

	local_node = pgdat-&gt;node_id;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36845;&#20195;&#32467;&#28857;&#20869;&#25152;&#26377;&#30340;&#20869;&#23384;&#22495;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">for</span> (i = 0; i &lt; MAX_NR_ZONES; i++) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zonelist</span> *<span style="color: #FF8C00;">zonelist</span>;

		zonelist = pgdat-&gt;node_zonelists + i;
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#35745;&#31639;&#31532;i&#20010;&#20869;&#23384;&#22495;&#30340;&#22791;&#29992;&#21015;&#34920;</span><span style="color: #8B8878;"> */</span>
		j = build_zonelists_node(pgdat, zonelist, 0, i);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36845;&#20195;&#22823;&#20110;&#24403;&#21069;&#32467;&#28857;&#32534;&#21495;&#30340;&#25152;&#26377;&#32467;&#28857;</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">for</span> (node = local_node + 1; node &lt; MAX_NUMNODES; node++) {
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>node_online(node))
				<span style="color: #FF1493;">continue</span>;
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">j&#27492;&#26102;&#20445;&#23384;&#30340;&#26159;&#22791;&#29992;&#21015;&#34920;&#30340;&#20301;&#32622;</span>
			j = build_zonelists_node(NODE_DATA(node), zonelist, j, i);
		}
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36845;&#20195;&#23567;&#20110;&#24403;&#21069;&#32467;&#28857;&#32534;&#21495;&#30340;&#25152;&#26377;&#32467;&#28857;</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">for</span> (node = 0; node &lt; local_node; node++) {
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>node_online(node))
				<span style="color: #FF1493;">continue</span>;
			j = build_zonelists_node(NODE_DATA(node), zonelist, j, i);
		}

		zonelist-&gt;zones[j] = <span style="color: #AF87FF;">NULL</span>;
	}
}

</pre>
</div>

<p>
build_zonelists_node建立内存域的备用列表：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">build_zonelists_node</span>(<span style="color: #5FD7FF;">pg_data_t</span> *<span style="color: #FF8C00;">pgdat</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zonelist</span> *<span style="color: #FF8C00;">zonelist</span>,
				<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nr_zones</span>, <span style="color: #FF1493;">enum</span> <span style="color: #5FD7FF;">zone_type</span> <span style="color: #FF8C00;">zone_type</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> *<span style="color: #FF8C00;">zone</span>;

	BUG_ON(zone_type &gt;= MAX_NR_ZONES);
	zone_type++;

	<span style="color: #FF1493;">do</span> {
		zone_type--; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20943;1&#65292;&#34920;&#31034;&#35774;&#32622;&#19968;&#20010;&#26356;&#26114;&#36149;&#30340;&#20869;&#23384;&#22495;&#31867;&#22411;&#12290;</span>
		zone = pgdat-&gt;node_zones + zone_type;
		<span style="color: #FF1493;">if</span> (populated_zone(zone)) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#30830;&#20445;&#20869;&#23384;&#22495;&#20013;&#30830;&#23454;&#26377;&#39029;&#23384;&#22312;</span>
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">nr_zones &#20445;&#23384;&#20869;&#23384;&#22791;&#29992;&#21015;&#34920;&#20301;&#32622;</span><span style="color: #8B8878;"> */</span>
			zonelist-&gt;zones[nr_zones++] = zone;
			check_highest_zone(zone_type);
		}

	} <span style="color: #FF1493;">while</span> (zone_type);
	<span style="color: #FF1493;">return</span> nr_zones;
}
</pre>
</div>

<p>
下图说明了系统中有4个结点时，第三个结点在多次循环中，备用列表填充过程：
<img src="image/memory/zone-list.png" alt="zone-list.png" />
</p>

<p>
下图说明了系统中有4个结点时，第三个结点建立完成的备用列表：
<img src="image/memory/zone-list-complete.png" alt="zone-list-complete.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org17e1857" class="outline-3">
<h3 id="org17e1857"><span class="section-number-3">4.2</span> 特定于体系结构的设置</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org827dedc" class="outline-4">
<h4 id="org827dedc"><span class="section-number-4">4.2.1</span> 内核在内存中的布局</h4>
<div class="outline-text-4" id="text-4-2-1">

<div class="figure">
<p><img src="image/memory/kernel-layout.png" alt="kernel-layout.png" />
</p>
</div>

<p>
以一个页帧保留, 接下来有640KB的区域, 之后紧邻的区域由系统保留, 用于映射各种ROM(通常是系统BIOS和显卡ROM), 不可能向映射ROM的区域写入数据. 由于内核总是会装载到一段连续的区域中, 如果要装载到之前的640KB区域中, 则要求内核必须小于640KB.
</p>

<p>
IA-32内核使用0x100000作为起始地址, 对应于内存的第2MB开始处.
</p>

<ul class="org-ul">
<li>_text 和 _etext 是代码段的起始和结束地址，包含了编译后的内核代码。</li>
<li>数据段位于 _etext 和 _edata 之间，保存了大部分内核变量。</li>
<li>初始化数据在内核启动过程结束后不再需要（例如，包含初始化为0的所有静态全局变量的BSS段）保存在最后一段，从 _edata 到 _end 。在内核初始化完成后，其中的大部分数据都可以从内存删除，给应用程序留出更多空间。这一段内存区划分为更小的子区间，以控制哪些可以删除，哪些不能删除。</li>
</ul>


<p>
编译内核之后, 会生成 System.map 文件, 包含内核全局变量 内核定义的函数和例程的地址, 内核代码段 数据段 初始化数据段的地址信息。
</p>

<p>
可以通过一下命令查看物理内存划分出的各个段的信息(64位系统):
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat /proc/iomem
00000000-00000fff : Reserved
00001000-00057fff : System RAM
00058000-00058fff : Reserved
00059000-0009efff : System RAM
0009f000-000fffff : Reserved
  000a0000-000bffff : PCI Bus 0000:00
  000c0000-000cffff : Video ROM
  000f0000-000fffff : System ROM
00100000-81860fff : System RAM
81861000-81861fff : ACPI Non-volatile Storage
81862000-81862fff : Reserved
81863000-850c4fff : System RAM
850c5000-85305fff : Reserved
85306000-88ad8fff : System RAM
88ad9000-88ad9fff : Reserved
88ada000-8a32efff : System RAM
8a32f000-8a631fff : Reserved
8a632000-8a799fff : System RAM
......
</pre>
</div>
</div>
</div>

<div id="outline-container-org9ce1c45" class="outline-4">
<h4 id="org9ce1c45"><span class="section-number-4">4.2.2</span> 初始化步骤</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
<b>IA-32的初始化步骤：</b>
</p>

<div class="org-src-container">
<pre class="src src-fundamental">setup_arch
	1. machine_specific_memory_setup
	2. parse_early_param
	3. setup_memory
	4. paging_init
		pagetable_init
	5. zone_sizes_init
		add_active_range
		free_area_init_nodes

1. &#21019;&#24314;&#19968;&#20010;&#21015;&#34920;, &#21253;&#21547;&#31995;&#32479;&#21344;&#25454;&#30340;&#20869;&#23384;&#21435;&#21644;&#31354;&#38386;&#20869;&#23384;&#21306;. (dmesg&#65306;BIOS-provided physical RAM map:)
2. &#35299;&#26512;&#21629;&#20196;&#34892;(mem=XXX, highmem=XXX, memmap=XXX ......)
3. &#30830;&#23450;&#33410;&#28857;&#21487;&#29992;&#30340;&#29289;&#29702;&#20869;&#23384;&#39029;&#30340;&#25968;&#30446;
   &#21021;&#22987;&#21270;bootmem&#20998;&#37197;&#22120;
   &#20998;&#37197;&#21508;&#31181;&#20869;&#23384;&#21306;(&#20363;&#22914;, &#36816;&#34892;&#31532;&#19968;&#20010;&#29992;&#25143;&#31354;&#38388;&#36807;&#31243;&#25152;&#38656;&#30340;&#26368;&#21021;&#30340;RAM&#30913;&#30424;

4. &#21021;&#22987;&#21270;&#20869;&#26680;&#39029;&#34920;,&#24182;&#21551;&#29992;&#20869;&#23384;&#20998;&#39029;
   &#36890;&#36807;&#35843;&#29992;pagetable_init, &#30830;&#20445;&#20102;&#30452;&#25509;&#26144;&#23556;&#21040;&#20869;&#26680;&#22320;&#22336;&#31354;&#38388;&#30340;&#29289;&#29702;&#20869;&#23384;&#34987;&#21021;&#22987;&#21270;.
5. &#21021;&#22987;&#21270;&#31995;&#32479;&#20013;&#25152;&#26377;&#33410;&#28857;&#30340;pgdat_t&#23454;&#20363;
   &#35843;&#29992;add_active_range&#23545;&#21487;&#29992;&#30340;&#29289;&#29702;&#20869;&#23384;&#24314;&#31435;&#19968;&#20010;&#21015;&#34920;;
   free_area_init_nodes&#20351;&#29992;&#19978;&#36848;&#20449;&#24687;&#24314;&#31435;&#23436;&#22791;&#30340;&#20869;&#26680;&#25968;&#25454;&#32467;&#26500;&#12290;
</pre>
</div>

<p>
<b>AMD64的初始化步骤：</b>
</p>
<div class="org-src-container">
<pre class="src src-fundamental">setup_arch
	1. setup_memory_region
	2. parse_early_param
	3. e820_register_active_region
		add_active_range
	4. init_memory_mapping
	5. config_initmem_init
	6. paging_init
		free_area_init_nodes

1. &#23436;&#25104;&#22522;&#26412;&#30340;&#20869;&#23384;&#35774;&#32622;, &#21487;&#29992;&#30340;&#20869;&#23384;&#20449;&#24687;&#30001;BIOS&#25552;&#20379;&#30340;E820&#26144;&#23556;&#32473;&#20986;.
2. &#35299;&#26512;&#21629;&#20196;&#34892;.
3. e820_register_active_region&#36890;&#36807;&#20998;&#26512;&#19978;&#36848;&#30340;E820&#26144;&#23556;&#24471;&#21040;&#30456;&#20851;&#20449;&#24687;&#21518;, &#35843;&#29992;add_active&#21019;&#24314;&#21487;&#29992;&#20869;&#23384;&#30340;&#19968;&#20010;&#31616;&#21333;&#21015;&#34920;.
4. &#23558;&#21487;&#29992;&#30340;&#29289;&#29702;&#20869;&#23384;&#30452;&#25509;&#26144;&#23556;&#21040;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#20013;&#20174;PAGE_OFFSET&#24320;&#22987;&#30340;&#20869;&#26680;&#22320;&#22336;&#31354;&#38388;.
5. &#28608;&#27963;bootmen&#20998;&#37197;&#22120;.
6. &#22788;&#29702;&#19968;&#20123;&#31232;&#30095;&#20869;&#23384;&#31995;&#32479;&#30340;&#35774;&#32622;&#20363;&#31243;,

</pre>
</div>
</div>
</div>

<div id="outline-container-org2bf4551" class="outline-4">
<h4 id="org2bf4551"><span class="section-number-4">4.2.3</span> 分页机制的初始化</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
paging_init负责建立只能用于内核的页表, 用户空间无法访问.
</p>

<p>
IA-32系统上内核通常将4GB可用的虚拟地址空间按3:1的比例划分. 低端3GB用于用户状态的应用程序, 高端1GB用于内核空间.
</p>

<p>
如此划分地址空间的动机如下:
</p>

<ul class="org-ul">
<li>在用户应用程序从用户态切换到核心态时, 内核必须装载在一个可靠的环境中, 因此有必要将地址空间的一部分分配给内核专用.</li>
<li>物理内存页映射到内核地址空间的起始处, 以便内核直接访问, 而无需复杂的页表操作.</li>
</ul>
</div>

<div id="outline-container-org8be8b1c" class="outline-5">
<h5 id="org8be8b1c"><span class="section-number-5">4.2.3.1</span> 内核地址空间的划分</h5>
<div class="outline-text-5" id="text-4-2-3-1">
<div class="org-src-container">
<pre class="src src-text">
&#29992;&#26469;&#31649;&#29702;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#30340;&#31532;4GB&#39029;&#34920;&#30340;&#32467;&#26500;, &#26631;&#26126;&#20102;&#22320;&#22336;&#31354;&#38388;&#30340;&#21508;&#20010;&#21306;&#22495;&#30340;&#29992;&#36884;, &#19982;&#29289;&#29702;&#20869;&#23384;&#30340;&#20998;&#37197;&#26080;&#20851;

1                         2      3          4   5        6        7
|_________________________|______|__________|___|________|________|
   &#30452;&#25509;&#26144;&#23556;&#30340;&#25152;&#26377;&#29289;&#29702;&#39029;&#24103;      8MB     VMALLOC       &#25345;&#20037;&#26144;&#23556;   &#22266;&#23450;&#26144;&#23556;

1: PAGE_OFFSET(0xC0000000)
2: high_memory
3: VMALLOC_START
4: VMALLOC_END
5: PKMAP_BASE
6: FIXADDR_START
7: 4GB
</pre>
</div>

<p>
第一段将系统的所有物理内存页映射到内核的虚拟地址空间中. 内核地址空间从偏移量0xC0000000(3GB)开始, 即每个虚拟地址x对应于物理地址(x - 0xC0000000).
</p>

<p>
直接映射区域从0xC0000000到和high_memory地址, 如果物理内存超过896MB, 无法直接映射全部的物理内存. 此值小于1GB是由于内核要保留128MB的地址空间用于其他目的。 内核中经常使用缩写normal和highmem来区分是否可以直接映射的页帧。
</p>

<p>
内核移植的每个体系结构都必须提供两个宏, 用于一致映射的内核虚拟内存部分, 进行无力和虚拟地址之间的转换.
</p>

<ul class="org-ul">
<li>__pa(vaddr) 返回与虚拟地址vaddr相关的物理地址</li>
<li>__va(paddr) 计算出对应于物理地址paddr的虚拟地址</li>
</ul>

<p>
这些函数不使用与处理虚拟地址空间中的任意地址, 只能用于其中的一致映射部分.
</p>

<p>
内核地址空间的最后128MB的用途:
</p>

<ol class="org-ol">
<li>虚拟内存中连续, 但物理内存不连续的内存区, 可以在vmalloc区域中分配.</li>

<li>持久映射用于将高端内存域中的非持久页映射到内核中.</li>

<li>固定映射是与物理地址空间中的固定页关联的虚拟地址空间项, 但具体关联的页帧可以自由选择. 与直接映射页相反, 虚拟固定映射地址与物理内存位置之间的关联可以自行定义, 关联建立后内核总是会注意到.</li>
</ol>



<p>
VMALLOC_OFFSET使得在直接映射的所有内存页和用于非连续分配的区域之间保留"空洞", 可以用作访问越界地址异常。
</p>

<p>
同理VMALLOC_START 至 VMALLOC_END区域中的vmalloc区域之间也会保留4KB的"空洞"。
</p>

<p>
固定映射区域可以指向物理内存的随机位置，该映射内部的虚拟地址和物理地址之间的关联不需要预设, 可以自由定义，定义之后不可改变，固定映射区域会一直延伸到虚拟地址空间的顶端。
</p>
</div>
</div>


<div id="outline-container-orgca056e2" class="outline-5">
<h5 id="orgca056e2"><span class="section-number-5">4.2.3.2</span> 划分虚拟地址空间</h5>
<div class="outline-text-5" id="text-4-2-3-2">

<div class="figure">
<p><img src="plantuml/memory/paging-init.png" alt="paging-init.png" />
</p>
</div>

<p>
pagetable_init 首先以swapper_pg_dir为基础，初始化系统的页表。然后启动IA-32系统上可用的两个扩展：
</p>

<ul class="org-ul">
<li>对超大内存页的支持。这些特别标记的页，其长度为4 MiB，而不是普通的4 KiB。该选项用于不会换出的内核页。增加页大小，使得页表项变少，这对地址转换后备缓冲器（TLB）有好处，可以减少其中来自内核的缓存项（节省TLB空间）。</li>

<li><p>
如果有可能，内核页还会设置 __PAGE_GLOBAL 属性。 变量 __PAGE_KERNEL 和 __PAGE_KERNEL_EXEC 指定了内核自身分配页帧的标志集，因此会将这两个变量设置 __PAGE_GLOBAL 属性。
</p>

<p>
注意： 在上下文切换期间，设置了 __PAGE_GLOBAL 位的页，对应的TLB缓存项不从TLB刷出。由于内核总是出现于虚拟地址空间中同样的位置，这提高了系统性能。
</p></li>
</ul>

<p>
借助于 kernel_physical_mapping_init初始化直接映射内存区，将物理内存页映射到虚拟地址空间中从 PAGE_OFFSET 开始的位置。内核接下来扫描各个页目录的所有相关项，将指针设置为正确的值。
</p>

<p>
接下来建立固定映射项和持久内核映射对应的内存区。同样是用适当的值填充页表。在用 pagetable_init 完成页表初始化之后，则将 cr3 寄存器设置为指向全局页目录（ swapper_pg_dir ）的指针。此时必须激活新的页表。在IA-32计算机上 cr3 寄存器重赋值刚好有这样的效果。
</p>

<p>
由于TLB缓存项仍然包含了启动时分配的一些内存地址数据，此时也必须刷出，__flush_all_tlb 可完成所需的工作。与上下文切换期间相反，设置了 _PAGE_GLOBAL 位的页也要刷出。
</p>

<p>
kmap_init 初始化全局变量 kmap_pte 。在从高端内存域将页映射到内核地址空间时，会使用该变量存入相应内存区的页表项。此外，用于高端内存内核映射的第一个固定映射内存区的地址保存在全局变量 kmem_vstart 中。
</p>
</div>
</div>

<div id="outline-container-org0972275" class="outline-5">
<h5 id="org0972275"><span class="section-number-5">4.2.3.3</span> 冷热缓存的初始化</h5>
<div class="outline-text-5" id="text-4-2-3-3">
<p>
冷热缓存通过 zone_pcp_init 函数来初始化。通过 free_area_init_nodes 发起调用。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> __meminit <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">zone_pcp_init</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> *<span style="color: #FF8C00;">zone</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">cpu</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#35745;&#31639;&#25209;&#37327;&#22823;&#23567;&#65292;&#29992;&#20110;&#35745;&#31639;&#26368;&#23567;&#21644;&#26368;&#22823;&#22635;&#20805;&#27700;&#24179;&#30340;&#22522;&#30784;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">batch</span> = zone_batchsize(zone);

	<span style="color: #FF1493;">for</span> (cpu = 0; cpu &lt; NR_CPUS; cpu++) {
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22635;&#20805;&#27599;&#20010;CPU&#30340; per_cpu_pageset &#23454;&#20363;&#30340;&#24120;&#37327;&#12290;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">zone_pcp &#36873;&#25321;&#19982;&#24403;&#21069;CPU&#30456;&#20851;&#30340;&#20869;&#23384;&#22495;&#30340; pageset &#23454;&#20363;&#12290;</span>
		setup_pageset(zone_pcp(zone,cpu), batch);
	}
	<span style="color: #FF1493;">if</span> (zone-&gt;present_pages)
		printk(KERN_DEBUG <span style="color: #CDC673;">"  %s zone: %lu pages, LIFO batch:%lu\n"</span>,
			zone-&gt;name, zone-&gt;present_pages, batch);
}

<span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">setup_pageset</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">per_cpu_pageset</span> *<span style="color: #FF8C00;">p</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">batch</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">per_cpu_pages</span> *<span style="color: #FF8C00;">pcp</span>;

	memset(p, 0, <span style="color: #FF1493;">sizeof</span>(*p));

	pcp = &amp;p-&gt;pcp[0];               <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#28909;&#39029;</span><span style="color: #8B8878;"> */</span>
	pcp-&gt;count = 0;
	pcp-&gt;high = 6 * batch;
	pcp-&gt;batch = max(1UL, 1 * batch);
	INIT_LIST_HEAD(&amp;pcp-&gt;list);

	pcp = &amp;p-&gt;pcp[1];               <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20919;&#39029;</span><span style="color: #8B8878;"> */</span>
	pcp-&gt;count = 0;
	pcp-&gt;high = 2 * batch;
	pcp-&gt;batch = max(1UL, batch/2);
	INIT_LIST_HEAD(&amp;pcp-&gt;list);
}
</pre>
</div>

<p>
zone_pcp_init 会输出各个内存域的页数，以及计算出的批量大小：
</p>

<div class="org-src-container">
<pre class="src src-shell">$ dmesg | grep LIFO
[    0.008114]   DMA zone: 3997 pages, LIFO batch:0
[    0.008116]   DMA32 zone: 562326 pages, LIFO batch:63
[    0.008117]   Normal zone: 1503232 pages, LIFO batch:63
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga1fcad3" class="outline-4">
<h4 id="orga1fcad3"><span class="section-number-4">4.2.4</span> 注册活动内存区</h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
活动内存区就是不包含空洞的内存区. 必须使用add_active_range在全局变量early_node_map中注册内存区。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">node_active_region</span> <span style="color: #5FD7FF;">__meminitdata</span> <span style="color: #FF8C00;">early_node_map</span>[MAX_ACTIVE_REGIONS];
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">__meminitdata</span> nr_nodemap_entries;
</pre>
</div>

<p>
当前注册的内存区数目记载在 nr_nodemap_entries中。
</p>

<p>
内存区的数据结构：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">node_active_region</span> {
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#27492;&#20869;&#23384;&#21306;&#20013;&#30340;&#31532;&#19968;&#20010;&#39029;&#24103;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">start_pfn</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#27492;&#20869;&#23384;&#21306;&#20013;&#30340;&#26368;&#21518;&#19968;&#20010;&#39029;&#24103;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">end_pfn</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20869;&#23384;&#21306;&#25152;&#23646;&#33410;&#28857;&#30340;NUMA ID</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nid</span>;
};
</pre>
</div>

<p>
活动内存区使用 add_active_range 注册：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;"> * &#27492;&#20989;&#25968;&#20250;&#23558;&#27880;&#20876;&#30340;&#21306;&#38388;&#23384;&#20648;&#22312; early_node_map &#20013;&#65292;&#20043;&#21518;&#36890;&#36807;</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">free_area_init_nodes()</span><span style="color: #CDC673;"> &#20989;&#25968;&#35745;&#31639;&#21306;&#22495;&#22823;&#23567;&#20197;&#21450;&#31354;&#27934;&#12290;</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> * &#22914;&#26524;&#21487;&#20197;&#65292;&#35813;&#20989;&#25968;&#36824;&#20250;&#21644;&#20197;&#23384;&#22312;&#30340;&#20869;&#23384;&#21306;&#36827;&#34892;&#21512;&#24182;&#12290;</span>
<span style="color: #CDC673;"> */</span>
<span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__init</span> add_active_range(<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nid</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">start_pfn</span>,
			     <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">end_pfn</span>)
</pre>
</div>
</div>

<div id="outline-container-org7544277" class="outline-5">
<h5 id="org7544277"><span class="section-number-5">4.2.4.1</span> IA-32上注册内存区</h5>
<div class="outline-text-5" id="text-4-2-4-1">
<p>
在IA-32系统上，通过 zone_size_init 调用 add_active_range 进行注册，此外 zone_size_init 函数还以页帧为单位，存储了不同内存区的边界。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__init</span> zone_sizes_init(<span style="color: #5FD7FF;">void</span>)
{
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">max_zone_pfns</span>[MAX_NR_ZONES];
	memset(max_zone_pfns, 0, <span style="color: #FF1493;">sizeof</span>(max_zone_pfns));

	<span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;">        MAX_DMA_ADDRESS &#26159;&#36866;&#29992;&#20110;DMA&#25805;&#20316;&#30340;&#26368;&#39640;&#20869;&#23384;&#22320;&#22336;&#12290;&#35813;&#24120;&#25968;&#22768;&#26126;&#20026; PAGE_OFFSET+0x1000000 &#12290;</span>
<span style="color: #CDC673;">        &#29289;&#29702;&#20869;&#23384;&#39029;&#26144;&#23556;&#21040;&#20174; PAGE_OFFSET &#24320;&#22987;&#30340;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#65292;&#32780;&#29289;&#29702;&#20869;&#23384;&#30340;&#21069;16 MiB&#36866;&#21512;&#20110;DMA&#25805;</span>
<span style="color: #CDC673;">        &#20316;&#65292;&#21313;&#20845;&#36827;&#21046;&#34920;&#31034;&#23601;&#26159;&#21069; 0x1000000 &#23383;&#33410;&#12290;</span>

<span style="color: #CDC673;">        &#29992; virt_to_phys &#36716;&#25442;&#65292;&#33719;&#24471;&#29289;&#29702;&#20869;&#23384;&#22320;&#22336;&#65292;&#21491;&#31227; PAGE_SHIFT &#20301;&#30456;&#24403;&#20110;&#38500;&#20197;&#39029;&#22823;&#23567;&#65292;&#35745;&#31639;&#26368;</span>
<span style="color: #CDC673;">        &#21518;&#24471;&#21040;&#36866;&#29992;&#20110;DMA&#30340;&#39029;&#25968;&#12290;</span>
<span style="color: #CDC673;">        */</span>
	max_zone_pfns[ZONE_DMA] =
		virt_to_phys((<span style="color: #5FD7FF;">char</span> *)MAX_DMA_ADDRESS) &gt;&gt; PAGE_SHIFT;
	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
<span style="color: #FF1493;">#ifdef</span> CONFIG_HIGHMEM
	<span style="color: #8B8878;">// </span><span style="color: #8B8878;">highend_pfn &#25351;&#23450;&#39640;&#31471;&#20869;&#23384;&#20013;&#30340;&#26368;&#39640;&#39029;&#21495;&#12290;</span>
	max_zone_pfns[ZONE_HIGHMEM] = highend_pfn;
	add_active_range(0, 0, highend_pfn);
<span style="color: #FF1493;">#else</span>
	<span style="color: #8B8878;">// </span><span style="color: #8B8878;">max_low_pfn &#25351;&#23450;&#20302;&#31471;&#20869;&#23384;&#30340;&#26368;&#39640;&#39029;&#21495;&#12290;</span>
	add_active_range(0, 0, max_low_pfn);
<span style="color: #FF1493;">#endif</span>

	free_area_init_nodes(max_zone_pfns);
}
</pre>
</div>

<p>
free_area_init_nodes 会合并 early_mem_map 和 max_zone_pfns 中的信息。
</p>
</div>
</div>

<div id="outline-container-org400e8ac" class="outline-5">
<h5 id="org400e8ac"><span class="section-number-5">4.2.4.2</span> AMD64上注册内存区</h5>
<div class="outline-text-5" id="text-4-2-4-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__init</span>
e820_register_active_regions(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nid</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">start_pfn</span>,
							<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">end_pfn</span>)
{
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">ei_startpfn</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">ei_endpfn</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;BIOS&#25552;&#20379;&#30340;&#20449;&#24687;&#65292;&#25214;&#21040;&#27963;&#21160;&#30340;&#20869;&#23384;&#21306;&#65292;&#24182;&#36890;&#36807; add_active_range &#36827;&#34892;&#27880;&#20876;&#12290;</span>
	<span style="color: #FF1493;">for</span> (i = 0; i &lt; e820.nr_map; i++)
		<span style="color: #FF1493;">if</span> (e820_find_active_region(&amp;e820.map[i],
					    start_pfn, end_pfn,
					    &amp;ei_startpfn, &amp;ei_endpfn))
			add_active_range(nid, ei_startpfn, ei_endpfn);
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">16MB ISA DMA zone</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">MAX_DMA_PFN</span>   ((16*1024*1024) &gt;&gt; PAGE_SHIFT)

<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">4GB broken PCI/AGP hardware bus master zone</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">MAX_DMA32_PFN</span> ((4UL*1024*1024*1024) &gt;&gt; PAGE_SHIFT)
<span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__init</span> paging_init(<span style="color: #5FD7FF;">void</span>)
{
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">max_zone_pfns</span>[MAX_NR_ZONES];
	memset(max_zone_pfns, 0, <span style="color: #FF1493;">sizeof</span>(max_zone_pfns));
	max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
	max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
	max_zone_pfns[ZONE_NORMAL] = end_pfn;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">end_pfn &#20026;&#26816;&#27979;&#21040;&#30340;&#26368;&#22823;&#39029;&#24103;&#32534;&#21495;&#12290;</span>
	<span style="color: #8B8878;">// </span><span style="color: #8B8878;">AMD64 &#19981;&#38656;&#35201;&#39640;&#31471;&#20869;&#23384;&#22495;&#65292; &#22240;&#27492;max_zone_pfns&#30340;&#39640;&#31471;&#20869;&#23384;&#22495;&#20026;NULL&#12290;</span>
	memory_present(0, 0, end_pfn);
	sparse_init();
	free_area_init_nodes(max_zone_pfns);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcd7d107" class="outline-4">
<h4 id="orgcd7d107"><span class="section-number-4">4.2.5</span> AMD64地址空间的设置</h4>
<div class="outline-text-4" id="text-4-2-5">
<p>
由于64位地址空间跨度太大, 当前只使用了48位的地址空间, 48位宽的地址字可以寻址256TB的地址空间.
尽管物理地址字位宽被限制在48位, 但在寻址虚拟地址空间是仍然使用了64位指针, 因而虚拟地址空间形式上仍然会跨越2<sup>64</sup>字节.
</p>

<p>
AMD64计算机上虚拟地址到物理地址空间映射方式:
虚拟地址的第47位([0,46])可以任意设置,而比特位[47,63]的之总是相同的: 或者全0, 或者全1. 因此整个地址空间划分位3部分: 下半部、上半部、中间禁用的区域. 上下两部分共同构成跨越2<sup>48</sup>字节的地址空间.
</p>

<p>
下半部地址空间:  0x0,                   0x0000 7FFF FFFF FFFF
上半部地址空间:  0xFFFF 8000 0000 0000, 0xFFFF FFFF FFFF FFFF
</p>


<div class="figure">
<p><img src="image/memory/amd64-vm-pm.png" alt="amd64-vm-pm.png" />
</p>
</div>


<p>
Linux内核在AMD64计算机上的虚拟地址空间的布局：
<img src="image/memory/amd64-vm-layout.png" alt="amd64-vm-layout.png" />
</p>

<p>
可访问的地址空间的整个下半部作为用户空间，上半部专用于内核。内核地址空间起始于一个起防护作用的空洞，以防止偶然访问地址空间的非规范部分。如果访问，处理器会引发一个一般性保护异常（general protection exception）。物理内存页则一致映射到从 PAGE_OFFSET 开始的内核空间中。2<sup>46</sup>字节（MAXMEM指定，总计64TB）专用于物理页帧。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#define</span> <span style="color: #87D700;">__AC</span>(<span style="color: #FF8C00;">X</span>,<span style="color: #FF8C00;">Y</span>)       (X##Y)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">_AC</span>(<span style="color: #FF8C00;">X</span>,<span style="color: #FF8C00;">Y</span>)        __AC(X,Y)
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__PAGE_OFFSET</span>   _AC(0xffff810000000000, UL)
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">PAGE_OFFSET</span>     __PAGE_OFFSET
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">MAXMEM</span>          _AC(0x3fffffffffff, UL)
</pre>
</div>

<p>
一致映射内存区和vmalloc内存区之间还有一个防护性空洞，范围从 VMALLOC_START 到 VMALLOC_END ：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">VMALLOC_START</span> _AC(0xffffc20000000000, UL)
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">VMALLOC_END</span> _AC(0xffffe1ffffffffff, UL)
</pre>
</div>

<p>
内核代码段映射到从 __START_KERNEL_MAP 开始的内存区。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">&#22914;&#26524;&#35201;&#32534;&#35793;&#21487;&#37325;&#23450;&#20301;&#20869;&#26680;&#26102;&#65292;&#21487;&#20197;&#37197;&#32622;&#20869;&#26680;&#20195;&#30721;&#27573;&#26144;&#23556;&#30340;&#36215;&#22987;&#22320;&#22336;&#65292;</span>
<span style="color: #8B8878;">&#26368;&#32456;&#30340;&#22320;&#22336; __START_KERNEL &#38656;&#35201;&#23545;&#40784;&#21040; __KERNEL_ALIGN&#12290;</span>
<span style="color: #8B8878;">*/</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__PHYSICAL_START</span>          CONFIG_PHYSICAL_START
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__KERNEL_ALIGN</span>          0x200000

<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__START_KERNEL</span>          (__START_KERNEL_map + __PHYSICAL_START)
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__START_KERNEL_map</span>      _AC(0xffffffff80000000, UL)
<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">&#20445;&#30041;&#32473;&#20869;&#26680;&#20108;&#36827;&#21046;&#20195;&#30721;&#30340;&#20869;&#23384;&#21306;&#38271;&#24230;&#20026; KERNEL_TEXT_SIZE &#65292;&#24403;&#21069;&#23450;&#20041;&#20026;40MB&#12290;</span>
<span style="color: #8B8878;">*/</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">KERNEL_TEXT_SIZE</span>          (40*1024*1024)
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">KERNEL_TEXT_START</span>         _AC(0xffffffff80000000, UL)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org26bfc49" class="outline-3">
<h3 id="org26bfc49"><span class="section-number-3">4.3</span> 启动过程中的内存管理</h3>
<div class="outline-text-3" id="text-4-3">
<p>
bootmem分配器用于在启动阶段早期分配内存。该分配器用一个位图来管理页， 位图比特位数目与系统中的物理内存页的数目相同。需要内存时逐个扫描位图，直至找到一个能够提供连续内存的位置。
</p>
</div>

<div id="outline-container-org608484e" class="outline-4">
<h4 id="org608484e"><span class="section-number-4">4.3.1</span> 数据结构</h4>
<div class="outline-text-4" id="text-4-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">typedef</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">bootmem_data</span> {
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20445;&#23384;&#31995;&#32479;&#20013;&#31532;&#19968;&#20010;&#39029;&#30340;&#32534;&#21495;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">node_boot_start</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21487;&#20197;&#30452;&#25509;&#31649;&#29702;&#30340;&#29289;&#29702;&#22320;&#22336;&#31354;&#38388;&#30340;&#26368;&#21518;&#19968;&#39029;&#30340;&#32534;&#21495;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">node_low_pfn</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25351;&#21521;&#23384;&#20648;&#20998;&#37197;&#20301;&#22270;&#30340;&#25351;&#38024;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">node_bootmem_map</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#19978;&#27425;&#20998;&#37197;&#30340;&#39029;&#20869;&#20559;&#31227;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">last_offset</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#19978;&#19968;&#27425;&#20998;&#37197;&#39029;&#30340;&#32534;&#21495;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">last_pos</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#19978;&#19968;&#27425;&#25104;&#21151;&#20998;&#37197;&#20869;&#23384;&#30340;&#20301;&#32622;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">last_success</span>;
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         * &#20869;&#23384;&#19981;&#36830;&#32493;&#30340;&#31995;&#32479;&#38656;&#35201;&#22810;&#20010;bootmem&#20998;&#37197;&#22120;</span>
<span style="color: #8B8878;">         * &#38142;&#34920;&#22836;&#26159;&#20840;&#23616;&#21464;&#37327; bdata_list</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">list_head</span> <span style="color: #FF8C00;">list</span>;
} <span style="color: #5FD7FF;">bootmem_data_t</span>;

</pre>
</div>
</div>
</div>

<div id="outline-container-orgb6dbd96" class="outline-4">
<h4 id="orgb6dbd96"><span class="section-number-4">4.3.2</span> 初始化</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>IA-32</li>
</ul>


<div class="figure">
<p><img src="plantuml/memory/ia32-bootmem.png" alt="ia32-bootmem.png" />
</p>
</div>

<p>
setup_bootmem_allocator ，会bootmem分配器。它首先调用通用函数 init_bootmem ，该函数是 init_bootmem_core 的一个前端。
</p>

<p>
init_bootmem_core 执行bootmem分配器的第一个初始化步骤。先前检测到的低端内存页帧的范围输入到相应的 bootmem_data_t 实例（这里是contig_bootmem_data ）中。最初在位图contig_bootmemdata-&gt;node_bootmem_map 中，所有的页都标记为已用。
</p>

<p>
init_bootmem_core 是一个体系结构无关的函数，它尚无法知道哪些页可用，哪些页不能使用。由于体系结构方面的原因，有些页需要特殊的处理，例如IA-32系统上的0页。有些页则已经使用，例如内核映像占用的页。实际可用的页必须由体系结构相关的代码显式标记出来。标记过程由两个特定于体系结构的函数完成：
</p>
<ul class="org-ul">
<li>register_bootmem_low_pages:  该函数通过将位图中对应的比特位清零，释放所有潜在可用的内存页。在IA-32系统上BIOS对该任务提供了支持，BIOS向内核提供了可用内存区的列表，即初始化过程中更早一点提供的e820映射。</li>

<li>reserve_bootmem: 由于bootmem分配器需要一些内存页管理分配位图，必须首先调用 reserve_bootmem 分配这些内存页。还有一些已经在使用中的的内存区，以及与内核配置相关的内存区，都需要使用 reserve_bootmem 注册对应的页。</li>
</ul>
<ul class="org-ul">
<li>AMD64</li>
</ul>


<div class="figure">
<p><img src="plantuml/memory/amd64-bootmem.png" alt="amd64-bootmem.png" />
</p>
</div>

<p>
首先，bootmem_bootmap_pages 计算bootmem位图所需页的数目，函数使用BIOS在e820映射提供的信息，相应的位图可用于查找长度适当的连续内存区。
</p>

<p>
然后，使用 init_bootmem 将该信息填充到体系结构无关的bootmem数据结构中。该函数将所有的页都标记为已分配，而现在必须选出空闲页。 free_bootmem_with_active_regions 可以再次使用e820映射中的信息，按照BIOS报告的使用情况，释放所有实际空闲的内存区。最后调用 reserve_bootmem 注册bootmem分配位图所需的空间。
</p>
</div>
</div>

<div id="outline-container-org8462234" class="outline-4">
<h4 id="org8462234"><span class="section-number-4">4.3.3</span> 对内核的接口</h4>
<div class="outline-text-4" id="text-4-3-3">
</div>
<div id="outline-container-orgaac515c" class="outline-5">
<h5 id="orgaac515c"><span class="section-number-5">4.3.3.1</span> 分配内存</h5>
<div class="outline-text-5" id="text-4-3-3-1">
<p>
分配函数：
</p>
<ul class="org-ul">
<li>alloc_bootmem(size) 和 alloc_bootmem_pages(size) 按指定大小在 ZONE_NORMAL 内存域分配内存。数据是对齐的，这使得内存或者从可适用于L1高速缓存的理想位置开始，或者从页边界开始。</li>

<li>alloc_bootmem_low 和 alloc_bootmem_low_pages 是从ZONE_DMA 内存域分配内存。因此，只有需要DMA内存时，才使用该函数。</li>
</ul>

<p>
NUMA系统的API是类似的，只在函数名增加 _node 后缀，以及指定用于内存分配的结点的参数。
</p>

<p>
上述函数都是__alloc_bootmem 的前端，实际工作由__alloc_bootmem_nopanic 处理。由于可以注册多个bootmem分配器，__alloc_bootmem_core 会遍历所有的分配器，直至分配成功为止。
</p>

<p>
在NUMA系统上，__alloc_bootmem_node 则用于实现该API函数。首先，工作传递到 __alloc_bootmem_core ，尝试在该结点的bootmem分配器进行分配。如果失败，则后退到 __alloc_bootmem ，并将尝试所有的结点。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> * <span style="color: #87D700;">__init</span> __alloc_bootmem(<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">size</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">align</span>,
				<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">goal</span>)
</pre>
</div>
<p>
__alloc_bootmem 需要3个参数来描述内存分配请求：
</p>
<ul class="org-ul">
<li>size 是所需内存区的长度</li>
<li>align 表示数据的对齐方式</li>
<li>goal 指定了开始搜索适当空闲内存区的起始地址。</li>
</ul>

<p>
各个前端使用__alloc_bootmem的方式如下：
</p>
<div class="org-src-container">
<pre class="src src-c">&lt;bootmem.h&gt;
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">alloc_bootmem</span>(<span style="color: #FF8C00;">x</span>) \
	__alloc_bootmem((x), SMP_CACHE_BYTES, __pa(MAX_DMA_ADDRESS))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">alloc_bootmem_low</span>(<span style="color: #FF8C00;">x</span>) \
	__alloc_bootmem((x), SMP_CACHE_BYTES, 0)
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">alloc_bootmem_pages</span>(<span style="color: #FF8C00;">x</span>) \
	__alloc_bootmem((x), PAGE_SIZE, __pa(MAX_DMA_ADDRESS))
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">alloc_bootmem_low_pages</span>(<span style="color: #FF8C00;">x</span>) \
	__alloc_bootmem((x), PAGE_SIZE, 0)
</pre>
</div>

<p>
内存对齐方式有两个选项：
</p>
<ul class="org-ul">
<li>SMP_CACHE_BYTES 会对齐数据，使之在大多数体系结构上能够理想地置于L1高速缓存中。</li>
<li>PAGE_SIZE 将数据对齐到页边界。后一种对齐方式适用于分配一个或多个整页。</li>
</ul>

<p>
低端DMA内存与普通内存的区别在于其起始地址。搜索DMA的内存从地址0开始，而请求普通内存时则从 MAX_DMA_ADDRESS 向上（ __pa 将内存地址转换为页号）。
</p>

<p>
__alloc_bootmem_core 函数大概执行一下操作：
</p>
<ol class="org-ol">
<li>从 goal 开始，扫描位图，查找满足分配请求的空闲内存区。</li>
<li>如果目标页紧接着上一次分配的页，即 bootmem_data-&gt; last_pos ，内核会检查 bootmem_data-&gt;last_offset ，判断所需的内存（包括对齐数据所需的空间）是否能够在上一页分配或从上一页开始分配。</li>
<li>新分配的页在位图对应的比特位设置为1。最后一页的数目也保存在bootmem_data-&gt;last_pos。如果该页未完全分配，则相应的偏移量保存在bootmem_data-&gt;last_offset；否则，该值设置为0。</li>
</ol>
</div>
</div>

<div id="outline-container-org8da601a" class="outline-5">
<h5 id="org8da601a"><span class="section-number-5">4.3.3.2</span> 释放内存</h5>
<div class="outline-text-5" id="text-4-3-3-2">
<p>
free_bootmem 函数负责内存的释放：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__init</span> free_bootmem(<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">addr</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">size</span>);
<span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__init</span> free_bootmem_node(<span style="color: #5FD7FF;">pg_data_t</span> *<span style="color: #FF8C00;">pgdat</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">physaddr</span>,
			      <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">size</span>);
</pre>
</div>

<p>
两个函数都通过__free_bootmem_core完成释放。该函数只能释放整页，因为bootmem分配器没有保存有关页划分的任何信息。__free_bootmem_core 首先计算完全包含在该内存区中的将被释放的页，部分包含在内存区中的页将忽略，位图中对应的项设置为0，完成页的释放。
</p>

<p>
该过程隐藏了一些风险，如果页包含在两个不同的内存区中，那么连续释放这些内存区，却无法释放该页。包含页的前一半和后一半的内存区在间隔一段时间后分别被释放，分配器无法了解到该页是否不再使用，因而也无法释放。该页的状态就一直保持为“使用中”，尽管事实上不是这样。尽管如此，由于 free_bootmem 很少使用，这也不是大问题。系统初始化期间分配的大多数内存区都用于基本的数据结构，在内核运行的所有时间都需要使用，因此无需释放。
</p>
</div>
</div>
</div>

<div id="outline-container-org2f2b197" class="outline-4">
<h4 id="org2f2b197"><span class="section-number-4">4.3.4</span> 停用bootmem分配器</h4>
<div class="outline-text-4" id="text-4-3-4">
<p>
在伙伴系统分配器能够提供分配服务后，必须停用bootmem分配器。在UMA和NUMA系统上，停用分别由 free_all_bootmem 和 free_all_bootmem_node 完成。在伙伴系统建立之后，特定于体系结构的初始化代码会调用这两个函数。
</p>

<p>
实际的释放工作由 free_all_bootmem_core 函数来完成，该函数首先扫描bootmem分配器的页位图，释放每个未用的页。然后对每个空闲页调用 __free_pages_bootmem ，该函数内部调用 __free_page 函数，使得这些页并入伙伴系统的数据结构。
</p>

<p>
最后，释放bootmem分配器的页位图占用的空间。
</p>
</div>
</div>

<div id="outline-container-orgd155ea5" class="outline-4">
<h4 id="orgd155ea5"><span class="section-number-4">4.3.5</span> 释放初始化数据</h4>
<div class="outline-text-4" id="text-4-3-5">
<p>
许多内核代码块和数据表只在系统初始化阶段需要，在结构建立之后，这些例程就不再需要了。(例如：链接到内核的驱动程序，驱动程序用于检测其设备的硬件数据库等)
</p>

<p>
内核提供两个属性 __init 和 __initcall，用于标记初始化函数和数据。这些必须至于函数或数据声明之前。
</p>

<p>
此外，数据段也可以标记为初始化数据，通过 __init_data 属性来标记。
</p>

<p>
__init 和 __init_data 借助特殊的GNU C编译器语句来实现.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__init</span>          <span style="color: #FF1493;">__attribute__</span> ((__section__ (<span style="color: #CDC673;">".init.text"</span>))) __cold
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__initdata</span>      <span style="color: #FF1493;">__attribute__</span> ((__section__ (<span style="color: #CDC673;">".init.data"</span>)))
</pre>
</div>

<p>
通过 <span class="underline"><span class="underline">attribute</span></span> 关键字使用 <span class="underline"><span class="underline">section</span></span> 属性通知编译器将随后的数据分别写入二进制文件的 .init.text和 .init.data段。
</p>

<p>
readelf工具可以用来查看elf文件的各个段
</p>
<div class="org-src-container">
<pre class="src src-shell">readelf --sections vmlinux






















</pre>
</div>

<p>
内核定义了两个变量，__init_begin 和  __init_end。 free_initmem 利用此变量来释放用于初始化的内存，并将相关的页返回给伙伴系统。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgdd10159" class="outline-2">
<h2 id="orgdd10159"><span class="section-number-2">5</span> 物理内存的管理</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org11a3d42" class="outline-3">
<h3 id="org11a3d42"><span class="section-number-3">5.1</span> 伙伴系统结构</h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> {
...
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#19981;&#21516;&#38271;&#24230;&#30340;&#31354;&#38386;&#21306;&#22495;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">1 2 4 8 ......</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> free_area free_area[MAX_ORDER];
...
};

<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">free_area</span> {
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#20110;&#36830;&#25509;&#31354;&#38386;&#39029;&#30340;&#38142;&#34920;&#12290;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">list_head</span> <span style="color: #FF8C00;">free_list</span>[MIGRATE_TYPES];
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25351;&#23450;&#24403;&#21069;&#20869;&#23384;&#21306;&#20013;&#31354;&#38386;&#39029;&#22359;&#30340;&#25968;&#30446;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">nr_free</span>;
};

</pre>
</div>


<div class="figure">
<p><img src="./image/memory/buddy.png" alt="buddy.png" />
</p>
</div>

<p>
伙伴系统内存管理专注于某个结点的某个内存域，例如，DMA或高端内存域。但所有内存域和结点的伙伴系统都通过备用分配列表连接起来。如下图所示：
<img src="./image/memory/buddy-zone-node.png" alt="buddy-zone-node.png" />
</p>

<p>
在首选的内存域或节点无法满足内存分配请求时，首先尝试同一结点的另一个内存域，接下来再尝试另一个结点，直至满足请求。
</p>

<p>
获取伙伴系统但前状态信息 <b>/proc/buddyinfo</b> ：
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat /proc/buddyinfo
Node 0, zone      DMA      4      2      3      0      3      2      0      0      1      1      3
Node 0, zone    DMA32      9      8      7      8      6      6      8      7      4      5    527
Node 0, zone   Normal   1592    890    675    247    461    173    200     73     43     12    692
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd106985" class="outline-3">
<h3 id="orgd106985"><span class="section-number-3">5.2</span> 避免碎片</h3>
<div class="outline-text-3" id="text-5-2">
<p>
现代cpu都提供了使用巨型页的可能性，比普通页大得多。使用大页时，地址转换后备缓冲器只需处理较少的项，降低TLB缓存失效的可能性。
</p>
</div>

<div id="outline-container-org46134fb" class="outline-4">
<h4 id="org46134fb"><span class="section-number-4">5.2.1</span> 依据可移动性组织页</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
Linux中存在物理内存碎片的问题，为了防止物理碎片，内核试图从最开始尽可能的防止碎片。
</p>

<p>
内核将已分配页可以划分为3种类型：
</p>
<ul class="org-ul">
<li>不可移动页：在内存中有固定位置，不能移动到其他地方。核心内核分配的大多数内存属于该类别。</li>
<li>可回收页：不能直接移动，可以删除，其内容可以从某些源重新生成。例如映射自文件的数据属于该类别。</li>
<li>可移动页：可以随意移动。用户空间应用程序的页属于该类别。</li>
</ul>

<p>
内核根据页的可移动性将具有相同类型的页进行分组，这样在可移动性页中，就可以进行移动，释放出更大的连续空间，且不会受到不可移动页的影响。
</p>

<p>
最开始，内存并未根据可移动性分区，而是在运行时形成的。
</p>
</div>

<div id="outline-container-org480ae0e" class="outline-5">
<h5 id="org480ae0e"><span class="section-number-5">5.2.1.1</span> 数据结构</h5>
<div class="outline-text-5" id="text-5-2-1-1">
<p>
内核定义页的迁移类型：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">MIGRATE_UNMOVABLE</span>     0
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">MIGRATE_RECLAIMABLE</span>   1
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">MIGRATE_MOVABLE</span>       2
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">MIGRATE_RESERVE</span>       3
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">MIGRATE_ISOLATE</span>       4 <span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#19981;&#29992;&#20110;&#20998;&#37197;&#65292;&#29305;&#27530;&#30340;&#34394;&#25311;&#21306;&#22495;&#65292;&#29992;&#20110;&#36328;&#36234;NUMA&#32467;&#28857;&#31227;&#21160;&#29289;&#29702;&#20869;&#23384;&#39029;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">MIGRATE_TYPES</span>         5
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">free_area</span> {
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">list_head</span>        <span style="color: #FF8C00;">free_list</span>[MIGRATE_TYPES];
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25152;&#26377;&#21015;&#34920;&#19978;&#31354;&#38386;&#39029;&#30340;&#25968;&#30446;</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">nr_free</span>;
};

<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#20110;&#36845;&#20195;&#25351;&#23450;&#36801;&#31227;&#31867;&#22411;&#30340;&#25152;&#26377;&#20998;&#37197;&#38454;</span>
<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">for_each_migratetype_order</span>(<span style="color: #FF8C00;">order</span>, <span style="color: #FF8C00;">type</span>) \
	<span style="color: #FF1493;">for</span> (order = 0; order &lt; MAX_ORDER; order++) \
		<span style="color: #FF1493;">for</span> (type = 0; type &lt; MIGRATE_TYPES; type++)
</pre>
</div>

<p>
当内核无法满足针对某一给定迁移类型的内存分配请求时，内核提供了备用列表，规定了接下来使用哪种迁移类型的页：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * This array describes the order lists are fallen back to when</span>
<span style="color: #8B8878;"> * the free lists for the desirable migrate type are depleted</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">fallbacks</span>[MIGRATE_TYPES][MIGRATE_TYPES-1] = {
	[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_RESERVE },
	[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_RESERVE },
	[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_RESERVE },
	[MIGRATE_RESERVE]     = { MIGRATE_RESERVE,     MIGRATE_RESERVE,   MIGRATE_RESERVE }, <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Never used</span><span style="color: #8B8878;"> */</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org36e4f6a" class="outline-5">
<h5 id="org36e4f6a"><span class="section-number-5">5.2.1.2</span> 全局变量和辅助函数</h5>
<div class="outline-text-5" id="text-5-2-1-2">
<ul class="org-ul">
<li>pageblock_order: 分配阶，如果内核定义了巨页，则定义为巨页的分配阶，否则为(MAX_ORDER-1)</li>
<li>pageblock_nr_pages: 上述分配阶对应的页数。</li>
</ul>

<p>
内核提供了两个标志，分别用于表示分配可移动的内存页 （__GFP_MOVABLE） 或可回收的内存页 （__GFP_RECLAIMABLE） 。如果这些标志都没有设置，则分配的内存假定为不可移动的。下列辅助函数可用于转换分配标志及对应的迁移类型：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Convert GFP flags to their corresponding migrate type</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">allocflags_to_migratetype</span>(<span style="color: #5FD7FF;">gfp_t</span> <span style="color: #FF8C00;">gfp_flags</span>)
{
	WARN_ON((gfp_flags &amp; GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);

	<span style="color: #FF1493;">if</span> (unlikely(page_group_by_mobility_disabled))
		<span style="color: #FF1493;">return</span> MIGRATE_UNMOVABLE;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26681;&#25454;&#36319;&#31227;&#21160;&#24615;&#36827;&#34892;&#20998;&#32452;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">return</span> (((gfp_flags &amp; __GFP_MOVABLE) != 0) &lt;&lt; 1) |
		((gfp_flags &amp; __GFP_RECLAIMABLE) != 0);
}
</pre>
</div>


<p>
获取各个迁移链表的当前页面分配状态 <b>/proc/pagetypeinfo</b> :
</p>
<div class="org-src-container">
<pre class="src src-c">$ sudo cat /proc/pagetypeinfo
[sudo] password <span style="color: #FF1493;">for</span> fanyf:
Page block order: 9
Pages per block:  512

Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10
Node    0, <span style="color: #5FD7FF;">zone</span>      <span style="color: #FF8C00;">DMA</span>, <span style="color: #5FD7FF;">type</span>    <span style="color: #FF8C00;">Unmovable</span>      4      2      3      0      3      2      0      0      1      0      0
Node    0, <span style="color: #5FD7FF;">zone</span>      <span style="color: #FF8C00;">DMA</span>, <span style="color: #5FD7FF;">type</span>      <span style="color: #FF8C00;">Movable</span>      0      0      0      0      0      0      0      0      0      1      3
Node    0, <span style="color: #5FD7FF;">zone</span>      <span style="color: #FF8C00;">DMA</span>, <span style="color: #5FD7FF;">type</span>  <span style="color: #FF8C00;">Reclaimable</span>      0      0      0      0      0      0      0      0      0      0      0
Node    0, <span style="color: #5FD7FF;">zone</span>      <span style="color: #FF8C00;">DMA</span>, <span style="color: #5FD7FF;">type</span>   <span style="color: #FF8C00;">HighAtomic</span>      0      0      0      0      0      0      0      0      0      0      0
Node    0, <span style="color: #5FD7FF;">zone</span>      <span style="color: #FF8C00;">DMA</span>, <span style="color: #5FD7FF;">type</span>      <span style="color: #FF8C00;">Isolate</span>      0      0      0      0      0      0      0      0      0      0      0
Node    0, <span style="color: #5FD7FF;">zone</span>    <span style="color: #FF8C00;">DMA32</span>, <span style="color: #5FD7FF;">type</span>    <span style="color: #FF8C00;">Unmovable</span>      1      2      1      2      1      0      1      2      0      0      0
Node    0, <span style="color: #5FD7FF;">zone</span>    <span style="color: #FF8C00;">DMA32</span>, <span style="color: #5FD7FF;">type</span>      <span style="color: #FF8C00;">Movable</span>      8      6      6      6      5      6      7      5      4      5    527
Node    0, <span style="color: #5FD7FF;">zone</span>    <span style="color: #FF8C00;">DMA32</span>, <span style="color: #5FD7FF;">type</span>  <span style="color: #FF8C00;">Reclaimable</span>      0      0      0      0      0      0      0      0      0      0      0
Node    0, <span style="color: #5FD7FF;">zone</span>    <span style="color: #FF8C00;">DMA32</span>, <span style="color: #5FD7FF;">type</span>   <span style="color: #FF8C00;">HighAtomic</span>      0      0      0      0      0      0      0      0      0      0      0
Node    0, <span style="color: #5FD7FF;">zone</span>    <span style="color: #FF8C00;">DMA32</span>, <span style="color: #5FD7FF;">type</span>      <span style="color: #FF8C00;">Isolate</span>      0      0      0      0      0      0      0      0      0      0      0
Node    0, <span style="color: #5FD7FF;">zone</span>   <span style="color: #FF8C00;">Normal</span>, <span style="color: #5FD7FF;">type</span>    <span style="color: #FF8C00;">Unmovable</span>     22     82     46     20      3      1      1      0      1      0      0
Node    0, <span style="color: #5FD7FF;">zone</span>   <span style="color: #FF8C00;">Normal</span>, <span style="color: #5FD7FF;">type</span>      <span style="color: #FF8C00;">Movable</span>   1862   1463   1049    622    145    346     36     50     31      1    584
Node    0, <span style="color: #5FD7FF;">zone</span>   <span style="color: #FF8C00;">Normal</span>, <span style="color: #5FD7FF;">type</span>  <span style="color: #FF8C00;">Reclaimable</span>    418    239     89     81     99     92     53     21     20     11      0
Node    0, <span style="color: #5FD7FF;">zone</span>   <span style="color: #FF8C00;">Normal</span>, <span style="color: #5FD7FF;">type</span>   <span style="color: #FF8C00;">HighAtomic</span>      0      0      0      0      0      0      0      0      0      0      0
Node    0, <span style="color: #5FD7FF;">zone</span>   <span style="color: #FF8C00;">Normal</span>, <span style="color: #5FD7FF;">type</span>      <span style="color: #FF8C00;">Isolate</span>      0      0      0      0      0      0      0      0      0      0      0

Number of blocks type     Unmovable      Movable  Reclaimable   HighAtomic      Isolate
Node 0, <span style="color: #5FD7FF;">zone</span>      <span style="color: #FF8C00;">DMA</span>            1            7            0            0            0
Node 0, <span style="color: #5FD7FF;">zone</span>    <span style="color: #FF8C00;">DMA32</span>            8         1098            0            0            0
Node 0, <span style="color: #5FD7FF;">zone</span>   <span style="color: #FF8C00;">Normal</span>          205         2527          204            0            0
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orge22dfca" class="outline-3">
<h3 id="orge22dfca"><span class="section-number-3">5.3</span> 初始化内存域和节点数据结构</h3>
<div class="outline-text-3" id="text-5-3">
<p>
体系结构代码在启动时需要建立一下信息：
</p>
<ul class="org-ul">
<li>系统中各个内存域的页帧边界，保存在max_zone_pfn数组。</li>
<li>各节点页帧的分配情况，保存在全局变量early_node_map中。</li>
</ul>
</div>

<div id="outline-container-org346a149" class="outline-4">
<h4 id="org346a149"><span class="section-number-4">5.3.1</span> 创建管理数据结构</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
free_area_init_nodes会初始化管理数据结构。
</p>


<div class="figure">
<p><img src="image/memory/free-area-init-nodes.png" alt="free-area-init-nodes.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-fundamental">free_area_init_nodes
	&#30830;&#23450;&#20869;&#23384;&#22495;&#36793;&#30028;
	free_area_init_node
		calculate_node_totalpages
		alloc_node_mem_map
		free_area_init_core
	check_for_reqular_memory
</pre>
</div>



<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__init</span> free_area_init_nodes(<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> *<span style="color: #FF8C00;">max_zone_pfn</span>)
{
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">nid</span>;
	<span style="color: #FF1493;">enum</span> <span style="color: #5FD7FF;">zone_type</span> <span style="color: #FF8C00;">i</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23545; early_node_map &#36827;&#34892;&#25490;&#24207;</span><span style="color: #8B8878;"> */</span>
	sort_node_map();

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#35760;&#24405;&#20869;&#23384;&#22495;&#30340;&#36793;&#30028;&#20301;&#32622;</span><span style="color: #8B8878;"> */</span>
	memset(arch_zone_lowest_possible_pfn, 0,
				<span style="color: #FF1493;">sizeof</span>(arch_zone_lowest_possible_pfn));
	memset(arch_zone_highest_possible_pfn, 0,
				<span style="color: #FF1493;">sizeof</span>(arch_zone_highest_possible_pfn));
	arch_zone_lowest_possible_pfn[0] = find_min_pfn_with_active_regions();
	arch_zone_highest_possible_pfn[0] = max_zone_pfn[0];
	<span style="color: #FF1493;">for</span> (i = 1; i &lt; MAX_NR_ZONES; i++) {
		<span style="color: #FF1493;">if</span> (i == ZONE_MOVABLE)
			<span style="color: #FF1493;">continue</span>;
		arch_zone_lowest_possible_pfn[i] =
			arch_zone_highest_possible_pfn[i-1];
		arch_zone_highest_possible_pfn[i] =
			max(max_zone_pfn[i], arch_zone_lowest_possible_pfn[i]);
	}
	arch_zone_lowest_possible_pfn[ZONE_MOVABLE] = 0;
	arch_zone_highest_possible_pfn[ZONE_MOVABLE] = 0;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22312;&#27599;&#20010;&#32467;&#28857;&#19978;&#26597;&#25214;ZONE_MOVABLE&#30340;&#36215;&#22987;PFN</span><span style="color: #8B8878;">  */</span>
	memset(zone_movable_pfn, 0, <span style="color: #FF1493;">sizeof</span>(zone_movable_pfn));
	find_zone_movable_pfns_for_nodes(zone_movable_pfn);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Print out the zone ranges</span><span style="color: #8B8878;"> */</span>
	printk(<span style="color: #CDC673;">"Zone PFN ranges:\n"</span>);
	<span style="color: #FF1493;">for</span> (i = 0; i &lt; MAX_NR_ZONES; i++) {
		<span style="color: #FF1493;">if</span> (i == ZONE_MOVABLE)
			<span style="color: #FF1493;">continue</span>;
		printk(<span style="color: #CDC673;">"  %-8s %8lu -&gt; %8lu\n"</span>,
				zone_names[i],
				arch_zone_lowest_possible_pfn[i],
				arch_zone_highest_possible_pfn[i]);
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Print out the PFNs ZONE_MOVABLE begins at in each node</span><span style="color: #8B8878;"> */</span>
	printk(<span style="color: #CDC673;">"Movable zone start PFN for each node\n"</span>);
	<span style="color: #FF1493;">for</span> (i = 0; i &lt; MAX_NUMNODES; i++) {
		<span style="color: #FF1493;">if</span> (zone_movable_pfn[i])
			printk(<span style="color: #CDC673;">"  Node %d: %lu\n"</span>, i, zone_movable_pfn[i]);
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Print out the early_node_map[]</span><span style="color: #8B8878;"> */</span>
	printk(<span style="color: #CDC673;">"early_node_map[%d] active PFN ranges\n"</span>, nr_nodemap_entries);
	<span style="color: #FF1493;">for</span> (i = 0; i &lt; nr_nodemap_entries; i++)
		printk(<span style="color: #CDC673;">"  %3d: %8lu -&gt; %8lu\n"</span>, early_node_map[i].nid,
						early_node_map[i].start_pfn,
						early_node_map[i].end_pfn);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#27599;&#20010;&#32467;&#28857;</span><span style="color: #8B8878;"> */</span>
	setup_nr_node_ids();
	for_each_online_node(nid) {
		<span style="color: #5FD7FF;">pg_data_t</span> *<span style="color: #FF8C00;">pgdat</span> = NODE_DATA(nid);
		free_area_init_node(nid, pgdat, <span style="color: #AF87FF;">NULL</span>,
				find_min_pfn_for_node(nid), <span style="color: #AF87FF;">NULL</span>);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#32467;&#28857;&#19978;&#26159;&#21542;&#26377;&#20869;&#23384;</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (pgdat-&gt;node_present_pages)
			node_set_state(nid, N_HIGH_MEMORY);
		check_for_regular_memory(pgdat);
	}
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4a0d1cd" class="outline-4">
<h4 id="org4a0d1cd"><span class="section-number-4">5.3.2</span> 对各个结点创建数据结构</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
free_area_init_node用于创建内存域的数据结构。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__meminit</span> free_area_init_node(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nid</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">pglist_data</span> *<span style="color: #FF8C00;">pgdat</span>,
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> *<span style="color: #FF8C00;">zones_size</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">node_start_pfn</span>,
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> *<span style="color: #FF8C00;">zholes_size</span>)
{
	pgdat-&gt;node_id = nid;
	pgdat-&gt;node_start_pfn = node_start_pfn;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;&#32467;&#28857;&#20013;&#39029;&#30340;&#24635;&#25968;</span>
	calculate_node_totalpages(pgdat, zones_size, zholes_size);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#29289;&#29702;&#20869;&#23384;&#39029;&#30340;struct page&#23454;&#20363;</span>
	alloc_node_mem_map(pgdat);

	free_area_init_core(pgdat, zones_size, zholes_size);
}
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__init_refok</span> alloc_node_mem_map(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">pglist_data</span> *<span style="color: #FF8C00;">pgdat</span>)
{
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Skip empty nodes</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>pgdat-&gt;node_spanned_pages)
		<span style="color: #FF1493;">return</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#36824;&#27809;&#26377;&#24314;&#31435;&#20869;&#23384;&#26144;&#23556;&#65292;&#21017;&#20998;&#37197;&#35813;&#32467;&#28857;&#30340;&#25152;&#26377;struct page&#23454;&#20363;&#12290;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>pgdat-&gt;node_mem_map) {
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">size</span>, <span style="color: #FF8C00;">start</span>, <span style="color: #FF8C00;">end</span>;
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> *<span style="color: #FF8C00;">map</span>;

		<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                 * The zone's endpoints aren't required to be MAX_ORDER</span>
<span style="color: #8B8878;">                 * aligned but the node_mem_map endpoints must be in order</span>
<span style="color: #8B8878;">                 * for the buddy allocator to function correctly.</span>
<span style="color: #8B8878;">                 */</span>
		start = pgdat-&gt;node_start_pfn &amp; ~(MAX_ORDER_NR_PAGES - 1);
		end = pgdat-&gt;node_start_pfn + pgdat-&gt;node_spanned_pages;
		end = ALIGN(end, MAX_ORDER_NR_PAGES);
		size =  (end - start) * <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span>);
		map = alloc_remap(pgdat-&gt;node_id, size);
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>map) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20307;&#31995;&#32467;&#26500;&#21487;&#20197;&#33258;&#23450;&#20041;&#20998;&#37197;&#20989;&#25968;&#65292;&#19968;&#33324;&#20307;&#31995;&#32467;&#26500;&#37117;&#20250;&#20351;&#29992;bootmem&#36827;&#34892;&#20998;&#37197;</span>
			map = alloc_bootmem_node(pgdat, size);
		pgdat-&gt;node_mem_map = map + (pgdat-&gt;node_start_pfn - start);
	}

	<span style="color: #FF1493;">if</span> (pgdat == NODE_DATA(0)) {
		mem_map = NODE_DATA(0)-&gt;node_mem_map;
		<span style="color: #FF1493;">if</span> (page_to_pfn(mem_map) != pgdat-&gt;node_start_pfn)
			mem_map -= (pgdat-&gt;node_start_pfn - ARCH_PFN_OFFSET);
	}
}


<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * &#21021;&#22987;&#21270;&#32467;&#28857;zone&#30340;&#25968;&#25454;&#32467;&#26500;&#65306;</span>
<span style="color: #8B8878;"> *   - &#23558;&#25152;&#26377;&#39029;&#26631;&#35760;&#20026;&#20445;&#30041;</span>
<span style="color: #8B8878;"> *   - &#23558;&#25152;&#26377;&#20869;&#23384;&#38431;&#21015;&#26631;&#35760;&#20026;&#31354;</span>
<span style="color: #8B8878;"> *   - &#28165;&#38500;&#20869;&#23384;&#30340;bitmap</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__meminit</span> free_area_init_core(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">pglist_data</span> *<span style="color: #FF8C00;">pgdat</span>,
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> *<span style="color: #FF8C00;">zones_size</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> *<span style="color: #FF8C00;">zholes_size</span>)
{
	<span style="color: #FF1493;">enum</span> <span style="color: #5FD7FF;">zone_type</span> <span style="color: #FF8C00;">j</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nid</span> = pgdat-&gt;node_id;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">zone_start_pfn</span> = pgdat-&gt;node_start_pfn;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ret</span>;
......
	<span style="color: #FF1493;">for</span> (j = 0; j &lt; MAX_NR_ZONES; j++) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> *<span style="color: #FF8C00;">zone</span> = pgdat-&gt;node_zones + j;
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">size</span>, <span style="color: #FF8C00;">realsize</span>, <span style="color: #FF8C00;">memmap_pages</span>;

		size = zone_spanned_pages_in_node(nid, j, zones_size);
		realsize = size - zone_absent_pages_in_node(nid, j,
								zholes_size);
		<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                 * Adjust realsize so that it accounts for how much memory</span>
<span style="color: #8B8878;">                 * is used by this zone for memmap. This affects the watermark</span>
<span style="color: #8B8878;">                 * and per-cpu initialisations</span>
<span style="color: #8B8878;">                 */</span>
		memmap_pages = (size * <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span>)) &gt;&gt; PAGE_SHIFT;
		<span style="color: #FF1493;">if</span> (realsize &gt;= memmap_pages) {
			realsize -= memmap_pages;
			printk(KERN_DEBUG
				<span style="color: #CDC673;">"  %s zone: %lu pages used for memmap\n"</span>,
				zone_names[j], memmap_pages);
		} <span style="color: #FF1493;">else</span>
			printk(KERN_WARNING
				<span style="color: #CDC673;">"  %s zone: %lu pages exceeds realsize %lu\n"</span>,
				zone_names[j], memmap_pages, realsize);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Account for reserved pages</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (j == 0 &amp;&amp; realsize &gt; dma_reserve) {
			realsize -= dma_reserve;
			printk(KERN_DEBUG <span style="color: #CDC673;">"  %s zone: %lu pages reserved\n"</span>,
					zone_names[0], dma_reserve);
		}

		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>is_highmem_idx(j))
			nr_kernel_pages += realsize;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32479;&#35745;&#25152;&#26377;&#19968;&#33268;&#26144;&#23556;&#30340;&#39029;</span>
		nr_all_pages += realsize;

		zone-&gt;spanned_pages = size;
		zone-&gt;present_pages = realsize;
<span style="color: #FF1493;">#ifdef</span> CONFIG_NUMA
		zone-&gt;node = nid;
		zone-&gt;min_unmapped_pages = (realsize*sysctl_min_unmapped_ratio)
						/ 100;
		zone-&gt;min_slab_pages = (realsize * sysctl_min_slab_ratio) / 100;
<span style="color: #FF1493;">#endif</span>
		zone-&gt;name = zone_names[j];
		spin_lock_init(&amp;zone-&gt;lock);
		spin_lock_init(&amp;zone-&gt;lru_lock);
		zone_seqlock_init(zone);
		zone-&gt;zone_pgdat = pgdat;

		zone-&gt;prev_priority = DEF_PRIORITY;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">zone_pcp_init &#21021;&#22987;&#21270;&#35813;&#20869;&#23384;&#22495;&#30340;per-CPU&#32531;&#23384;</span>
		zone_pcp_init(zone);
		INIT_LIST_HEAD(&amp;zone-&gt;active_list);
		INIT_LIST_HEAD(&amp;zone-&gt;inactive_list);
		zone-&gt;nr_scan_active = 0;
		zone-&gt;nr_scan_inactive = 0;
		zap_zone_vm_stats(zone);
		zone-&gt;flags = 0;
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>size)
			<span style="color: #FF1493;">continue</span>;

		set_pageblock_order(pageblock_default_order());
		setup_usemap(pgdat, zone, size);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;free_area&#21015;&#34920;&#65292;&#24182;&#23558;&#23646;&#20110;&#35813;&#20869;&#23384;&#22495;&#30340;&#25152;&#26377;page&#23454;&#20363;&#26159;&#25351;&#20026;&#21021;&#22987;&#40664;&#35748;&#20540;</span>
		ret = init_currently_empty_zone(zone, zone_start_pfn,
						size, MEMMAP_EARLY);
		BUG_ON(ret);
		zone_start_pfn += size;
	}
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge04a9a9" class="outline-3">
<h3 id="orge04a9a9"><span class="section-number-3">5.4</span> 分配器API</h3>
<div class="outline-text-3" id="text-5-4">
<p>
伙伴系统中，其接口只能分配2的整数幂个页。内核中要分配细粒度的内存只能借助slab分配器（或者slub slob）。
</p>

<p>
分配函数：
</p>
<ul class="org-ul">
<li>alloc_pages(mask, order) 分配2<sup>order</sup>个页并返回一个 struct page 的实例，表示分配的内存块的起始页。 alloc_page(mask) 是alloc_pages在 order = 0 情况下的简化形式，只分配一页。</li>
<li>get_zeroed_page(mask) 分配一页并返回一个 page 实例，页对应的内存填充0 （所有其他函数，分配之后页的内容是未定义的）。</li>
<li>__get_free_pages(mask, order) 和 __get_free_page(mask) 返回分配内存块的虚拟地址，而不是 page 实例。</li>
<li>get_dma_pages(gfp_mask, order) 用来获得适用于DMA的页。</li>
</ul>

<p>
在空闲内存无法满足请求以至于分配失败的情况下，所有上述函数都返回空指针或者0。
</p>

<p>
释放函数：
</p>
<ul class="org-ul">
<li>free_page(struct page *) 和 free_pages(struct page *, order) 用于将一个或2<sup>order</sup>页返回给内存管理子系统。内存区的起始地址由指向该内存区的第一个 page 实例的指针表示。</li>
<li>__free_page(addr) 和 __free_pages(addr, order) 使用了虚拟内存地址而不是 page 实例。</li>
</ul>
</div>

<div id="outline-container-org3292f27" class="outline-4">
<h4 id="org3292f27"><span class="section-number-4">5.4.1</span> 分配掩码</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
GFP(Get Free Page)
</p>

<p>
内存分配掩码:
</p>
<ul class="org-ul">
<li>__GFP_DMA</li>
<li>__GFP_HIGHMEM</li>
<li>__GFP_DMA32</li>
<li>__GFP_MOVABLE 不表示物理内存域, 通知内核应该在特殊的虚拟内存域ZONE_MOVABLE进行分配</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #FF1493;">enum</span> <span style="color: #5FD7FF;">zone_type</span> <span style="color: #87D700;">gfp_zone</span>(<span style="color: #5FD7FF;">gfp_t</span> <span style="color: #FF8C00;">flags</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">base</span> = 0;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#37197;&#32622;&#20102; __GFP_THISNODE, &#21017;&#21482;&#33021;&#20174;&#26412;NUMA&#33410;&#28857;&#20998;&#37197;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#ifdef</span> CONFIG_NUMA
	<span style="color: #FF1493;">if</span> (flags &amp; __GFP_THISNODE)
		base = MAX_NR_ZONES;
<span style="color: #FF1493;">#endif</span>

<span style="color: #FF1493;">#ifdef</span> CONFIG_ZONE_DMA
	<span style="color: #FF1493;">if</span> (flags &amp; __GFP_DMA)
		<span style="color: #FF1493;">return</span> base + ZONE_DMA;
<span style="color: #FF1493;">#endif</span>
<span style="color: #FF1493;">#ifdef</span> CONFIG_ZONE_DMA32
	<span style="color: #FF1493;">if</span> (flags &amp; __GFP_DMA32)
		<span style="color: #FF1493;">return</span> base + ZONE_DMA32;
<span style="color: #FF1493;">#endif</span>
	<span style="color: #FF1493;">if</span> ((flags &amp; (__GFP_HIGHMEM | __GFP_MOVABLE)) ==
			(__GFP_HIGHMEM | __GFP_MOVABLE))
		<span style="color: #FF1493;">return</span> base + ZONE_MOVABLE;
<span style="color: #FF1493;">#ifdef</span> CONFIG_HIGHMEM
	<span style="color: #FF1493;">if</span> (flags &amp; __GFP_HIGHMEM)
		<span style="color: #FF1493;">return</span> base + ZONE_HIGHMEM;
<span style="color: #FF1493;">#endif</span>
	<span style="color: #FF1493;">return</span> base + ZONE_NORMAL;
}

</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> 内存域修饰符和扫描的内存域之间的关联</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">修饰符</th>
<th scope="col" class="org-left">扫描的内存域</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">无</td>
<td class="org-left">ZONE_NORMAL ZONE_DMA</td>
</tr>

<tr>
<td class="org-left">GFP_DMA</td>
<td class="org-left">ZONE_DMA</td>
</tr>

<tr>
<td class="org-left">__GFP_DMA &amp; __GFP_HIGHMEM</td>
<td class="org-left">ZONE_DMA</td>
</tr>

<tr>
<td class="org-left">__GFP_HIGHMEM</td>
<td class="org-left">ZONE_HIGHMEM ZONE_NORMAL ZONE_DMA</td>
</tr>
</tbody>
</table>

<p>
__GFP_MOVABLE 只有在 __GFP_HIGHMEM 同时指定时，会使用特殊的虚拟内存域 ZONE_MOVABLE 满足内存分配请求。
</p>

<p>
内存分配掩码的额外标志：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_WAIT</span>      ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x10u)  <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21487;&#20197;&#31561;&#24453;&#21644;&#37325;&#35843;&#24230;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_HIGH</span>      ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x20u)  <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#24212;&#35813;&#35775;&#38382;&#32039;&#24613;&#20998;&#37197;&#27744;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_IO</span>        ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x40u)  <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21487;&#20197;&#21551;&#21160;&#29289;&#29702;io</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_FS</span>        ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x80u)  <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21487;&#20197;&#35843;&#29992;&#24213;&#23618;&#25991;&#20214;&#31995;&#32479;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_COLD</span>      ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x100u) <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#38656;&#35201;&#32531;&#23384;&#20919;&#39029;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_NOWARN</span>    ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x200u) <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#31105;&#27490;&#20998;&#37197;&#22833;&#36133;&#35686;&#21578;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_REPEAT</span>    ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x400u) <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#37325;&#25342;&#20998;&#37197;&#65292;&#21487;&#33021;&#22833;&#36133;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_NOFAIL</span>    ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x800u) <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#19968;&#30452;&#37325;&#35797;&#65292;&#19981;&#20250;&#22833;&#36133;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_NORETRY</span>   ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x1000u)<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#19981;&#37325;&#35797;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_COMP</span>      ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x4000u)<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#28155;&#21152;&#22797;&#21512;&#39029;&#20803;&#25968;&#25454;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_ZERO</span>      ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x8000u)<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25104;&#21151;&#21518;&#65292;&#22635;&#20805;0</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_NOMEMALLOC</span> ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x10000u) <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#19981;&#20351;&#29992;&#32039;&#24613;&#20998;&#37197;&#38142;&#34920;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_HARDWALL</span>   ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x20000u) <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#24378;&#21046;&#22312;cpuset&#35774;&#32622;&#30340;&#32467;&#28857;&#20998;&#37197;&#20869;&#23384;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_THISNODE</span>  ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x40000u)<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#27809;&#26377;&#22791;&#29992;&#32467;&#28857;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_RECLAIMABLE</span> ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x80000u) <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#39029;&#26159;&#21487;&#22238;&#25910;&#30340;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">__GFP_MOVABLE</span>   ((__force <span style="color: #5FD7FF;">gfp_t</span>)0x100000u)  <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#39029;&#26159;&#21487;&#31227;&#21160;&#30340;</span><span style="color: #8B8878;"> */</span>
</pre>
</div>

<ul class="org-ul">
<li>__GFP_WAIT 表示分配内存的请求可以中断</li>
<li>__GFP_HIGH 表示内核急切的需要内存, 在分配内存失败可能给内核带来严重后果是, 使用此标志</li>
<li>__GFP_IO 在查找空闲内存期间内核可以进行I/O操作</li>
<li>__GFP_FS 允许内核执行VFS操作, 在与VFS层有联系的内核子系统中必须禁用, 因为这可能引起循环递归调用</li>
<li>__GFP_COLD 分配不需要在CPU高速缓存中的'冷'页时使用</li>
<li>__GFP_NOWARN 分配失败时 禁止内核故障警告</li>
<li>__GFP_REPEAT 分配失败 自动重试有限的次数</li>
<li>__GFP_NOFALL 分配失败 一直重试</li>
<li>__GFP_ZERO 分配成功时, 将页填充为0</li>
<li>__GFP_HARDWALL 限制当前进程只能在允许运行的各个cpu关联的节点上分配内存(NUMA系统才有意义)</li>
<li>__GFP_THISNODE 分配失败时 不允许从其他备用节点分配</li>
<li>__GFP_RECLAIMABLE和__GFP_MOVABLE  页迁移机制使用的标志, 分别将分配的内存标记为可回收的或可移动的</li>
</ul>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#20110;&#21407;&#23376;&#20998;&#37197;&#65292;&#20219;&#20309;&#24773;&#20917;&#37117;&#19981;&#33021;&#20013;&#26029;</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_ATOMIC</span>      (__GFP_HIGH)
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31105;&#27490;I/O&#25805;&#20316;&#65292;&#21487;&#20197;&#20013;&#26029;</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_NOIO</span>        (__GFP_WAIT)
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31105;&#27490;&#35775;&#38382;VFS&#23618;&#65292;&#21487;&#20197;&#20013;&#26029;</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_NOFS</span>        (__GFP_WAIT | __GFP_IO)
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20869;&#26680;&#31354;&#38388;&#20998;&#37197;</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_KERNEL</span>      (__GFP_WAIT | __GFP_IO | __GFP_FS)
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_TEMPORARY</span>   (__GFP_WAIT | __GFP_IO | __GFP_FS | \
			 __GFP_RECLAIMABLE)
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#25143;&#31354;&#38388;&#20998;&#37197;</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_USER</span>        (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL)
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#25143;&#31354;&#38388;&#20998;&#37197;&#39640;&#31471;&#20869;&#23384;&#39029;</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_HIGHUSER</span>    (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL | \
			 __GFP_HIGHMEM)
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20174;&#34394;&#25311;&#20869;&#23384;&#22495;ZONE_MOVABLE&#20998;&#37197;&#20869;&#23384;</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_HIGHUSER_MOVABLE</span>    (__GFP_WAIT | __GFP_IO | __GFP_FS | \
				 __GFP_HARDWALL | __GFP_HIGHMEM | \
				 __GFP_MOVABLE)
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_NOFS_PAGECACHE</span>      (__GFP_WAIT | __GFP_IO | __GFP_MOVABLE)
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_USER_PAGECACHE</span>      (__GFP_WAIT | __GFP_IO | __GFP_FS | \
				 __GFP_HARDWALL | __GFP_MOVABLE)
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">GFP_HIGHUSER_PAGECACHE</span>  (__GFP_WAIT | __GFP_IO | __GFP_FS | \
				 __GFP_HARDWALL | __GFP_HIGHMEM | \
				 __GFP_MOVABLE)
</pre>
</div>
</div>
</div>

<div id="outline-container-org80141d9" class="outline-4">
<h4 id="org80141d9"><span class="section-number-4">5.4.2</span> 内存分配宏</h4>
<div class="outline-text-4" id="text-5-4-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#define</span> <span style="color: #87D700;">alloc_pages</span>(<span style="color: #FF8C00;">gfp_mask</span>, <span style="color: #FF8C00;">order</span>) \
		alloc_pages_node(numa_node_id(), gfp_mask, order)

<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">alloc_page</span>(<span style="color: #FF8C00;">gfp_mask</span>) alloc_pages(gfp_mask, 0)

<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">__get_free_page</span>(<span style="color: #FF8C00;">gfp_mask</span>) \
		__get_free_pages((gfp_mask),0)

<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">__get_dma_pages</span>(<span style="color: #FF8C00;">gfp_mask</span>, <span style="color: #FF8C00;">order</span>) \
		__get_free_pages((gfp_mask) | GFP_DMA,(order))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgca2a204" class="outline-3">
<h3 id="orgca2a204"><span class="section-number-3">5.5</span> 分配页</h3>
<div class="outline-text-3" id="text-5-5">
<p>
最终，所有的分配函数都会调用 alloc_pages_node 。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> *<span style="color: #87D700;">alloc_pages_node</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nid</span>, <span style="color: #5FD7FF;">gfp_t</span> <span style="color: #FF8C00;">gfp_mask</span>,
						<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">order</span>)
{
	<span style="color: #FF1493;">if</span> (unlikely(order &gt;= MAX_ORDER))
		<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Unknown node is current node</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (nid &lt; 0)
		nid = numa_node_id();

	<span style="color: #FF1493;">return</span> __alloc_pages(gfp_mask, order,
		NODE_DATA(nid)-&gt;node_zonelists + gfp_zone(gfp_mask));
}
</pre>
</div>
</div>

<div id="outline-container-orgc689daa" class="outline-4">
<h4 id="orgc689daa"><span class="section-number-4">5.5.1</span> 选择页</h4>
<div class="outline-text-4" id="text-5-5-1">
</div>
<div id="outline-container-org2b36845" class="outline-5">
<h5 id="org2b36845"><span class="section-number-5">5.5.1.1</span> 辅助函数</h5>
<div class="outline-text-5" id="text-5-5-1-1">
<p>
以下标志用于控制到达各个水印指定的临界状态时的行为。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">ALLOC_NO_WATERMARKS</span>     0x01 <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#19981;&#26816;&#26597;&#27700;&#21360;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">ALLOC_WMARK_MIN</span>         0x02 <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20351;&#29992;pages_min &#27700;&#21360;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">ALLOC_WMARK_LOW</span>         0x04 <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20351;&#29992; pages_low &#27700;&#21360;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">ALLOC_WMARK_HIGH</span>        0x08 <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20351;&#29992; pages_high &#27700;&#21360;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">ALLOC_HARDER</span>            0x10 <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23581;&#35797;&#26356;&#21162;&#21147;&#30340;&#20998;&#37197;</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">ALLOC_HIGH</span>              0x20 <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#35774;&#32622; __GFP_HIGH</span><span style="color: #8B8878;">  */</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">ALLOC_CPUSET</span>            0x40 <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26816;&#26597;&#20869;&#23384;&#32467;&#28857;&#26159;&#21542;&#25351;&#23450;&#23545;&#24212;&#30340;cpuset</span><span style="color: #8B8878;"> */</span>
</pre>
</div>


<p>
zone_watermark_ok 根据设置的标志判断能否从给定的内存域分配内存：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">zone_watermark_ok</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">zone</span> *<span style="color: #FF8C00;">z</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">order</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">mark</span>,
		      <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">classzone_idx</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">alloc_flags</span>)
{
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">free_pages my go negative - that's OK</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">min</span> = mark;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#31354;&#38386;&#39029;&#30340;&#25968;&#30446;</span>
	<span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">free_pages</span> = zone_page_state(z, NR_FREE_PAGES) - (1 &lt;&lt; order) + 1;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">o</span>;

	<span style="color: #FF1493;">if</span> (alloc_flags &amp; ALLOC_HIGH)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#26368;&#23567;&#20540;&#20943;&#23567;&#24403;&#21069;&#30340;&#19968;&#21322;</span>
		min -= min / 2;
	<span style="color: #FF1493;">if</span> (alloc_flags &amp; ALLOC_HARDER)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#26368;&#23567;&#20540;&#20943;&#23567;&#24403;&#21069;&#20540;&#30340;&#22235;&#20998;&#20043;&#19968;</span>
		min -= min / 4;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#26597;&#31354;&#38386;&#39029;&#30340;&#25968;&#30446;&#26159;&#21542;&#23567;&#20110;&#26368;&#23567;&#20540;</span>
	<span style="color: #FF1493;">if</span> (free_pages &lt;= min + z-&gt;lowmem_reserve[classzone_idx])
		<span style="color: #FF1493;">return</span> 0;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36941;&#21382;&#23567;&#20110;&#24403;&#21069;&#38454;&#30340;&#25152;&#26377;&#20998;&#37197;&#38454;</span>
	<span style="color: #FF1493;">for</span> (o = 0; o &lt; order; o++) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">At the next order, this order's pages become unavailable</span><span style="color: #8B8878;"> */</span>
		free_pages -= z-&gt;free_area[o].nr_free &lt;&lt; o;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23545;&#20110;&#19979;&#19968;&#20491;&#20998;&#37197;&#38454;&#65292;min&#20540;&#20943;&#23567;&#19968;&#21322;</span><span style="color: #8B8878;"> */</span>
		min &gt;&gt;= 1;

		<span style="color: #FF1493;">if</span> (free_pages &lt;= min)
			<span style="color: #FF1493;">return</span> 0;
	}
	<span style="color: #FF1493;">return</span> 1;
}
</pre>
</div>


<p>
get_page_from_freelist 函数通过标志集和分配阶来判断是否能够进行分配，如果可以，则发起实际的分配工作。
</p>

<div class="org-src-container">
<pre class="src src-c">
</pre>
</div>
</div>
</div>
</div>
</div>



























<div id="outline-container-org76e2628" class="outline-3">
<h3 id="org76e2628"><span class="section-number-3">5.6</span> 释放页</h3>
</div>
<div id="outline-container-org0a4d8e6" class="outline-3">
<h3 id="org0a4d8e6"><span class="section-number-3">5.7</span> 内核中不连续页的分配</h3>
</div>
<div id="outline-container-orgf882117" class="outline-3">
<h3 id="orgf882117"><span class="section-number-3">5.8</span> 内核映射</h3>
</div>
</div>

<div id="outline-container-org592ca10" class="outline-2">
<h2 id="org592ca10"><span class="section-number-2">6</span> slab分配器</h2>
</div>
<div id="outline-container-org3cfb9c9" class="outline-2">
<h2 id="org3cfb9c9"><span class="section-number-2">7</span> 处理器高速缓存和TLB控制</h2>
</div>

<div id="outline-container-org844cad0" class="outline-2">
<h2 id="org844cad0"><span class="section-number-2">8</span> ？？</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org586b6f9" class="outline-3">
<h3 id="org586b6f9"><span class="section-number-3">8.1</span> Linux kernel 64位地址空间分配</h3>
<div class="outline-text-3" id="text-8-1">
</div>
<div id="outline-container-orgd7dae1c" class="outline-4">
<h4 id="orgd7dae1c"><span class="section-number-4">8.1.1</span> 具有四级页表的虚拟地址空间</h4>
<div class="outline-text-4" id="text-8-1-1">
<div class="org-src-container">
<pre class="src src-fundamental">========================================================================================================================
    Start addr    |   Offset   |     End addr     |  Size   | VM area description
========================================================================================================================
		  |            |                  |         |
 0000000000000000 |    0       | 00007fffffffffff |  128 TB | user-space virtual memory, different per mm
__________________|____________|__________________|_________|___________________________________________________________
		  |            |                  |         |
 0000800000000000 | +128    TB | ffff7fffffffffff | ~16M TB | ... huge, almost 64 bits wide hole of non-canonical
		  |            |                  |         |     virtual memory addresses up to the -128 TB
		  |            |                  |         |     starting offset of kernel mappings.
__________________|____________|__________________|_________|___________________________________________________________
							    |
							    | Kernel-space virtual memory, shared between all processes:
____________________________________________________________|___________________________________________________________
		  |            |                  |         |
 ffff800000000000 | -128    TB | ffff87ffffffffff |    8 TB | ... guard hole, also reserved for hypervisor
 ffff880000000000 | -120    TB | ffff887fffffffff |  0.5 TB | LDT remap for PTI
 ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)
 ffffc88000000000 |  -55.5  TB | ffffc8ffffffffff |  0.5 TB | ... unused hole
 ffffc90000000000 |  -55    TB | ffffe8ffffffffff |   32 TB | vmalloc/ioremap space (vmalloc_base)
 ffffe90000000000 |  -23    TB | ffffe9ffffffffff |    1 TB | ... unused hole
 ffffea0000000000 |  -22    TB | ffffeaffffffffff |    1 TB | virtual memory map (vmemmap_base)
 ffffeb0000000000 |  -21    TB | ffffebffffffffff |    1 TB | ... unused hole
 ffffec0000000000 |  -20    TB | fffffbffffffffff |   16 TB | KASAN shadow memory
__________________|____________|__________________|_________|____________________________________________________________
							    |
							    | Identical layout to the 56-bit one from here on:
____________________________________________________________|____________________________________________________________
		  |            |                  |         |
 fffffc0000000000 |   -4    TB | fffffdffffffffff |    2 TB | ... unused hole
		  |            |                  |         | vaddr_end for KASLR
 fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping
 fffffe8000000000 |   -1.5  TB | fffffeffffffffff |  0.5 TB | ... unused hole
 ffffff0000000000 |   -1    TB | ffffff7fffffffff |  0.5 TB | %esp fixup stacks
 ffffff8000000000 | -512    GB | ffffffeeffffffff |  444 GB | ... unused hole
 ffffffef00000000 |  -68    GB | fffffffeffffffff |   64 GB | EFI region mapping space
 ffffffff00000000 |   -4    GB | ffffffff7fffffff |    2 GB | ... unused hole
 ffffffff80000000 |   -2    GB | ffffffff9fffffff |  512 MB | kernel text mapping, mapped to physical address 0
 ffffffff80000000 |-2048    MB |                  |         |
 ffffffffa0000000 |-1536    MB | fffffffffeffffff | 1520 MB | module mapping space
 ffffffffff000000 |  -16    MB |                  |         |
    FIXADDR_START | ~-11    MB | ffffffffff5fffff | ~0.5 MB | kernel-internal fixmap range, variable size and offset
 ffffffffff600000 |  -10    MB | ffffffffff600fff |    4 kB | legacy vsyscall ABI
 ffffffffffe00000 |   -2    MB | ffffffffffffffff |    2 MB | ... unused hole
__________________|____________|__________________|_________|___________________________________________________________
</pre>
</div>
</div>
</div>

<div id="outline-container-org516227e" class="outline-4">
<h4 id="org516227e"><span class="section-number-4">8.1.2</span> 具有五级页表的虚拟地址空间</h4>
<div class="outline-text-4" id="text-8-1-2">
<div class="org-src-container">
<pre class="src src-fundamental">========================================================================================================================
    Start addr    |   Offset   |     End addr     |  Size   | VM area description
========================================================================================================================
		  |            |                  |         |
 0000000000000000 |    0       | 00ffffffffffffff |   64 PB | user-space virtual memory, different per mm
__________________|____________|__________________|_________|___________________________________________________________
		  |            |                  |         |
 0100000000000000 |  +64    PB | feffffffffffffff | ~16K PB | ... huge, still almost 64 bits wide hole of non-canonical
		  |            |                  |         |     virtual memory addresses up to the -64 PB
		  |            |                  |         |     starting offset of kernel mappings.
__________________|____________|__________________|_________|___________________________________________________________
							    |
							    | Kernel-space virtual memory, shared between all processes:
____________________________________________________________|___________________________________________________________
		  |            |                  |         |
 ff00000000000000 |  -64    PB | ff0fffffffffffff |    4 PB | ... guard hole, also reserved for hypervisor
 ff10000000000000 |  -60    PB | ff10ffffffffffff | 0.25 PB | LDT remap for PTI
 ff11000000000000 |  -59.75 PB | ff90ffffffffffff |   32 PB | direct mapping of all physical memory (page_offset_base)
 ff91000000000000 |  -27.75 PB | ff9fffffffffffff | 3.75 PB | ... unused hole
 ffa0000000000000 |  -24    PB | ffd1ffffffffffff | 12.5 PB | vmalloc/ioremap space (vmalloc_base)
 ffd2000000000000 |  -11.5  PB | ffd3ffffffffffff |  0.5 PB | ... unused hole
 ffd4000000000000 |  -11    PB | ffd5ffffffffffff |  0.5 PB | virtual memory map (vmemmap_base)
 ffd6000000000000 |  -10.5  PB | ffdeffffffffffff | 2.25 PB | ... unused hole
 ffdf000000000000 |   -8.25 PB | fffffbffffffffff |   ~8 PB | KASAN shadow memory
__________________|____________|__________________|_________|____________________________________________________________
							    |
							    | Identical layout to the 47-bit one from here on:
____________________________________________________________|____________________________________________________________
		  |            |                  |         |
 fffffc0000000000 |   -4    TB | fffffdffffffffff |    2 TB | ... unused hole
		  |            |                  |         | vaddr_end for KASLR
 fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping
 fffffe8000000000 |   -1.5  TB | fffffeffffffffff |  0.5 TB | ... unused hole
 ffffff0000000000 |   -1    TB | ffffff7fffffffff |  0.5 TB | %esp fixup stacks
 ffffff8000000000 | -512    GB | ffffffeeffffffff |  444 GB | ... unused hole
 ffffffef00000000 |  -68    GB | fffffffeffffffff |   64 GB | EFI region mapping space
 ffffffff00000000 |   -4    GB | ffffffff7fffffff |    2 GB | ... unused hole
 ffffffff80000000 |   -2    GB | ffffffff9fffffff |  512 MB | kernel text mapping, mapped to physical address 0
 ffffffff80000000 |-2048    MB |                  |         |
 ffffffffa0000000 |-1536    MB | fffffffffeffffff | 1520 MB | module mapping space
 ffffffffff000000 |  -16    MB |                  |         |
    FIXADDR_START | ~-11    MB | ffffffffff5fffff | ~0.5 MB | kernel-internal fixmap range, variable size and offset
 ffffffffff600000 |  -10    MB | ffffffffff600fff |    4 kB | legacy vsyscall ABI
 ffffffffffe00000 |   -2    MB | ffffffffffffffff |    2 MB | ... unused hole
__________________|____________|__________________|_________|___________________________________________________________

</pre>
</div>


<div class="org-src-container">
<pre class="src src-c">
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c">
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c">
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c">
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c">
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2021-12-02 Thu 23:07</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
