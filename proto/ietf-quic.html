<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ietf-quic协议</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">ietf-quic协议</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgce44892">1. 概览</a>
<ul>
<li><a href="#orgc807eea">1.1. 文档结构</a>
<ul>
<li><a href="#orgc43ff2a">1.1.1. Stream：QUIC提供的基础服务抽象</a></li>
<li><a href="#org1528995">1.1.2. Connection：QUIC端点通信的上下文</a></li>
<li><a href="#org573b500">1.1.3. Packet和Frame：QUIC通信的基本单位</a></li>
<li><a href="#org81b9513">1.1.4. QCUI协议元素的编码细节</a></li>
</ul>
</li>
<li><a href="#org07cfe13">1.2. 术语定义</a></li>
<li><a href="#orgcb3418f">1.3. 符号约定</a></li>
</ul>
</li>
<li><a href="#org3d63a7d">2. Streams</a>
<ul>
<li><a href="#org49ea271">2.1. stream类型和标识</a></li>
<li><a href="#org7ed0742">2.2. 发送和接收数据</a></li>
<li><a href="#orgc694200">2.3. Stream优先级</a></li>
<li><a href="#org0dcd072">2.4. stream操作</a></li>
</ul>
</li>
<li><a href="#orge157dc6">3. stream状态</a>
<ul>
<li><a href="#orgcf4704a">3.1. Stream发送状态</a></li>
<li><a href="#org94eae5c">3.2. 接受 Stream States</a></li>
<li><a href="#orgf591e34">3.3. 允许的帧类型</a></li>
<li><a href="#org3e71129">3.4. 双向的Stream状态</a></li>
<li><a href="#org89c6c81">3.5. 请求状态转换</a></li>
</ul>
</li>
<li><a href="#org4de4d28">4. 流量控制</a>
<ul>
<li><a href="#org228e530">4.1. 数据流控</a></li>
<li><a href="#org83d314a">4.2. 增加流控限制</a></li>
<li><a href="#org0b51b82">4.3. 流控性能</a></li>
<li><a href="#org06a1eac">4.4. 处理stream撤销</a></li>
<li><a href="#org693578c">4.5. stream最终大小</a></li>
<li><a href="#org523e769">4.6. 控制并发</a></li>
</ul>
</li>
<li><a href="#orgc1c311e">5. 连接</a>
<ul>
<li><a href="#org27b6638">5.1. Connection ID</a>
<ul>
<li><a href="#orgadff140">5.1.1. Connection ID问题</a></li>
<li><a href="#org078dca2">5.1.2. 使用和停用Conneciton ID</a></li>
</ul>
</li>
<li><a href="#org133cd1d">5.2. 数据包和连接的匹配</a>
<ul>
<li><a href="#orgff31ae2">5.2.1. Client数据包处理</a></li>
<li><a href="#org381f818">5.2.2. Server数据包处理</a></li>
<li><a href="#org1b5ec66">5.2.3. 考虑一个简单的负载均衡</a></li>
</ul>
</li>
<li><a href="#orgcf5734d">5.3. 连接操作</a></li>
</ul>
</li>
<li><a href="#org171d2e7">6. 版本协商</a>
<ul>
<li><a href="#org5f5d790">6.1. 发送版本协商数据包</a></li>
<li><a href="#org9a1cd56">6.2. 处理版本协商数据包</a></li>
<li><a href="#org0c1b719">6.3. 使用保留的版本</a></li>
</ul>
</li>
<li><a href="#org767f96b">7. 握手的加密和传输</a>
<ul>
<li><a href="#org4dff9f9">7.1. 握手流的示例</a></li>
<li><a href="#org698a288">7.2. 协商Connection ID</a></li>
<li><a href="#org75953b8">7.3. Connection ID认证</a></li>
<li><a href="#org6b720e0">7.4. 传输参数</a>
<ul>
<li><a href="#org022a440">7.4.1. 0-RTT的传输参数值</a></li>
<li><a href="#org768aa19">7.4.2. 新的传输参数</a></li>
</ul>
</li>
<li><a href="#orgbe0a75e">7.5. 缓冲加密消息</a></li>
</ul>
</li>
<li><a href="#orgf8d98d2">8. 地址验证</a>
<ul>
<li><a href="#orgbaac176">8.1. 连接建立期间的地址验证</a>
<ul>
<li><a href="#org5fd9e80">8.1.1. Token结构</a></li>
<li><a href="#orga7f20ac">8.1.2. 使用Retry数据包进行地址验证</a></li>
<li><a href="#org3e95370">8.1.3. 后续连接的地址验证</a></li>
<li><a href="#org6512349">8.1.4. 地址验证token的完整性</a></li>
</ul>
</li>
<li><a href="#orgbdb94ee">8.2. 路径验证</a>
<ul>
<li><a href="#org1d09891">8.2.1. 启动路径验证</a></li>
<li><a href="#org8dd3c13">8.2.2. 路径验证的响应</a></li>
<li><a href="#orga0e73e4">8.2.3. 路径验证成功</a></li>
<li><a href="#org96b8658">8.2.4. 路径验证失败</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgad55bc7">9. 连接迁移</a>
<ul>
<li><a href="#orgcce5d96">9.1. 探测新路径</a></li>
<li><a href="#org9f709c1">9.2. 响应连接迁移</a>
<ul>
<li><a href="#org60def95">9.2.1. 对等地址欺骗</a></li>
<li><a href="#org6ecea0f">9.2.2. 路径中的地址欺骗</a></li>
<li><a href="#org221f230">9.2.3. 路径之外的数据包转发</a></li>
</ul>
</li>
<li><a href="#orga198562">9.3. 丢包检测和拥塞控制</a></li>
<li><a href="#org8a2949f">9.4. 连接迁移的私有数据的影响</a></li>
<li><a href="#org799e5c4">9.5. server的首选地址</a>
<ul>
<li><a href="#orgded576e">9.5.1. 首选地址的传递</a></li>
<li><a href="#orgfd649be">9.5.2. 迁移到首选地址</a></li>
<li><a href="#org0de7ffb">9.5.3. client迁移和首选地址的交互</a></li>
<li><a href="#org1801c46">9.5.4. IPv6流标签的使用和迁移</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6515396">10. 连接终止</a>
<ul>
<li><a href="#orgafad81d">10.1. 空闲超时</a>
<ul>
<li><a href="#org6f721fd">10.1.1. 存活探测</a></li>
<li><a href="#org4ffccad">10.1.2. 延迟空闲超时</a></li>
</ul>
</li>
<li><a href="#org8ff3c2e">10.2. 立即关闭</a>
<ul>
<li><a href="#org913f691">10.2.1. Closing连接状态</a></li>
<li><a href="#org6cea21d">10.2.2. Draining连接状态</a></li>
<li><a href="#orgf84f6c8">10.2.3. 握手期间的立即关闭</a></li>
</ul>
</li>
<li><a href="#org92e2ff8">10.3. 无状态重置</a>
<ul>
<li><a href="#org6e7406f">10.3.1. 检测无状态重置</a></li>
<li><a href="#orgf855924">10.3.2. 计算无状态重置token</a></li>
<li><a href="#org8f8e3ee">10.3.3. 环路</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6c91727">11. 错误处理</a>
<ul>
<li><a href="#org1992544">11.1. 连接错误</a></li>
<li><a href="#org6381f7a">11.2. Stream错误</a></li>
</ul>
</li>
<li><a href="#orga3b39b6">12. 数据包和帧</a>
<ul>
<li><a href="#org39f01bc">12.1. 受保护的数据包</a></li>
<li><a href="#org79bf252">12.2. 合并数据包</a></li>
<li><a href="#orgdde20f8">12.3. 数据包编号</a></li>
<li><a href="#org4cefe13">12.4. 帧和帧类型</a></li>
<li><a href="#org8a6a4a1">12.5. 帧和数据包号空间</a></li>
</ul>
</li>
<li><a href="#org78dcce4">13. 打包及可靠性</a>
<ul>
<li><a href="#org4d07d05">13.1. 数据包处理</a></li>
<li><a href="#org2e80701">13.2. 生成确认</a>
<ul>
<li><a href="#org7c63dd6">13.2.1. 发送ACK帧</a></li>
<li><a href="#org8a1fd9f">13.2.2. 确认的频率</a></li>
<li><a href="#org8b43eb2">13.2.3. 管理ACK的范围</a></li>
<li><a href="#orgbc2682e">13.2.4. 通过跟踪ACK帧来限制范围</a></li>
<li><a href="#org4e4ccb0">13.2.5. 主机延迟的测量和报告</a></li>
<li><a href="#orge395b3f">13.2.6. ACK帧和数据包保护</a></li>
<li><a href="#org07347af">13.2.7. PADDING帧对拥塞窗口的消耗</a></li>
<li><a href="#org91c17e7">13.2.8. 重传消息</a></li>
</ul>
</li>
<li><a href="#orgbd123b7">13.3. 显示的拥塞通知</a>
<ul>
<li><a href="#org07b2787">13.3.1. ECN计数的上报</a></li>
<li><a href="#org9aaa906">13.3.2. ECN验证</a>
<ul>
<li><a href="#org4fb6fdc">13.3.2.1. 接收带有ECN计数的ACK帧</a></li>
<li><a href="#org95edc40">13.3.2.2. ECN验证结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd5fef71">14. 数据报大小</a>
<ul>
<li><a href="#org28cf0a9">14.1. 初始数据报大小</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
flow control credit：流量控制信用，暂时理解为类似tcp的通告窗口大小。
</p>

<div id="outline-container-orgce44892" class="outline-2">
<h2 id="orgce44892"><span class="section-number-2">1.</span> 概览</h2>
<div class="outline-text-2" id="text-1">
<p>
QUIC 是一种安全的通用传输协议。本文档为 QUIC v1 版本定义的内容。
</p>

<p>
QUIC 是一种面向连接的协议，它在client和server之间创建有状态的交互。
</p>

<p>
QUIC 握手整合了加密和传输参数的协商。 QUIC使用定制的框架进行 TLS 握手。 [QUIC-TLS]中详细描述了TLS和QUIC的集成。握手的过程被设计为能够尽快交换应用程序数据，例如client立即发送数据 (0-RTT) 的选项（需要事先通信或配置才能启用）。
</p>

<p>
QUIC端点通过交换QUIC数据包进行通讯，大部分数据包所包含的帧会在端点之间携带控制信息和应用数据。QUIC验证每个数据包并且尽可能的加密每个数据包。QUIC数据包包含在UDP数据报中，可以很方便的在系统和网络中部署。
</p>

<p>
在QUIC连接上，应用协议通过stream（有序字节序列）交换信息。分为两种stream：双向stream：两个端点都可以发送数据; 单向stream：只允许单个方向发送数据。基于信用的方案用于限制stream创建，并限制可以发送的数据量。
</p>

<p>
QUIC中提供了一些必要的反馈信息，用来实现可靠交付以及拥塞控制。[QUIC-RECOVERY]的第6小节描述了丢失数据的检测和恢复算法。[QUIC-RECOVERY]第7小节中描述了一种塞控制算法。
</p>


<p>
QUIC连接不会严格绑定到某个网络路径。QUIC中提供了连接迁移，能够通过连接标识符（Connection ID）将连接迁移到新的网络路径。在此版本中（QUIC v1），只提供了客户端的连接迁移功能。连接迁移能够允许网络拓扑或者地址映射的变化。
</p>

<p>
QUIC连接建立后，可以通过多种选项来终止连接：应用正常关闭，端点协商超时时间，发生错误时立即断开，在一个端点丢失状态后无状态机制提供的终止连接。
</p>
</div>

<div id="outline-container-orgc807eea" class="outline-3">
<h3 id="orgc807eea"><span class="section-number-3">1.1.</span> 文档结构</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-orgc43ff2a" class="outline-4">
<h4 id="orgc43ff2a"><span class="section-number-4">1.1.1.</span> Stream：QUIC提供的基础服务抽象</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>第 2 节描述了与Stream相关的核心概念，</li>
<li>第 3 节提供了stream状态的参考模型，</li>
<li>第 4 节概述了流量控制的操作。</li>
</ul>
</div>
</div>

<div id="outline-container-org1528995" class="outline-4">
<h4 id="org1528995"><span class="section-number-4">1.1.2.</span> Connection：QUIC端点通信的上下文</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>第 5 节描述了与连接相关的核心概念，</li>
<li>第 6 节描述了版本协商，</li>
<li>第 7 节详细介绍了建立连接的过程，</li>
<li>第 8 节描述了地址验证和拒绝服务的紧急缓解措施，</li>
<li>第 9 节描述了端点如何将连接迁移到新的网络路径，</li>
<li>第 10 节列出了终止连接时的选项，以及</li>
<li>第 11 节提供了对于stream和connection错误处理的指导。</li>
</ul>
</div>
</div>

<div id="outline-container-org573b500" class="outline-4">
<h4 id="org573b500"><span class="section-number-4">1.1.3.</span> Packet和Frame：QUIC通信的基本单位</h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li>第 12 节描述了与Packet和Frame相关的概念，</li>
<li>第 13 节定义了数据的传输、重传、和确认的模型，以及</li>
<li>第 14 节规定了管理数据报大小的规则携带QUIC数据包。</li>
<li>第 14 节规定了管理数据报携带QUIC数据包大小的规则。</li>
</ul>
</div>
</div>

<div id="outline-container-org81b9513" class="outline-4">
<h4 id="org81b9513"><span class="section-number-4">1.1.4.</span> QCUI协议元素的编码细节</h4>
<div class="outline-text-4" id="text-1-1-4">
<ul class="org-ul">
<li>第 15 节（版本），</li>
<li>第 16 节（整数编码），</li>
<li>第 17 节（packet headers），</li>
<li>第 18 节（传输参数），</li>
<li>第 19 条（frames），以及</li>
<li>第 20 节（错误）。</li>
</ul>


<p>
[QUIC-RECOVERY]描述了 QUIC 的丢失检测和拥塞控制。
</p>

<p>
[QUIC-TLS]描述了使用 TLS 和其他加密机制。
</p>
</div>
</div>
</div>

<div id="outline-container-org07cfe13" class="outline-3">
<h3 id="org07cfe13"><span class="section-number-3">1.2.</span> 术语定义</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Endpoint: QUIC连接中的可以生成、接收、处理QUIC数据包的实体。分为两种：client， server。</li>
<li>Client: 发起QUIC连接的端点。</li>
<li>Server: 被动接收QUIC连接的端点。</li>
<li>QUIC packet: 可以被压缩到UDP数据报中的单元。一个UDP 数据报中可以包含一个或多个quic packet。</li>
<li>Ack-eliciting packet: 指QUIC packet中包含的帧是除ACK、PADDING、CONNECTION CLOSE以外的帧。</li>
<li>Frame: 结构化的协议信息单元，有多种类型的frame，每种包含不同的信息，frame包含在quic packet中。</li>
<li>Address: 没有任何限定时，表示网络路径的一端的IP版本、IP地址、UDP端口号的三元组。</li>
<li>Connection ID: 用于标识一个端点的QUIC连接，每个端点都会为对等端选择一个或者多个Connection ID并将其包含在要发送的数据报中。</li>
<li>Stream: QUIC连接中的一个单项或者双向的顺序字节流通道。一个QUIC连接可以同时携带多个stream。</li>
<li>Application: 使用QUIC的发送或者接收数据的实例。</li>
</ul>
</div>
</div>

<div id="outline-container-orgcb3418f" class="outline-3">
<h3 id="orgcb3418f"><span class="section-number-3">1.3.</span> 符号约定</h3>
<div class="outline-text-3" id="text-1-3">
<p>
文档中使用的Packet和Frame的图都是自定义格式，目的是为了总结和描述协议。
</p>

<p>
Individual fields include length information, plus indications about fixed value, optionality, or repetitions.  Individual fields use the following notational conventions, with all lengths in bits:
</p>

<p>
单个字段包括长度信息，以及关于固定值、可选性或重复的提示。各个字段使用以下符号约定，所有长度均以位为单位：
</p>

<p>
x(A)：表示x占用A比特位
</p>

<p>
x(i)：表示 x 使用第 16 节中描述的长度编码保存的数值。
</p>

<p>
x(A..B)：表示x可以是从A到B的任意长度；A省略表示最少零位，B省略表示没有设定上限；这种格式的值总是以字节边界结束。
</p>

<p>
x(L)=C：表示x有一个固定值C；长度由 L 描述，它可以使用上述任何长度形式。
</p>

<p>
x (L) = C..D：表示x的值在C到D的范围内， L 同上。
</p>

<p>
[x(L)]：表示x是可选的，长度为L。
</p>

<p>
x (L) &#x2026;：表示 x 重复零次或多次，并且
   每个实例的长度为 L
</p>

<p>
本文档使用网络字节序（大端序）。字段从每个字节的高位开始放置。
</p>

<p>
图 1 提供了一个示例：
</p>

<div class="org-src-container">
<pre class="src src-fundamental">
Example Structure {
  One-bit Field (1),           //&#21333;&#20010;&#27604;&#29305;&#20301;&#30340;&#23383;&#27573;
  7-bit Field with Fixed Value (7) = 61,  //&#20540;&#20026;61&#30340;7&#27604;&#29305;&#20301;&#30340;&#23383;&#27573;
  Field with Variable-Length Integer (i), //&#25972;&#24418;&#30340;&#38271;&#24230;&#21464;&#37327;&#23383;&#27573;
  Arbitrary-Length Field (..),  //&#20219;&#24847;&#38271;&#24230;&#30340;&#23383;&#27573;
  Variable-Length Field (8..24), //8bit-24bit&#38271;&#24230;&#30340;&#23383;&#27573;
  Field With Minimum Length (16..),  //&#26368;&#23567;16&#20301;&#30340;&#23383;&#27573;
  Field With Maximum Length (..128), //&#26368;&#38271;128&#20301;&#30340;&#23383;&#27573;
  [Optional Field (64)],  //&#21487;&#36873;&#30340;64&#20301;&#30340;&#23383;&#27573;
  Repeated Field (8) ..., //8bit&#30340;&#23383;&#27573;&#37325;&#22797;0&#27425;&#25110;&#32773;&#22810;&#27425;&#12290;
}

                       Figure 1: Example Format
</pre>
</div>


<p>
当使用单个bit的字段时，可以通过携带比特位的字节值来说明bit位的位置。例如，0x80表示字节的最高位。
</p>
</div>
</div>
</div>

<div id="outline-container-org3d63a7d" class="outline-2">
<h2 id="org3d63a7d"><span class="section-number-2">2.</span> Streams</h2>
<div class="outline-text-2" id="text-2">
<p>
QUIC中的stream为应用提供了轻量且有序的字节流抽象。 Stream可以是单向或者双向。
</p>

<p>
Stream可以通过发送数据来创建。stream管理相关的其他操作（stream的结束、撤销、流控管理）都尽量设计为最小开销。例如单个STREAM帧可以打开stream、携带数据、关闭stream。Stream可以长时间存在，可以在连接持续期间一直存在。
</p>

<p>
Stream可以由任一端点创建，可以和其他stream同时交错的发送数据，也可以撤销。
</p>

<p>
QUIC 允许任意数量的流并发操作，并允许在任何流上发送任意数量的数据，受流控制约束和流限制（第4节）。
</p>
</div>

<div id="outline-container-org49ea271" class="outline-3">
<h3 id="org49ea271"><span class="section-number-3">2.1.</span> stream类型和标识</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Stream可以是单向或者双向的。单向Stream只能在发起者向对等端方向上携带数据。双向stream允许在两个方向发送数据。
</p>

<p>
stream在连接中由一个数值标识，称为stream ID。Stream ID 是一个 62 位整数（0 到 2<sup>62-1</sup>），在quic connecton中唯一标识stream。Stream ID 被编码为可变长度的整数。 QUIC 端点不得在一个连接中重用Stream ID。
</p>

<p>
Stream ID的最低位（0x01）标识连接的发起端。Client发起的stream，将最低位置0，Stream ID为偶数。Server发起的stream将最低位置1，Stream ID为奇数。
</p>

<p>
Stream ID的第二位（0x02）标识是双向stream（置0）还是单向stream（置1）。
</p>

<p>
第两位的组合类型 如下：
</p>
<div class="org-src-container">
<pre class="src src-fundmental">                +======+==================================+
                | Bits | Stream Type                      |
                +======+==================================+
                | 0x00 | Client-Initiated, Bidirectional  |
                +------+----------------------------------+
                | 0x01 | Server-Initiated, Bidirectional  |
                +------+----------------------------------+
                | 0x02 | Client-Initiated, Unidirectional |
                +------+----------------------------------+
                | 0x03 | Server-Initiated, Unidirectional |
                +------+----------------------------------+

                          Table 1: Stream ID Types

低两位00 : client发起，双向
低两位01 : server发起，双向
低两位10 : client发起，单向
低两位11 : server发起，单向

</pre>
</div>

<p>
每种类型的stream空间从最小值开始（分别为0x00和0x03）。每种类型的连续stream都会通过递增的Stream ID创建。
</p>
</div>
</div>

<div id="outline-container-org7ed0742" class="outline-3">
<h3 id="org7ed0742"><span class="section-number-3">2.2.</span> 发送和接收数据</h3>
<div class="outline-text-3" id="text-2-2">
<p>
STREAM帧中封装了应用要发送的数据。端点使用STREAM帧中的stream ID和Offset字段来顺序的放置数据。
</p>

<p>
端点必须能够将stream数据作为有序的字节流递送给应用。这要求端点缓存接收到的任何乱序的数据，直到达到流控的限制。
</p>

<p>
端点可能在stream上相同stream offset处多次收到数据。已经接收的数据可以被丢弃。如果要多次发送给定Offset的数据，则数据一定不能修改；端点可以将相同offset处的不同数据视为PROTOCOL_VIOLATION连接错误。
</p>

<p>
端点除非确保在对等端设置的流控限制内，否则不能在任何stream发送数据。
</p>
</div>
</div>

<div id="outline-container-orgc694200" class="outline-3">
<h3 id="orgc694200"><span class="section-number-3">2.3.</span> Stream优先级</h3>
<div class="outline-text-3" id="text-2-3">
<p>
如果合理分配stream的资源的优先级，则stream的复用可以很大程度上提升应用性能。
</p>

<p>
QUIC不提供优先级信息的交换机制。相反，它依赖于从应用程序接收优先级信息。
</p>

<p>
QUIC 实现应该提供应用程序可以指示stream相对优先级的方法。实现能够通过使用应用提供的信息来决定如何为活跃的stream分配资源。
</p>
</div>
</div>

<div id="outline-container-org0dcd072" class="outline-3">
<h3 id="org0dcd072"><span class="section-number-3">2.4.</span> stream操作</h3>
<div class="outline-text-3" id="text-2-4">
<p>
文档中没有为QUIC定义API，而是定义应用协议可以依赖的函数集。应用协议可以假设QUIC提供了本节描述的操作接口。
</p>

<p>
在stream的发送端，应用协议能够：
</p>
<ul class="org-ul">
<li>写数据，能够根据对等端发送的流控信用，发送已经写入的数据。</li>
<li>结束stream，导致发送一个FIN被置位的STREAM帧。</li>
<li>reset stream，如果stream不是终止状态，则发送一个RESET_STREAM帧。</li>
</ul>

<p>
在stream的接收端，应用协议能够：
</p>
<ul class="org-ul">
<li>读数据</li>
<li>终止读取,并关闭请求，可能导致发送STOP_SENDING帧。</li>
</ul>

<p>
应用协议也可以请求获取stream上的状态变化，包括对等端是否打开或者重置stream，对等端是否终止读取stream，新数据是不是可用，数据由于流控限制可写或者不可写。
</p>
</div>
</div>
</div>

<div id="outline-container-orge157dc6" class="outline-2">
<h2 id="orge157dc6"><span class="section-number-2">3.</span> stream状态</h2>
<div class="outline-text-2" id="text-3">
<p>
本节分别从stream的发送组件和接收组件来描述stream。分为两种状态机：用于端点发送数据的stream，用于端点接收数据的stream。
</p>

<p>
单向stream使用发送状态还是接收状态，取决于stream类型和端点的角色。双向stream在两个端点都使用两个状态机。大部分情况下，不管是双向还是单向stream，状态机都是相同的。对于双向stream来说，打开stream的条件会更复杂，因为发送端或者接收端任何一方打开都会导致stream在两个方向上打开。？？？？？？？
</p>


<p>
文档中使用stream状态来描述不同类型的帧何时或者怎样被发送，以及接收到不同类型的帧时的反应。实现方式可以定义不同的状态机，只要能够和这些状态机的行为一致就可以。
</p>
</div>

<div id="outline-container-orgcf4704a" class="outline-3">
<h3 id="orgcf4704a"><span class="section-number-3">3.1.</span> Stream发送状态</h3>
<div class="outline-text-3" id="text-3-1">
<p>
以下展示了stream发送数据到对等端的的状态变化:
</p>

<div class="org-src-container">
<pre class="src src-fundmental">
    o
    | Create Stream (Sending)
    | Peer Creates Bidirectional Stream
    v
+-------+
| Ready | Send RESET_STREAM
|       |-----------------------.
+-------+                       |
    |                           |
    | Send STREAM /             |
    |      STREAM_DATA_BLOCKED  |
    v                           |
+-------+                       |
| Send  | Send RESET_STREAM     |
|       |----------------------&gt;|
+-------+                       |
    |                           |
    | Send STREAM + FIN         |
    v                           v
+-------+                   +-------+
| Data  | Send RESET_STREAM | Reset |
| Sent  |------------------&gt;| Sent  |
+-------+                   +-------+
    |                           |
    | Recv All ACKs             | Recv ACK
    v                           v
+-------+                   +-------+
| Data  |                   | Reset |
| Recvd |                   | Recvd |
+-------+                   +-------+

         Figure 2: States for Sending Parts of Streams
</pre>
</div>

<p>
Ready代表新创建的Stream, 可以从应用程序接收数据。 Stream数据可能会在此状态缓存以准备发送。
</p>

<p>
首次发送“STREAM"或者"STREAM_DATA_BLOCKED"帧会使得Stream的发送部分进入”Send“状态。实现方式可能会选择推迟为stream分配Stream ID，直到它发送第一个 STREAM 帧并进入Send状态，以便更好的做Stream优化。
</p>

<p>
如果对等端发起双向stream导致的接收部分被创建时，其发送部分也从”Ready“状态开始。
</p>

<p>
在”Send“状态中，端点在STREAM帧中传输Stream数据（必要时重传）。端点遵循对等端设置的流控规则，并继续接收和处理MAX_STREAM_DATA的帧。端点如果在”Send“状态下被stream流控阻塞时，会生成STREAM_DATA_BLOCKED帧。
</p>

<p>
在应用程序指示已发送所有stream数据，并发送包含 FIN 标志的 STREAM 帧之后，stream的发送端进入”Data Sent“状态，在此状态下，端点仅在必要时重传stream数据，并且不需要检查流控限制，或者发送STREAM_DATA_BLOCKED帧。直到对等端接收了最终的stream offset后才可能收到MAX_FRAME_DATA帧。在”Data Sent“状态下，端点可以忽略从对等端接收的任何MAX_STREAM_DATA帧。
</p>

<p>
一旦所有的stream数据被全部确认，stream的发送部分进入”Data Recvd“状态，这是一个最终状态。
</p>

<p>
在”Ready“、”Send“、”Data Sent“状态下，应用可以发信号表示希望放弃stream data的传输，或者端点可能会接收到对等端发送的STOP_SENDING帧，这两种情况都会导致发送RESET_STREAM帧，使得stream进入”Reset Recvd“状态。
</p>

<p>
端点可能发送RESET_STREAM帧作为stream的第一帧，这会使得stream的发送部分打开后立即转换到”Reset Recvd“状态。
</p>

<p>
一旦包含RESET_STREAM的数据包被确认，stream的发送部分进入”Reset Recvd“状态（最终状态）。
</p>
</div>
</div>

<div id="outline-container-org94eae5c" class="outline-3">
<h3 id="org94eae5c"><span class="section-number-3">3.2.</span> 接受 Stream States</h3>
<div class="outline-text-3" id="text-3-2">
<p>
以下显示了从对等端接收数据的stream状态。stream的接收部分仅仅镜像对等端发送部分的一些状态（例如接收端没有Ready状态）。接收端会跟踪数据递送到应用的情况，而这些对发送端是不可见的。
</p>

<div class="org-src-container">
<pre class="src src-fundmental">
    o
    | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
    | Create Bidirectional Stream (Sending)
    | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
    | Create Higher-Numbered Stream
    v
+-------+
| Recv  | Recv RESET_STREAM
|       |-----------------------.
+-------+                       |
    |                           |
    | Recv STREAM + FIN         |
    v                           |
+-------+                       |
| Size  | Recv RESET_STREAM     |
| Known |----------------------&gt;|
+-------+                       |
    |                           |
    | Recv All Data             |
    v                           v
+-------+ Recv RESET_STREAM +-------+
| Data  |--- (optional) ---&gt;| Reset |
| Recvd |  Recv All Data    | Recvd |
+-------+&lt;-- (optional) ----+-------+
    |                           |
    | App Read All Data         | App Read Reset
    v                           v
+-------+                   +-------+
| Data  |                   | Reset |
| Read  |                   | Read  |
+-------+                   +-------+

        Figure 3: States for Receiving Parts of Streams

</pre>
</div>

<p>
当对等端发起stream，在stream收到第一个STREAM帧、STREAM_DATA_BLOCK帧或者RESET_STREAM帧后，接收部分被创建。当对等端发起双向stream，且发送部分接收到MAX_STREAM_DATA帧或者STOP_SENDING帧时，也会创建接收部分。接收部分的初始状态是”Recv“。
</p>

<p>
对于双向stream，当由端点初始化的发送端进入”Ready“状态后，其接收端同时进入”Recv”状态。
</p>

<p>
当端点在stream上接收到对等端发送的MAX_STREAM_DATA帧或者SOTP_SENDING帧时，会打开一条双向stream。如果从一个未打开的Stream上接收到MAX_STREAM_DATA帧，则表示对等端已经打开stream并提供流量控制信用。从一个未打开的stream上接收到STOP_SENDING帧，表示对等端不再希望在此stream上接收数据。如果出现数据包丢失或者重新排序，任何帧都有可能在STREAM帧或者STREAM_DATA_BLOCKED帧之前到达。
</p>

<p>
Before a stream is created, all streams of the same type with lower numbered stream IDs MUST be created.  This ensures that the creation order for streams is consistent on both endpoints.
相同类型的所有stream
</p>

<p>
在一条stream被创建之前，要保证所有相同类型的具有较低stream ID的流都已被创建（？？？）。这确保两个端点上的stream的创建顺序保持一致。
</p>

<p>
在”Recv“状态下，端点会接收到STREAM和STREAM_DATA_BLOCKED帧。传入的数据将被缓存并且可以被重组为正确的顺序以递交给应用程序。随着数据被应用程序消费，缓冲区将变为可用，端点发送MAX_STREAM_DATA帧以允许对等端发送更多数据。
</p>

<p>
当接收到带有FIN的STREAM帧时，就可以得到stream的最终大小，stream的接收部分进入”Size Know“状态。这个状态下端点不再需要发送MAX_STREAM_DATA帧，仅仅接收重传的stream data。
</p>

<p>
一旦stream的所有数据被接收，接收部分进入”Data Recvd“状态，这有可能发生在接收到带有FIN的STREAM帧（不确定理解是否正确）之后。  在所有数据被接收后，stream的上的任何STREAM和STREAM_DATA_BLOCKED都可以被丢弃。
</p>

<p>
”Data Recvd“状态会持续到stream的数据被递送至应用。一旦stream数据递送完成，stream进入”Data Read“状态（最终状态）。
</p>

<p>
在”Recv“或者”Size Know“状态接收到RESET_STREAM时，会导致stream进入”Reset Recvd”状态。这可能中断向应用递送stream数据。
</p>

<p>
有可能在全部stream数据被接收后，又收到RESET_STREAM帧。类似的，也有可能在收到RESET_STREAM帧后，其余的stream数据全部抵达。实际的实现可以自由的选择和管理这种情况。
</p>

<p>
发送RESET_STREAM帧意味着端点无法保证递送stream数据，但是没有要求在收到RESET_STREAM后就不能向应用递送stream数据。实现方式可以中断递送stream数据，丢弃任何未消费的stream数据，并通知接收到了RESET_STREAM。如果stream数据被接收完整并且缓存等待应用读取，RESET_STREAM可能被阻止或者保留。如果RESET_STREAM被阻止，stream的接收部分进入“Data Recvd”状态。
</p>

<p>
一旦应用程序接收到stream被重置的信号，接收部分转换到“Reset Read”状态（最终状态）。
</p>
</div>
</div>

<div id="outline-container-orgf591e34" class="outline-3">
<h3 id="orgf591e34"><span class="section-number-3">3.3.</span> 允许的帧类型</h3>
<div class="outline-text-3" id="text-3-3">
<p>
stream的发送端只会发送三种类型帧，这些帧会影响发送端或者接收端的的状态，分别是：STREAM、STREAM_DATA_BLOCKED、RESET_STREAM。
</p>

<p>
发送者在最终状态下（“Data  Recvd”或者“Reset Recvd”）不能发送任何帧。发送者在发送RESET_STREAM后不会在发送STREAM或者STREAM_DATA_BLOCKED帧。 接收者可能在任何状态下接收到STREAM、STREAM_DATA_BLOCKED、RESET_STREAM类型的帧（由于可能延迟交付携带这些帧的数据包）。
</p>

<p>
stream的接收者能够发送MAX_STREAM_DATA帧和STOP_SENDING帧。
</p>

<p>
接收端只会在“Recv”状态下发送MAX_STREAM_DATA帧。接收者在没有收到RESET_STREAM帧之前，可以在任意状态（除了“Reset Recvd”或者“Reset  Read”状态）发送STOP_SENDING。在“Data Recvd”状态下发送STOP_SENDING帧没有任何意义，因为所有stream数据都已经接收。由于可能延迟交付数据包，发送端可能在任意状态下接收MAX_STREAM_DATA或者STOP_SENDING帧。
</p>
</div>
</div>

<div id="outline-container-org3e71129" class="outline-3">
<h3 id="org3e71129"><span class="section-number-3">3.4.</span> 双向的Stream状态</h3>
<div class="outline-text-3" id="text-3-4">
<p>
双向stream由发送部分和接收部分组成。
</p>

<p>
实现可以将双向stream的状态表示为发送和接收状态的组合。最简单的模型是在发送或接收部分处于非终止状态时将stream表示为“open”状态，当发送部分和接收部分都处于终止状态时将stream表示为“closed“。
</p>

<p>
以下展示了双向stream状态的映射，大致对应于HTTP/2中定义的stream状态。这表明stream的发送部分或者接收部分的多个状态会映射到一个相同的组合状态上。注意这只是映射的一种可能性。这种映射要求在转换到”closed“或者”half-closed“状态之前数据要被确认。
</p>

<div class="org-src-container">
<pre class="src src-fundmental">+===================+=======================+=================+
| Sending Part      | Receiving Part        | Composite State |
+===================+=======================+=================+
| No Stream / Ready | No Stream / Recv (*1) | idle            |
+-------------------+-----------------------+-----------------+
| Ready / Send /    | Recv / Size Known     | open            |
| Data Sent         |                       |                 |
+-------------------+-----------------------+-----------------+
| Ready / Send /    | Data Recvd / Data     | half-closed     |
| Data Sent         | Read                  | (remote)        |
+-------------------+-----------------------+-----------------+
| Ready / Send /    | Reset Recvd / Reset   | half-closed     |
| Data Sent         | Read                  | (remote)        |
+-------------------+-----------------------+-----------------+
| Data Recvd        | Recv / Size Known     | half-closed     |
|                   |                       | (local)         |
+-------------------+-----------------------+-----------------+
| Reset Sent /      | Recv / Size Known     | half-closed     |
| Reset Recvd       |                       | (local)         |
+-------------------+-----------------------+-----------------+
| Reset Sent /      | Data Recvd / Data     | closed          |
| Reset Recvd       | Read                  |                 |
+-------------------+-----------------------+-----------------+
| Reset Sent /      | Reset Recvd / Reset   | closed          |
| Reset Recvd       | Read                  |                 |
+-------------------+-----------------------+-----------------+
| Data Recvd        | Data Recvd / Data     | closed          |
|                   | Read                  |                 |
+-------------------+-----------------------+-----------------+
| Data Recvd        | Reset Recvd / Reset   | closed          |
|                   | Read                  |                 |
+-------------------+-----------------------+-----------------+

      Table 2: Possible Mapping of Stream States to HTTP/2

|  如果stream还没有被创建，或者接收部分处于”Recv“状态并且没有收到
|  任何帧，则认为该stream为”idle“状态。

</pre>
</div>
</div>
</div>

<div id="outline-container-org89c6c81" class="outline-3">
<h3 id="org89c6c81"><span class="section-number-3">3.5.</span> 请求状态转换</h3>
<div class="outline-text-3" id="text-3-5">
<p>
如果应用不再关心stream上接收的数据，则可以直接终止读取，并指定一个应用错误码。
</p>

<p>
如果stream处于”Recv“或者”Size Known“状态，可以通过发送STOP_SENDING帧来通知反方向的stream关闭。这通常表示接收端应用不再读取stream上接收的数据，但不能保证传入的数据被忽略。
</p>

<p>
在发送SOTP_SENDING帧后收到的STREAM帧仍然被计入连接以及流量控制，即使这些帧马上被丢弃。
</p>

<p>
STOP_SENDING帧会请求其接收端发送RESET_STREAM帧。如果stream处于”Ready“或者”Send“状态，在收到STOP_SENDING帧后必须发送RESET_STREAM帧。如果stream处于”Data Sent“状态，则端点会延迟发送RESET_STREAM，直到以发送的数据包被确认或者已经丢失。
</p>

<p>
端点在回复RESET_STREAM帧时，应当将接收到的SOTP_SENDING帧中的错误码拷贝至要发送的RESET_STREAM帧中，但是也可以使用任意的应用错误码。端点在发送STOP_SENDING帧后，如果随后在该stream上收到RESET_STREAM帧，可以忽略该帧中的错误码。
</p>

<p>
仅当stream没有被对等端重置时才能够发送STOP_SENDING。STOP_SENDING大部分用在stream处于”Recv“或者”Size Known“状态的情况。
</p>

<p>
如果端点之前发送的包含STOP_SENDING的数据包丢失，则应当再次发送STOP_SENDING帧。但是如果在stream上接收到了所有数据或者收到RESET_STREAM帧（也就是stream只要不是”Recv“或者”Size Known“状态），此时STOP_SENDING可以不发送。
</p>

<p>
端点希望在双向stream上终止两个方向传输时，可以在一个方向上使用RESET_STREAM帧来终止，另一个方向发送STOP_SENDING帧来提示对等端关闭反方向的stream。
</p>
</div>
</div>
</div>

<div id="outline-container-org4de4d28" class="outline-2">
<h2 id="org4de4d28"><span class="section-number-2">4.</span> 流量控制</h2>
<div class="outline-text-2" id="text-4">
<p>
接收端需要限制缓冲的数据量，用来预防由于发送端过快而被数据淹没，以及一些恶意发送端导致消耗大量内存。为了能够实现对接收端连接的内存限制，stream可以被单独流控，也可以以连接为整体进行流控。QUIC接收端可以控制发送端在stream上发送的最大数据量，也可以控制所有stream上的总量。
</p>

<p>
类似的，为了限制连接内的并发，QUIC端点可以控制对等端可以发起的最大stream数量。
</p>

<p>
在CRYPTO帧中发送的数据和stream数据的流控方式不同，QUIC依赖加密协议实现来避免过度缓存数据（参照[QUIC-TLS]）。为了避免在多层次上缓冲数据，QUIC实现应当为加密协议提供接口来传递其缓冲区限制。
</p>
</div>

<div id="outline-container-org228e530" class="outline-3">
<h3 id="org228e530"><span class="section-number-3">4.1.</span> 数据流控</h3>
<div class="outline-text-3" id="text-4-1">
<p>
QCUI采用基于限制的流控方案，接收端在给定stream上或者在整个连接上通告其准备接收的总字节数。这就产生两种级别的流控：
</p>
<ul class="org-ul">
<li>Stream级别的流控：为了防止单个stream消耗真个连接的接收缓冲区，限制每条Stream上能够发送的数据量。</li>
<li>连接级别的流控：为了防止一条连接上发送端过度消耗接收端的缓冲区容量，限制所有stream上可以发送的数据总量。</li>
</ul>

<p>
当被任何一种流控策略限制时，发送端不得发送stream数据。
</p>

<p>
在握手期间，接收端通过传输参数来为所有stream设置初始限制，随后接收端通过发送MAX_STREAM_DATA帧或者MAX_DATA帧来向发送端通告更大的限制。
</p>

<p>
接收端通过在MAX_STREAM_DATA帧中携带Stream ID，来为对应的stream通告更大的限制。MAX_STREAM_DATA帧表示stream上的最大字节偏移。接收端可以根据当前stream上的数据消耗，决定要通告的流控偏移量。
</p>

<p>
接收端通过发送MAX_DATA帧在连接上通告更大的流控限制，该帧表示在所有stream上流控限制的最大值。接收端维护在所有stream上接收的总字节数，用来检查是否违反了通告的连接流控限制或者stream数据限制。接收端可以根据当前所有stream上消耗的字节总量，决定要通告的最大数据限制。
</p>

<p>
接收端为连接或者stream通告了限制后，还可以再次通知一个更小的限制，但是此时没有任何作用。
</p>

<p>
如果发送端违反了连接通告限制或者stream数据限制，接收端必须以FLOW_CONTROL_ERROR类型的错误关闭连接。
</p>

<p>
对于没有增加流控限制的MAX_STREAM_DATA或者MAX_DATA帧，发送端必需将其忽略。
</p>

<p>
如果发送端发送的数据达到限制，则不能发送任何新数据。发送端应该通过STREAM_DATA_BLOCKED或者DATA_BLOCKED帧来通知接收端，其有数据要发送但被流控限制阻塞。如果发送端阻塞时间超过了空闲时间，即使其有数据发送，接收端也可能关闭连接。为了防止连接关闭，发送端在被流控限制阻塞并且没有ack要发送的情况下，应当定期发送STREAM_DATA_BLOCKED帧或者DATA_BLOCKED帧。
</p>
</div>
</div>

<div id="outline-container-org83d314a" class="outline-3">
<h3 id="org83d314a"><span class="section-number-3">4.2.</span> 增加流控限制</h3>
<div class="outline-text-3" id="text-4-2">
<p>
//实现最终决定何时发送MAX_STREAM_DATA和MAX_DATA帧，本节提供了一些注意事项。
</p>

<p>
为了避免阻塞发送端，接收端可以在一个往返内多次发送MAX_STREAM_DATA或者MAX_DATA帧，也可以尽早发送以便为丢失帧或后续数据恢复留出时间。
</p>

<p>
控制帧会增加连接的开销，因此不建议频繁发送变化较小的MAX_STREAM_DATA和MAX_DATA帧。另一方面，如果更新不那么频繁，就需要更大的限制来避免发送端阻塞，这就要求发送端预留更多的资源。所以可以通过这两方面来权衡和确定其通告的限制大小。
</p>

<p>
接收端可以根据往返时间和接收端应用读取数据的速率来自动调整频率以及通告信用数量。作为优化，端点只在有其他帧要发送时才发送与流控相关的帧，以确保流控帧不需要发送额外的数据包。
</p>

<p>
发送端被阻塞时，不强制要求发送STREAM_DATA_BLOCKED或者DATA_BLOCK帧。因此，接收端在发送MAX_STREAM_DATA或者MAX_DATA帧之前，不能等待STREAM_DATA_BLOCK或者DATA_BLODKED帧，否则发送端会在连接的其余部分被阻塞（不理解）。即使发送端发送了STREAM_DATA_BLOCKED或者DATA_BLOCK帧，接收端等待这些帧会导致至少一个往行程。
</p>

<p>
发送端被阻塞后，如果收到流控信用通告，则可能允许在响应中发送大量数据，导致短暂的拥塞。有关发送方如何避免这种拥塞的讨论，请参见 [QUIC-RECOVERY] 的第 7.7 节。
</p>
</div>
</div>

<div id="outline-container-org0b51b82" class="outline-3">
<h3 id="org0b51b82"><span class="section-number-3">4.3.</span> 流控性能</h3>
<div class="outline-text-3" id="text-4-3">
<p>
如果端点无法保证对等端在连接上具有比其带宽延迟更大的可用流控信用，则其接收的吞吐量会受到流控限制。
</p>

<p>
数据包丢失会导致接收缓冲区出现空隙，从而阻止应用读取数据和释放接收缓冲区。
</p>

<p>
即使的发送流控限制可以提高性能。只发送流控限制数据包会增加网络负载，并影响性能。所以尽量将流控更新信息同其他帧一起发送（例如ACK），可以有效的降低更新的成本。
</p>
</div>
</div>

<div id="outline-container-org06a1eac" class="outline-3">
<h3 id="org06a1eac"><span class="section-number-3">4.4.</span> 处理stream撤销</h3>
<div class="outline-text-3" id="text-4-4">
<p>
端点最终需要同意每个stream消耗的流控信用量，以便记录连接级别的流控的全部字节。
</p>

<p>
在收到RESET_STREAM帧后，端点将拆除对应stream的状态，并忽略该stream上接收的数据。
</p>

<p>
RESET_STREAM会直接导致stream在一个方向上终止。对于双向stream，RESET_STREAM不会作用于反方向上的数据。如果stream上的某个方向没有终止，则两个端点必需维护该方向的流控状态，直到该方向进入终止状态。
</p>
</div>
</div>

<div id="outline-container-org693578c" class="outline-3">
<h3 id="org693578c"><span class="section-number-3">4.5.</span> stream最终大小</h3>
<div class="outline-text-3" id="text-4-5">
<p>
stream的最终大小表示stream消耗的流控信用总量。假设stream中的每个字节都发送一次，则最终大小为发送的字节大小。
</p>

<p>
无论stream时如何终止的，发送端总是会可靠的将最终大小传递给接收端。最终大小是带有FIN标志的STREAM帧中携带的Offset和Length字段的总和，这些字段可能是隐式的。或者，RESET_STREAM帧会携带的Final Size字段会包含最终大小的值。这保证两个端点就发送端在stream上消耗多少流控信用方面上达成一致。
</p>

<p>
当stream的接收端进入”Size Known“或者”Reset Recvd“状态时，端点就会知道最终大小。接收端必需使用stream的最终大小来说明stream在其连接级别流控制器中发送的所有字节。（不太理解）
</p>

<p>
当stream处于或者超过最终大小时，端点不得发送任何数据。
</p>

<p>
一旦获取到stream的最终大小后，不能再改变。如果接收到的RESET_STREAM或者STREAM帧，这些帧表示要修改stream的最终大小，端点应当响应FINAL_SIZE_ERROR类型的错误（第11节描述了错误处理细节）。接收端收到处于或者超过最终大小的数据时，应当将其视为FINAL_SIZE_ERROR类型的错误，即使在stream关闭之后也应如此。并不强制生成这些错误，因为生成这些错误也意味着端点需要为关闭的stream维护最终大小状态。
</p>
</div>
</div>

<div id="outline-container-org523e769" class="outline-3">
<h3 id="org523e769"><span class="section-number-3">4.6.</span> 控制并发</h3>
<div class="outline-text-3" id="text-4-6">
<p>
端点限制对等端能够打开传入的stream累计数量。仅当Stream ID小于（max_stream*4 + first_stream_di_of_type）时stream才能够被打开。初始限制会在传输参数中设置（18.2章节）。后续的限制通过MAX_STREAMS帧来通告（19.11章节）。独立限制适用于单向和双向stream。（不理解独立限制）
</p>

<p>
如果收到max_streams传输参数或者MAX_STREAMS帧，并且其值大于2<sup>60</sup>，此时将无法使用可变长的整数来表示Stream ID最大值（章节16），此时如果是max_streams传输参数，必需使用TRANSPORT_PARAMETER_ERROR类型的错误关闭连接; MAX_STREAMS帧则用FRAME_ENCODING_ERROR类型的错误关闭连接（章节10.2）。
</p>

<p>
端点一定不能超过对等端设置的限制。如果端点收到的帧Stream ID超过自己向对等端发送的值，必需视为STREAM_LIMIT_ERROR类型的连接错误（章节11有详细的错误处理）。
</p>

<p>
一旦接收端使用MAX_STREAMS帧通告stream限制，如果再次通告一个更小的值将不起作用。对于没有增加stream限制的MAX_STREAMS帧，必需将其忽略。
</p>

<p>
与stream和连接流控一样，本文档让实现来决定应当何时通过MAX_STREAMS通告对等端，以及限制多少stream。实现可以选择在stream被关闭时增加限制，以保持可用的stream数量和对等端大体一致。
</p>

<p>
端点由于对等端限制而不能打开新的stream时，应当发送STREAMS_BLOCK帧（章节19.14）。该信号对调试很有帮助。端点不得在通告附加的信用之前一直等待此信号，因为这样做会导致对等端被阻塞至少一个往返周期，如果对等端不发送STREAMS_BLOCKED帧，将会导致无限期的阻塞。
</p>
</div>
</div>
</div>

<div id="outline-container-orgc1c311e" class="outline-2">
<h2 id="orgc1c311e"><span class="section-number-2">5.</span> 连接</h2>
<div class="outline-text-2" id="text-5">
<p>
QUIC连接在client和server之间是一种共享状态。
</p>

<p>
每个连接都从握手阶段开始，在建立连接期间，两个端点通过加密握手协议[QUIC-TLS]协商共享密钥和应用层协议。握手（章节7）将确认两个端点将会通信（章节8.1），还会确认连接上的建连参数（章节7.4）。
</p>

<p>
应用协议在握手期间使用连接会有一些限制。0-RTT允许client在接收到server的响应之前发送应用数据，但是0-RTT没有提供针对重放攻击的保护（QUIC-TLS章节9.2）。server在接收到client最终的握手加密消息（用于确认client身份以及是否存活）前，server也可以向client发送应用数据。这些属性使得应用协议能够提供安全的交易选项，以减少延迟。
</p>

<p>
Connection ID（章节5.1）允许将连接迁移到新的网络路径，端点可以直接选择迁移，或者由于网络变化而不得不迁移。章节9描述了迁移过程的安全和隐私问题的相关措施。
</p>

<p>
对于不再需要的连接，有多种方式可以终止连接，参见章节10。
</p>
</div>

<div id="outline-container-org27b6638" class="outline-3">
<h3 id="org27b6638"><span class="section-number-3">5.1.</span> Connection ID</h3>
<div class="outline-text-3" id="text-5-1">
<p>
每个连接都有一组连接标识符或者Connection ID，每个都能够标识连接。Connection ID由端点独立选择，每个端点为对等端选择要使用的Connection ID。
</p>

<p>
Connection ID的主要功能是用来确保：如果底层网络协议地址（UDP、IP）发生变化时，不会导致QUIC数据包被递送到错误的端点。每个端点都使用特定的方法来选择Connection ID，使得对应Connection ID的数据包能够被路由到端点，并且接收后能够被端点识别。
</p>

<p>
端点在使用多个Connection ID发送数据包时，即使是针对同一个连接，但是如果没有端点合作，就无法识别数据包。
</p>

<p>
Connection ID一定不能包含任何外部观察者能够使用的信息，外部观察者能利用这些信息与同连接上的其他connection ID相关联。例如，在相同的连接上，同一个Connection ID不能送多次。
</p>

<p>
带有Long Header的数据包包含Source Connection ID和Destination Connection ID字段，这些字段用来为新连接设置Connection ID，参见章节7.2。
</p>

<p>
带有Short Header的数据包只包含Destination Connection ID，并省略其长度。Destination Conneciton ID对于端点来说是已知的。端点使用基于Connection ID路由的负载均衡器时，能够在Connection ID的长度或者编码方式上和负载均衡器达成一致。固定的部分可以被编码为明确的长度，这允许Connection ID的长度可变，并且仍然能够被负载均衡器使用。
</p>

<p>
版本协商数据包会回显client选择的Connection ID，用于确保数据包路由到正确的client，并证明此数据包是对client的响应。
</p>

<p>
如果端点不需要通过Conneciton ID标识连接，则可以使用零长度的Connection ID。然而，在相同的ip地址和端口上的复用连接时，会在以下情况中出现失败：对等端连接迁移、NAT重新绑定、client端口重用，所以端点一定不能相同的ip地址和端口上，使用多个零长度Connection ID的并发连接，除非确认这些协议功能没有使用。
</p>

<p>
端点使用非零长度的Connection ID时，需要确保对等端有Connection ID可用。端点使用NEW_CONNECTION_ID帧来提供这些Connection ID。
</p>
</div>

<div id="outline-container-orgadff140" class="outline-4">
<h4 id="orgadff140"><span class="section-number-4">5.1.1.</span> Connection ID问题</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
每个Conenction ID都有一个关联的序列号，用来帮助检测NEW_CONNECTION_ID或者RETIRE_CONNECTION_ID帧是否引用了相同的值。初始的Connection ID由client在握手期间发出，存储在数据包Long Header中的Source Connection ID字段中。初始的COnnection ID的序列号为0。如果发送了preferred_address传输参数，则Connection ID的序列号为1。
</p>

<p>
通过NEW_CONNECTION_ID帧可以向对等端提供其他的Connection ID。每发出新的COnnection ID其序列号都加1。client选择的首个Destination Connection ID以及Retry数据包提供的Connection ID均没有分配序列号。
</p>

<p>
端点发出一个Connection ID后，在连接期间必需接收所有携带此Connection ID的数据包，直到对等端发送RETIRE_CONNECTION_ID帧来通知此Connection ID无效（章节19.16）。Connection ID发出后只要没有停用就认为是存活的，只要存活就可以在任何时刻任意类型的数据包中使用。server通过preferred_address传输参数发送的Connection ID也是如此。
</p>

<p>
端点应当确保其对等端有充足可用且还未使用的Connection ID。端点通过active_connection_id_limit传输参数来通告愿意维护的Connection ID数量。端点提供Connection ID不得多于对等端的限制。如果NEW_CONNECTION_ID帧通过在Retire Prior To字段中包含足够大的值时，则端点可以发送暂时超出对等方限制的Connection ID。
</p>

<p>
端点可能会基于NEW_CONNECTION_ID帧的Retire Prior TO字段，添加一些活动的Connection ID并停用其他的Connection ID。在处理NEW_CONNECTION_ID帧并且添加或者停用活动的Connection ID之后，如果活跃的Connection ID数量超过了active_connection_id_limit参数值，则必需以CONNECTION_ID_LIMIT_ERROR类型的错误关闭连接。
</p>

<p>
当对等端停用Connection ID后，端点必需提供新的Connection ID。如果端点提供的Connection ID少于对等端的active_connection_id_limit限制，则可以只在接收到带有之前未使用Connection ID的数据包时，才提供新的Connection ID。端点可以限制每个连接发出的Connection ID的总数，以避免Connection ID被用光（章节10.3.2）。端点也可以减少Connection ID的发布，以减少其维护路径状态的数量，例如路径验证状态：因为对等端可能会通过所有发布Connection ID路径与其交互。
</p>

<p>
如果端点要发起连接迁移并使用非零长度的Connection ID，首先确保有足够的Connection ID池，以允许对等端在迁移时使用新的Connection ID，因为当Connection ID池耗尽时，对等端将无法响应。
</p>

<p>
端点如果在握手期间选择零长度Connection ID，则不能发出新的Connection ID。
</p>
</div>
</div>

<div id="outline-container-org078dca2" class="outline-4">
<h4 id="org078dca2"><span class="section-number-4">5.1.2.</span> 使用和停用Conneciton ID</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
在连接期间，端点可以修改用于对等端的Connection ID。端点使用Connection ID来响应一个迁移的对等端（章节9.5）。
</p>

<p>
端点维护一组从其对等端接收到的Connection ID，在发送数据包时可以使用其中的任何一个。当端点希望删除连接 ID 时，它会向其对等方发送 RETIRE_CONNECTION_ID 帧。RETIRE_CONNECTION_ID 帧表示不会再次使用该Connection ID，并请求对等端使用 NEW_CONNECTION_ID 帧将其替换为新的Connection ID。
</p>

<p>
如第 9.5 节所述，端点将Connection ID 的使用限制在从单个本地地址发送到单个目标地址的数据包中。当端点不再使用使用Connection ID对应的本地地址或目标地址时，应该停用Connection ID。
</p>

<p>
在某些情况下，端点可能需要停止接受先前发布的Connection ID。此时端点可以通过发送一个带有增加的Retire Before To 字段的NEW_CONNECTION_ID帧，使对等端停用Connection ID。端点应该继续接受先前发布的Connection ID，直到被对等端停用。如果端点不再处理指定的Connection ID，则可以关闭连接。
</p>

<p>
对等端在接收到增加的 Retire Prior To 字段后， 在将新提供的Connection ID添加到活动的Connection ID集合之前，对等方必须停用相应的Connection ID，并发送RETIRE_CONNECTION_ID帧。按照这样的顺序执行，能够使得端点替换所有活动的Connection ID，并保证对等端有可用的Connection ID，且不会超过对等端设置的active_connection_id_limit值（章节18.2）。如果请求时没有停止使用Connection ID可能导致失败，因为端点可能无法继续将Connection ID用于活动的连接。
</p>

<p>
在RETIRE_CONNECTION_ID帧未被确认之前，端点应该限制在本地停用的Connection ID数量。端点允许发送和跟踪RETIRE_CONNECTION_ID帧的数量，应当至少是active_connection_id_limit参数的2倍。端点虽然可以将超过限制的Connection ID视为CONNECTION_ID_LIMIT_ERROR类型的错误，但是在没有停用Connection ID之前，端点必需一直记录此值。
</p>

<p>
在接收 RETIRE_CONNECTION_ID 帧之前，不应该再次发布 Retire Prior To 字段的更新。
</p>
</div>
</div>
</div>

<div id="outline-container-org133cd1d" class="outline-3">
<h3 id="org133cd1d"><span class="section-number-3">5.2.</span> 数据包和连接的匹配</h3>
<div class="outline-text-3" id="text-5-2">
<p>
传入的数据包在接收时会被分类。数据包可以与现有连接相关联，或者可能创建一个新连接（server端）。
</p>

<p>
端点尝试将数据包与现有连接相关联。如果数据包具有非零长度Destination Connection ID，并于一个已存在的连接对应时，QUIC会将数据包和连接关联。注意，一个连接可以关联多个Connection ID；见第 5.1 节。
</p>

<p>
如果Destination Connection ID 的长度为零，并且数据包中的地址信息和端点对应连接的地址信息匹配，则 QUIC 会将数据包作为对应连接的一部分进行处理。端点可以仅使用目标 IP 和端口或同时使用源地址和目标地址进行标识，尽管这会使连接变得脆弱，如第 5.1 节所述。
</p>

<p>
如果数据包没有对应的现存连接，则端点可以发送Stateless Reset（第 10.3 节）。Stateless Reset可以使对端快速标识连接变为不可用。
</p>

<p>
数据包匹配上现存连接后，如果与连接状态冲突，则丢弃该数据包。例如，如果数据包指示的协议版本与连接的协议版本不同，或者一旦预期的密钥可用时数据包保护的删除失败，则数据包将被丢弃。
</p>

<p>
一些缺乏完整性保护的无效数据包，例如初始、重试或版本协商，可能会被丢弃。如果在处理数据包内容前发现错误，或者在处理期间要还原任何修改，则端点必须生成连接错误。
</p>
</div>

<div id="outline-container-orgff31ae2" class="outline-4">
<h4 id="orgff31ae2"><span class="section-number-4">5.2.1.</span> Client数据包处理</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
server向client发送数据包时总是会包含client选择的Destination Connection ID。client在 选择使用零长度的Connection ID时，会使用本地ip地址和端口来标识连接。在基于Destination Connection ID无法匹配现存连接时，或者Destination Connection ID长度为0，ip和端口不匹配时，丢弃该数据包。
</p>

<p>
由于数据包可能丢失或者乱序，client可能会收到已经被密钥加密但是还未计算出密钥的情况，client可以丢弃数据包，或者先把数据包缓存，等待后续的数据包来计算密钥。
</p>

<p>
如果client接收到的数据包使用的不是初始选择的版本，必需将数据包丢弃。
</p>
</div>
</div>

<div id="outline-container-org381f818" class="outline-4">
<h4 id="org381f818"><span class="section-number-4">5.2.2.</span> Server数据包处理</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
如果server不支持数据包的版本，或者数据包足够大，可以为任意支持的版本初始化新连接，则server应当发送版本协商数据包（章节6.1）。server可以限定响应版本协商数据包的数量。如果是指定了不支持版本的小数据包，server必需将其丢弃。
</p>

<p>
首个不支持版本的数据包可以为特定版本的字段使用不同的语义和编码方式。特别是不同的数据包保护密钥可能用于不同的版本。如果server不支持特定的版本，则其大概率无法解密数据包，也无法正确解释数据包内容。Server应当响应版本协商数据包。
</p>

<p>
如果支持数据包的版本，或者通过Connection ID匹配了连接，或者ip和端口匹配（零长度的Connection ID），这类数据包都使用选择的连接进行处理，否则继续按以下描述处理：
</p>

<p>
如果数据包是完全符合规范的初始数据包，则服务器继续握手（章节7）。这会将client选择的版本提交至server。
</p>

<p>
如果服务器拒绝接受新连接，它应该发送一个带有CONNECTION_CLOSE帧的初始数据包，其中包含CONNECTION_REFUSED错误代码。
</p>

<p>
如果数据包是 0-RTT 数据包，服务器可以缓存有限数量的这些数据包，以期待迟到的初始数据包。client在收到server的响应之前，不能发送握手数据包，因此server应该忽略任何此类数据包。
</p>

<p>
其他情况下，server必须丢弃传入的数据包。
</p>
</div>
</div>

<div id="outline-container-org1b5ec66" class="outline-4">
<h4 id="org1b5ec66"><span class="section-number-4">5.2.3.</span> 考虑一个简单的负载均衡</h4>
<div class="outline-text-4" id="text-5-2-3">
<p>
在部署server时，可以server之间通过源ip、目的ip以及端口进行负载均衡。修改client的ip或端口可能导致数据包被转发到错误的server。在部署这种server时，可以使用以下方法实现维持连接：
</p>
<ul class="org-ul">
<li>server可以使用带外机制（out-of-band），根据Connection ID将数据包转发到正确的server。</li>
<li>如果server可以使用专用的server ip或者端口（不同于client发起连接的目的地址或端口），则可以使用preferred_address传输参数来请求client将连接移动到专用的地址上。注意，client可以选择不使用preferred_address。</li>
</ul>

<p>
如果部署server时，没有实现由于client地址更改而维持连接的方案，则应该使用disable_active_migration传输参数来指示此种情况。 在client已经根据preferred_address参数采取行动后（开始连接迁移），disable_active_migration参数不会阻止连接迁移。
</p>

<p>
使用这种简单形式的负载均衡的部署server时，必须避免创建无状态重置预言机（stateless reset oracle）见第 21.11 节。
</p>
</div>
</div>
</div>

<div id="outline-container-orgcf5734d" class="outline-3">
<h3 id="orgcf5734d"><span class="section-number-3">5.3.</span> 连接操作</h3>
<div class="outline-text-3" id="text-5-3">
<p>
本文档没有为 QUIC 定义 API，而是定义了一组QUIC连接函数。应用可以假设 QUIC 的实现提供了一组接口，其中包括本节中描述的操作。
</p>

<p>
从client角色实现时，应用程序协议可以：
</p>
<ul class="org-ul">
<li>打开连接，开始第 7 节中描述的交换过程；</li>
<li>在Early Data可用时，启用Early Data；</li>
<li>当Early Data被server接受或拒绝时，能被通知。</li>
</ul>

<p>
从server角色实现时，应用程序协议可以：
</p>
<ul class="org-ul">
<li>侦听传入连接，为第 7 节中描述的交换做准备；</li>
<li>如果支持 Early Data，则在发送给client的 TLS resumption ticket中，嵌入应用控制数据；</li>
<li>如果支持 Early Data，则从client的TLS resumption ticket中检索应用控制数据，并根据该信息接受或拒绝 Early Data。</li>
</ul>

<p>
在任一角色中，应用协议可以：
</p>
<ul class="org-ul">
<li>为每种类型stream配置允许的初始最小值，如传输参数（章节7.4）中所述；</li>
<li>通过为stream和连接设置流量控制限制，来控制接收缓冲区的资源分配；</li>
<li>确定握手是否成功完成或仍在进行；</li>
<li>在空闲超时过期之前，通过生成 PING 帧（章节19.2）或请求发送额外的帧（10.1章节），以防止连接静默关闭；</li>
<li>立即关闭（10.2 章节）连接。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org171d2e7" class="outline-2">
<h2 id="org171d2e7"><span class="section-number-2">6.</span> 版本协商</h2>
<div class="outline-text-2" id="text-6">
<p>
当client使用的QUIC版本不被server支持时，server可以进行版本协商。server发送版本协商数据包来响应每个可能发起连接的数据包，详细信息参考5.2章节。
</p>

<p>
client发送的第一个数据包的大小将决定server是否会发送版本协商数据包。client支持多个QUIC版本时，应当确保其发送的第一个UDP数据报是其支持的所有版本最小数据报中的最大值，必要时使用PADDING帧（19.1章节），以确保server存在支持的版本时能够作出响应。如果server收到的数据包小于所有中指定的最小值，则可能不会发送版本协商数据包，详情参见14.1章节。
</p>
</div>

<div id="outline-container-org5f5d790" class="outline-3">
<h3 id="org5f5d790"><span class="section-number-3">6.1.</span> 发送版本协商数据包</h3>
<div class="outline-text-3" id="text-6-1">
<p>
如果client指定的版本不被server支持时，server会响应一个版本协商数据包（17.2.1章节），其中包含server允许的版本列表。端点在收到版本协商数据包后，禁止使用版本协商数据包来响应。
</p>

<p>
server可以在保留状态的情况下处理一些不支持的版本的数据包。尽管server响应的初始数据包或者版本协商数据包可能丢失，但是client会继续发送新的数据包，直到成功收到响应，或者停止尝试连接。
</p>

<p>
server可能会限制发送版本协商数据包的数量。例如，server能够识别0-RTT的数据包时，可能会期望收到一个Initial数据包，并且不会发送版本协商数据包来响应0-RTT数据包。
</p>
</div>
</div>

<div id="outline-container-org9a1cd56" class="outline-3">
<h3 id="org9a1cd56"><span class="section-number-3">6.2.</span> 处理版本协商数据包</h3>
<div class="outline-text-3" id="text-6-2">
<p>
QUIC版本协商数据包的设计，能够允许在以后为版本协商定义更多的功能。未来的标准规范可能会改变（支持多个版本的）QUIC应答接版本协商数据包的实现方式。
</p>

<p>
如果client仅支持其发送的QUIC版本，当收到版本协商数据包后，必需放弃尝试当前连接，以下两种情况除外：client如果接收并成功处理过（除版本协商之外的）其他数据包，包括较早的版本协商数据包，则必需丢弃版本协商数据包；如果版本协商数据包中列出的QUIC版本和client选定的相同，则client必需丢弃该版本协商数据包。
</p>

<p>
关于版本协商如何执行，留给未来的标准规范来定义，特别是能够确保对降级版本攻击的鲁棒性（21.12章节）。
</p>
</div>
</div>

<div id="outline-container-org0c1b719" class="outline-3">
<h3 id="org0c1b719"><span class="section-number-3">6.3.</span> 使用保留的版本</h3>
<div class="outline-text-3" id="text-6-3">
<p>
如果server未来要使用新的版本，client必需能够正确处理不支持的版本。部分版本号被保留（0x?a?a?a?a, 如15章节中的定义）。
</p>

<p>
端点可以在任何被忽略的不识别字段或者不支持版本的字段中添加保留报本，来测试对等端是否正确忽略了此值。例如，端点可能在版本协商数据包中包含保留版本（17.2.1章节）；端点可能发送带有保留版本的数据包来测试对等端能否正确丢弃该数据包。
</p>
</div>
</div>
</div>

<div id="outline-container-org767f96b" class="outline-2">
<h2 id="org767f96b"><span class="section-number-2">7.</span> 握手的加密和传输</h2>
<div class="outline-text-2" id="text-7">
<p>
QUIC握手依赖加密和传输的组合，以最小化建立连接的延迟。QUIC使用CRYPTO帧（19.6章节）来传输加密握手信息。本文当中定义的QUIC版本使用 0x00000001来标识，并使用[QUIC-TLS]中描述的TLS。不同QUIC版本可以标识使用不同的加密握手协议。
</p>

<p>
QUIC提供可靠的、有序的加密握手数据的交付。QUIC数据包保护用于尽可能多的加密握手协议。加密握手必需提供以下属性：
</p>
<ul class="org-ul">
<li>认证的密钥交换
<ul class="org-ul">
<li>始终要对server进行认证，</li>
<li>可以选择对client进行认证，</li>
<li>每个连接生成不同的且没有关联的key，</li>
<li>密钥原料能够用于0-RTT或者1-RTT数据包的保护。</li>
</ul></li>
<li>对两端传输参数值的交换进行认证，对server传输参数的机密保护（7.4章节）。</li>
<li>应用协议协商的认证（TLS为此使用应用层协议协商[ALPN]）.</li>
</ul>

<p>
CRYPTO帧可以在不同的数据包序号空间中发送（12.3章节）。CRYPTO帧使用offsets来确保加密握手数据的有序交付。
</p>

<p>
以下展示了简化的握手，以及用于推进握手的数据包和帧的交换。在握手时开启应用数据的交换（如果可用），使用”*“展示。一旦握手完成，端点就可以自由交换应用数据。
</p>

<div class="org-src-container">
<pre class="src src-fundamental">Client                                               Server

Initial (CRYPTO)
0-RTT (*)              ----------&gt;
                                           Initial (CRYPTO)
                                         Handshake (CRYPTO)
                       &lt;----------                1-RTT (*)
Handshake (CRYPTO)
1-RTT (*)              ----------&gt;
                       &lt;----------   1-RTT (HANDSHAKE_DONE)

1-RTT                  &lt;=========&gt;                    1-RTT

                 Figure 4: Simplified QUIC Handshake
</pre>
</div>

<p>
端点可以使用握手期间发送的数据包来测试是否支持显示拥塞通知（Explict Congestion Notification，ECN），详见13.4章节。端点通过观察ACK帧（确认端点发送的第一个数据包的ACK帧）中携带的ECN计数，验证是否支持ECN，详见13.4.2章节。
</p>

<p>
端点必需明确的协商一个应用协议，这可以避免正在使用的协议出现分歧。
</p>
</div>

<div id="outline-container-org4dff9f9" class="outline-3">
<h3 id="org4dff9f9"><span class="section-number-3">7.1.</span> 握手流的示例</h3>
<div class="outline-text-3" id="text-7-1">
<p>
QUIC中TLS的完整内容可以查看[QUIC-TLS]，此处仅提供一些示例。关于对client地址的验证，在8.1.2章节中展示。
</p>

<p>
一旦任意地址验证交换完成，加密握手协商出一致的加密密钥。加密握手包含在Initial数据包（17.2.2章节）和Handshake数据包（17.2.4章节）中。
</p>

<p>
图5提供了1-RTT握手的概览。每行展示了一个QUIC数据包，首先是类型和包序号，随后是数据包中包含的帧。例如，第一个数据包的类型是Initial，包序号为0，包含携带ClientHello的CRYPTO帧。
</p>

<p>
多个QUIC数据包（即使是不同的类型）可以被合并在单个UDP数据报中（12.2章节）；因此，握手至少包含4个UDP数据报，或者更多（受协议固有的限制，例如拥塞控制和anti-amplification）。例如，server的首个数据包包含Initial数据包、Handshake数据包、1-RTT数据包中的”0.5-RTT data“。
</p>

<div class="org-src-container">
<pre class="src src-fundamental">Client                                                  Server

Initial[0]: CRYPTO[CH] -&gt;

                                 Initial[0]: CRYPTO[SH] ACK[0]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 &lt;- 1-RTT[0]: STREAM[1, "..."]

Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[0]: STREAM[0, "..."], ACK[0] -&gt;

                                          Handshake[1]: ACK[0]
         &lt;- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, "..."], ACK[0]

                  Figure 5: Example 1-RTT Handshake
</pre>
</div>

<p>
图6展示了带有0-RTT握手和0-RTT数据的单个数据包的连接示例。注意，server使用1-RTT数据包确认0-RTT的数据（12.3章节），并且 client在相同的包序号空间中发送1-RTT的数据包。
</p>
<div class="org-src-container">
<pre class="src src-fundamental">Client                                                  Server

Initial[0]: CRYPTO[CH]
0-RTT[0]: STREAM[0, "..."] -&gt;

                                 Initial[0]: CRYPTO[SH] ACK[0]
                                  Handshake[0] CRYPTO[EE, FIN]
                          &lt;- 1-RTT[0]: STREAM[1, "..."] ACK[0]

Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[1]: STREAM[0, "..."] ACK[0] -&gt;

                                          Handshake[1]: ACK[0]
         &lt;- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, "..."], ACK[1]

                  Figure 6: Example 0-RTT Handshake
</pre>
</div>
</div>
</div>

<div id="outline-container-org698a288" class="outline-3">
<h3 id="org698a288"><span class="section-number-3">7.2.</span> 协商Connection ID</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Connection ID用于确保数据包的一致性路由，详见5.1章节的描述。Long Header中包含两个ID：Destination Connection ID由数据包的接收端选择，用于提供一致性路由；Source Connection ID用于由对等端设置Destination Connection ID。
</p>

<p>
握手期间，带有Long Header的数据包（章节17.2）用于建立两个端点使用的Connection ID。每个端点使用Source Connection ID字段来指定接收数据包中的Destination Connection ID字段。在处理完首个Initial数据包后，两个端点都会使用接收数据包中的Source Connection ID字段，作为后续要发送数据包的Destination Connection ID。
</p>

<p>
当由client发送Initial数据包，并且之前从未收到过由server发送的Initial或者Retry数据包时，client会使用不可预测的值填充Destination Connection ID字段，Destination Connection ID长度至少8字节。当从server收到数据包后，client必需在此连接的所有数据包上，使用（和Source Connection ID）相同的Destination COnnection ID值。
</p>

<p>
client发送的首个Initial数据包的Destination Connection ID字段用于确定Initial数据包的保护密钥。在收到Retry数据包后，密钥会发生变化，参见[QUIC-TLS]5.2章节。
</p>

<p>
client使用其选择的值填充Source Connection ID字段，并设置Source Connection ID长度字段。
</p>

<p>
client的首个0-RTT数据包，使用和其Initial数据包相同的Destination Connection ID和Source Connection ID。
</p>

<p>
在第一次收到server的Initial或者Retry数据包时，client使用server提供的Source Connection ID作为后续数据包的Destination Connection ID，包括任何0-RTT数据包，这意味着client在建立连接期间，可能需要修改两次其设置的Destination Connection ID字段：一次响应Retry数据包，一次响应server的Initial数据包。一旦client收到server的有效的Initial数据包，必需丢弃该连接上收到的不同于Source Connection ID的数据包。
</p>

<p>
client在响应首个接收到的Initial或者Retry数据包时，必需修改Destination Connection ID。server必需基于首个收到的Initial数据包，来设置发送数据包的Destination Connection ID。仅当NEW_CONNECTION_ID帧携带一个新的值时，才允许对Destination Connection ID进行修改；如果后续的Initial数据包包含不同的Source Connection ID，必需丢弃这些数据包。这可以避免由于对多个具有不同的Source Connection ID的Initial数据包进行无状态处理而导致未知的结果。
</p>

<p>
在连接生命周期内，端点可以改变其发送的Destination Connection ID，特别是在响应连接迁移时（9章节），详见5.1.1章节。
</p>
</div>
</div>

<div id="outline-container-org75953b8" class="outline-3">
<h3 id="org75953b8"><span class="section-number-3">7.3.</span> Connection ID认证</h3>
<div class="outline-text-3" id="text-7-3">
<p>
在握手期间，每个端点都通过在传输参数中包含所有值，来对其选择的Connection ID进行认证（7.4章节）。这可以确保所有用于握手的Connection ID也通过加密握手进行认证。
</p>

<p>
每个端点会将自己首个发送的Initial数据包中的Source Connection ID字段值包含在initial_source_connection_id传输参数中（18.2）。server将 <b>首个接收到的Initial数据包</b> 中的Destination Connection ID字段包含在original_destination_connection_id传输参数中；如果server发送Retry数据包，则表示是发送Retry之前收到 <b>首个Initial数据包</b> 。当server发送Retry时，也需要将Retry中的Source Connection ID字段包含在retry_source_connection_id传输参数中。
</p>

<p>
端等端提供的传输参数值必需匹配端点发送（或者从server接收）的Initial Packet数据包中的Destination Connection ID和Source Connection ID字段。端点必需验证其接收的传输参数是否匹配Connection ID值。 通过在传输参数中包含Connection ID值并验证这些参数能够确保在握手期间，攻击者不能够通过在数据包中注入其选择的Connection ID来影响正常Connection ID的选择。
</p>

<p>
如果任意端点的initial_source_connnection_id传输参数缺失，或者来自server的original_destination_connection_id传输参数的缺失，端点必需将其视为TRANSPORT_PARAMETER_ERROR类型的连接错误。
</p>

<p>
端点必需将以下情况视为TRANSPORT_PARAMETER_ERROR或者PROTOCOL_VIOLATION类型的错误：
</p>
<ul class="org-ul">
<li>接收到server的Retry数据包后，retry_source_connection_id传输参数缺失。</li>
<li>没有收到Retry数据包，但却有retry_source_connection_id传输参数。</li>
<li>从对端接收的传输参数值与Initial数据包的Destination Connection ID和Source Connection ID不匹配。</li>
</ul>

<p>
如果选择0长度的Connection ID，对应的传输参数也包含一个零长度的值。
</p>

<p>
下图展示了完成握手过程使用的Connection ID，Initial数据包的交换，以及在握手期间，包含建立Connection ID的1-RTT数据包的交换。
</p>

<div class="org-src-container">
<pre class="src src-fundamental">Client                                                  Server

Initial: DCID=S1, SCID=C1 -&gt;
                                  &lt;- Initial: DCID=C1, SCID=S3
                             ...
1-RTT: DCID=S3 -&gt;
                                             &lt;- 1-RTT: DCID=C1

            Figure 7: Use of Connection IDs in a Handshake
</pre>
</div>

<p>
以下展示了一个包含Retrty的简化握手过程。
</p>
<div class="org-src-container">
<pre class="src src-fundamental">Client                                                  Server

Initial: DCID=S1, SCID=C1 -&gt;
                                    &lt;- Retry: DCID=C1, SCID=S2
Initial: DCID=S2, SCID=C1 -&gt;
                                  &lt;- Initial: DCID=C1, SCID=S3
                             ...
1-RTT: DCID=S3 -&gt;
                                             &lt;- 1-RTT: DCID=C1

      Figure 8: Use of Connection IDs in a Handshake with Retry
</pre>
</div>

<p>
以上两种情况，client将initial_source_connection_id传输参数设置为”C1“。
</p>

<p>
当握手过程中没有Retry数据包时，server将original_destination_connenction_id设置为”S1“（注意，此值由client选择），并将initial_source_connection_id设置为”S3“，这种情况下，server不包含retry_source_connection_id传输参数。
</p>

<p>
当握手过程包含Retry时，server将original_destination_connection_id设置为”S1“，retry_source_connection_id设置为”S2“，initial_source_connection_id设置为”S3“。
</p>
</div>
</div>

<div id="outline-container-org6b720e0" class="outline-3">
<h3 id="org6b720e0"><span class="section-number-3">7.4.</span> 传输参数</h3>
<div class="outline-text-3" id="text-7-4">
<p>
在建立连接期间，两端都对声明的传输参数进行验证。端点需要遵守每个参数规定的限制；每个参数的描述都包括了其处理规则。
</p>

<p>
每个端点都单方面的声明其传输参数，每个端点都可以选择对立于对等端的传输参数值。
</p>

<p>
18章节中描述了传输参数编码的详细信息。
</p>

<p>
QUIC将编码的传输参数包含在加密握手中。一旦握手完成，对等端声明的传输参数变为可用，两端都验证对等端提供的值。
</p>

<p>
第18.2章中描述了传输参数的定义。
</p>

<p>
端点如果收到无效的传输参数，必需将其视为TRANSPORT_PARAMETER_ERROR类型的连接错误。
</p>

<p>
对于给定的传输参数扩展名，端点最多只能发送一次。如果端点收到重复的传输参数，必需将其视为TRANSPORT_PARAMETER_ERROR类型的连接错误。
</p>

<p>
在握手期间，端点使用传输参数来验证connection ID的协商（7.3）。
</p>

<p>
ALPN（参考[ALPN]文档）允许client在建立连接期间提供多个应用协议。在握手期间，client包含的传输参数适用于其提供的所有应用协议。应用协议可以为传输参数设定建议值，例如初始的流控限制。但是如果应用协议为传输参数设置的值发生冲突，则client可能无法提供多应用协议的支持。
</p>
</div>

<div id="outline-container-org022a440" class="outline-4">
<h4 id="org022a440"><span class="section-number-4">7.4.1.</span> 0-RTT的传输参数值</h4>
<div class="outline-text-4" id="text-7-4-1">
<p>
能否使用0-RTT取决于client和server在先前连接上协商的协议参数。为了开启0-RTT，端点需要将server的传输参数和在连接上收到的session ticket存储在一起，还需要存储应用协议或者加密握手所需的任何信息；详见[QUIC-TLS]4.6。在利用session ticket进行0-RTT的尝试时，会使用存储的传输参数值。
</p>

<p>
存储的传输参数适用于新的连接，直到握手完成并且cleint开始发送1-RTT的数据包。握手完成后，client就能使用握手中建立的传输参数。并非所有的传输参数都可以被存储，因为某些参数不适用于之后的连接，或者0-RTT不需要这些参数。
</p>

<p>
对于新传输参数定义（7.4.2），必需指定这些参数对于0-RTT而言，是需要强制存储，可选存储，还是禁止存储。client不需要存储其无法处理的传输参数。
</p>

<p>
以下描述的参数，client禁止存储这些参数值：ack_delay_exponent, max_ack_delay, initial_source_connection_id, original_destination_connection_id, preferred_address, retry_source_connection_id, stateless_reset_token。对于以上参数，client必需适用server在握手中提供的新值；如果server未提供，则适用默认值。
</p>

<p>
如果client想尝试发送0-RTT数据，则必需存储自身能够处理的并且server使用的（除以上参数外的）其他参数值，server可以存储这些传输参数，或者将受完整性保护的值拷贝存储在ticket中，并在接收0-RTT时恢复这些信息。server根据传输参数决定是否接受0-RTT的数据。
</p>

<p>
如果server接受0-RTT的数据，则禁止减少任何限制或者修改client可能违反的值。特别是，server不能将以下参数（18.2）设置为小于自身存储的参数值:
</p>
<ul class="org-ul">
<li>active_connection_id_limit</li>
<li>initial_max_data</li>
<li>initial_max_stream_data_bidi_local</li>
<li>initial_max_stream_data_bidi_remote</li>
<li>initial_max_stream_data_uni</li>
<li>initial_max_streams_bidi</li>
<li>initial_max_streams_uni</li>
</ul>

<p>
如果将某些传输参数省略或者将其值设置为0，有可能导致虽然开启了0-RTT，但是无法使用。对于0-RTT，如果传输参数是有关发送应用数据限制的，应当被设置为非零值。（？？？？）包括initial_max_data，和以下二者之一：(1) initial_max_streams_bidi和initial_max_stream_data_bidi_remote； (2) initial_max_streams_uni和initial_max_stream_data_uni。
</p>

<p>
server为stream提供的初始的stream流控限制值，可能要大于client在0-RTT中设置的值（client存储的值）。握手完成后，client使用initial_max_stream_data_bidi_remote和initial_max_stream_data_uni提供的新值更新所有发送stream的流控限制。
</p>

<p>
server可以存储和恢复先前发送的max_idle_timeout、max_udp_payload_size 和 disable_active_migration 参数值，如果client选择较小的值，则拒绝0-RTT。在接受0-RTT 数据的同时降低这些参数的值，可能会降低连接的性能。具体来说，降低max_udp_payload_size可能会导致丢包，这会比直接拒绝 0-RTT数据的性能更差。
</p>

<p>
如果server不能支持传输参数的恢复值，则必须拒绝 0-RTT 数据。
</p>

<p>
当使用0-RTT数据包发送帧时，client必须只使用存储的传输参数，它不得使用从server更新的传输参数或从接收到的1-RTT 数据包中的帧中学习的更新值。握手过程中中的传输参数更新值仅适用于 1-RTT 数据包。例如，存储流量控制限制适用于所有 0-RTT 数据包，即使这些值因握手或 1-RTT 数据包中发送的帧而增加。如果在0-RTT 中更新传输参数时，server可以将其视为 PROTOCOL_VIOLATION 类型的连接错误。
</p>
</div>
</div>

<div id="outline-container-org768aa19" class="outline-4">
<h4 id="org768aa19"><span class="section-number-4">7.4.2.</span> 新的传输参数</h4>
<div class="outline-text-4" id="text-7-4-2">
<p>
新的协议参数可以用来协商新的协议行为。端点不支持传输参数时，必需将其忽略。因此，缺少传输参数时，或禁用利用该参数协商的协议功能。如18.1章节的描述，某些标识符被保留，以用于执行此要求。
</p>

<p>
当client不识别某个传输参数时，可以将其丢弃，并在后续的连接上尝试0-RTT。如果client添加对这些参数的支持，则可能会在尝试0-RTT时违反建立传输参数的约束。新的传输参数可以通过设置最保守值的默认值来避免此问题。client则可以通过存储所有参数来避免此问题，即使是client当前不支持的传输参数。
</p>

<p>
22.3章节描述了新的传输参数的注册规则。
</p>
</div>
</div>
</div>

<div id="outline-container-orgbe0a75e" class="outline-3">
<h3 id="orgbe0a75e"><span class="section-number-3">7.5.</span> 缓冲加密消息</h3>
<div class="outline-text-3" id="text-7-5">
<p>
缓冲加密消息，首先需要维护一个接收无序的CRYPTO数据的缓冲区。由于CRYPTO帧没有流量控制，端点可能会强制对等端缓冲未知大小的数据。
</p>

<p>
实现必需支持缓冲至少4096的无序CRYPTO帧数据。端点可能会选择在握手期间允许缓冲更多数据，这可以交换更大的密钥或者凭证。在连接的生命周期中，端点的缓冲区大小可以改变。
</p>

<p>
在握手期间，无法缓冲CRYPTO帧可能导致连接失败。如果在握手期间的CRYPTO帧超出了缓冲区，则端点可以林时扩充缓冲区，以完成握手。如果端点不扩展其缓冲区，则必需以CRYPTO_BUFFER_EXCEEDED错误码关闭连接。
</p>

<p>
握手完成后，如果端点无法缓冲CRYPTO帧的所有数据，则可能丢弃该CRYPTO帧和之后收到的CRYPTO帧，或者选择以CRYPTO_BUFFER_EXCEEDED错误码关闭连接。即使丢弃的CRYPTO帧的数据包也必须进行确认，因为数据包已被接收和处理。
</p>
</div>
</div>
</div>

<div id="outline-container-orgf8d98d2" class="outline-2">
<h2 id="orgf8d98d2"><span class="section-number-2">8.</span> 地址验证</h2>
<div class="outline-text-2" id="text-8">
<p>
地址验证可以确保端点不能用于流量放大攻击。在这种攻击中，向server发送的数据包中包含标识受害者的虚假源地址信息。如果server生成更多的或者更大的数据包来响应该数据包，则攻击者可以利用该server向受害者发送比其自身能够发送数据还要多的数据。
</p>

<p>
针对放大攻击的主要防御措施是：验证对等端是否能够在其声称的传输地址上处接收数据包。因此端点从为验证的地址接收数据包后，端点必需将其向未验证地址发送的数据量限制为从该地址接收数据量的三倍。这种对响应大小的限制称为抗放大限制（anti-amplification）。
</p>

<p>
在建立连接期间（8.1）和连接迁移期（8.2）间都需要执行地址验证。
</p>
</div>

<div id="outline-container-orgbaac176" class="outline-3">
<h3 id="orgbaac176"><span class="section-number-3">8.1.</span> 连接建立期间的地址验证</h3>
<div class="outline-text-3" id="text-8-1">
<p>
建立连接隐式的为两个端点提供了地址验证。特别是当收到由握手密钥保护的数据包就确认对等端成功处理了Initial数据包。端点成功处理对等端发送的握手数据包后，就可以认为对等端的地址已经被验证。
</p>

<p>
此外，如果对等端是使用端点选择的Connection ID并且Conneciton ID至少包含64位的熵，则可以认为对等端地址已经验证。
</p>

<p>
对于client，能够通过首个Initial数据包中的Destination Connection ID字段值来验证server地址（如果值正确，则说明server已经成功处理了任意数据包）。server发送的Initial数据包通过Destination Connection ID值衍生出来的key进行保护（[QUIC-TLS] 5.2），或者Destination Connection ID值由server在版本协商数据包中回显（第6章），或者包含在Retry数据包的Integrity Tag中（[QUIC-TLS] 5.8）。
</p>

<p>
在验证client地址之前，server发送的字节数不得超过其接收字节的三倍。这可以限制利用虚假源地址进行欺骗攻击的规模。为了避免在地址验证之前被放大，server必需计算单个连接上接收的udp数据报载荷大小总和，包括成功处理的数据报和丢弃的数据报。
</p>

<p>
client必需确保包含Initial数据报的udp数据报，其载荷至少1200字节，必要时添加PADDING帧。client发送带有填充的数据报，能够允许server在完成地址验证之前发送更多的数据。
</p>

<p>
如果来自server的Initial或者Handshake数据包丢失，并且client不再发送额外的Initial或者Handshake数据包，可能会导致死锁。例如，当server达到了抗放大限制（anti-amplification），并且client已经收到其发送全部数据的确认。这种情况下，client没有理由在发送额外的数据包，而server由于还没有验证cleint地址而不能够发送更多的数据。为了避免这种死锁的发生，client必需在探测超时（Probe Timeout， PTO）后发送一个数据包（[QUIC-RECOVERY] 6.2）。具体来说，如果client没有握手密钥，则必需发送一个至少包含1200字节Initial数据包的UDP数据报，否则发送一个Handshake数据包。
</p>

<p>
server可能会希望在开始加密握手之前验证client的地址。在完成握手之前，QUIC使用Initial数据包中的token来提供地址验证。在建立连接期间使用Retry数据包将token传递给client（8.1.2），或者在之前的连接上使用NEW_TOKEN帧来将token传递给client（8.1.3）。
</p>

<p>
server除了受地址验证之前施加的发送限制之外，也受拥塞控制设置的限制。client仅受到拥塞控制的限制。
</p>
</div>

<div id="outline-container-org5fd9e80" class="outline-4">
<h4 id="org5fd9e80"><span class="section-number-4">8.1.1.</span> Token结构</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
NEW_TOKEN帧中或者Retry数据包中的token必需以某种方式构造，以允许server标识其如何提供给client。这些touken在相同的字段中携带，但server需要予以不同的处理。
</p>
</div>
</div>

<div id="outline-container-orga7f20ac" class="outline-4">
<h4 id="orga7f20ac"><span class="section-number-4">8.1.2.</span> 使用Retry数据包进行地址验证</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
在收到client的Initial数据包后，server可以通过发送包含token的Retry数据包来要求地址验证（17.2.5）。client在收到Retry数据包后，必需为该连接上所有已经发送的Initial数据包重复此token。
</p>

<p>
server收到包含token（由其发送的Retry提供的token）的Initial数据包响应后，不可以发送另外的Retry数据包，只能拒绝连接或者继续处理。
</p>

<p>
server也可以通过Retry数据包来推迟建立连接的状态和处理成本，这要求server提供不同的Connection ID，以及original_destination_connecton_id(18.2中定义)传输参数，以强制server证明自身或者与其合作的实体收到了来自client的原始Initial数据包。提供不同的Connection ID也使得server能够控制后续数据包的路由方式。这可以用于将连接重定向至不同的server实例。
</p>

<p>
如果server收到的client的Initial数据包包含无效的Retry token，其余都是有效的，则认为client不会接受另外的Retry Token。此类数据包，server可以选择将其丢弃，并允许client超时后检测握手失败，但这会对client造成显著的延迟；相反，server应当立即关闭（10.2）带有INVALID_TOKEN错误的连接。注意，此时server尚未为连接建立任何状态，因此不会进入关闭状态。
</p>

<p>
以下展示了使用Retry数据包的流程：
</p>
<div class="org-src-container">
<pre class="src src-fundamental">Client                                                  Server

   Initial[0]: CRYPTO[CH] -&gt;

                                                   &lt;- Retry+Token

   Initial+Token[1]: CRYPTO[CH] -&gt;

                                    Initial[0]: CRYPTO[SH] ACK[1]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    &lt;- 1-RTT[0]: STREAM[1, "..."]

                   Figure 9: Example Handshake with Retry
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e95370" class="outline-4">
<h4 id="org3e95370"><span class="section-number-4">8.1.3.</span> 后续连接的地址验证</h4>
<div class="outline-text-4" id="text-8-1-3">
<p>
server在一个连接上提供的地址验证token，也可以用于后续的连接。地址验证对于0-RTT尤其重要，因为server可能会向client发送大量的数据以响应0-RTT。
</p>

<p>
server使用NEW_TOKEN帧（19.7）为client提供的地址验证token，也可以用于验证后续的连接。在后续的连接中，client可以将此token包含在Initial数据包中来提供地址验证，client必需在其发送的所有Initial数据包中包含该token，除非server使用Retry数据包发送了新的token。client不可以将Retry中提供的token用于后续的连接。如果Initial数据包中没有包含server期待的token，则server可以将其丢弃。
</p>

<p>
NEW_TOKEN帧中携带的token可以在一段时间之内使用，因此token应当有一个过期时间，可以是一个明确的过期时间，也可以是一个可用于动态计算过期时间的时间戳。server可以存储过期时间，或者以加密的形式保存在token中。
</p>

<p>
使用NEW_TOKEN发布的token不能包含任何有关连接的明文信息。例如，之前的Connection ID或者地址信息，除非这些信息被加密。server必需确保其所发送的NEW_TOKEN帧在所有client中是唯一的（重传的NEW_TOKEN除外）。 server通过某些信息来区分token是来自Retry和NEW_TOKEN，这些信息可以被server以外的实体访问。
</p>

<p>
两个不同的连接上的client端口号有可能相同，因此不能够通过端口号验证。
</p>

<p>
NEW_TOKEN帧中的token适用于任何可信连接的server（例如：server name包含在证书中）。如果client保留了可信的且未使用的token，在连接server时，应当将该token包含在Initial数据包的Token字段中。server有可能通过包含token直接验证client地址，而无需额外的往返。如果token不适用于某个server，client不能使用该token来连接server，除非client知道发布token的server和要连接的server共同管理token。client可以使用先前连接的tokne来连接对应的server。
</p>

<p>
token允许server将发布token的连接和使用token的连接相关联。client如果想打破这种关联，可以丢弃使用NEW_TOKEN帧发布的token。相比之下，Retry数据包中的token必需在尝试连接期间立即使用，且不能用于后续的连接。
</p>

<p>
client不应当在不同的连接中重用通过NEW_TOKEN发布的token。重用token会使得连接被链接到单个网络路径的实体（9.5）。
</p>

<p>
client可能在单个连接上收到多个token。如果不考虑可链接性，任何token可以用于任何连接尝试。server可以发送额外的token，以启用多个连接尝试的地址验证，或者替换可能失效的token。也就是说，client尽量选择发送最近未使用的token，这些token有效的概率更大。虽然保存和使用旧的token没有负面影响，但是client应当认为这些token对于server进行地址验证没有什么作用。
</p>

<p>
当server收到带有地址验证token的Initial数据包时，必需验证token，除非已经完成了地址验证。如果token无效，server应当认为client没有经过地址验证并继续处理，例如发送Retry数据包。serrver可以区分NEW_TOKEN和Retry数据包的token（8.1.1），Retry的验证更加严格。如果验证成功，server应当继续进行握手处理。
</p>

<div class="org-center">
<p>
注意：
    将client视为未验证的而非丢弃数据包的原理：client可能收到了先前连接中使用NEW_TOKEN帧发送的token，如果server丢失状态，则无法再验证此token。如果数据包丢失则导致连接失败。
</p>
</div>

<p>
在无状态的设计中，server可以使用加密和经过验证的token向client传递信息，server稍后可以恢复这些信息来验证client的地址。token没有集成到加密握手中，因此token没有被认证，因此client可以重用token。为了避免此类型的攻击，server可以限制token只被用来进行client的地址验证。
</p>

<p>
client可以利用某个连接上获得的token，进行相同版本的任意连接尝试。选择使用的token时，client不需要考虑尝试连接的其他属性，包括可能的应用程序协议、session tickets、或者其他连接属性。
</p>
</div>
</div>

<div id="outline-container-org6512349" class="outline-4">
<h4 id="org6512349"><span class="section-number-4">8.1.4.</span> 地址验证token的完整性</h4>
<div class="outline-text-4" id="text-8-1-4">
<p>
地址验证token必需是难以猜测的，至少包含128位熵的随即数。
</p>

<p>
基于token的方案允许server将任何验证相关的状态卸载到client。这依赖于server必需对token进行完整性校验，防止client伪造或者修改token。如果没有完整性保护，恶意的client可以生成或者猜测server所接受的token值。
</p>

<p>
Retry数据包中的token应当包含一些信息，server通过这些信息能够验证client数据包中的源IP和端口没有发生变化。
</p>

<p>
NEW_TOKEN帧中发送的token必需包含一些信息，这些信息允许server验证client IP地址在token发布后没有改变。server可以使用NEW_TOKEN帧的token来决定不再发送Retry数据包，即使client地址改变。如果client IP地址改变，server必需遵守抗放大（anti-amplification）限制（第8章）。注意，在 NAT 的情况下，此要求可能不足以保护共享 NAT 的其他主机免受放大攻击。
</p>

<p>
攻击者可以重放token，来将server作为DDos攻击的放大器。为了防止此类攻击，server必需确保对重放的token进行阻止或者限制。serverr应当确保Retry数据包中的token只在短时间内有效，因为client会在短时间内返回。通过NEW_TOKEN帧提供的token需要长时间有效，但不应当被多次接受。如果可以，鼓励server只使用一次token，可以在token中包含有关client的额外信息，以进一步缩小token的适用性或者重用性。
</p>
</div>
</div>
</div>

<div id="outline-container-orgbdb94ee" class="outline-3">
<h3 id="orgbdb94ee"><span class="section-number-3">8.2.</span> 路径验证</h3>
<div class="outline-text-3" id="text-8-2">
<p>
在连接迁移（第9章）期间，两端都需要进行路径验证，以验证地址修改后是否可达。在路径验证中，端点测试本机地址到对等端地址是否可达，这里地址指的是IP和端口的2元组。
</p>

<p>
路径验证测试在路径上向对等端发送的数据包是否被对端接收。路径验证用来确保对端迁移时发送的数据包不会携带虚假的源地址。
</p>

<p>
路径验证不会验证对等端的发送方向，确认不能够用于返回路径验证，因为其包含的熵不足，且可能被欺骗。端点独立的确定路径上每个方向的可达性，因此返回可达性只能通过对等端建立。
</p>

<p>
任何端点可以在任意时间使用路径验证。例如，端点可能会检查对等端在静止一段时间后，是否仍然拥有的地址。
</p>

<p>
路径验证没有作为NAT穿越机制来设计。尽管此处描述的机制可能对创建支持NAT穿越的NAT绑定有效，实际期望是：端点能够在路径上接收数据包，而不需要首先在该路径上发送数据包。有效的NAT穿越需要额外的同步机制。
</p>

<p>
端点在发送路径验证的PATH_CHALLENGE和PATH_RESPONSE帧时，可以发送其他类型的帧。例如，端点可以在发送PATH_CHALLENGE帧时包含PADDING帧用于路径最大传输单元发现（PMTUD）（14.2.1）。端点也可以在发送PATH_RESPONSE帧时包含自己的PATH_CHALLENGE帧。
</p>

<p>
端点在新的本地地址上使用新Connection ID发送探测（9.5）。在探测新路径时，端点可以确保对等端具有一个可用且未使用的Conneciton ID用于响应。在同一个数据包中发送NEW_CONNECTION_ID和PATH_CHALLENGE帧时，如果对等端的active_connection_id_limit允许，需要确保在对等端在发送响应时具有可用且未使用的Connection ID。
</p>

<p>
端点可以选择同时探测多条路径。同时探测路径的数量受其对等方先前提供的额外Connection ID 数量的限制，因为每探测一个新本地地址，都需要一个以前未使用的Connection ID。
</p>
</div>

<div id="outline-container-org1d09891" class="outline-4">
<h4 id="org1d09891"><span class="section-number-4">8.2.1.</span> 启动路径验证</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
端点通过在需要验证的路径上发送PATH_CHALLENGE帧来启动路径验证，其中包含一些不可预测的payload。
</p>

<p>
端点可以发送多个PATH_CHALLENGE帧来防止数据包丢失。端点不能在单个数据包中包含多个PATH_CHALLENGE帧。
</p>

<p>
端点在探测新路径时，发送的PATH_CHALLENGE帧不能比其要发送的Initial数据包更加频繁，以确保连接迁移不会比新建连接更多的负载到新路径上。
</p>

<p>
端点必须在每个 PATH_CHALLENGE 帧中使用不可预测的数据，以便它可以将对等方的响应与对应的 PATH_CHALLENGE 相关联。
</p>

<p>
端点必须将包含 PATH_CHALLENGE 帧的数据报扩展到至少 1200 字节的最大数据报允许的最小大小，除非路径的抗放大限制不允许发送此大小的数据报。发送这种大小的 UDP 数据报可以确保：从端点到对等方的网络路径可以用于 QUIC；参阅第 14 节。
</p>

<p>
当端点由于抗放大限制而无法将数据报大小扩展到 1200 字节时，将不会验证路径 MTU。为确保路径 MTU 足够大，端点必须通过发送包含PATH_CHALLENGE帧的至少1200字节的的数据包来执行第二次路径验证。此附加验证可以在成功接收到PATH_RESPONSE帧后执行，或者在路径上收到足够的字节（发送更大的数据包不会导致超出抗放大限制）后执行。
</p>

<p>
如果数据报中包含PATH_CHALLENGE或者PATH_RESPONSE时，即使数据包很小，也不能丢弃。
</p>
</div>
</div>


<div id="outline-container-org8dd3c13" class="outline-4">
<h4 id="org8dd3c13"><span class="section-number-4">8.2.2.</span> 路径验证的响应</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
在接收到 PATH_CHALLENGE 帧时，端点必将PATH_CHALLENGE帧中的数据包含在 PATH_RESPONSE 帧中来进行响应。除非受到拥塞控制的约束，否则端点不得延迟PATH_RESPONSE 帧的数据包的传输。
</p>

<p>
PATH_RESPONSE 帧必须在收到 PATH_CHALLENGE 帧的网络路径上发送。这确保只有当路径在两个方向都有效时，对等端的路径验证才会成功。发起路径验证的端点不能强制执行此要求，因为这会导致对迁移的攻击；见第 9.3.3 节。
</p>

<p>
端点必须将包含 PATH_RESPONSE 帧的数据报扩展到至少 1200 字节的最大数据报允许的最小大小。这验证了该路径是否能够在两个方向上携带这种大小的数据报。但是，如果结果数据超过抗放大限制，端点不得扩展包含 PATH_RESPONSE 帧的数据报。仅当接收到的 PATH_CHALLENGE 未在扩展数据报中发送时，才会发生这种情况。
</p>

<p>
端点不得发送多个 PATH_RESPONSE 帧以响应一个 PATH_CHALLENGE 帧；见第 13.3 节。对等方应根据需要发送更多 PATH_CHALLENGE 帧以唤起额外的 PATH_RESPONSE 帧。
</p>
</div>
</div>

<div id="outline-container-orga0e73e4" class="outline-4">
<h4 id="orga0e73e4"><span class="section-number-4">8.2.3.</span> 路径验证成功</h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
当收到PATH_RESPONSE帧并且包含在先前 PATH_CHALLENGE 帧中发送的数据时，路径验证成功。在任何网络路径上收到的 PATH_RESPONSE 帧都会验证发送 PATH_CHALLENGE 的路径。
</p>

<p>
如果端点发送的PATH_CHALLENGE帧的数据报未扩展到至少1200字节，并且其响应验证了对等端地址，则路径被验证，但是路径MTU没有被验证。因此，端点现在可以发送已接收数据量的三倍以上的数据。然而，端点必须用扩展的数据报发起另一个路径验证，以验证该路径是否支持所需的 MTU。
</p>

<p>
收到对包含 PATH_CHALLENGE 帧的数据包的确认不是充分的验证，因为该确认可能被恶意对等端欺骗。
</p>
</div>
</div>

<div id="outline-container-org96b8658" class="outline-4">
<h4 id="org96b8658"><span class="section-number-4">8.2.4.</span> 路径验证失败</h4>
<div class="outline-text-4" id="text-8-2-4">
<p>
只有当尝试验证路径的端点放弃验证路径时，路径验证才会失败。端点应该基于定时器来放弃路径验证。设置此计时器时，要注意新路径的往返时间可能比原始路径更长。建议使用当前 PTO 或新路径的 PTO（使用 kInitialRtt，如 [QUIC-RECOVERY] 中定义）中较大值的三倍。
</p>

<p>
在路径验证失败之前，此超时可以允许多个PTO过期，因此单个 PATH_CHALLENGE 或 PATH_RESPONSE 帧的丢失不会导致路径验证失败。
</p>

<p>
注意，端点可能会在新路径上接收包含其他帧的数据包，但路径验证需要具有适当数据的 PATH_RESPONSE 帧才能成功。
</p>

<p>
当端点放弃路径验证时，它确定路径不可用。这并不一定意味着连接失败 &#x2013; 端点可以根据需要继续通过其他路径发送数据包。如果没有可用路径，端点可以等待新路径可用或关闭连接。如果端点到其对等端没有有效的网络路径，则端点可以使用 NO_VIABLE_PATH 连接错误发出信号，注意这只有在网络路径存在但不支持所需的 MTU 时才有可能发生（第 14 节）。
</p>

<p>
端点也可能会因为其他原因放弃路径验证。 主要发生在：如果在旧路径上进行路径验证时，启动了到新路径的连接迁移。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgad55bc7" class="outline-2">
<h2 id="orgad55bc7"><span class="section-number-2">9.</span> 连接迁移</h2>
<div class="outline-text-2" id="text-9">
<p>
Connection ID允许在端点的地址（ip或者端口）发生改变时，连接仍然存在，例如当端点迁移到新的网络时会发生这种情况。本章将介绍端点迁移到新地址的过程。
</p>

<p>
QUIC 的设计依赖于端点在握手期间保持稳定的地址。在确认握手之前，端点不得发起连接迁移，如 [QUIC-TLS] 的第 4.1.2 节的定义。
</p>

<p>
如果对等方发送了 disable_active_migration 传输参数，则端点不可以从不同的本地地址向对等方在握手期间使用的地址发送数据包（包括探测数据包；参见第 9.1 节），除非端点收到了perferred_address传输参数。如果对等方违反此要求，端点要么丢弃该路径上传入的数据包，而不会生成无状态重置，要么继续进行路径验证并允许对等方迁移。生成无状态重置或关闭连接将允许网络中的第三方通过欺骗或以其他方式操纵观察到的流量来关闭连接。
</p>

<p>
并非所有对等端地址的更改都是有意或主动的迁移。对等方可能会遇到 NAT 重新绑定：由于中间设备（通常是 NAT）为流分配新的外出端口甚至是新的外出IP地址而导致的地址更改。如果端点检测到对等地址的任何更改，端点必须执行路径验证（第 8.2 节），除非它先前已验证该地址。
</p>

<p>
当端点没有经过验证的路径用以发送数据包时，它可以丢弃连接状态。能够进行连接迁移的端点，可以在丢弃连接状态之前等待新路径变得可用。
</p>

<p>
本文档限制只能将连接迁移到新的客户端地址，例外情况第 9.6 节中描述。客户端负责启动所有迁移。服务器不会首先向客户端地址发送非探测数据包（参见第 9.1 节），直到收到来自该地址的非探测数据包。如果客户端收到来自未知服务器地址的数据包，则客户端必须丢弃这些数据包。
</p>
</div>

<div id="outline-container-orgcce5d96" class="outline-3">
<h3 id="orgcce5d96"><span class="section-number-3">9.1.</span> 探测新路径</h3>
<div class="outline-text-3" id="text-9-1">
<p>
在将连接迁移到新的本地地址之前，端点通过路径验证（第 8.2 节），从新的本地地址探测对等端是否可达。路径验证失败仅意味着新路径不可用于此连接。除非没有可用的有效路径来替代，否则路径验证失败不会导致连接结束。
</p>

<p>
PATH_CHALLENGE、PATH_RESPONSE、NEW_CONNECTION_ID 和 PADDING 帧是“探测帧”，所有其他帧都是“非探测帧”。仅包含探测帧的数据包是“探测数据包”，包含任何其他帧的数据包是“非探测数据包”
</p>
</div>
</div>

<div id="outline-container-org9f709c1" class="outline-3">
<h3 id="org9f709c1"><span class="section-number-3">9.2.</span> 响应连接迁移</h3>
<div class="outline-text-3" id="text-9-2">
<p>
从新的对等端地址接收到包含非探测帧的数据包，表示对等端已经迁移到该地址。
</p>

<p>
如果接收端允许迁移，则必须向新地址发送后续数据包，并且必需启动路径验证（8.2章节）以验证对等端地址的所有权（如果尚未进行验证）。如果接收方没有来自对等端的未使用Connection ID，则在对等方提供之前，它将无法在新路径上发送任何内容；见第 9.5 节。
</p>

<p>
端点仅更改其发送数据包的地址，以响应编号最高的非探测数据包。这可确保端点在收到重新排序的数据包时，不会将数据包发送到旧的对等地址上。
</p>

<p>
端点可以将数据发送到未经验证的对等地址上，但它必须防止潜在的攻击，如第 9.3.1 和 9.3.2 节所述。如果该地址近期使用过，则端点可以跳过对等地址的验证。特别是，如果端点在检测到某种形式的虚假迁移后返回到先前经过验证的路径，则跳过地址验证，并恢复丢包检测和拥塞状态以降低攻击对性能的影响。
</p>

<p>
在更改其发送非探测数据包的地址后，端点可以放弃对其他地址的路径验证。
</p>

<p>
从新的对等地址接收数据包，也可能是由于对等端 NAT 重新绑定的结果。
</p>

<p>
在验证新的client地址后，server应该向客户端发送新的地址验证token（第 8 节）。
</p>
</div>

<div id="outline-container-org60def95" class="outline-4">
<h4 id="org60def95"><span class="section-number-4">9.2.1.</span> 对等地址欺骗</h4>
<div class="outline-text-4" id="text-9-2-1">
<p>
对等端有可能使用源地址进行欺骗，从而导致端点向另外的主机发送过多的数据。如果端点发送的数据明显多于（欺骗的）对等方，攻击者可以用连接迁移来放大其自身可以向受害者生成的数据量。
</p>

<p>
如第 9.3 节所述，端点需要验证对等方的新地址以确认对等方拥有新地址。在验证对等方的地址有效之前，端点会限制它发送到该地址的数据量；请参阅第 8 节。如果没有此限制，端点可能会被用于对受害者进行拒绝服务攻击。
</p>

<p>
如果端点如上所述跳过对等地址的验证，则不需要限制其发送速率。
</p>
</div>
</div>

<div id="outline-container-org6ecea0f" class="outline-4">
<h4 id="org6ecea0f"><span class="section-number-4">9.2.2.</span> 路径中的地址欺骗</h4>
<div class="outline-text-4" id="text-9-2-2">
<p>
路径上的攻击者可以通过复制和转发具有欺骗地址的数据包，使其在原始数据包之前到达，从而导致虚假连接迁移。带有欺骗地址的数据包将被视为来自迁移连接，而原始数据包将被视为重复数据包并被丢弃。在虚假迁移之后，源地址的验证将失败，因为源地址的实体没有必要的加密密钥来读取或响应发送给它的 PATH_CHALLENGE 帧。
</p>

<p>
为了防止连接由于这类虚假迁移而失败，当新的对等地址验证失败时，端点必须恢复使用最后经过验证的对等地址。此外，从合法对等地址接上收具有更高数据包编号的数据包，将触发另一次连接迁移，这将导致对虚假迁移地址的验证被放弃（包含由攻击者注入单个数据包发起的迁移）。
</p>

<p>
如果端点没有关于最后验证的对等地址的状态，它必须通过丢弃所有连接状态来关闭连接。这导致对连接上新数据包进行普通处理。例如，端点可以发送Stateless Reset以响应任何进一步传入的数据包。
</p>
</div>
</div>

<div id="outline-container-org221f230" class="outline-4">
<h4 id="org221f230"><span class="section-number-4">9.2.3.</span> 路径之外的数据包转发</h4>
<div class="outline-text-4" id="text-9-2-3">
<p>
如果是能够观察到数据包的路径之外的攻击者，可能会将真实数据包的副本转发到端点。如果复制的数据包在真正的数据包之前到达，这将显示为 NAT 重新绑定。任何真正的数据包都将作为副本丢弃。如果攻击者能够继续转发数据包，攻击者可以将迁移到某个路径。这会使攻击者置于路径上，使其能够观察或丢弃所有后续数据包。
</p>

<p>
这种攻击方式依赖于攻击者使用的路径与端点之间的直接路径具有大致相同的特征。如果发送的数据包相对较少，或者数据包丢失与尝试攻击同时发生时，攻击更可靠。
</p>

<p>
在原始路径上接收的非探测数据包会增加了最大数据包编号，这将导致端点移回该路径。在这条路径上发送数据包会降低攻击成功的可能性。因此，缓解这种攻击依赖于触发数据包交换。
</p>

<p>
为应对这种表面的迁移，端点必须使用 PATH_CHALLENGE 帧验证先前活动的路径。这会导致在该路径上发送新数据包，如果路径不再可行，则验证将会超时失败；如果路径可行，则验证将成功。
</p>

<p>
在活动路径上接收 PATH_CHALLENGE 的端点应该发送一个非探测数据包作为响应。如果非探测数据包在攻击者制作副本之前到达，则会导致连接迁移回原始路径。任何后续迁移到另一条路径都会重新执行整个过程。
</p>

<p>
虽然这种防御是不完善，但可以认为问题不算严重。 虽然多次尝试使用原始路径，但是如果攻击的路径确实比原始路径快，则无法区分是攻击还是路由改进。
</p>

<p>
端点还可以使用启发式方法来改进对这种攻击方式的检测。例如，如果最近在旧路径上接收到数据包，则不可能是 NAT 重新绑定；同样，重新绑定在 IPv6 路径上很少见。端点还可以查找重复的数据包。相反，连接 ID 的更改更有可能表明是有意迁移而不是攻击。
</p>
</div>
</div>
</div>

<div id="outline-container-orga198562" class="outline-3">
<h3 id="orga198562"><span class="section-number-3">9.3.</span> 丢包检测和拥塞控制</h3>
<div class="outline-text-3" id="text-9-3">
<p>
新路径上的可用容量与旧路径上的可能不同。在旧路径上发送的数据包不能作用于新路径的拥塞控制或 RTT 估算。
</p>

<p>
在确认对等端对其新地址的所有权后，端点必须立即将新路径的拥塞控制器和往返时间估算器重置为初始值（参见 [QUIC-RECOVERY] 的附录 A.3 和 B.3），除非对等方地址只修改了端口号。因为仅仅端口的更改，通常是 NAT 重新绑定或其他中间设备活动的结果，所以在这些情况下，端点可以改为保留其拥塞控制状态和往返时间估计，而不是恢复到初始值。在将旧路径保留的拥塞控制状态用于具有显著不同特性的新路径时，发送方可能会过于激进地传输，直到拥塞控制器和 RTT 估算器已经适应。通常，建议实现在新路径上使用以前的值时要谨慎。
</p>

<p>
当端点在迁移期间从/向多个地址发送数据和探测时，接收端可能会出现明显的重新排序，因为生成的两条路径可能具有不同的往返时间。接收端在多条路径上接收数据包时，仍将发送覆盖所有接收数据包的 ACK 帧。
</p>

<p>
虽然在连接迁移期间可能使用多条路径，但单个拥塞控制上下文和单个丢失恢复上下文（如 [QUIC-RECOVERY] 中所述）可能就足够了。例如，端点可能会延迟切换到新的拥塞控制上下文，直到确认不再需要旧路径（例如第 9.3.3 节中描述的情况）。
</p>

<p>
发送方可以对探测数据包进行例外处理，以便其丢失检测是独立的，并且不会过度地导致拥塞控制器降低其发送速率。当发送 PATH_CHALLENGE 时，端点可能会设置一个单独的计时器，如果收到相应的 PATH_RESPONSE，则取消该计时器。如果计时器在收到 PATH_RESPONSE 之前触发，端点可能会发送一个新的 PATH_CHALLENGE，并在更长的时间内重新启动计时器。这个计时器应该按照 [QUIC-RECOVERY] 的第 6.2.1 节中的描述来设置，并且不能更激进。
</p>
</div>
</div>

<div id="outline-container-org8a2949f" class="outline-3">
<h3 id="org8a2949f"><span class="section-number-3">9.4.</span> 连接迁移的私有数据的影响</h3>
<div class="outline-text-3" id="text-9-4">
<p>
如果在多个网络路径上使用固定的Connection ID，能够使被动观察者关联这些路径之间的活动。在网络之间移动的端点可能不希望它们的活动被除对等端以外的任何实体关联，因此从不同的本地地址发送时应当使用不同的Connection ID，如第 5.1 节所述。为了使其有效，端点需要确保它们提供的Connection ID 不能被任何其他实体链接。
</p>

<p>
在任何时候，端点都可以将它们传输的Destination Connection ID 更改为尚未在另一条路径上使用的值。
</p>

<p>
当从多个本地地址发送时，端点不得重用Connection ID。例如，在 9.2 节中描述的启动连接迁移或在 9.1 节中描述的探测新的网络路径时。
</p>

<p>
类似地，当发送到多个目标地址时，端点不得重用Connection ID。由于网络更改不受其对等方控制，端点可能会从新的源地址上接收到具有相同Destination Connection ID 字段值的数据包，在这种情况下，它可以继续在新远程地址上使用当前Connection ID，同时仍在相同的本地地址上发送。
</p>

<p>
这些关于Connection ID 重用的要求仅适用于数据包的发送，因为对端有可能不是有意更改路径，所以还是使用相同的Conneciton ID。例如，经过一段时间的网络不活动后，NAT 重新绑定可能会导致在客户端恢复发送时在新路径上发送数据包。端点响应此类事件在第 9.3 节中描述。
</p>

<p>
在每个新网络路径上的两个方向上，通过在发送数据包时使用不同的Connection ID，能够消除利用Connection ID 将来自同一连接的数据包链接到不同网络路径的情况。报头保护确保数据包编号不能用于关联活动，但这不会阻止使用数据包的其他属性（例如时间和大小）来关联活动。
</p>

<p>
端点不应该向带有零长度Connection ID请求的对等方发起迁移，因为新路径上的流量可能很容易被链接到旧路径上的流量。如果server能够将具有零长度Connection ID的数据包关联到正确的连接，则意味着server正在使用其他信息来关联数据包。例如，server可能会为每个client提供一个唯一的地址&#x2013;例如，使用 HTTP 替代服务 [ALTSVC]。在多个网络路径上的数据包的路由信息，也能够使除对等端实体以外的实体将路径上的活动进行关联。
</p>

<p>
在一段时间不活动后再次发送流量时，client可能希望通过切换到新的Connection ID、源 UDP 端口或 IP 地址（参见 [RFC8981]）来降低可链接性。同时更改发送数据包的地址可能会导致server检测到连接迁移。This ensures that the mechanisms that support migration are exercised even for clients that do not experience NAT rebindings or genuine migrations. 更改地址会导致对等方重置其拥塞控制状态（请参阅第 9.4 节），因此地址应该只偶尔更改。
</p>

<p>
如果端点耗尽可用Connection ID ，则无法探测新路径或启动迁移，也无法响应其对等方的探测或迁移尝试。为了确保能够进行迁移，并且在不同路径上发送的数据包不被关联，端点应该在对等体迁移之前提供新的Connection ID；见第 5.1.1 节。如果对等端可能已经用尽了可用的Connection ID，迁移端点可能会在新网络路径上发送的所有数据包中包含一个 NEW_CONNECTION_ID 帧。
</p>
</div>
</div>

<div id="outline-container-org799e5c4" class="outline-3">
<h3 id="org799e5c4"><span class="section-number-3">9.5.</span> server的首选地址</h3>
<div class="outline-text-3" id="text-9-5">
<p>
QUIC 允许server接受一个 IP 地址上的连接，并在握手后不久尝试将这些连接转移到另一个地址。这在client最初连接到多个server共享的地址但更喜欢使用单播地址以确保连接稳定性时特别有用。本节介绍将连接迁移到首选server地址的协议。
</p>

<p>
本文档的QUIC版本不支持在连接中将连接迁移到新的server地址。如果client从新的server地址接收到数据包，而client还没有启动到该地址的迁移，则应该丢弃这些数据包。
</p>
</div>

<div id="outline-container-orgded576e" class="outline-4">
<h4 id="orgded576e"><span class="section-number-4">9.5.1.</span> 首选地址的传递</h4>
<div class="outline-text-4" id="text-9-5-1">
<p>
server通过在 TLS 握手中包含 preferred_address 传输参数来传达首选地址。
</p>

<p>
服务器可以传达IPv4和IPv6的首选地址，以允许client选择最适合其网络连接的地址。
</p>

<p>
一旦握手被确认，client应该选择server提供的两个地址之一，并启动路径验证（见第 8.2 节）。client使用之前未使用的活动Connection ID 构造数据包，这些 ID 取自 preferred_address 传输参数或 NEW_CONNECTION_ID 帧。
</p>

<p>
一旦路径验证成功，客户端应该开始使用新的Connection ID 将所有后续数据包发送到新的server地址，并停止使用旧的server地址。如果路径验证失败，client必须继续将所有后续数据包发送到server的原始 IP 地址。
</p>
</div>
</div>

<div id="outline-container-orgfd649be" class="outline-4">
<h4 id="orgfd649be"><span class="section-number-4">9.5.2.</span> 迁移到首选地址</h4>
<div class="outline-text-4" id="text-9-5-2">
<p>
client在迁移到首选地址时，必须首先验证它选择的地址；见第 21.5.3 节。
</p>

<p>
server在接受连接后的任何时刻都可能收到寻址到其首选 IP 地址的数据包。如果此数据包包含 PATH_CHALLENGE 帧，则server会发送包含 PATH_RESPONSE 帧的数据包（第 8.2 节）。server必须从其原始地址发送非探测数据包，直到它在其首选地址上接收到client的非探测数据并且server验证了新路径。
</p>

<p>
server必须探测从其首选地址到client的路径。这有助于防止攻击者发起的虚假迁移。
</p>

<p>
一旦server完成其路径验证，并在其首选地址上接收到具有新的最大数据包编号的非探测数据包，server就开始从其首选 IP 地址向client发送非探测数据包。server应该丢弃在旧 IP 地址上接收到的此连接的新数据包。server可以继续处理在旧 IP 地址上接收到的延迟数据包。
</p>

<p>
server在 preferred_address 传输参数中提供的地址仅对提供它们的连接有效。client不得将这些地址用于其他连接，包括从当前连接恢复的连接。
</p>
</div>
</div>

<div id="outline-container-org0de7ffb" class="outline-4">
<h4 id="org0de7ffb"><span class="section-number-4">9.5.3.</span> client迁移和首选地址的交互</h4>
<div class="outline-text-4" id="text-9-5-3">
<p>
client可能需要在迁移到server的首选地址之前执行连接迁移。在这种情况下，client应该同时执行从新client地址到server的原始和首选地址的路径验证。
</p>

<p>
如果server首选地址的路径验证成功，则client必须放弃对原始地址的验证，并迁移到server的首选地址。如果server首选地址的路径验证失败，但原始地址的验证成功，则client可以迁移到其新地址，并继续使用server的原始地址。
</p>

<p>
如果在server首选地址收到的数据包，数据包的源地址与握手期间从client观察到的源地址不同，则server必须防止潜在的攻击，如第 9.3.1 和 9.3.2 节所述。除了是client刻意进行同时迁移之外，这也可能是因为client在使用server首选地址访问网络时使用了不同的 NAT 绑定。
</p>

<p>
server应该在收到来自不同client地址的探测包时，启动到client新地址的路径验证；参见第 8 节。
</p>

<p>
client迁移到新地址时，应该使用相同协议族的server首选地址。
</p>

<p>
在preferred_address 传输参数中提供的Connection ID 不特定于所提供的地址。提供此Connection ID 是为了确保client具有可用于迁移的Connection ID，但client可以在任何路径上使用此Connection ID。
</p>
</div>
</div>


<div id="outline-container-org1801c46" class="outline-4">
<h4 id="org1801c46"><span class="section-number-4">9.5.4.</span> IPv6流标签的使用和迁移</h4>
<div class="outline-text-4" id="text-9-5-4">
<p>
端点使用 IPv6 发送数据时应该应用符合 [RFC6437] 的 IPv6 流标签，除非本地 API 不允许设置 IPv6 流标签。
</p>

<p>
流标签生成必须设计为最小化与先前使用的流标签的链接机会，因为稳定的流标签将能够关联多个路径上的活动；见第 9.5 节。
</p>

<p>
[RFC6437] 建议使用伪随机函数导出值来生成流标签。在生成流标签时，要确保源地址、目标地址、Destination Connection ID 字段与其他可观察标识符的更改同步。可以将这些输入与本地秘密相结合的加密散列函数来实现这一点。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org6515396" class="outline-2">
<h2 id="org6515396"><span class="section-number-2">10.</span> 连接终止</h2>
<div class="outline-text-2" id="text-10">
<p>
QUIC连接建立后可以通过以下三种方式终止：
</p>
<ul class="org-ul">
<li>空闲超时（10.1）</li>
<li>立即关闭（10.2）</li>
<li>无状态重置（10.3）</li>
</ul>

<p>
如果端点没有已验证路径用以发送数据包，则可以丢弃连接状态。
</p>
</div>

<div id="outline-container-orgafad81d" class="outline-3">
<h3 id="orgafad81d"><span class="section-number-3">10.1.</span> 空闲超时</h3>
<div class="outline-text-3" id="text-10-1">
<p>
如果任一端点指定了 max_idle_timeout 传输参数（第 18.2 节），则当连接空闲的时间超过两个端点通告的 max_idle_timeout 值的最小值时，连接将被静默关闭并丢弃其状态。
</p>

<p>
每个端点都通告一个 max_idle_timeout，但端点的有效值计算为两个通告值（或唯一通告值，如果只有一个端点通告非零值）中的最小值。虽然宣布 max_idle_timeout，但是如果端点需要在有效值之前放弃连接，则可以启动立即关闭（第 10.2 节）。
</p>

<p>
当一个端点收到对等端数据包并成功处理时，端点重新启动其空闲计时器。如果自上次接收和处理数据包后没有发送其他确认数据包，端点也会在发送确认数据包时重新启动其空闲计时器。在发送数据包时重新启动此计时器可确保在启动新活动后不会关闭连接。
</p>

<p>
为避免空闲超时时间过小，端点必须将空闲超时时间增加到至少是当前探测超时（PTO）的三倍。这允许多个 PTO 到期，因此可以在空闲超时之前发送和丢失多个探测。
</p>
</div>

<div id="outline-container-org6f721fd" class="outline-4">
<h4 id="org6f721fd"><span class="section-number-4">10.1.1.</span> 存活探测</h4>
<div class="outline-text-4" id="text-10-1-1">
<p>
如果端点发送数据包时已经接近超时，则对等端可能会丢弃这些数据包，因为在这些数据包到达之前，对等方的空闲超时时间可能已经到期。
</p>

<p>
如果对等方可能很快超时，端点可以发送 PING 或另一个 ack-eliciting 帧来测试连接的活跃性，例如在 PTO 内；参见 [QUIC-RECOVERY] 的第 6.2 节。当无法安全地重试任何应用程序数据时，这将特别有用。注意，由应用程序确定哪些数据可以安全重试。
</p>
</div>
</div>

<div id="outline-container-org4ffccad" class="outline-4">
<h4 id="org4ffccad"><span class="section-number-4">10.1.2.</span> 延迟空闲超时</h4>
<div class="outline-text-4" id="text-10-1-2">
<p>
如果端点正在等待响应数据，但没有或无法发送应用程序数据时，可以通过发送 ack-eliciting 数据包以避免空闲超时。
</p>

<p>
QUIC 的实现可能为应用程序提供延迟空闲超时的选项。当应用程序不想丢失与打开的连接相关联的状态，但又不希望在一段时间内交换应用程序数据时，可以使用此功能。使用此选项时，端点可以定期发送 PING 帧（第 19.2 节），这将导致对等方重新启动其空闲超时周期。如果发送的PING帧也是自收到数据包后发送的第一个 ack-eliciting 数据包，则会重新启动此端点的空闲超时。发送 PING 帧会导致对等方以确认响应，这也会重新启动端点的空闲超时。
</p>

<p>
使用 QUIC 的应用程序协议应该提供有关何时推迟空闲超时的指导。不必要地发送 PING 帧可能会对性能产生不利影响。
</p>

<p>
如果在使用 max_idle_timeout 传输参数协商的时间内没有发送或接收数据包，则连接将超时；请参阅第 10 节。但是，中间设备中的状态可能会提前超时。尽管 [RFC4787] 中的 REQ-5 建议使用 2 分钟的超时间隔，但实践表明，有必要每 30 秒发送一次数据包，以防止大多数中间设备丢失 UDP 流的状态 [GATEWAY]。
</p>
</div>
</div>
</div>

<div id="outline-container-org8ff3c2e" class="outline-3">
<h3 id="org8ff3c2e"><span class="section-number-3">10.2.</span> 立即关闭</h3>
<div class="outline-text-3" id="text-10-2">
<p>
端点可以通过发送 CONNECTION_CLOSE 帧（第 19.19 节）以立即终止连接。 CONNECTION_CLOSE 帧会导致所有stream立即关闭，可以认为stream被隐式重置。
</p>

<p>
发送 CONNECTION_CLOSE 帧后，端点立即进入关闭状态；见第 10.2.1 节。端点收到CONNECTION_CLOSE帧后，进入draining状态；见第 10.2.2 节。
</p>

<p>
违反协议会导致立即关闭。
</p>

<p>
在应用程序协议安排关闭连接后，可以使用立即关闭，这可能是在应用协议协商正常关闭之后。应用程序协议可以交换两个端点同意关闭连接所需的消息，之后应用程序请求 QUIC 关闭连接。当 QUIC 因此关闭连接时，使用带有application-supplied的错误代码的 CONNECTION_CLOSE 帧,向对等方发出关闭信号。
</p>

<p>
连接的closing和draining状态的存在是为了确保连接完全关闭，并正确丢弃延迟或重新排序的数据包。这些状态的持续时间应该至少是当前 PTO （[QUIC-RECOVERY] 中定义）间隔的三倍。
</p>

<p>
如果在退出closing或draining状态之前，处理连接状态可能会导致端点在接收到迟到的数据包时，生成没有必要的无状态重置。端点有一些替代方法来确保迟到的数据包不会引起响应，例如端点能够关闭 UDP 套接字，提前结束这些状态以允许更快的资源恢复。server如果保留打开套接字以接受新连接时，不应该提前结束closing或draining状态。
</p>

<p>
一旦其closing或draining状态结束，端点应该丢弃所有连接状态。端点如果收到这个连接后续的任何数据包，可以发送一个无状态重置来响应。
</p>
</div>

<div id="outline-container-org913f691" class="outline-4">
<h4 id="org913f691"><span class="section-number-4">10.2.1.</span> Closing连接状态</h4>
<div class="outline-text-4" id="text-10-2-1">
<p>
端点在发起立即关闭后进入closing状态。
</p>

<p>
在closing状态下，端点只保留生成 CONNECTION_CLOSE 帧的信息，以及识别该连接数据包的信息。处于closing状态的端点可通过发送一个包含 CONNECTION_CLOSE 帧的数据包，来响应传入的属于该连接任何数据包。
</p>

<p>
在closing状态下，端点应该限制生成数据包的速率。例如，端点可以在接收到一定量的数据包或者等待一定的时间后再对接收的数据包作出响应。
</p>

<p>
端点只需要其选择的Connection ID 和 QUIC 版本就能够识别关闭连接的数据包；端点可以丢弃所有其他连接状态。正在关闭的端点不需要处理任何接收到的帧。端点可以为传入的数据包保留数据包保护密钥，以允许它读取和处理 CONNECTION_CLOSE 帧。
</p>

<p>
端点可以在进入closing状态时丢弃数据包保护密钥，并发送包含 CONNECTION_CLOSE 帧的数据包以响应收到的任何 UDP 数据报。但是，端点在丢弃数据包保护密钥后，无法识别和丢弃无效数据包。为避免被用于放大攻击，此类端点必须将其发送的数据包的累积大小限制该连接上接收数据包的累积大小的三倍。为了最小化端点的关闭连接状态，端点可以发送完全相同的数据包以响应任何接收到的数据包。
</p>

<div class="org-center">
<p>
closing数据包重传时不需要使用新数据包编号；见第 12.3 节。发送新的数据包编号主要有利于丢失恢复和拥塞控制，这与关闭的连接无关。重传最终数据包需要更少的状态。
</p>
</div>

<p>
当处于closing状态时，端点可以从新的源地址接收数据包，这有可能是连接迁移；见第 9 节。处于closing状态的端点要么丢弃从未验证地址接收的数据包，要么将其发送到未验证地址的数据包的累积大小限制为从该地址接收的数据包大小的三倍。
</p>

<p>
端点在关闭时不应处理密钥更新（[QUIC-TLS] 的第 6 节）。密钥更新可能会阻止端点从closing状态移动到draining状态，因为端点将无法处理随后收到的数据包，除此之外不会产生任何影响。
</p>
</div>
</div>

<div id="outline-container-org6cea21d" class="outline-4">
<h4 id="org6cea21d"><span class="section-number-4">10.2.2.</span> Draining连接状态</h4>
<div class="outline-text-4" id="text-10-2-2">
<p>
一旦端点接收到 CONNECTION_CLOSE 帧就会进入draining状态，这也表示其对等方正处于closing或draining。处于draining状态的端点不得发送任何数据包，其他方面和closing状态相同。一旦连接处于耗尽状态，就不需要保留数据包保护密钥。
</p>

<p>
接收 CONNECTION_CLOSE 帧的端点可以在进入draining状态之前发送包含 CONNECTION_CLOSE 帧的单个数据包，如果可以使用 NO_ERROR 错误代码。端点不得发送更多数据包。这样做可能会导致 CONNECTION_CLOSE 帧的不断交换，直到一个端点退出closing状态。
</p>

<p>
如果端点收到 CONNECTION_CLOSE 帧，则它可以从closing状态进入draining状态，这表明对等端处于closing或draining状态。在这种情况下，当closing状态结束时，draining状态随之结束。
</p>
</div>
</div>

<div id="outline-container-orgf84f6c8" class="outline-4">
<h4 id="orgf84f6c8"><span class="section-number-4">10.2.3.</span> 握手期间的立即关闭</h4>
<div class="outline-text-4" id="text-10-2-3">
<p>
当发送 CONNECTION_CLOSE 帧时，目的是确保对等方将处理该帧。通常，这意味着需要在具有最高数据包保护级别的数据包中发送帧以避免数据包被丢弃。在确认握手后（参见 [QUIC-TLS] 的第 4.1.2 节），端点必须在 1-RTT 数据包中发送任何 CONNECTION_CLOSE 帧。但是，在确认握手之前，对等方可能无法使用更高级的数据包保护密钥，因此可以在使用较低数据包保护级别的数据包中发送另一个 CONNECTION_CLOSE 帧。具体来说：
</p>

<ul class="org-ul">
<li>client总是知道server是否具有握手密钥（参见第 17.2.2.1 节），但server可能不知道client是否具有握手密钥。在这种情况下，server应该在Handshake和Initial数据包中发送一个 CONNECTION_CLOSE 帧，以确保其中至少一个可以被客户端处理。</li>

<li>client在 0-RTT 数据包中发送 CONNECTION_CLOSE 帧时，不能保证server已接受 0-RTT。在Initial数据包中发送 CONNECTION_CLOSE 帧使server更有可能收到关闭信号，即使其收不到应用程序错误代码。</li>

<li>在确认握手之前，对等方可能无法处理 1-RTT 数据包，因此端点应该在Handshake和 1-RTT 数据包中发送 CONNECTION_CLOSE 帧。server还应该在Initial数据包中发送一个CONNECTION_CLOSE 帧。</li>
</ul>

<p>
在 Initial 或 Handshake 数据包中发送 0x1d 类型的 CONNECTION_CLOSE 时，可能会暴露应用程序状态或用来更改应用程序状态。当在Initial或Handshake数据包中发送帧时，必需使用 0x1c 类型的 CONNECTION_CLOSE 帧替换 0x1d 。否则，可能会泄露有关应用程序状态的信息。端点必须清除 Reason Phrase 字段的值，并且应该在转换为 0x1c 类型的 CONNECTION_CLOSE 时使用 APPLICATION_ERROR 代码。
</p>

<p>
在发送多种类型的 CONNECTION_CLOSE 帧的数据包时，可以合并为单个 UDP 数据报；见第 12.2 节。
</p>

<p>
端点可以在Initial数据包中发送 CONNECTION_CLOSE 帧。这可能是为了响应在 Initial 或 Handshake 数据包中收到的未经验证的信息。这种立即关闭可能会将合法连接暴露给拒绝服务。 QUIC在握手期间没有对路径攻击的防御措施；见第 21.2 节。然而，可以利用减少对合法对等端的错误反馈为代价，如果端点丢弃非法数据包而不是使用 CONNECTION_CLOSE 终止连接，则可以使攻击者更加难以制造某些形式的拒绝服务攻击。因此，如果在缺少身份验证的数据包中检测到错误，端点可能会丢弃数据包而不是立即关闭。
</p>

<p>
还没有进入established状态的端点不会进入closing状态，例如server在Initial数据包中检测到错误。没有连接状态的端点在发送 CONNECTION_CLOSE 帧时不会进入closing或draining状态。
</p>
</div>
</div>
</div>

<div id="outline-container-org92e2ff8" class="outline-3">
<h3 id="org92e2ff8"><span class="section-number-3">10.3.</span> 无状态重置</h3>
<div class="outline-text-3" id="text-10-3">
<p>
无状态重置是为无权访问连接状态的端点提供的最后手段。端点崩溃或中断时已经无法继续处理连接，但是对等端可能继续发送数据。当端点接收的数据包无法关联活动连接时，可以发送无状态重置。
</p>

<p>
无状态重置不适用于指示活动连接中的错误。如果端点希望传达致命连接错误，必须使用 CONNECTION_CLOSE 帧。
</p>

<p>
为了支持此过程，端点发出无状态重置token，这是一个很难猜测的 16 字节值。如果对等方随后收到无状态重置，即以该无状态重置token结尾的 UDP 数据报，则将立即终止连接。
</p>

<p>
无状态重置token特定于Connection ID。端点通过在 NEW_CONNECTION_ID 帧的Stateless Reset Token字段来发布无状态重置token。server还可以在握手期间发出 stateless_reset_token 传输参数，该参数适用于它在握手期间选择的Connection ID。这些交换受加密保护，因此只有client和server知道自身的值。注意，client不能使用 stateless_reset_token 传输参数，因为它们的传输参数没有加密保护。
</p>

<p>
当通过 RETIRE_CONNECTION_ID 帧（第 19.16 节）退出关联的Connection ID 时，token将失效。
</p>

<p>
当端点接收到无法处理的数据包时，应当发送以下格式的数据包（请参阅第 1.3 节）。
</p>

<div class="org-src-container">
<pre class="src src-fundamental">
Stateless Reset {
  Fixed Bits (2) = 1,
  Unpredictable Bits (38..),
  Stateless Reset Token (128),
}

                      Figure 10: Stateless Reset
</pre>
</div>

<p>
这种设计确保无状态重置与具有short header的常规数据包无法区分。
</p>

<p>
无状态重置使用整个 UDP 数据报，从数据包头的前两位开始。第一个字节的其余部分和之后的任意数量的字节被设置为随机数。数据报的最后 16 个字节包含一个无状态重置token。
</p>

<p>
如果是被其他实体接收到此数据包，无状态重置将显示为具有short header的数据包。为了使无状态重置显示为有效的 QUIC 数据包，不可预测位字段需要包含至少 38 位数据（或 5 个字节，减去两个固定位）。
</p>

<p>
如果接收方需要使用Connection ID，由此可能生成最小的21字节的无状态重置数据包，这时可能比较容易和其他类型的数据包区分。为了使其难以区分，端点应该确保它发送的所有数据包长度，至少比它请求对端时包含最小Connection ID的数据包长度长 22 个字节，并根据需要添加 PADDING 帧。这确保了对等方发送的任何无状态重置与发送到端点的有效数据包是不可区分的。如果端点要发送无状态重置以响应 43 个字节或更短的数据包时，则发送的无状态重置数据包应该比它响应的数据包短一个字节。
</p>

<p>
这些值是基于无状态重置token的长度与数据包保护 AEAD 的最小扩展长度相同的假设。如果端点可以协商具有更大最小扩展的数据包保护方案，则需要额外的不可预测字节。
</p>

<p>
端点不得发送比它接收的数据包大三倍或更多的无状态重置，以避免被用于放大。第 10.3.3 节描述了对无状态重置大小的附加限制。端点必须丢弃过小（小于QUIC数据包的最小长度）的数据包。举个例子，使用 [QUIC-TLS] 中定义的一组 AEAD 函数，小于 21 字节的短报头数据包永远不会有效。
</p>

<p>
端点必须发送格式化为带有short header的无状态重置数据包。然而，端点必须将任何以有效无状态重置token结尾的数据包视为无状态重置，因为其他 QUIC 版本可能允许使用long header。
</p>

<p>
端点可以发送无状态重置以响应具有long header的数据包。在无状态重置token可供对等方使用之前，无状态重置不会生效。在这个 QUIC 版本中，具有long header的数据包仅在连接建立期间使用。由于无状态重置token在连接建立完成或接近完成之前不可用，因此忽略带有long header的未知数据包可能与发送无状态重置效果相同。
</p>

<p>
端点无法从具有short header的数据包中确定Source Connection ID；因此，它不能在无状态重置中设置Destination Connection ID。因此，Destination Connection ID 将与先前数据包中使用的值不同。随机的Destination Connection ID 使Connection ID 看起来像是使用 NEW_CONNECTION_ID 帧提供的新Connection ID 的结果；见第 19.15 节。
</p>

<p>
使用随机的Connection ID 会导致两个问题：
</p>

<ul class="org-ul">
<li>数据包可能无法到达对等方。如果Destination Connection ID 对于向对等方路由至关重要，则此数据包可能会被错误地路由。这也可能会触发另一个无状态重置的响应；见第 10.3.3 节。未正确路由的无状态重置是一种无效的错误检测和恢复机制。在这种情况下，端点将需要依赖其他方法（例如计时器）来检测连接是否失败。</li>

<li>对等端之外的实体可能将随机生成的Connection ID 识别为潜在的无状态重置。偶尔使用不同Connection ID 的端点可能会对此引入一些不确定性。</li>
</ul>

<p>
这种无状态重置设计特定于 QUIC V1。An endpoint that supports multiple versions of QUIC needs to generate a Stateless Reset that will be accepted by peers that support any version that the endpoint might support (or might have supported prior to losing state). 设计新版本的 QUIC 时，必需重用此设计或者使用除最后 16 个字节以外的数据包的一部分来承载数据。
</p>
</div>

<div id="outline-container-org6e7406f" class="outline-4">
<h4 id="org6e7406f"><span class="section-number-4">10.3.1.</span> 检测无状态重置</h4>
<div class="outline-text-4" id="text-10-3-1">
<p>
端点使用 UDP 数据报的结尾 16 字节来检测潜在的无状态重置。端点记录所有与它最近发送的数据报的Connection ID 和远程地址相关联的无状态重置token。这包括来自 NEW_CONNECTION_ID 帧的无状态重置token的字段值，以及server的传输参数，但不包括与未使用或已停用的Connection ID 关联的无状态重置token。端点通过将数据报的最后 16 个字节和所有接收数据报远程地址相关联的无状态复位token进行比较，来将接收到的数据报识别为无状态重置。
</p>

<p>
可以对每个入站数据报执行此比较。如果来自数据报的任何数据包被成功处理时，端点可以跳过此检查。但是，当传入数据报中的第一个数据包无法与连接关联或无法解密时，必须执行比较。
</p>

<p>
当无状态重置token和端点未使用的或者是已停用的Connection ID 相关联时，端点不需要检查该token。
</p>

<p>
当将数据报与无状态重置token值进行比较时，端点必须在不泄漏有关token值的信息的情况下执行比较。例如，在恒定时间内执行此比较可保护各个无状态重置token的值不会通过时间方面的通道泄漏信息（？？？）。另一种方法是存储和比较无状态重置token的转换值而不是原始token值，这里的转换说的是使用密钥（例如，分组密码、散列消息身份验证代码 (HMAC) 的加密安全伪随机函数） [RFC2104]）。端点没有必要保护有关数据包是否成功解密的信息，或者有效无状态重置token数量的信息。
</p>

<p>
如果数据报的最后 16 个字节与无状态重置token的值相同，则端点必须进入draining状态并且不再在此连接上发送任何其他数据包。
</p>
</div>
</div>

<div id="outline-container-orgf855924" class="outline-4">
<h4 id="orgf855924"><span class="section-number-4">10.3.2.</span> 计算无状态重置token</h4>
<div class="outline-text-4" id="text-10-3-2">
<p>
无状态重置token必须难以猜测。为了创建无状态重置token，端点可以为其创建的每个连接随机生成 [RANDOM] 密钥。但是，当集群中有多个实例时会带来进程协调的问题，或者端点丢失状态时的存储问题。无状态重置专门用于处理状态丢失的情况，因此这种方法不是最理想的。
</p>

<p>
可以在到同一端点的所有连接中使用单个静态密钥，密钥通过使用伪随机函数生成，该函数采用静态密钥和端点选择的连接 ID（参见第 5.1 节）作为输入。端点可以使用 HMAC [RFC2104]（例如，HMAC(static_key, connection_id)）或基于 HMAC 的密钥派生函数 (HKDF) [RFC5869]（例如，使用静态密钥作为输入密钥材料，连接 ID作为盐）。此函数的输出被截断为 16 个字节，以生成该连接的无状态重置token。
</p>

<p>
失去状态的端点可以使用相同的方法生成有效的无状态重置token。Connection ID 来自端点接收的数据包。
</p>

<p>
这种设计依赖于对等端始终在其数据包中发送Connection ID，以便端点可以使用数据包中的Connection ID 来重置连接。使用这种设计的端点要么对所有连接使用相同的Connection ID长度，要么对Connection ID 的长度进行编码，以便它可以在没有状态的情况下恢复。此外，它不能提供零长度的Connection ID。
</p>

<p>
无状态重置token如果暴露，则任何实体都能利用token终止连接，因此一个值只能使用一次。这种选择无状态重置token的方法意味着Connection ID 和静态密钥的组合不得用于另一个连接。如果共享静态密钥的实例使用相同的Connection ID，或者如果攻击者可以将数据包路由到没有状态但具有相同静态密钥的实例，则可能发生拒绝服务攻击；见第 21.11 节。如果是由被暴露的无状态重置token重置的连接，其Connection ID 不得在共享静态密钥的节点上重新用于新连接。
</p>

<p>
相同的无状态重置token不得用于多个Connection ID。不要求端点将新值与所有以前的值进行比较，但如果是重复值可以视为 PROTOCOL_VIOLATION 类型的连接错误。
</p>

<p>
注意，无状态重置没有任何加密保护。
</p>
</div>
</div>

<div id="outline-container-org8f8e3ee" class="outline-4">
<h4 id="org8f8e3ee"><span class="section-number-4">10.3.3.</span> 环路</h4>
<div class="outline-text-4" id="text-10-3-3">
<p>
无状态重置的设计原理：在不知道无状态重置token的情况下，它与有效数据包无法区分。例如，如果server向另一台server发送无状态重置，它可能会收到另一个无状态重置的响应，这可能导致无限交换。
</p>

<p>
端点必须确保它发送的每个无状态重置都小于触发它的数据包，除非它能够保持足够的状态以防止循环。当出现环路的情况时，数据包最终会因为太小而无法触发响应。
</p>

<p>
端点可以记录它已发送的无状态重置的数量，一旦达到限制就停止生成新的无状态重置。对不同的远程地址使用单独的限制可以确保当其他对等点或连接已经超出限制时，可以使用无状态重置来关闭连接。
</p>

<p>
小于 41 字节的无状态重置可能会被观察者识别为无状态重置，具体取决于对等方Connection ID 的长度。如果对于小的数据包不发送无状态重置，在仅发送非常小的数据包的断开连接的情况中，无状态重置无法用于检测这种情况；此类故障可能只能通过其他方式检测，例如计时器。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org6c91727" class="outline-2">
<h2 id="org6c91727"><span class="section-number-2">11.</span> 错误处理</h2>
<div class="outline-text-2" id="text-11">
<p>
端点检测到错误时，应该通知其对等方出现该错误。传输级和应用级错误都会影响整个连接；见第 11.1 节。只有应用程序级别的错误可以被隔离到单个流中；见第 11.2 节。
</p>

<p>
错误代码（第 20 节）应该包含在发出错误信号的帧中。在此规范标识错误条件的地方，它还标识了所使用的错误代码；尽管这些被称为要求，但不同的实施策略可能会导致报告不同的错误。特别是，端点可以在检测到错误情况时，使用任何合理的错误代码；通用错误代码（例如 PROTOCOL_VIOLATION 或 INTERNAL_ERROR）总是可以用来代替特定的错误代码。
</p>

<p>
如果是能够用 CONNECTION_CLOSE 或 RESET_STREAM 帧来通知的错误， 则不应当使用无状态重置（第 10.3 节）。如果端点在连接上具备发送帧的所需状态，则不得使用无状态重置。
</p>
</div>

<div id="outline-container-org1992544" class="outline-3">
<h3 id="org1992544"><span class="section-number-3">11.1.</span> 连接错误</h3>
<div class="outline-text-3" id="text-11-1">
<p>
如果是导致连接不可用的错误，例如明显违反协议语义或影响整个连接的状态损坏，必须使用 CONNECTION_CLOSE 帧（第 19.19 节）发出信号。
</p>

<p>
特定于应用程序协议的错误，使用帧类型为 0x1d 的 CONNECTION_CLOSE 帧发出信号。特定于传输的错误，包括本文档中描述的所有错误，都应该将错误包含在帧类型为 0x1c 的 CONNECTION_CLOSE 帧中。
</p>

<p>
CONNECTION_CLOSE 帧可以在重传的（？？？表面意思是丢失的数据包）数据包中发送。如果端点在终止的连接上接收到更多数据包，则它应该准备好重传包含 CONNECTION_CLOSE 帧的数据包。通过限制重传次数和发送最终数据包的时间，能够限制在终止连接上花费的精力。
</p>

<p>
如果端点选择不重传包含 CONNECTION_CLOSE 帧的数据包，有可能导致对等端丢失第一个此类数据包。端点如果继续接收终止连接上的数据，此时唯一可用的机制就是尝试无状态重置过程（第 10.3 节）。
</p>

<p>
由于Initial数据包的 AEAD 不提供强身份验证，端点可以丢弃无效的Initial数据包。即使本规范要求连接错误，也允许丢弃Initial数据包。如果端点不处理数据包中的帧或者不采取恢复措施，则它只能丢弃数据包。丢弃无效的Initial数据包可用于减少拒绝服务的风险；见第 21.2 节。
</p>
</div>
</div>

<div id="outline-container-org6381f7a" class="outline-3">
<h3 id="org6381f7a"><span class="section-number-3">11.2.</span> Stream错误</h3>
<div class="outline-text-3" id="text-11-2">
<p>
如果应用程序级别的错误影响单个流，但可以其他方式使连接处于可恢复状态，则端点可以发送带有适当错误代码的 RESET_STREAM 帧（第 19.4 节）来终止受影响的流。
</p>

<p>
在不涉及应用程序协议的情况下重置流，可能导致应用程序协议进入不可恢复状态。 RESET_STREAM 只能由使用 QUIC 的应用程序协议发起。
</p>

<p>
RESET_STREAM 中携带的应用程序错误代码的语义由应用程序协议定义。只有应用程序协议能够终止流。应用协议的本地实例使用 API 调用，远程实例使用 STOP_SENDING 帧，这会自动触发RESET_STREAM。
</p>

<p>
应用协议应该定义任意端点提前撤销流时的处理规则。
</p>
</div>
</div>
</div>

<div id="outline-container-orga3b39b6" class="outline-2">
<h2 id="orga3b39b6"><span class="section-number-2">12.</span> 数据包和帧</h2>
<div class="outline-text-2" id="text-12">
<p>
QUIC 端点通过交换数据包进行通信。数据包受机密性和完整性保护；见第 12.1 节。数据包在 UDP 数据报中携带；见第 12.2 节。
</p>

<p>
此版本的 QUIC 在连接建立时使用long header；见第 17.2 节。带有long header的数据包是 Initial（第 17.2.2 节）、0-RTT（第 17.2.3 节）、Handshake（第 17.2.4 节）和 Retry（第 17.2.5 节）。版本协商使用带有long header的与版本无关的数据包；见第 17.2.1 节。
</p>

<p>
带有short header的数据包被设计为最小开销，在建立连接且 1-RTT 密钥可用后使用；见第 17.3 节。
</p>
</div>

<div id="outline-container-org39f01bc" class="outline-3">
<h3 id="org39f01bc"><span class="section-number-3">12.1.</span> 受保护的数据包</h3>
<div class="outline-text-3" id="text-12-1">
<p>
不同数据包类型的QUIC数据包具有不同级别的加密保护。有关数据包保护的详细信息可参阅 [QUIC-TLS]；本节对所提供的保护进行概述。
</p>

<p>
版本协商包没有加密保护；参见 [QUIC-INVARIANTS]。
</p>

<p>
Retry数据包使用 AEAD 功能 [AEAD] 来防止意外修改。
</p>

<p>
Initial数据包使用 AEAD 函数，其密钥是使用在线上可见的值派生的。因此Initial数据包没有有效的机密性保护。初始的保护是为确保数据包的发送方位于网络路径上。任何实体从client接收Initial数据包后都可以恢复密钥，这将允许它们读取数据包的内容，并生成能够被任一端点成功验证的Initial数据包。 AEAD 还保护Initial数据包不被意外修改。
</p>

<p>
所有其他数据包都使用从加密握手派生的密钥进行保护。加密握手确保只有通信端点才能收到Handshake、0-RTT 和 1-RTT 数据包的相应密钥。使用 0-RTT 和 1-RTT 密钥保护的数据包具有很强的机密性和完整性保护。
</p>

<p>
出现在某些数据包类型中的数据包编号字段，可以作为报头保护的一部分来替代机密性保护；有关详细信息，请参阅 [QUIC-TLS] 的第 5.4 节。底层包号随着每个发送的数据包在给定包号空间中增加；有关详细信息，请参阅第 12.3 节。
</p>
</div>
</div>

<div id="outline-container-org79bf252" class="outline-3">
<h3 id="org79bf252"><span class="section-number-3">12.2.</span> 合并数据包</h3>
<div class="outline-text-3" id="text-12-2">
<p>
Initial（第 17.2.2 节）、0-RTT（第 17.2.3 节）和Handshake（第 17.2.4 节）数据包包含一个长度字段，用于确定数据包的结尾。长度包括数据包编号和有效载荷字段，这两个字段都是机密保护的并且最初长度未知。一旦头保护被移除，就会得到Payload 字段的长度。
</p>

<p>
使用长度字段，发送方可以将多个 QUIC 数据包合并为一个 UDP 数据报。这可以减少完成加密握手和开始发送数据所需的 UDP 数据报的数量。这也可用于构建路径最大传输单元 (PMTU) 探针；见第 14.4.1 节。接收者必须能够处理合并的数据包。
</p>

<p>
按照加密级别递增的顺序（Initial、0-RTT、Handshake、1-RTT；参见 [QUIC-TLS] 的第 4.1.4 节），合并数据包使得接收者更有可能单程处理所有数据包。具有short header的数据包不包含长度，因此它只能是 UDP 数据报中包含的最后一个数据包。当端点以相同的加密级别发送数据包时，应该在单个数据包中包含多个帧，而不是合并多个数据包。
</p>

<p>
接收者可以根据 UDP 数据报中包含的第一个数据包中的信息进行路由。发送方不得将具有不同Conneciton ID 的 QUIC 数据包合并为单个 UDP 数据报。如果后续的数据包的Destination Connection ID与数据报中的第一个数据包不同，则应该将其忽略。
</p>

<p>
合并为单个 UDP 数据报的每个 QUIC 数据包都是独立且完整的。接收到QUIC合并数据包后，必须单独处理每个 QUIC 数据包并分别确认它们，就如同接收到不同 UDP 数据报的有效载荷的一样。例如，如果解密失败（因为密钥不可用或出于任何其他原因），接收方可能会丢弃或缓冲数据包以供以后处理，但必须尝试处理剩余的数据包。
</p>

<p>
Retry数据包（第 17.2.5 节）、版本协商数据包（第 17.2.1 节）和具有short header的数据包（第 17.3 节）不包含长度字段，因此同一 UDP 数据报中这些数据包后不能跟随任何其他类型的数据包。注意，不会出现Retry或版本协商数据包与另一个数据包合并的情况。
</p>
</div>
</div>

<div id="outline-container-orgdde20f8" class="outline-3">
<h3 id="orgdde20f8"><span class="section-number-3">12.3.</span> 数据包编号</h3>
<div class="outline-text-3" id="text-12-3">
<p>
包号是0到2<sup>62-1</sup>范围内的一个整数。该数字用于确定数据包保护的加密随机数。每个端点维护一个单独的数据包编号用于发送和接收。
</p>

<p>
数据包编号限制在此范围内，因为它们需要能被 ACK 帧（第 19.3 节）的Largest Acknowledged字段来描述。然而，当出现在long header或者short header中时，数据包号数量会减少并编码为 1 到 4 个字节；见第 17.1 节。
</p>

<p>
版本协商（第 17.2.1 节）和Retry（第 17.2.5 节）数据包不包含数据包编号。
</p>

<p>
QUIC中的包号分为三个空间：
</p>

<ul class="org-ul">
<li>Initial space：所有Initial 数据包（17.2.2节）都在这个空间。</li>

<li>Handshake空间：所有握手包（第 17.2.4 节）都在此空间中。</li>

<li>应用数据空间：所有0-RTT（17.2.3节）和1-RTT（17.3.1节）数据包都在这个空间中。</li>
</ul>

<p>
如 [QUIC-TLS] 中所述，每种数据包类型使用不同的保护密钥。
</p>

<p>
从概念上讲，数据包编号空间是可以处理和确认数据包的上下文。Initial数据包只能使用Initial数据包保护密钥发送，也是由Initial数据包进行确认。同样，Handshake数据包在握手加密级别发送，且只能在Handshake数据包中确认。
</p>

<p>
这使得在不同数据包编号空间中发送的数据之间进行强制加密隔离。每个空间中的数据包编号从0 开始。在同一数据包编号空间中发送的后续数据包必须将数据包编号至少增加 1。
</p>

<p>
0-RTT 和 1-RTT 数据存在于同一个数据包编号空间中，这使两种数据包类型之间的丢失恢复算法更容易实现。
</p>

<p>
QUIC 端点不得在一个连接中的相同数据包编号空间内重用数据包编号。如果发送的数据包数量达到 2<sup>62-1</sup>，则发送方必须关闭连接，并且不发送 CONNECTION_CLOSE 帧或任何其他数据包；端点可以发送无状态重置（第 10.3 节）以响应它接收到的更多数据包。
</p>

<p>
接收方必须丢弃一个新的未受保护的数据包，除非确定它没有处理过相同数据包编号空间的相同编号的数据包。如 [QUIC-TLS] 的第 9.5 节中描述，删除数据包保护后必须进行重复抑制。
</p>

<p>
端点如果为检测重复数据而跟踪所有数据包，则可能累积过多状态。可以通过维护数据包编号最小值来限制检测重复所需的数据包，低于该编号的所有数据包将立即丢弃。任何最小值都需要考虑往返时间的巨大变化，其中包括对等点可能以更大的往返时间探测网络路径的可能性；请参阅第 9 节。
</p>

<p>
第 17.1 节描述了发送方的数据包编号编码和接收方的解码。
</p>
</div>
</div>

<div id="outline-container-org4cefe13" class="outline-3">
<h3 id="org4cefe13"><span class="section-number-3">12.4.</span> 帧和帧类型</h3>
<div class="outline-text-3" id="text-12-4">
<p>
QUIC 数据包的有效载荷，在去除数据包保护后，由一系列完整的帧组成，如图 11 所示。版本协商、无状态重置和Retry数据包不包含帧”
</p>

<div class="org-src-container">
<pre class="src src-fundamental">Packet Payload {
  Frame (8..) ...,
}

                       Figure 11: QUIC Payload
</pre>
</div>

<p>
包含帧的数据包的有效载荷必须至少包含一个帧，可以包含多个帧和多种帧类型。端点如果收到不包含帧的数据包，必需将其视为 PROTOCOL_VIOLATION 类型的连接错误。帧总是填充在单个 QUIC 数据包中，不能跨越多个数据包。
</p>

<p>
每一帧都以一个帧类型开始，表明它的类型，紧接着是附加的Type-Dependeng字段：
</p>
<div class="org-src-container">
<pre class="src src-fundamental">Frame {
  Frame Type (i),
  Type-Dependent Fields (..),
}

                   Figure 12: Generic Frame Layout
</pre>
</div>

<p>
表 3 总结了有关本规范中定义的每种帧类型的信息。此摘要的说明包含在表格之后。
</p>
<div class="org-src-container">
<pre class="src src-fundamental">+============+======================+===============+======+======+
| Type Value | Frame Type Name      | Definition    | Pkts | Spec |
+============+======================+===============+======+======+
| 0x00       | PADDING              | Section 19.1  | IH01 | NP   |
+------------+----------------------+---------------+------+------+
| 0x01       | PING                 | Section 19.2  | IH01 |      |
+------------+----------------------+---------------+------+------+
| 0x02-0x03  | ACK                  | Section 19.3  | IH_1 | NC   |
+------------+----------------------+---------------+------+------+
| 0x04       | RESET_STREAM         | Section 19.4  | __01 |      |
+------------+----------------------+---------------+------+------+
| 0x05       | STOP_SENDING         | Section 19.5  | __01 |      |
+------------+----------------------+---------------+------+------+
| 0x06       | CRYPTO               | Section 19.6  | IH_1 |      |
+------------+----------------------+---------------+------+------+
| 0x07       | NEW_TOKEN            | Section 19.7  | ___1 |      |
+------------+----------------------+---------------+------+------+
| 0x08-0x0f  | STREAM               | Section 19.8  | __01 | F    |
+------------+----------------------+---------------+------+------+
| 0x10       | MAX_DATA             | Section 19.9  | __01 |      |
+------------+----------------------+---------------+------+------+
| 0x11       | MAX_STREAM_DATA      | Section 19.10 | __01 |      |
+------------+----------------------+---------------+------+------+
| 0x12-0x13  | MAX_STREAMS          | Section 19.11 | __01 |      |
+------------+----------------------+---------------+------+------+
| 0x14       | DATA_BLOCKED         | Section 19.12 | __01 |      |
+------------+----------------------+---------------+------+------+
| 0x15       | STREAM_DATA_BLOCKED  | Section 19.13 | __01 |      |
+------------+----------------------+---------------+------+------+
| 0x16-0x17  | STREAMS_BLOCKED      | Section 19.14 | __01 |      |
+------------+----------------------+---------------+------+------+
| 0x18       | NEW_CONNECTION_ID    | Section 19.15 | __01 | P    |
+------------+----------------------+---------------+------+------+
| 0x19       | RETIRE_CONNECTION_ID | Section 19.16 | __01 |      |
+------------+----------------------+---------------+------+------+
| 0x1a       | PATH_CHALLENGE       | Section 19.17 | __01 | P    |
+------------+----------------------+---------------+------+------+
| 0x1b       | PATH_RESPONSE        | Section 19.18 | ___1 | P    |
+------------+----------------------+---------------+------+------+
| 0x1c-0x1d  | CONNECTION_CLOSE     | Section 19.19 | ih01 | N    |
+------------+----------------------+---------------+------+------+
| 0x1e       | HANDSHAKE_DONE       | Section 19.20 | ___1 |      |
+------------+----------------------+---------------+------+------+

                        Table 3: Frame Types
</pre>
</div>


<p>
第 19 节更详细地解释了每种帧类型的格式和语义。本节的其余部分提供了重要信息和一般信息的摘要。
</p>

<p>
ACK、STREAM、MAX_STREAMS、STREAMS_BLOCKED、CONNECTION_CLOSE帧中的Frame Type用于携带其他frame-specific的标志。对于所有其他帧，帧类型字段仅标识帧。
</p>

<p>
表3中的“Pkts”列列出了每种帧类型可能出现的数据包类型，由以下字符表示：
</p>

<p>
I:   Initial (Section 17.2.2)
</p>

<p>
H:   Handshake (Section 17.2.4)
</p>

<p>
0:   0-RTT (Section 17.2.3)
</p>

<p>
1:   1-RTT (Section 17.3.1)
</p>

<p>
ih:  只有类型为 0x1c 的CONNECTION_CLOSE帧可以出现在 Initial或者Handshake数据包中。
</p>

<p>
有关这些限制的更多详细信息，请参阅第 12.5 节。注意，所有帧都可以出现在 1-RTT 数据包中。端点如果接收到不允许帧类型的数据包，必需将其视为 PROTOCOL_VIOLATION 类型的连接错误。
</p>

<p>
表 3 中的“Spec”列总结了有关控制帧类型的处理或生成的特殊规则，如以下字符所示：
</p>

<p>
N: 仅包含带有此标记的帧的数据包未得到确认；见第 13.2 节。
</p>

<p>
C: 出于拥塞控制目的，仅包含带有此标记的帧的数据包不计入传输的字节数；见[快速恢复]。
</p>

<p>
P: 仅包含带有此标记的帧的数据包，可用于在连接迁移过程中探测新的网络路径；见第 9.1 节。
</p>

<p>
F: 带有此标记的帧内容受流控限制；见第 4 节。
</p>

<p>
表 3 中的“Pkts”和“Spec”列不构成IANA注册管理机构的一部分；见第 22.4 节。
</p>

<p>
端点如果收到未知类型的帧，必需将其视为 FRAME_ENCODING_ERROR 类型的连接错误。
</p>

<p>
在这个版本的 QUIC 中，所有的帧都是幂等的。也就是说，有效帧在多次接收时不会引起副作用或错误。
</p>

<p>
帧类型字段使用可变长度整数编码（见第 16 节），但有一个例外。为确保在解析帧时的简单高效，帧类型必须使用尽可能短的编码。对于本文档中定义的帧类型，这意味着单字节编码，即使可以将这些值编码为两字节、四字节或八字节的可变长度整数。例如，尽管 0x4001 是一个合法的两字节编码的可变长整数，且值为 1（啥意思，写错了？0x0001？），但 PING 帧始终编码为值为 0x01 的单个字节。此规则适用于所有当前和未来的 QUIC 帧类型。端点接收到的帧类型，其编码长度如果实际所需编码长度长的话，应该将其视为 PROTOCOL_VIOLATION 类型的连接错误。
</p>
</div>
</div>

<div id="outline-container-org8a6a4a1" class="outline-3">
<h3 id="org8a6a4a1"><span class="section-number-3">12.5.</span> 帧和数据包号空间</h3>
<div class="outline-text-3" id="text-12-5">
<p>
某些帧在不同的包号空间中是被禁止的。这里只概括了 TLS 的规则，因为与建立连接相关的帧通常可以出现在任何数据包编号空间中的数据包中，而与传输数据相关的帧只能出现在应用程序数据包编号空间中：
</p>

<ul class="org-ul">
<li>PADDING、PING 和CRYPTO 帧可以出现在任何数据包编号空间中。</li>

<li>用于表示QUIC层错误的（类型为 0x1c）CONNECTION_CLOSE 帧，可能出现在任何数据包编号空间中。 如果是表示应用层错误的 CONNECTION_CLOSE 帧（类型为0x1d），只能出现在应用程序数据包编号空间中。</li>

<li>ACK 帧可以出现在任何数据包编号空间中，但只能确认对应数据包编号空间中的数据包。但是如下所述，0-RTT 数据包不能包含 ACK 帧。</li>

<li>所有其他帧类型，只能在应用程序数据包编号空间中发送。</li>
</ul>

<p>
请注意，由于各种原因，无法在 0-RTT 数据包中发送以下帧：ACK、CRYPTO、HANDSHAKE_DONE、NEW_TOKEN、PATH_RESPONSE 和 RETIRE_CONNECTION_ID。 server如果在 0-RTT 数据包中收到以上帧，必需将其视为 PROTOCOL_VIOLATION 类型的连接错误。
</p>
</div>
</div>
</div>

<div id="outline-container-org78dcce4" class="outline-2">
<h2 id="org78dcce4"><span class="section-number-2">13.</span> 打包及可靠性</h2>
<div class="outline-text-2" id="text-13">
<p>
发送方可以在一个 QUIC 数据包中发送一个或多个帧；见第 12.4 节。
</p>

<p>
发送方可以通过在每个 QUIC 数据包中包含尽可能多的帧来最小化每个数据包的带宽和计算成本。如果发送方要发送的数据包还能够继续打包，则可能会等待一小段时间来收集更多的帧，以避免发送大量小数据包。实现可以使用有关应用程序发送行为或启发式的原则来确定是否等待以及等待多长时间。这个等待期由实现来决定，一个实现应该小心谨慎地确定延迟，因为任何延迟都可能增加可见的应用程序延迟。
</p>

<p>
流复用是通过将来自多个流的 STREAM 帧交织成一个或多个 QUIC 数据包来实现的。单个 QUIC 数据包可以包含来自一个或多个流的多个 STREAM 帧。
</p>

<p>
QUIC 的好处之一是避免跨多个流的队头阻塞。当发生数据包丢失时，只有流的数据在该数据包时才会被阻塞，等待接收重传，而其他流可以继续处理。注意，当多个流的数据包含在单个 QUIC 数据包中时，该数据包如果丢失会，则会阻止所有这些流的处理。建议实现在发送的数据包中包含尽可能少的流，而不会降低未填充数据包的传输效率。
</p>
</div>

<div id="outline-container-org4d07d05" class="outline-3">
<h3 id="org4d07d05"><span class="section-number-3">13.1.</span> 数据包处理</h3>
<div class="outline-text-3" id="text-13-1">
<p>
在成功移除数据包保护并且数据包中包含的所有帧被处理之前，不得确认数据包。对于 STREAM 帧来说，这意味着只要数据已经入队以准备被应用程序协议接收，但不需要等待数据被递送和消费。
</p>

<p>
一旦数据包被完全处理，接收端通过发送一个或多个包含接收数据包编号的 ACK 帧来确认接收。
</p>

<p>
端点如果能够检测到收到确认数据包中包含的包号是其并未发送过的，则应该将其视为 PROTOCOL_VIOLATION 类型的连接错误。有关如何实现这一点的进一步讨论，请参见第 21.4 节。
</p>
</div>
</div>

<div id="outline-container-org2e80701" class="outline-3">
<h3 id="org2e80701"><span class="section-number-3">13.2.</span> 生成确认</h3>
<div class="outline-text-3" id="text-13-2">
<p>
端点需要确认所有的已接收接收和处理的数据包。然而，只有 ack-eliciting 数据包会导致ACK帧在最大 ack 延迟内被发送。对非 ack-eliciting 的数据包的确认，只会发生在ACK 帧由于其他原因被发送时。
</p>

<p>
当端点出于任何原因发送数据包时，如果最近没有发送过ACK帧，则应该尝试在数据包中包含一个 ACK帧。这样做有助于对等端及时检测数据包的丢失。
</p>

<p>
通常，接收端的频繁确认会改善丢失和拥塞响应，但这需要与接收端由于响应每个ack-elicitig数据包而发送ACK帧产生的过度负载相平衡。下面提供的指导旨在实现这种平衡。
</p>
</div>

<div id="outline-container-org7c63dd6" class="outline-4">
<h4 id="org7c63dd6"><span class="section-number-4">13.2.1.</span> 发送ACK帧</h4>
<div class="outline-text-4" id="text-13-2-1">
<p>
每个数据包应该至少被确认一次，并且端点如果使用 max_ack_delay（见第 18.2 节）传输参数协商的最大延迟时，在该延迟内至少需要对ack-elictiong数据包确认一次。 max_ack_delay 声明了一个明确的约定：端点承诺永远不会故意将 ack-eliciting 数据包的确认延迟至超过指定值。否则，RTT 估算都会过度增加，并可能导致来自对等端的虚假或延迟重传。发送方使用接收方的 max_ack_delay 值来确定定时器的重传超时，详见 [QUIC-RECOVERY] 的 6.2 节。
</p>

<p>
端点必须立即确认所有 ack-eliciting 的 Initial 和 Handshake 数据包，对于所有 ack-eliciting 0-RTT 和 1-RTT 数据包，则需要在其通告的 max_ack_delay 进行确认，以下情况除外：在握手确认之前，端点在收到Handshake、0-RTT 或 1-RTT 数据包时，可能没有解密这些数据包的密钥，因此，端点可能会缓冲这些数据包，并在密钥可用时进行确认。
</p>

<p>
由于只包含 ACK 帧的数据包不受拥塞控制，因此端点不得发送多个这样的数据包来响应一个接收到的ack-eliciting数据包。
</p>

<p>
端点绝不能发送一个 non-ack-eliciting 的包来响应一个 non-ack-eliciting 的包，即使在接收到的包之前有包间隙。这可以避免了无限的确认循环。Non-ack-eliciting数据包最终会在当端点发送 ACK 帧以响应其他事件时，被确认。
</p>

<p>
端点如果只发送了 ACK 帧，将不会收到来自其对等方的确认，除非这些ACK帧含在具有ack-eliciting帧的数据包中。当有新的 ack-eliciting 数据包要确认时，端点应该奖ACK 帧和其他帧一起发送。当只有non-ack-eliciting 数据包需要确认时，端点可以选择不发送带有输出帧的 ACK 帧，直到收到 ack-eliciting 数据包。
</p>

<p>
仅发送 non-ack-eliciting 数据包的端点可以选择偶尔向这些数据包添加 ack-eliciting 帧，以确保可以收到确认；见第 13.2.4 节。在这种情况下，端点绝不能在所有数据包中发送 ack-eliciting 帧，以避免无限的确认循环。
</p>

<p>
为了辅助发送方的丢失检测，当端点在以下情况接收到一个 ack-eliciting 数据包时，它应该生成ACK 帧并立即发送：
</p>

<ul class="org-ul">
<li>当接收到的数据包的编号小于另一个收到的已被确认的 ack-eliciting 数据包，或</li>

<li>当数据包的编号大于已接收到的ack-elicting数据包的最高编号，并且这两个数据包之间存在丢失的数据包时。</li>
</ul>

<p>
类似地，在 IP 报头中标有 ECN Congestion Experienced (CE) 代码点的数据包应该立即得到确认，以减少对等端对拥塞事件的响应时间。
</p>

<p>
实现时，如果偏离上述要求，应当仔细考虑变更对与端点建立连接的性能影响，以及对网络其他用户的性能影响。
</p>
</div>
</div>

<div id="outline-container-org8a1fd9f" class="outline-4">
<h4 id="org8a1fd9f"><span class="section-number-4">13.2.2.</span> 确认的频率</h4>
<div class="outline-text-4" id="text-13-2-2">
<p>
由接收方决定响应 ack-eliciting 数据包的确认频率。
</p>

<p>
端点依赖及时的确认来检测丢失；参见 [QUIC-RECOVERY] 的第 6 节。基于窗口的拥塞控制器（例如 [QUIC-RECOVERY] 第 7 节中描述的控制器）依靠确认来管理它们的拥塞窗口。在这两种情况下，延迟确认都会对性能产生不利影响。
</p>

<p>
另一方面，减少仅携带确认的数据包的频率，可以降低两个端点的数据包传输和处理成本。在严重不对称链路上，这可以提高连接吞吐量，并减少确认流量对返回路径容量的占用量；参见 [RFC3449] 的第 3 节。
</p>

<p>
接收者应该在至少收到两个 ack-eliciting 数据包后再发送一个 ACK 帧。该建议本质上是通用的，并且与 TCP 端点行为的建议一致 [RFC5681]。
</p>

<p>
接收端在确定是否发送 ACK 帧作为响应之前，可以处理多个可用数据包。
</p>
</div>
</div>

<div id="outline-container-org8b43eb2" class="outline-4">
<h4 id="org8b43eb2"><span class="section-number-4">13.2.3.</span> 管理ACK的范围</h4>
<div class="outline-text-4" id="text-13-2-3">
<p>
在发送 ACK 帧时，会包含一个或多个范围的确认数据包。包括对旧数据包的确认，以减少了由于先前未发送的 ACK 帧而导致的虚假重传的机会，但代价是更大的 ACK 帧。
</p>

<p>
ACK 帧应该总是确认最近收到的数据包，并且如果数据包的顺序越乱，就越需要快速发送更新的 ACK 帧，以防止对端宣布数据包丢失并虚假地重新传输这些数据包。一个 ACK 帧应该能够填充在单个 QUIC 数据包中，否则，忽略较旧的范围（具有最小数据包编号的范围）。
</p>

<p>
接收端会限制其记录的ACK范围的数量（第 19.3.1 节），以限制 ACK 帧的大小并避免资源耗尽。在收到一个 ACK 帧的确认后，接收者应该停止跟踪已确认的 ACK 范围。发送方可以期待大多数数据包的确认，但 QUIC 不保证能够收到接收端处理的每个数据包的确认。
</p>

<p>
保留太多的 ACK Ranges 可能会导致 ACK 帧变得太大。接收方可以丢弃未确认的 ACK 范围以限制 ACK 帧大小，但代价是发送方的重传次数增加。如果 ACK 帧太大而无法装入数据包，则必需丢弃。接收者还可以进一步限制 ACK 帧的大小，以为其他帧保留空间，或限制ack确认消耗的容量。
</p>

<p>
接收者必须保留一个 ACK 范围，除非它可以确保它随后不会接受具有该范围内数字的数据包。随着范围被丢弃，维护最小值的数据包号，是以最少状态实现这一目标的一种方法。
</p>

<p>
接收者可以丢弃所有的 ACK 范围，但必须保留已成功处理的最大数据包编号，因为它用于从后续数据包中恢复数据包编号；见第 17.1 节。
</p>

<p>
接收方应该包含一个 ACK 范围，该范围包含每个接收的 ACK 帧中最大数据包编号。Largest Acknowledged 字段用于发送方的 ECN 验证，并且如果包含的值比先前 ACK 帧中包含的值低，可能导致 ECN 被禁用；见第 13.4.2 节。
</p>

<p>
第 13.2.4 节描述了用于确定在每个 ACK 帧中确认哪些数据包的示例。尽管该算法的目标是为每个处理的数据包生成一个确认，但仍有可能丢失确认。
</p>
</div>
</div>

<div id="outline-container-orgbc2682e" class="outline-4">
<h4 id="orgbc2682e"><span class="section-number-4">13.2.4.</span> 通过跟踪ACK帧来限制范围</h4>
<div class="outline-text-4" id="text-13-2-4">
<p>
当发送包含 ACK 帧的数据包时，可以保存该帧中的Largest Acknowledged字段，当包含 ACK 帧的数据包被确认时，接收器可以停止确认小于或等于发送的 ACK 帧中的Largest Acknowledged字段的数据包。
</p>

<p>
接收端如果只发送 non-ack-eliciting 数据包（例如 ACK 帧），则可能在很长一段时间内都不会收到确认。这可能会导致接收端长时间保持大量 ACK 帧的状态，并且它发送的 ACK 帧可能会过大。在这种情况下，接收方可以偶尔发送 PING 或其他小的 ack-eliciting 帧，例如每次往返发送一次，以使得对等方发送 ACK。
</p>

<p>
在没有 ACK 帧丢失的情况下，该算法允许最小 1 RTT 的重新排序。在 ACK 帧丢失和重新排序的情况下，this approach does not guarantee that every acknowledgment is seen by the sender before it is no longer included in the ACK frame.  数据包可能会被乱序接收，并且所有后续包含这些数据包的 ACK 帧可能会丢失。在这种情况下，丢失恢复算法可能会导致虚假重传，但发送方将继续向前处理。
</p>
</div>
</div>

<div id="outline-container-org4e4ccb0" class="outline-4">
<h4 id="org4e4ccb0"><span class="section-number-4">13.2.5.</span> 主机延迟的测量和报告</h4>
<div class="outline-text-4" id="text-13-2-5">
<p>
端点会测量从接收到最大数据包编号的数据包到发送确认之间有意引入的延迟。端点将这个延迟 编码在ACK帧的 ACK Delay 字段中；见第 19.3 节。这允许 ACK 帧的接收端可以针对延迟进行调整，这有利于当确认被延迟时，更好的获得路径 RTT 估算。
</p>

<p>
数据包在被处理之前可能会保存在操作系统内核或主机上的其他地方。端点在填充 ACK Delay字段时，禁止包含其无法控制的延迟。然而，端点应该包含由解密密钥不可用引起的缓冲延迟，因为这些延迟可能很大并且很可能是非重复的。
</p>

<p>
当测量的确认延迟大于其 max_ack_delay 时，端点应该报告测量的延迟。当延迟很大时，此信息在握手期间特别有用；见第 13.2.1 节。
</p>
</div>
</div>

<div id="outline-container-orge395b3f" class="outline-4">
<h4 id="orge395b3f"><span class="section-number-4">13.2.6.</span> ACK帧和数据包保护</h4>
<div class="outline-text-4" id="text-13-2-6">
<p>
ACK 帧必须与被确认的数据包具有相同数据包编号空间；见第 12.1 节。例如，使用 1-RTT 密钥保护的数据包必须在同样使用 1-RTT 密钥保护的数据包中进行确认。
</p>

<p>
client使用 0-RTT 数据包保护发送的数据包，必须由server在由 1-RTT 密钥保护的数据包中确认。这可能意味着如果server加密握手消息延迟或丢失时，客户端将无法使用这些确认。注意，同样的限制适用于由 1-RTT 密钥保护的由server发送的其他数据。
</p>
</div>
</div>

<div id="outline-container-org07347af" class="outline-4">
<h4 id="org07347af"><span class="section-number-4">13.2.7.</span> PADDING帧对拥塞窗口的消耗</h4>
<div class="outline-text-4" id="text-13-2-7">
<p>
出于拥塞控制的目的[QUIC-RECOVERY]，包含PADDING帧的数据包被认为是在传输中。因此，仅包含 PADDING 帧的数据包会消耗拥塞窗口，但不会生成确认。为避免死锁，发送方应确保定期发送除 PADDING 帧之外的其他帧，使得能够引起接收方的确认。
</p>
</div>
</div>

<div id="outline-container-org91c17e7" class="outline-4">
<h4 id="org91c17e7"><span class="section-number-4">13.2.8.</span> 重传消息</h4>
<div class="outline-text-4" id="text-13-2-8">
<p>
已经确定丢失的 QUIC 数据包不会全部重传。这同样适用于包含在丢失数据包中的帧。相反，会根据需要在新的帧中携带这些消息再次发送。
</p>

<p>
新的帧和数据包用于携带确定已丢失的消息。通常，当确定包含该信息的数据包丢失时，会再次发送信息，当包含该信息的数据包被确认时停止发送。
</p>

<ul class="org-ul">
<li>在 CRYPTO 帧中发送的数据根据 [QUIC-RECOVERY] 中的规则重传，直到所有数据都得到确认。当相应数据包编号空间的密钥被丢弃时，Handshake和Initial数据包的 CRYPTO 帧中的数据将被丢弃。</li>

<li>在 STREAM 帧中发送的应用程序数据将在新的 STREAM 帧中重新传输，除非端点已为该流发送了 RESET_STREAM。端点一旦发送 RESET_STREAM 帧，就不再需要其他 STREAM 帧。</li>

<li>ACK 帧携带最新的确认集合和来自最大确认包的确认延迟，如第 13.2.1 节所述。延迟传输带有 ACK 帧的数据包或重新发送的旧 ACK 帧，可能会导致对等方生成夸张的 RTT 样本，或者对等端不必要地禁用 ECN。</li>

<li>取消流传输时，例如发送RESET_STREAM 帧，需要直到该帧被确认或者直到对等方对所有流数据进行确认（即，发送部分进入“Reset Recvd”或“Data Recvd”状态）才能停止发送。 再次发送 RESET_STREAM 帧时，其内容不得更改。</li>

<li>同样，当使用 STOP_SENDING 帧请求取消流传输时，直到流的接收部分进入“Data Recvd”或“Reset Recvd”状态后才能停止发送；见第 3.5 节。</li>

<li>连接关闭信号，包括包含 CONNECTION_CLOSE 帧的数据包，在检测到数据包丢失时不会再次发送。重新发送这些信号在第 10 节中描述。</li>

<li>current connection maximum data在 MAX_DATA 帧中发送。如果包含最近发送的 MAX_DATA 帧的数据包丢失，或当端点决定更新限制时，则在 MAX_DATA 帧中发送更新的值。避免过于频繁地发送此帧，因为限制可能会频繁增加，这会导致发送大量不必要的MAX_DATA 帧；见第 4.2 节。</li>

<li>The current maximum stream data offset在 MAX_STREAM_DATA 帧中发送。与 MAX_DATA 一样，当包含 MAX_STREAM_DATA 帧的数据包丢失或更新限制时，将发送更新的值，注意防止帧发送过于频繁。当流的接收部分进入“Size Know”或“Reset Recvd”状态时，端点应该停止发送 MAX_STREAM_DATA 帧。</li>

<li>The limit on streams of a given type 在 MAX_STREAMS 帧中发送。与 MAX_DATA 一样，当包含流类型帧的最新 MAX_STREAMS 的数据包被声明丢失或限制更新时，将发送更新的值，注意防止帧发送过于频繁。</li>

<li>Blocked signals 在 DATA_BLOCKED、STREAM_DATA_BLOCKED 和 STREAMS_BLOCKED 帧中携带。 DATA_BLOCKED 帧用于连接，STREAM_DATA_BLOCKED 帧用于stream，而 STREAMS_BLOCKED 帧的范围限定为特定的stream类型。如果包含这类帧的数据包丢失，则发送新帧，但仅当端点在相应限制上被阻塞时才发送。这些帧中总是会包含阻塞这些帧传输的限制。</li>

<li>定期发送用于检查存活或者路径验证的 PATH_CHALLENGE 帧，直到接收到匹配的 PATH_RESPONSE 帧或直到不再需要存活检查或路径验证检查。 PATH_CHALLENGE 帧每次发送时都包含不同的有效载荷。</li>

<li>对于用来进行路径验证的 PATH_RESPONSE 帧，对该帧的响应仅发送一次。对等方应根据需要发送更多 PATH_CHALLENGE 帧以唤起额外的 PATH_RESPONSE 帧。</li>

<li>新的Connection ID 在 NEW_CONNECTION_ID 帧中发送，如果包含它们的数据包丢失，则重新传输。该帧的重传携带相同的序列号值。同样，停用的Connection ID 在 RETIRE_CONNECTION_ID 帧中发送，如果包含它们的数据包丢失，则重新传输。</li>

<li>包含NEW_TOKEN 帧的数据包丢失时重传。检测重新排序和重复的 NEW_TOKEN 帧，只能直接比较帧内容，没有其他特别的方式。</li>

<li>PING 和 PADDING 帧不包含任何信息，因此丢失的 PING 或 PADDING 帧不需要修复。</li>

<li>HANDSHAKE_DONE 帧必须被重传，直到它被确认。</li>
</ul>

<p>
端点应该优先重传数据而不是发送新数据，除非应用程序特殊指定了优先级；见第 2.3 节。
</p>

<p>
尽管鼓励发送方在每次发送数据包时组装包含最新信息的帧，但不禁止重传丢失数据包的帧的副本。由于数据包编号长度、Connection ID 长度和路径 MTU 的变化，重传帧副本可以使得处理负载大大减少。接收者必须接受包含过时帧的数据包，例如 MAX_DATA 帧携带的maxium data小于旧数据包中的值。
</p>

<p>
一旦数据包被确认，发送方应该避免重传这些数据包。这包括在声明丢失后又被确认的数据包，在网络重新排序的情况下会有这种情况。这样做要求发送方在声明丢失后，保留有关数据包的信息。发送端可以一段时间（允许重新排序的时间）之后，再丢弃此信息，例如 PTO（[QUIC-RECOVERY] 的第 6.2 节），或基于其他事件来丢弃该信息，例如达到内存限制。
</p>

<p>
在检测到丢失时，发送方必须采取适当的拥塞控制措施。丢失检测和拥塞控制的细节在 [QUIC-RECOVERY] 中有描述。
</p>
</div>
</div>
</div>

<div id="outline-container-orgbd123b7" class="outline-3">
<h3 id="orgbd123b7"><span class="section-number-3">13.3.</span> 显示的拥塞通知</h3>
<div class="outline-text-3" id="text-13-3">
<p>
QUIC 端点可以使用 ECN [RFC3168] 来检测和响应网络拥塞。 ECN 允许端点在 IP 数据包的 ECN 字段中设置支持 ECN-Capable Transport (ECT) codepoint。然后，网络节点可以通过在 ECN 字段中设置 ECN-CE codepoint而不是丢弃数据包来指示拥塞 [RFC8087]。如 [QUIC-RECOVERY] 中所述，端点通过降低其响应的发送速率来报告拥塞。
</p>

<p>
要启用 ECN， QUIC 端点的发送端首先需要确定路径是否支持 ECN 标记，以及对端是否报告接收到的 IP 标头中的 ECN 值；见第 13.4.2 节。
</p>
</div>

<div id="outline-container-org07b2787" class="outline-4">
<h4 id="org07b2787"><span class="section-number-4">13.3.1.</span> ECN计数的上报</h4>
<div class="outline-text-4" id="text-13-3-1">
<p>
ECN 的使用要求接收端点从 IP 数据包中读取 ECN 字段，这不可能所有平台上实现。如果端点没有实现 ECN 支持或无权访问接收到的 ECN 字段，它不会报告它接收到的数据包的 ECN 计数。
</p>

<p>
如果端点可以可访问ECN标记，即使端点没有在它发送的数据包中设置 ECT 字段，端点也必须提供有关它收到的 ECN 标记的反馈。未能报告 ECN 计数将导致发送方禁止此连接使用 ECN。
</p>

<p>
端点在接收带有 ECT(0)、ECT(1) 或 ECN-CE codepoint的 IP 数据包时，如果启用了 ECN ，需要增加相应的 ECT(0)、ECT(1) 或 ECN-CE 计数。这些 ECN 计数包含在后续的 ACK 帧中；见第 13.2 和 19.3 节。
</p>

<p>
每个数据包编号空间都会维护单独的确认状态和单独的ECN 计数。合并的 QUIC 数据包（参见第 12.2 节）共享相同的 IP 标头，因此对于每个合并的 QUIC 数据包的ECN 计数增加一次。
</p>

<p>
例如，如果 Initial、Handshake 和 1-RTT QUIC 数据包合并为单个 UDP 数据报，则所有三个数据包编号空间的 ECN 计数将根据单个数据包IP报头的 ECN 字段递增 1。
</p>

<p>
ECN 计数仅在来自ip数据包的QUIC数据包被处理时增加。因此，不会处理重复的QUIC 数据包，也不会增加 ECN 计数；有关相关安全问题，请参阅第 21.10 节。
</p>
</div>
</div>

<div id="outline-container-org9aaa906" class="outline-4">
<h4 id="org9aaa906"><span class="section-number-4">13.3.2.</span> ECN验证</h4>
<div class="outline-text-4" id="text-13-3-2">
<p>
有故障的网络设备可能会错误地丢弃携带非零 ECN codepoint 的数据包。当存在此类设备时，为了确保连接性，端点验证每个网络路径的 ECN 计数，并在检测到错误时禁用该路径上的 ECN。
</p>

<p>
对新路径执行 ECN 验证：
</p>

<ul class="org-ul">
<li>当端点在通过新路径向对等方发送数据包时，会在早期数据包的 IP 标头中设置 ECT(0) codepoint [RFC8311]。</li>

<li>端点监控是否所有使用 ECT codepoint发送的数据包最终都被视为丢失（[QUIC-RECOVERY] 的第 6 节），全部丢失时表明 ECN 验证失败。</li>
</ul>

<p>
如果端点预计带有 ECT codepoint的 IP 数据包可能会被带有故障的网络元素丢弃，则端点可以仅为路径上的前十个传出数据包设置 ECT codepoint，或三个 PTO 时间段内设置 ECT codepoint（参见[QUIC-RECOVERY] 的第 6.2 节）。如果所有标有非零 ECN codepoint的数据包随后丢失，则可以假设标记导致丢失，直接禁用标记。
</p>

<p>
因此，端点在切换到server的首选地址，或者在连接迁移时，可以尝试为每个连接使用 ECN 来验证。附录 A.4 描述了一种可能的算法。
</p>

<p>
也可以使用其他方法来探测路径是否支持 ECN ，不同的标记策略也是如此。实现可以使用 RFC 中定义的其他方法；参见 [RFC8311]。使用 ECT(1) codepoint的实现需要使用报告的 ECT(1) 计数来执行 ECN 验证。
</p>
</div>

<div id="outline-container-org4fb6fdc" class="outline-5">
<h5 id="org4fb6fdc"><span class="section-number-5">13.3.2.1.</span> 接收带有ECN计数的ACK帧</h5>
<div class="outline-text-5" id="text-13-3-2-1">
<p>
网络错误应用 ECN-CE 标记会导致连接性能下降。因此，端点接收带有 ECN 计数的 ACK 帧后，会在使用计数之前验证这些计数。它通过将新接收的计数与上次成功处理的 ACK 帧的计数进行比较来执行此验证。 ECN 计数的增加，都依据被最新的ACK帧确认的数据包的ECN 标记进行验证。
</p>

<p>
如果 ACK 帧新确认了端点发送的带有 ECT(0) 或 ECT(1) codepoint的数据包，但是相应的 ECN 计数不存在于 ACK 帧中，则 ECN 验证失败。此检查可以检测将 ECN 字段置零的网络元素，或不报告 ECN 标记的对等体。
</p>

<p>
如果 ECT(0) 和 ECN-CE 计数增加的总和小于新确认的最初使用 ECT(0) 标记发送的数据包的数量，则 ECN 验证也会失败。类似地，如果 ECT(1) 和 ECN-CE 计数增加的总和小于新确认的使用 ECT(1) 标记发送的数据包的数量，则 ECN 验证失败。这些检查可以检测网络对 ECN-CE 标记的重新标记。
</p>

<p>
当 ACK 帧丢失时，端点可能会丢失对数据包的确认。因此，ECT(0)、ECT(1) 和 ECN-CE 计数的总增加可能大于 ACK 帧新确认的数据包数量。这就是为什么允许 ECN 计数大于已确认的数据包总数的原因。
</p>

<p>
验证重新排序的 ACK 帧的 ECN 计数，可能会导致失败。端点处理ACK帧时，不得因为ACK帧未增加最大确认包号，而导致 ECN 验证失败。
</p>

<p>
如果 ECT(0) 或 ECT(1) 的接收总数超过发送的对应 ECT codepoint 数据包总数，则 ECN 验证可能会失败。特别是，当端点收到非零 ECN 计数，但是从未发送过对应的 ECT codepoint 数据包，验证将失败。此检查可以检测何时将网络中的数据包重新标记为 ECT(0) 或 ECT(1)。
</p>
</div>
</div>

<div id="outline-container-org95edc40" class="outline-5">
<h5 id="org95edc40"><span class="section-number-5">13.3.2.2.</span> ECN验证结果</h5>
<div class="outline-text-5" id="text-13-3-2-2">
<p>
如果验证失败，则端点必须禁用 ECN。它停止在它发送的 IP 数据包中设置 ECT codepoint，并假设网络路径或对等方不支持 ECN。
</p>

<p>
即使验证失败，端点可以稍后再次在连接中重新验证相同路径的 ECN。端点可以继续定期尝试验证。
</p>

<p>
成功验证后，端点可以继续在它发送的后续数据包中设置 ECT codepoint，并期望该路径具有 ECN 能力。在连接中，网络路由和路径元素可能发生改变；如果稍后验证失败，端点必须禁用 ECN。
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd5fef71" class="outline-2">
<h2 id="orgd5fef71"><span class="section-number-2">14.</span> 数据报大小</h2>
<div class="outline-text-2" id="text-14">
</div>
<div id="outline-container-org28cf0a9" class="outline-3">
<h3 id="org28cf0a9"><span class="section-number-3">14.1.</span> 初始数据报大小</h3>
<div class="outline-text-3" id="text-14-1">
<div class="org-src-container">
<pre class="src src-fundamental">
</pre>
</div>

<div class="org-src-container">
<pre class="src src-fundamental">
</pre>
</div>

<div class="org-src-container">
<pre class="src src-fundamental">
</pre>
</div>

<div class="org-src-container">
<pre class="src src-fundamental">
</pre>
</div>

<div class="org-src-container">
<pre class="src src-fundamental">
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:55</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
