<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org3668c4e">1. 早期的QUIC加密定义</a>
<ul>
<li><a href="#orgf30a0f4">1.1. 概括</a></li>
<li><a href="#orgf14d698">1.2. 源地址欺骗</a></li>
<li><a href="#org7677172">1.3. 重放保护</a></li>
<li><a href="#org6af0fff">1.4. 握手成本</a></li>
<li><a href="#orgb5e5477">1.5. 有线协议</a></li>
<li><a href="#orgec1efe8">1.6. 客户端握手。</a></li>
<li><a href="#orge119dae">1.7. 密钥推导</a></li>
<li><a href="#org2c78ba5">1.8. 客户端加密标签值</a></li>
<li><a href="#org93149ba">1.9. 证书压缩</a></li>
</ul>
</li>
<li><a href="#org5086122">2. 新标准</a></li>
</ul>
</div>
</div>
<p>
QUIC 加密
</p>

<p>
亚当兰利 &lt;agl@google.com&gt;
Wan-Teh Chang &lt;wtc@google.com&gt;
（修订 20161206。）
</p>

<p>
（注意：这个文件在这一点上已经很老了。QUIC 现在是一个 IETF 规范，它的加密握手现在基于 TLS 1.3 而不是这个工作。因此这个文件只是历史意义。）
</p>

<p>
概括
源地址欺骗
重放保护
握手成本
有线协议
客户端握手。
密钥推导
客户端加密标签值
证书压缩
未来发展方向
致谢
</p>

<div id="outline-container-org3668c4e" class="outline-2">
<h2 id="org3668c4e"><span class="section-number-2">1.</span> 早期的QUIC加密定义</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgf30a0f4" class="outline-3">
<h3 id="orgf30a0f4"><span class="section-number-3">1.1.</span> 概括</h3>
<div class="outline-text-3" id="text-1-1">
<p>
QUIC 加密协议是 QUIC 的一部分，为连接提供传输安全性。QUIC 加密协议注定要消亡。将来它会被 TLS 1.3 取代，但在 TLS 1.3 开始之前，QUIC 需要一个加密协议。
</p>

<p>
使用当前的 QUIC 加密协议，当客户端缓存了有关服务器的信息时，它可以建立没有往返的加密连接。相比之下，TLS 至少需要两次往返（计算 TCP 3 次握手）。QUIC 握手的效率应该是普通 TLS 握手（2048 位 RSA）的 5 倍，并且具有更高的安全级别。
</p>
</div>
</div>

<div id="outline-container-orgf14d698" class="outline-3">
<h3 id="orgf14d698"><span class="section-number-3">1.2.</span> 源地址欺骗</h3>
<div class="outline-text-3" id="text-1-2">
<p>
互联网上很少有协议在没有至少一次初始化往返的情况下工作。由于 TCP 和基于 TLS 的协议在应用程序数据可以流动之前至少还有一个往返，因此大多数协议都有一个往返。
</p>

<p>
这两个往返都交换随机数：TCP 中的序列号（或 SYN cookie）和 TLS 中的加密随机值（client_random 和 server_random）。TCP nonce 防止 IP 地址欺骗，TLS nonce 防止重放攻击。任何试图消除往返的协议都必须以某种方式解决这两个问题。
</p>

<p>
作为一个反例，DNS 是一个没有任何初始化往返的协议，因此它必须自己处理 IP 地址欺骗和重放攻击。DNS 只是忽略 IP 地址欺骗，因此镜像 DDoS 攻击是一个真正的问题。对于重放保护，DNSSEC 依赖于时钟同步和短期签名。这允许按设计在有限的时间内重播，因为这与 DNS 的缓存语义相吻合。但这不是一种严格的重放保护形式，因为允许重放。
</p>

<p>
在 QUIC 中，我们分别处理这两个问题。
</p>

<p>
IP 地址欺骗问题是通过根据需要向客户端发出“源地址令牌”来处理的。从客户端的角度来看，这是一个不透明的字节字符串。从服务器的角度来看，它是一个经过身份验证的加密块（例如 AES-GCM），其中至少包含客户端的 IP 地址和服务器的时间戳。服务器只会将给定 IP 的源地址令牌发送到该 IP。客户端收到令牌被视为 IP 地址所有权的证明，就像收到 TCP 序列号一样。
</p>

<p>
客户端可以在未来的请求中包含源地址令牌，以证明其源 IP 地址的所有权。如果客户端移动了 IP 地址，令牌太旧，或者客户端没有令牌，那么服务器可能会拒绝连接并向客户端返回一个新的令牌。但是如果客户端保持在相同的 IP 地址上，那么它可以重用源地址令牌以避免获得新的往返所需的往返。
</p>

<p>
令牌的生命周期是服务器的事情，但由于源地址令牌是不记名令牌，它们可以被窃取和重复使用以绕过基于 IP 地址的限制。（尽管攻击者不会收到响应。）源地址令牌也可以在 IP 地址的所有权更改后（即在 DHCP 池中）收集并可能使用。减少令牌的生命周期以减少无需额外往返即可处理的请求数量为代价来改善这两个问题。
</p>

<p>
源地址令牌与 TCP 序列号的交换不同，它不需要源展示接收发送到源 IP 地址的数据包的连续能力。这允许使用源地址令牌连续从服务器请求流量，即使下游链路已经饱和并且丢弃率足够高以至于无法建立 TCP 连接。这种“自我 DOS”攻击可用于对同一下游链接上的其他用户进行 DOS 攻击。
</p>

<p>
但是，我们注意到 TCP 实际上也可以使用类似的技巧，因此 QUIC 不会在这方面使事情明显变得更糟。事实上，一旦建立连接，QUIC 会在数据包中包含一个熵位，并要求接收者发送他们声称已收到的熵的散列 - 从而解决了 TCP 的问题。
</p>

<p>
为了最小化延迟，服务器可以决定动态地放宽源地址限制。可以想象一台服务器跟踪来自不同 IP 地址的请求数量，并且仅在“单向”连接数超过全局限制或特定 IP 范围时才需要源地址令牌。这可能很有效，但尚不清楚这是否全局稳定。如果大量 QUIC 服务器实施了此策略，那么大量的镜像 DDoS 攻击可能会分散到它们之间，这样任何一台服务器都不会达到攻击阈值。
</p>
</div>
</div>


<div id="outline-container-org7677172" class="outline-3">
<h3 id="org7677172"><span class="section-number-3">1.3.</span> 重放保护</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在 TLS 中，每一方都会生成一个随机数，用于通过强制他们在密钥派生中包含（假设在所有时间都是唯一的）值来确保另一方是新鲜的。如果没有往返，客户端仍然可以包含一个随机数，从而确保服务器是最新的，但服务器没有机会为客户端这样做。
</p>

<p>
在没有服务器输入的情况下提供重放保护从根本上来说是非常昂贵的。它需要在服务器上保持一致的状态。虽然如果服务器是一台机器这是合理的，但现代网站遍布世界各地。
</p>

<p>
因此，QUIC 不会在服务器第一次回复之前为客户端的数据提供重放保护。如果攻击者重放任何此类信息，则由应用程序来确保任何此类信息都是安全的。例如，在 Chrome 中，只有在握手确认之前发送 GET 请求。
</p>
</div>
</div>

<div id="outline-container-org6af0fff" class="outline-3">
<h3 id="org6af0fff"><span class="section-number-3">1.4.</span> 握手成本</h3>
<div class="outline-text-3" id="text-1-4">
<p>
在 TLS 中，服务器根据客户端对它们的广告支持为每个连接选择连接参数。在 QUIC 中，服务器的首选项是完全枚举和静态的。它们与 Diffie-Hellman 公共值一起捆绑到“服务器配置”中。此服务器配置已过期，并由服务器的私钥签名。由于服务器配置是静态的，因此不需要对每个连接进行签名操作，多个连接只需一个签名即可。
</p>

<p>
连接的密钥使用 Diffie-Hellman 达成一致。服务器的 Diffie-Hellman 值可在服务器配置中找到，客户端在其第一个握手消息中提供一个。由于服务器配置必须保留一段时间才能允许 0-RTT 握手，因此这为连接的前向安全性设置了上限。只要服务器保留服务器配置的 Diffie-Hellman 秘密，使用该服务器配置加密的数据如果泄露就可能被解密。
</p>

<p>
因此，QUIC 提供了两个级别的保密：来自客户端的初始数据使用服务器服务器配置中的 Diffie-Hellman 值进行加密，这可能会持续数天。收到连接后，服务器立即回复一个临时的 Diffie-Hellman 值，并重新设置连接的密钥。
</p>

<p>
（这可能看起来比前向安全 TLS 连接提供的前向安全性更低。但是，为了避免往返，通常在大型部署中启用 TLS SessionTickets。SessionTicket 密钥足以解密连接，但为了使恢复有效，它必须保留一段合理的时间——通常是几天。因此 SessionTicket 密钥和服务器配置密钥是类似的，实际上 QUIC 的有效安全性更高，因为它的前向安全模式更好。）
</p>

<p>
单个连接是前向安全的通常范围，但用于单个连接的临时密钥与用于所有连接 60 秒的临时密钥之间的安全差异可以忽略不计。因此，我们可以在很短的时间内通过所有连接在服务器上分摊 Diffie-Hellman 密钥生成。
</p>

<p>
（因为服务器配置和 Diffie-Hellman 私有值是服务器处理 QUIC 连接所需的全部内容，所以证书的私钥永远不需要放在服务器上。相反，可以通过以下方式实现一种短期证书形式签署短期服务器配置并仅在服务器上安装那些配置。）
</p>

<p>
如果我们让 S 是一个秘密密钥操作（即 RSA 解密），P 是一个公钥操作（即 RSA 加密），F 是一个 Diffie-Hellman，不动点，标量乘法，A 是一个任意点，标量乘法，那么：
</p>

<ol class="org-ol">
<li>TLS，非前向安全握手：服务器，1S（1100μs）；客户端，1P（34µs）。</li>
<li>TLS，前向安全握手：服务器，1S + 1F + 1A (1301µs)；客户端，1P + 1F + 1A (235µs)。</li>
<li>QUIC：服务器，2A（100μs）；客户端，1F + 2A + 1P (184µs)。</li>
</ol>

<p>
（不包括客户端验证证书链所需的操作。）
</p>

<p>
如果我们为每一个选择通用原语（RSA 2048 用于公共和私有操作，ECDH P-256 用于 TLS 前向安全性，Curve25519 用于 QUIC），那么我们将在 i7-3770S 上获得括号中的示例时间。如果 QUIC 使用 P-256，那么服务器时间将是 300 微秒，客户端将是 385 微秒，因此相当多的收益来自使用更好的原语。
</p>

<p>
TLS 会话恢复率在野外大约为 50%，但 QUIC 没有明确包括会话恢复。但是，通过让客户端和服务器维护 Diffie-Hellman 结果的缓存，它可以在没有任何协议支持的情况下实现恢复的许多好处。这个可选的缓存消除了与同一服务器多次握手的计算负担，只要客户端没有轮换其临时密钥。如果我们假设 TLS 的恢复率为 50%，并假设 QUIC 缓存不执行任何操作，那么我们将获得与介绍中提到的 TLS 相关的大约 5 倍的加速。
</p>
</div>
</div>


<div id="outline-container-orgb5e5477" class="outline-3">
<h3 id="orgb5e5477"><span class="section-number-3">1.5.</span> 有线协议</h3>
<div class="outline-text-3" id="text-1-5">
<p>
QUIC 是一种数据报协议，一旦建立了密钥，每个数据报（UDP 层以上）的完整有效载荷都会被验证和加密。底层数据报协议为加密层提供了发送可靠的、任意大小的消息的方法。这些消息具有统一的键值格式。
</p>

<p>
密钥是 32 位标签。这试图在魔术数字注册表的专制和字符串的冗长之间提供平衡。就有线协议而言，这些是不透明的 32 位值，在本文档中，标签通常会像 EXMP 一样编写。虽然它被写成一个字符串，但它只是值 0x504d5845 的助记符。那个值，在小端，是 ASCII 字符串 EXM P。
</p>

<p>
如果一个标签是用 ASCII 写的，但少于四个字符，那么剩下的字符就好像是 NUL 一样。所以EXP对应于0x505845。
</p>

<p>
如果标签值包含超出 ASCII 范围的字节，它们将以十六进制写入，例如 504d5845。
</p>

<p>
除非另有说明，否则所有值都是小端的。
</p>

<p>
握手消息包括：
</p>
<ol class="org-ol">
<li>消息的标签。</li>
<li>包含标记值对数量的 uint16。</li>
<li>两个字节的填充，发送时应为零，但在接收时应忽略。</li>
<li>一系列 uint32 标记和 uint32 结束偏移，每个标记值对一个。标签必须严格单调递增，并且结束偏移量必须是单调非递减的。结束偏移量给出了从值数据的开始到该标签数据结束后一个字节的偏移量。（因此最后一个标签的结束偏移量包含值数据的长度）。</li>
<li>值数据，无填充连接。</li>
</ol>

<p>
标签值格式允许在仅验证一小部分数据后对标签进行有效的二进制搜索。标签严格单调的要求也消除了重复标签周围的任何歧义。
</p>

<p>
尽管 32 位长度目前已超出需要，但 16 位长度存在不足以处理更大的后量子值的风险。
</p>

<p>
任何消息都可能包含填充 (PAD) 标记。这些可用于破坏流量分析。此外，我们可以为客户端 hello 定义全局最小大小以限制放大攻击。小于最小值的客户端 hello 需要一个 PAD 标签来弥补差异。
</p>
</div>
</div>


<div id="outline-container-orgec1efe8" class="outline-3">
<h3 id="orgec1efe8"><span class="section-number-3">1.6.</span> 客户端握手。</h3>
<div class="outline-text-3" id="text-1-6">
<p>
客户端握手的流程如图1所示。 从概念上讲，QUIC中的所有握手都是0-RTT，只是其中一些失败需要重试。
</p>


<p>
<a href="./image/quic-crypto/client-handshake-flow.png">client握手流程图</a>
图 1. 客户端握手流程。
</p>

<p>
为了执行 0-RTT 握手，客户端需要有一个已被验证为真实的服务器配置。最初我们假设客户端对服务器一无所知，因此，在尝试握手之前，客户端将发送“初始”客户端 hello 消息以从服务器获取服务器配置和真实性证明。在客户端收到它需要的所有信息之前，可能会有几轮早期的客户端 hello，因为服务器可能不愿意向未经验证的 IP 地址发送大量的真实性证明。
</p>

<p>
客户端问候消息具有消息标记 CHLO，并且在其早期形式中包含以下标记/值对：
</p>

<p>
<b>SNI</b>         Server Name Indication （可选）：服务器的完全限定 DNS 名称，规范化为小写，没有尾随句点。国际化域名需要编码为 RFC 5890 中定义的 A 标签。SNI 标签的值不能是 IP 地址文字。
</p>

<p>
<b>STK</b>         Source-address token （可选）：服务器先前提供的源地址令牌（如果有）。
</p>

<p>
<b>PDMD</b>        Proof demand：按优先顺序描述客户可接受的证明类型的标签列表。目前只定义了 X509。
</p>

<p>
<b>CCS</b>         Common certificate sets（可选）：客户端拥有的一系列 64 位、FNV-1a 散列的通用证书集。（请参阅有关证书压缩的部分。）
</p>

<p>
<b>CCRT</b>        Cached certificates （可选）：缓存证书的一系列 64 位 FNV-1a 哈希值。（请参阅有关证书压缩的部分。）
</p>

<p>
<b>VER</b>         Version：一个单一的标签，它反映了客户端在第一次数据传输中的每个 QUIC 数据包中通告的协议版本。如果发生版本协商，则该字段设置为客户端使用的第一个版本。如果报文中的版本与标签中的版本不相等，则服务器需要验证服务器不支持标签中的版本，以防御降级攻击。
</p>

<p>
<b>XLCT</b>        客户端希望服务器使用的叶证书的 64 位 FNV-1a 哈希值。证书的全部内容将被添加到HKDF中。如果存在缓存的证书，则第一个此类条目应与该字段的值相同。
</p>


<p>
（QUIC 的其他部分可能会定义要包含在客户端和服务器 hello 中的附加标签。例如，流的最大数量、拥塞控制参数等。但是，这些标签在本规范中没有定义。）
</p>

<p>
作为对客户端 hello 的响应，服务器将发送拒绝消息或服务器 hello。服务器 hello 表示握手成功，并且永远不会由早期的客户端 hello 产生，因为它不包含足够的信息来执行握手。拒绝消息包含客户端可以用来随后执行更好的握手尝试的信息。
</p>

<p>
拒绝消息具有标签 <b>REJ</b> 并包含以下标签/值对：
</p>

<p>
<b>SCFG</b>        Server config（可选）：包含服务器序列化配置的消息。（如下面所描述的。）
<b>STK</b>         Source-address token（可选）：客户端应该在未来的客户端 hello 消息中回显的不透明字节字符串。
<b>SNO</b>         Server nonce（可选）：服务器可以设置一个随机数，客户端应该在任何未来（完整）客户端 hello 消息中回显。这允许服务器在没有罢工寄存器的情况下运行，并允许具有时钟偏差的客户端进行连接。
<b>STTL</b>        服务器配置有效的持续时间（以秒为单位）。
<b>ff545243</b>    Certificate chain （可选）：服务器的证书链。（请参阅有关证书压缩的部分。）
<b>PROF</b>        Proof of authenticity （可选）：在 X.509 的情况下，通过叶证书中的公钥对服务器配置进行签名。签名的格式目前由公钥的类型固定：
                RSA: RSA-PSS-SHA256
                ECDSA: ECDSA-SHA256
</p>

<p>
签名计算如下：
</p>
<ol class="org-ol">
<li>标签“QUIC server config signature”</li>
<li>下一个字段中散列的 32 位长度（以字节为单位）（即 8）。</li>
<li>CHLO 的 SHA256 哈希值</li>
<li>一个 0x00 字节</li>
<li>序列化的服务器配置。</li>
</ol>


<p>
尽管拒绝消息的所有元素都是可选的，但服务器必须允许客户端取得进展。例如，如果客户端没有提供源地址令牌并且服务器不愿意将服务器配置发送到未经验证的 IP 地址，则服务器必须回复源地址令牌，以便客户端的下一次握手尝试更成功。
</p>

<p>
某些标签以十六进制而不是 ASCII 表示法指定。这是因为标签的形成使得它们要么出现在消息的开头，要么出现在消息的结尾。回想一下，作为数字的标签是以小端顺序写在电线上的。
</p>

<p>
包含熵的标签被移动到消息的开头，因为服务器可能不会维护状态，因此可能会处理重复的客户端 hello 两次。如果数据包丢失命中拒绝消息并且熵字段跨越数据包边界，则客户端可能会错误组装它们。
</p>

<p>
Large tags（到目前为止的证书链）被移到消息的末尾，这样它们就不会延迟其他可能足够的字段的接收。
</p>

<p>
服务器配置包含服务器的序列化首选项，并采用带有标签 <b>SCFG</b> 的握手消息的形式。它包含以下标签/值对：
</p>

<p>
<b>SCID</b>        Server Config ID：此服务器配置的不透明 16 字节标识符。
</p>

<p>
<b>KEXS</b>        Key exchange algorithms：标签列表，按优先顺序，指定服务器支持的密钥交换算法。定义了以下标签：
                C255: Curve25519
                P256: P-256
</p>

<p>
<b>AEAD</b>        Authenticated encryption algorithms：标签列表，按优先顺序，指定服务器支持的 AEAD 原语。定义了以下标签：
                AESG:  带有 12 字节标签和 IV 的 AES-GCM。IV 的前四个字节取自密钥推导，后八个字节是数据包序列号。
                S20P:  Salsa20 和 Poly1305。（暂定，尚未实施。）
</p>

<p>
<b>PUBS</b>        公共值列表，24 位，小端长度前缀，顺序与 KEXS 相同。P-256 公共值（如果有）被编码为 X9.62 格式的未压缩点。
<b>ORBT</b>        Orbit：一个 8 字节的不透明值，用于标识罢工寄存器（残留）。
</p>

<p>
<b>EXPY</b>        Expiry：服务器配置的 64 位到期时间，以 UNIX 纪元秒为单位。
<b>VER</b>         Versions：服务器支持的版本标签列表。底层 QUIC 数据包协议具有版本协商。服务器支持的版本镜像在签名的服务器配置中，以确认没有发生降级攻击。
</p>


<p>
一旦客户端收到服务器配置，并通过验证证书链和签名对其进行身份验证，它就可以通过发送完整的客户端问候来执行不会失败的握手。完整的客户端问候包含与早期客户端问候相同的标签，并添加了其他几个标签：
</p>

<p>
<b>SCID</b>        Server Config ID：客户端正在使用的服务器配置的 ID。
<b>AEAD</b>        Authenticated encryption：要使用的AEAD算法的标签。
<b>KEXS</b>        Key exchange：要使用的密钥交换算法的标签。
<b>NONC</b>        Client nonce：32 字节，包括 4 字节的时间戳（大端，UNIX 纪元秒）、8 字节的服务器轨道和 20 字节的随机数据。
<b>SNO</b>         Server nonce（可选）：如果服务器提供了一个回显的服务器随机数。
<b>PUBS</b>        Public value：客户端对给定密钥交换算法的公共价值。
<b>CETV</b>        Client encrypted tag-values（可选）：序列化消息，使用client hello中指定的 AEAD 算法加密，并使用以下 CETV 部分中指定的方式派生的密钥。此消息将包含更多的加密标签值对，用于指定客户端证书、ChannelID 等。
</p>


<p>
在发送完整的客户端 hello 后，客户端拥有连接的非前向安全密钥，因为它可以从服务器配置和 <b>PUBS</b> 中的公共值计算共享值。（有关密钥派生的详细信息，请参见下文。）这些密钥称为初始密钥（与稍后出现的前向安全密钥相对），客户端应使用这些密钥对未来的数据包进行加密。一旦收到加密数据包，就不再接受未加密的数据包。
</p>

<p>
此时，客户端可以自由地开始向服务器发送应用程序数据。事实上，如果它希望实现 0-RTT，那么它必须在等待服务器的回复之前开始发送。
</p>

<p>
数据的重传发生在握手层以下的一层，但是该层仍然必须知道加密的变化。新数据包必须使用初始密钥传输，但是，如果客户端 hello 需要重新传输，则必须以明文方式重新传输。数据包发送层必须知道最初使用哪个安全级别来发送任何给定的数据包，并注意不要使用更高的安全级别，除非对等方已确认拥有这些密钥（即通过使用该安全级别发送数据包）。
</p>

<p>
服务器将接受或拒绝握手。如果服务器拒绝客户端 hello，它将发送一个 REJ 消息，并且所有使用初始密钥传输的数据包都必须被视为丢失并且需要在新的初始密钥下重新传输。因此，当服务器hello或rej未决时，客户端应该限制未完成的数据量。
</p>

<p>
如果握手成功，服务器将返回服务器 hello 消息。该消息具有标签 SHLO，使用初始密钥加密，除了为拒绝消息定义的标签/值对之外，还包含以下标签/值对：
  <b>PUBS</b>        客户端使用的密钥交换算法的临时公共值。
</p>


<p>
有了临时Public value，双方就可以计算出前向安全密钥。（请参阅密钥派生部分。）服务器可以立即切换到发送使用前向安全密钥加密的数据包。客户端必须等待收到服务器hello。（注意：我们正在考虑让服务器等待，直到它收到一个前向安全数据包，然后再发送任何自己的数据。如果服务器 hello 数据包被丢弃，这可以避免停顿。）
</p>
</div>
</div>


<div id="outline-container-orge119dae" class="outline-3">
<h3 id="orge119dae"><span class="section-number-3">1.7.</span> 密钥推导</h3>
<div class="outline-text-3" id="text-1-7">
<p>
密钥材料由基于 HMAC 的密钥派生函数 (HKDF) 和哈希函数 SHA-256 生成。HKDF（在 RFC 5869 中指定）使用在 NIST SP 800-56C 中指定的经批准的两步密钥派生程序。
</p>

<p>
<b>第 1 步：HKDF-Extract</b>
      密钥协议的输出（在 Curve25519 和 P-256 的情况下为 32 字节）是预主密钥，它是 HKDF-Extract 函数的输入密钥材料 (IKM)。盐输入是client nonce，后跟server nonce（如果有）。HKDF-Extract 输出一个伪随机密钥 (PRK)，它是主密钥。如果使用 SHA-256，主密钥长度为 32 个字节。
</p>

<p>
<b>第 2 步：HKDF-Expand</b>
      PRK 输入是主机密。信息输入（上下文和应用程序特定信息）是以下数据的串联：
</p>
<ol class="org-ol">
<li>“QUIC key expansion”标签</li>
<li>一个 0x00 字节</li>
<li>来自数据包层的连接的 GUID。</li>
<li>client hello消息</li>
<li>server config消息</li>
<li>叶证书的DER编码内容</li>
</ol>

<p>
密钥材料按以下顺序分配：
</p>
<ol class="org-ol">
<li>客户端写入密钥。</li>
<li>服务器写入密钥。</li>
<li>客户写IV。</li>
<li>服务器写IV。</li>
</ol>

<p>
如果任何原语需要少于整数字节的密钥材料，则丢弃最后一个字节的剩余部分。
</p>

<p>
当导出forward-secret密钥时，使用相同的输入，除了 info 使用标签“QUIC forward secure key expansion”。
</p>

<p>
当服务器的初始密钥被导出时，它们必须多样化以确保服务器能够向 HKDF 提供熵。
</p>

<p>
<b>第 1 步：HKDF-Extract</b>
      服务器写入密钥加上发现的轮次中的服务器写入 IV 的串联是 HKDF-Extract 函数的输入密钥材料 (IKM)。盐输入是多样化的随机数。HKDF-Extract 输出一个伪随机密钥（PRK），这是多样化的秘密。如果使用 SHA-256，多样化秘密的长度为 32 个字节。
</p>

<p>
<b>第 2 步：HKDF-Expand</b>
      PRK 输入是多样化的秘密。信息输入（上下文和应用程序特定信息）是“QUIC key diversification”标签。
</p>

<p>
密钥材料按以下顺序分配：
</p>
<ol class="org-ol">
<li>服务器写入密钥。</li>
<li>服务器写IV。</li>
</ol>
</div>
</div>




<div id="outline-container-org2c78ba5" class="outline-3">
<h3 id="org2c78ba5"><span class="section-number-3">1.8.</span> 客户端加密标签值</h3>
<div class="outline-text-3" id="text-1-8">
<p>
客户端问候可能包含 CETV 标记，以便在客户端问候中指定客户端证书、ChannelID 和其他非公开数据。（这与 TLS 形成对比，后者以明文形式发送客户端证书。）
</p>

<p>
CETV 消息使用客户端问候中指定的 AEAD 进行序列化和加密。除了 info 使用“QUIC CETV block”标签外，密钥的派生方式与连接的密钥相同（请参阅上面的密钥派生）。推导中使用的client hello消息是没有 CETV 标记的。当稍后派生连接密钥时，使用的client hello将包含 CETV 标记。
</p>

<p>
AEAD 随机数始终为零，这是安全的，因为只有一条消息使用密钥加密。
</p>

<p>
证明拥有客户端证书和 ChannelID 都需要的私钥，是通过签署 CETV 密钥派生中使用的 HKDF 信息输入来完成的
</p>

<p>
CETV 消息可以包含以下标签：
</p>

<p>
<b>CIDK</b>
      ChannelID key（可选）：一对 32 字节的大端数字，它们一起指定一个 (x, y) 对。这是 P-256 曲线上的一个点和 ECDSA 公钥。
<b>CIDS</b>
      ChannelID signature（可选）：一对 32 字节的大端数字，它们一起指定 HKDF 输入的 ECDSA 签名的 (r, s) 对。
</p>
</div>
</div>



<div id="outline-container-org93149ba" class="outline-3">
<h3 id="org93149ba"><span class="section-number-3">1.9.</span> 证书压缩</h3>
<div class="outline-text-3" id="text-1-9">
<p>
在 TLS 中，证书链以未压缩的方式传输，并在完全握手中占用绝大多数字节。在 QUIC 中，我们希望能够通过压缩证书来避免一些往返。
</p>

<p>
证书链是一系列证书，就本节而言，它们是不透明的字节字符串。叶证书始终是链中的第一个，并且永远不应包含根 CA 证书。
</p>

<p>
在拒绝消息的 CRT\xFF 标记中序列化证书链时，服务器会考虑客户端已经拥有的信息。这种先验知识可以有两种形式：拥有一组通用中间证书，或者来自与同一服务器的先前交互的缓存证书。
</p>

<p>
前者表示为客户端 hello 的 CCS 标记中的一系列 64 位 FNV-1a 哈希值。如果客户端和服务器共享至少一个公共证书集，则可以简单地引用其中存在的证书。
</p>

<p>
缓存的证书在客户端 hello 的 CCRT 标记中表示为 64 位 FNV-1a 哈希值。如果有任何仍在证书链中，那么它们可以被哈希替换。
</p>

<p>
任何剩余的证书都使用预共享字典进行 gzip 压缩，该字典由前两种方法之一指定的证书以及来自 Alexa 前 5000 名证书的一组通用字符串组成。
</p>

<p>
它的具体表示被放置在拒绝消息的 CERT 标签中，并具有以下 TLS 表示样式的 Cert 结构格式：
</p>

<p>
枚举 { end_of_list(0), 压缩 (1), 缓存 (2), 通用 (3) } EntryType;
</p>

<p>
结构{
  条目类型；
  选择（类型）{
    案例压缩：
      // 没有什么
    缓存案例：
      不透明哈希[8]；
    常见情况：
      不透明的 set_hash[8];
      uint32 索引；
  }
} 入口;
</p>

<p>
结构{
  条目条目[];
  uint32 uncompressed_length;
  不透明的 gzip_data[];
证书；
</p>

<p>
（回想一下，QUIC 中的数字是小端的。）
</p>

<p>
条目列表由 end_of_list 类型的条目终止，而不是像 TLS 中常见的长度前缀。gzip_data 扩展到值的末尾。
</p>

<p>
gzip 预共享字典包含压缩或缓存类型的证书，以相反的顺序连接，后跟约 1500 字节的公共子字符串，此处未给出。
</p>



<p>
未来发展方向
</p>

<p>
ChannelID 很可能会从协议的这一层中删除，取而代之的是，加密握手将产生一个可以在更高层签名的通道绑定值。
Trevor Perrin 指出，服务器可以返回一个服务器可以返回一个包含哈希（前向安全秘密）的加密票证，客户端可以在未来的连接中回显给服务器。这将为这些握手节省一次 Diffie-Hellman 操作。
服务器应该能够向客户端指示他们应该等到转发安全密钥建立后再发送应用程序数据。
为了避免被服务器hello数据包的head-of-line阻塞，服务器可以避免发送安全数据，直到客户端确认收到服务器hello。（例如：通过发送转发安全数据包本身。）
</p>


<p>
致谢
</p>

<p>
感谢 Trevor Perrin、Ben Laurie 和 Emilia K?äsper 的宝贵反馈。
</p>




<p>
QUIC Crypto
</p>

<p>
Adam Langley &lt;agl@google.com&gt;
Wan-Teh Chang &lt;wtc@google.com&gt;
(Revision 20161206.)
</p>

<p>
(Note: this document is pretty old at this point. QUIC is now an IETF spec and its cryptographic handshake is now based on TLS 1.3 rather than this work. Thus this document is only of historical interest.)
</p>

<p>
Summary
Source address spoofing
Replay protection
Handshake costs
Wire Protocol
Client handshake.
Key derivation
Client encrypted tag values
Certificate compression
Future directions
Acknowledgements
</p>

<p>
Summary
</p>

<p>
The QUIC crypto protocol is the part of QUIC that provides transport security to a connection. The QUIC crypto protocol is destined to die. It will be replaced by TLS 1.3 in the future, but QUIC needed a crypto protocol before TLS 1.3 was even started.
</p>

<p>
With the current QUIC crypto protocol, when the client has cached information about the server, it can establish an encrypted connection with no round trips. TLS, in contrast, requires at least two round trips (counting the TCP 3-way handshake). QUIC handshakes should be ~5 times more efficient than common TLS handshakes (2048-bit RSA) and at a greater security level.
</p>

<p>
Source address spoofing
</p>

<p>
Very few protocols on the Internet work without at least one initialisation round trip. Most protocols have a round trip due to TCP and TLS-based protocols additionally have at least one more before application data can flow.
</p>

<p>
Both of these rounds trips exchange nonces: sequence numbers (or SYN cookies) in the case of TCP and cryptographic random values (client_random and server_random) in TLS. The TCP nonce prevents IP address spoofing and the TLS nonce prevents replay attacks. Any protocol which seeks to eliminate round trips has to somehow address these two problems.
</p>

<p>
As a counterexample, DNS is a protocol that doesn't have any initialisation round trips, thus it has to deal with IP address spoofing and replay attacks itself. DNS simply ignores IP address spoofing and thus mirror DDoS attacks are a real problem. For replay protection, DNSSEC relies on clock synchronisation and short-lived signatures. This allows replays for a limited time by design because that meshes with DNS’s caching semantics. But it's not a strict form of replay protection because replays are permitted.
</p>

<p>
In QUIC we deal with the two problems separately.
</p>

<p>
The IP address spoofing problem is handled by issuing the client, on demand, a “source-address token”. This is an opaque byte string from the client's point of view. From the server's point of view it's an authenticated-encryption block (e.g. AES-GCM) that contains, at least, the client's IP address and a timestamp by the server. The server will only send a source address token for a given IP to that IP. Receipt of the token by the client is taken as proof of ownership of the IP address in the same way that receipt of a TCP sequence number is.
</p>

<p>
Clients can include the source address token in future requests in order to demonstrate ownership of their source IP address. If the client has moved IP addresses, the token is too old, or the client doesn’t have a token, then the server may reject the connection and return a fresh token to the client. But if the client has remained on the same IP address then it can reuse a source-address token to avoid the round trip needed to obtain a fresh one.
</p>

<p>
The lifetime of a token is a matter for the server but, since source address tokens are bearer tokens, they can be stolen and reused in order to bypass IP address based restrictions. (Although the attacker would not receive the response.) Source address tokens can also be collected and possibly used after ownership of the IP address has changed (i.e. in a DHCP pool). Reducing the lifetime of tokens ameliorates both of these concerns at the cost of reducing the number of requests that can be handled without additional round trips.
</p>

<p>
Source address tokens, unlike an exchange of TCP sequence numbers, do not require the source to demonstrate a continuous ability to receive packets sent to the source IP address. This allows a source address token to be used to continuously request traffic from a server even once the downstream link has been saturated and the drop rate is high enough that TCP connections couldn't be established. This “self DOS” attack can be used to DOS other users on the same downstream links.
</p>

<p>
However, we note that a similar trick is actually possible with TCP and so QUIC doesn’t make things obviously worse in this respect. Indeed, once the connection is established, QUIC includes an entropy bit in packets and requires that receivers send a hash of the entropies that they claim to have received - thus solving the issue with TCP.
</p>

<p>
In order to minimise latency, servers may decide to relax source address restrictions dynamically. One can imagine a server that tracks the number of requests coming from different IP addresses and only demands source-address tokens when the count of “unrequited” connections exceeds a limit globally, or for a certain IP range. This may well be effective but it’s unclear whether this is globally stable. If a large number of QUIC servers implemented this strategy then a substantial mirror DDoS attack may be split across them such that the attack threshold wasn’t reached by any one server.
</p>


<p>
Replay protection
</p>

<p>
In TLS, each side generates an nonce which is used to ensure that the other party is fresh by forcing them to include the (assumed to be unique for all time) value in the key derivation. Without a round trip the client can still include an nonce and so ensure that the server is fresh, but the server doesn't have a chance to do so for the client.
</p>

<p>
Providing replay protection without input from the server is fundamentally very expensive. It requires consistent state at the server. Although this is reasonable if the server is a single machine, modern websites are spread around the world.
</p>

<p>
Thus QUIC doesn’t provide replay protection for the client’s data prior to the server’s first reply.  It’s up the application to ensure that any such information is safe if replayed by an attacker. For example, in Chrome, only GET requests are sent before handshake confirmation.
</p>

<p>
Handshake costs
</p>

<p>
In TLS, the server picks connection parameters for each connection based on the client’s advertised support for them. In QUIC, the server’s preferences are fully enumerated and static. They are bundled, along with Diffie-Hellman public values into a “server config”. This server config has an expiry and is signed by the server’s private key. Because the server config is static, a signing operation is not needed for each connection, rather a single signature suffices for many connections.
</p>

<p>
The keys for a connection are agreed using Diffie-Hellman. The server’s Diffie-Hellman value is found in the server config and the client provides one in its first handshake message. Because the server config must be kept for some time in order to allow 0-RTT handshakes, this puts an upper bound on the forward security of the connection. As long as the server keeps the Diffie-Hellman secrets for a server config, data encrypted using that server config could be decrypted if they leak.
</p>

<p>
Thus QUIC provides two levels of secrecy: the initial data from the client is encrypted using the Diffie-Hellman value in the server’s server config, which may persist for several days. Immediately upon receiving the connection, the server replies with an ephemeral Diffie-Hellman value and the connection is rekeyed.
</p>

<p>
(This may appear to provide less forward security than a forward-secure TLS connection. However, to avoid round trips TLS SessionTickets are typically enabled in large deployments. The SessionTicket key is sufficient to decrypt a connection but, for resumption to be effective, it must be retained for reasonable period - typically some number of days. Thus the SessionTicket key and the server config key are analogous and the effective security is actually greater with QUIC because its forward-secure mode is then superior.)
</p>

<p>
A single connection is the usual scope for forward security, but the security difference between an ephemeral key used for a single connection, and one used for all connections for 60 seconds is negligible. Thus we can amortise the Diffie-Hellman key generation at the server over all the connections in a small time span.
</p>

<p>
(Because the server config and Diffie-Hellman private values are all the server needs in order to process QUIC connections, the private key for the certificate need never be placed on the server. Rather, a form of short-lived certificates can be implemented by signing short-lived server configs and installing only those on the server.)
</p>

<p>
If we let S be a secret key operation (i.e. RSA decrypt), P be a public key operation (i.e. RSA encrypt), F be a Diffie-Hellman, fixed point, scalar multiplication and A be an arbitrary point, scalar multiplication then:
</p>

<p>
TLS, non-forward-secure handshake: server, 1S (1100µs); client, 1P (34µs).
TLS, forward-secure handshake: server, 1S + 1F + 1A (1301µs); client, 1P + 1F + 1A (235µs).
QUIC: server, 2A (100µs); client, 1F + 2A + 1P (184µs).
</p>

<p>
(The operations needed for the client to verify the certificate chain are not included.)
</p>

<p>
If we pick common primitives for each of these (RSA 2048 for the public and private operations, ECDH P-256 for TLS forward security and Curve25519 for QUIC) then we obtain the example times in parenthesis on an i7-3770S. If QUIC were to use P-256 then the server times would be 300µs and the client would be 385µs, so a fair amount of the gain comes from using better primitives.
</p>

<p>
TLS session resumption rates in the wild are roughly 50%, but QUIC doesn’t include session resumption explicitly. However, it can achieve many of the benefits of resumption without any support in the protocol by having clients and servers maintain a cache of Diffie-Hellman results. This optional cache eliminates the computational burden of handshaking several times with the same server so long the client hasn't rotated its ephemeral key. If we assume a 50% resumption rate for TLS and assume that the QUIC cache does nothing, then we get the roughly 5x speedup in relation to TLS that was mentioned in the introduction.
</p>


<p>
Wire Protocol
</p>

<p>
QUIC is a datagram protocol, and the full payload of each datagram (above the UDP layer) are authenticated and encrypted once keys have been established. The underlying datagram protocol provides the crypto layer with the means to send reliable, arbitrary sized messages. These messages have a uniform, key-value format.
</p>

<p>
The keys are 32-bit tags. This seeks to provide a balance between the tyranny of magic number registries and the verbosity of strings. As far as the wire protocol is concerned, these are opaque, 32-bit values and, in this document, tags will often be written like EXMP. Although it’s written as a string, it’s just a mnemonic for the value 0x504d5845. That value, in little-endian, is the ASCII string E X M P.
</p>

<p>
If a tag is written in ASCII but is less than four characters then it’s as if the remaining characters were NUL. So EXP corresponds to 0x505845.
</p>

<p>
If the tag value contains bytes outside of the ASCII range, they’ll be written in hex, e.g. 504d5845.
</p>

<p>
All values are little-endian unless otherwise noted.
</p>

<p>
A handshake message consists of:
The tag of the message.
A uint16 containing the number of tag-value pairs.
Two bytes of padding which should be zero when sent but ignored when received.
A series of uint32 tags and uint32 end offsets, one for each tag-value pair. The tags must be strictly monotonically increasing, and the end-offsets must be monotonic non-decreasing. The end offset gives the offset, from the start of the value data, to a byte one beyond the end of the data for that tag. (Thus the end offset of the last tag contains the length of the value data).
The value data, concatenated without padding.
</p>

<p>
The tag-value format allows for an efficient binary search for a tag after only a small fraction of the data has been validated. The requirement that the tags be strictly monotonic also removes any ambiguity around duplicated tags.
</p>

<p>
Although the 32-bit lengths are currently more than needed, 16-bit lengths ran the risk of being insufficient to handle larger, post-quantum values.
</p>

<p>
Any message may contain a padding (PAD) tag. These can be used to to defeat traffic analysis. Additionally, we may define a global minimum size for client hellos to limit amplification attacks. Client hellos that are smaller than the minimum would need a PAD tag to make up the difference.
</p>


<p>
Client handshake.
</p>

<p>
The flow of a client handshake is illustrated in figure 1. Conceptually, all handshakes in QUIC are 0-RTT, it’s just that some of them fail and need to be retried.
</p>


<p>
Figure 1. Client handshake flow.
</p>

<p>
In order to perform a 0-RTT handshake, the client needs to have a server config that has been verified to be authentic. Initially we assume that the client knows nothing about the server and so, before a handshake can be attempted, the client will send “inchoate” client hello messages to elicit a server config and proof of authenticity from the server. There may be several rounds of inchoate client hellos before the client receives all the information that it needs because the server may be unwilling to send a large proof of authenticity to an unvalidated IP address.
</p>

<p>
Client hello messages have the message tag CHLO and, in their inchoate form, contain the following tag/value pairs:
</p>

<p>
SNI
Server Name Indication (optional): the fully qualified DNS name of the server, canonicalised to lowercase with no trailing period. Internationalized domain names need to be encoded as A-labels defined in RFC 5890. The value of the SNI tag must not be an IP address literal.
STK
Source-address token (optional): the source-address token that the server has previously provided, if any.
PDMD
Proof demand: a list of tags describing the types of proof acceptable to the client, in preference order. Currently only X509 is defined.
CCS
Common certificate sets (optional): a series of 64-bit, FNV-1a hashes of sets of common certificates that the client possesses. (See section on certificate compression.)
CCRT
Cached certificates (optional): a series of 64-bit, FNV-1a hashes of cached certificates for this server. (See section on certificate compression.)
VER
Version: a single tag that mirrors the protocol version advertised by the client in each QUIC packet in the first flight of data. If version negotiation happens, then this field is set to the first version used by the client. If the version in the packet does not equal the version in the tag, then the server needs to verify that the server does not support the version in the tag in order to defend against downgrade attacks.
XLCT
A 64-bit,  FNV-1a hash of the leaf certificate that the client expects the server to be using. The full contents of the certificate will be added into the HKDF. If cached certificates are present, the first such entry should be identical to the value of this field.
</p>


<p>
(Other parts of QUIC may define additional tags to be included in the client and server hellos. For example, the maximum number of stream, congestion control parameters etc. However, those tags are not defined in this specification.)
</p>

<p>
In response to a client hello the server will either send a rejection message, or a server hello. The server hello indicates a successful handshake and can never result from an inchoate client hello as it doesn’t contain enough information to perform a handshake. The rejection messages contain information that the client can use to perform a better handshake attempt subsequently.
</p>

<p>
Rejection messages have the tag REJ and contain the following tag/value pairs:
</p>

<p>
SCFG
Server config (optional): a message containing the server’s serialised config. (Described below.)
STK
Source-address token (optional): an opaque byte string that the client should echo in future client hello messages.
SNO
Server nonce (optional): the server may set an nonce, which the client should echo in any future (full) client hello messages. This allows a server to operate without a strike-register and for clients with clock-skew to connect.
STTL
The duration, in seconds, that the server config is valid for.
ff545243
Certificate chain (optional): the server’s certificate chain. (See section on certificate compression.)
PROF
Proof of authenticity (optional): in the case of X.509, a signature of the server config by the public key in the leaf certificate. The format of the signature is currently fixed by the type of public key:
RSA
RSA-PSS-SHA256
ECDSA
ECDSA-SHA256
</p>

<p>
The signature is calculated over:
The label “QUIC server config signature”
The 32 bit length of the hash in the next field in bytes (which is 8).
The SHA256 hash of the CHLO
An 0x00 byte
The serialised server config.
</p>


<p>
Although all the elements of the rejection message are optional, the server must allow the client to make progress. For example, if the client didn’t present a source-address token and the server is unwilling to send the server config to an unverified IP address, then the server must reply with a source-address token so that the client’s next handshake attempt will be more successful.
</p>

<p>
Some tags are specified in hex rather than in the ASCII notation. This is because the tags are formed so that they will either come at the beginning or end of a message. Recall that tags, as numbers, are written in little-endian order on the wire.
</p>

<p>
Tags containing entropy are moved to the beginning of the message as the server may not be maintaining state and therefore may process a duplicated client hello twice. If packet loss hits the reject message and the entropy fields spanned a packet boundary then the client may misassemble them.
</p>

<p>
Large tags (the certificate chain so far) are moved to the end of the message so that they don’t delay the receipt of other fields that may be sufficient.
</p>

<p>
The server config contains the serialised preferences for the server and takes the form of a handshake message with tag SCFG. It contains the following tag/value pairs:
</p>

<p>
SCID
Server config ID: an opaque, 16-byte identifier for this server config.
KEXS
Key exchange algorithms: a list of tags, in preference order, specifying the key exchange algorithms that the server supports. The following tags are defined:
</p>

<p>
C255
Curve25519
P256
P-256
</p>



<p>
AEAD
Authenticated encryption algorithms: a list of tags, in preference order, specifying the AEAD primitives supported by the server. The following tags are defined:
</p>

<p>
AESG
AES-GCM with a 12-byte tag and IV. The first four bytes of the IV are taken from the key derivation and the last eight are the packet sequence number.
S20P
Salsa20 with Poly1305. (Provisional and not yet implemented.)
</p>



<p>
PUBS
A list of public values, 24-bit, little-endian length prefixed, in the same order as in KEXS. P-256 public values, if any, are encoded as uncompressed points in X9.62 format.
ORBT
Orbit: an 8-byte, opaque value that identifies the strike-register  (vestigial).
EXPY
Expiry: a 64-bit expiry time for the server config in UNIX epoch seconds.
VER
Versions: the list of version tags supported by the server. The underlying QUIC packet protocol has a version negotiation. The server’s supported versions are mirrored in the signed server config to confirm that no downgrade attack occurred.
</p>


<p>
Once the client has received a server config, and has authenticated it by verifying the certificate chain and signature, it can perform a handshake that isn’t designed to fail by sending a full client hello. A full client hello contains the same tags as an inchoate client hello, with the addition of several others:
</p>

<p>
SCID
Server config ID: the ID of the server config that the client is using.
AEAD
Authenticated encryption: the tag of the AEAD algorithm to be used.
KEXS
Key exchange: the tag of the key exchange algorithm to be used.
NONC
Client nonce: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data.
SNO
Server nonce (optional): an echoed server nonce, if the server has provided one.
PUBS
Public value: the client’s public value for the given key exchange algorithm.
CETV
Client encrypted tag-values (optional): a serialised message, encrypted with the AEAD algorithm specified in this client hello and with keys derived in the manner specified in the CETV section, below. This message will contain further, encrypted tag-value pairs that specify client certificates, ChannelIDs etc.
</p>


<p>
After sending a full client hello, the client is in possession of non-forward-secure keys for the connection since it can calculate the shared value from the server config and the public value in PUBS. (For details of the key derivation, see below.) These keys are called the initial keys (as opposed the the forward-secure keys that come later) and the client should encrypt future packets with these keys. It should also configure the packet processing to accept packets encrypted with these keys in a latching fashion: once an encrypted packet has been received, no further unencrypted packets should be accepted.
</p>

<p>
At this point, the client is free to start sending application data to the server. Indeed, if it wishes to achieve 0-RTT then it must start sending before waiting for the server’s reply.
</p>

<p>
Retransmission of data occurs at a layer below the handshake layer, however that layer must still be aware of the change of encryption. New packets must be transmitted using the initial keys but, if the client hello needs to be retransmitted, then it must be retransmitted in the clear. The packet sending layer must be aware of which security level was originally used to send any given packet and be careful not to use a higher security level unless the peer has acknowledged possession of those keys (i.e. by sending a packet using that security level).
</p>

<p>
The server will either accept or reject the handshake. In the event that the server rejects the client hello, it will send a REJ message and all packets transmitted using the initial keys must be considered lost and need to be retransmitted under the new, initial keys. Because of this, clients should limit the amount of data outstanding while a server hello or rejection is pending.
</p>

<p>
In the happy event that the handshake is successful, the server will return a server hello message. This message has the tag SHLO, is encrypted using the initial keys,  and contains the following tag/value pairs in addition to those defined for a rejection message:
PUBS
An ephemeral public value for the key exchange algorithm used by the client.
</p>


<p>
With the ephemeral public value in hand, both sides can calculate the forward-secure keys. (See section on key derivation.) The server can switch to sending packets encrypted with the forward-secure keys immediately. The client has to wait for receipt of the server hello. (Note: we are considering having the server wait until it has received a forward-secure packet before sending any itself. This avoids a stall if the server hello packet is dropped.)
</p>


<p>
Key derivation
</p>

<p>
Key material is generated by an HMAC-based key derivation function (HKDF) with hash function  SHA-256.  HKDF (specified in RFC 5869) uses the approved two-step key derivation procedure specified in NIST SP 800-56C.
</p>

<p>
Step 1: HKDF-Extract
The output of the key agreement (32 bytes in the case of Curve25519 and P-256) is the premaster secret, which is the input keying material (IKM) for the HKDF-Extract function. The salt input is the client nonce followed by the server nonce (if any).  HKDF-Extract outputs a pseudorandom key (PRK), which is the master secret. The master secret is 32 bytes long if SHA-256 is used.
</p>

<p>
Step 2: HKDF-Expand
The PRK input is the master secret. The info input (context and application specific information) is the concatenation of the following data:
The label “QUIC key expansion”
An 0x00 byte
The GUID of the connection from the packet layer.
The client hello message
The server config message
The DER encoded contents of the leaf certificate
</p>

<p>
Key material is assigned in this order:
Client write key.
Server write key.
Client write IV.
Server write IV.
</p>

<p>
If any primitive requires less than a whole number of bytes of key material, then the remainder of the last byte is discarded.
</p>

<p>
When the forward-secret keys are derived, the same inputs are used except that info uses the label “QUIC forward secure key expansion”.
</p>

<p>
When the server’s initial keys are derived, they must be diversified to ensure that the server is able to provide entropy into the HKDF.
</p>

<p>
Step 1: HKDF-Extract
The concatenation of the server write key plus the server write IV from the found round is the input keying material (IKM) for the HKDF-Extract function. The salt input is the diversification nonce.  HKDF-Extract outputs a pseudorandom key (PRK), which is the diversification secret. The diversification secret is 32 bytes long if SHA-256 is used.
</p>

<p>
Step 2: HKDF-Expand
The PRK input is the diversification secret. The info input (context and application specific information) is the label "QUIC key diversification".
</p>

<p>
Key material is assigned in this order:
</p>
<ol class="org-ol">
<li>Server write key.</li>
<li>Server write IV.</li>
</ol>




<p>
Client encrypted tag values
</p>

<p>
A client hello may contain a CETV tag in order to specify client certificates, ChannelIDs and other non-public data in the client hello. (That’s in contrast to TLS, which sends client certificates in the clear.)
</p>

<p>
The CETV message is serialised and encrypted with the AEAD that is specified in the client hello. The key is derived in the same way as the keys for the connection (see Key Derivation, above) except that info uses the label “QUIC CETV block”. The client hello message used in the derivation is the client hello without the CETV tag. When the connection keys are later derived, the client hello used will include the CETV tag.
</p>

<p>
The AEAD nonce is always zero, which is safe because only a single message is ever encrypted with the key.
</p>

<p>
Proving possession of a private key, which is needed for both client certificates and ChannelIDs, is done by signing the HKDF info input that is used in the CETV key derivation.
</p>

<p>
The CETV message can include the following tags:
</p>

<p>
CIDK
ChannelID key (optional): a pair of 32-byte, big-endian numbers which, together, specify an (x, y) pair. This is a point on the P-256 curve and an ECDSA public key.
CIDS
ChannelID signature (optional): a pair of 32-byte, big-endian numbers which, together, specify the (r, s) pair of an ECDSA signature of the HKDF input.
</p>



<p>
Certificate compression
</p>

<p>
In TLS, certificate chains are transmitted uncompressed and take up the vast majority of the bytes in full handshakes. In QUIC, we hope to be able to avoid some round trips by compressing the certificates.
</p>

<p>
A certificate chain is a series of certificates which, for the purposes of this section, are opaque byte strings. The leaf certificate is always first in the chain and the root CA certificate should never be included.
</p>

<p>
When serialising a certificate chain in the CRT\xFF tag of a rejection message, the server considers what information the client already has. This prior knowledge can come in two forms: possession of bundles of common intermediate certificates, or cached certificates from prior interactions with the same server.
</p>

<p>
The former are expressed as a series of 64-bit, FNV-1a hashes in the CCS tag of the client hello. If both the client and server share at least one common certificate set then certificates that exist in them can simply be referenced.
</p>

<p>
The cached certificates are expressed as 64-bit, FNV-1a hashes in the CCRT tag of the client hello. If any are still in the certificate chain then they can be replaced by the hash.
</p>

<p>
Any remaining certificates are gzip compressed with a pre-shared dictionary that consists of the certificates specified by either of the first two methods, and a block of common strings from certificates taken from the Alexa top 5000.
</p>

<p>
The concrete representation of this is placed into the CERT tag of the rejection message and has the format of a Cert structure in the following TLS presentation style:
</p>

<p>
enum { end_of_list(0), compressed(1), cached(2), common(3) } EntryType;
</p>

<p>
struct {
  EntryType type;
  select (type) {
    case compressed:
      // nothing
    case cached:
      opaque hash[8];
    case common:
      opaque set_hash[8];
      uint32 index;
  }
} Entry;
</p>

<p>
struct {
  Entry entries[];
  uint32 uncompressed_length;
  opaque gzip_data[];
} Certs;
</p>

<p>
(Recall that numbers are little-endian in QUIC.)
</p>

<p>
The entries list is terminated by an Entry of type end_of_list, rather than length-prefixed as would be common in TLS. The gzip_data extends to the end of the value.
</p>

<p>
The gzip, pre-shared dictionary contains the certificates of type compressed or cached, concatenated in reverse order, followed by ~1500 bytes of common substrings that are not given here.
</p>



<p>
Future directions
</p>

<p>
It’s likely that ChannelID will be removed from this layer of the protocol and, instead, the crypto handshake will produce a channel binding value that can be signed at a higher layer.
Trevor Perrin has pointed out that the server can return a server can return an encrypted ticket containing Hash(forward secure secret) that the client could echo to the server on future connections. This would save one Diffie-Hellman operation for those handshakes.
Servers should be able to indicate to clients that they should wait until forward secure keys are established before sending application data.
In order to avoid head-of-line blocking by the server hello packet, the server could avoid sending forward secure data until the client confirms receipt of server hello. (For example: by sending a forward secure packet itself.)
</p>


<p>
Acknowledgements
</p>

<p>
Thanks to Trevor Perrin, Ben Laurie and Emilia Käsper for their valuable feedback.
</p>
</div>
</div>
</div>


<div id="outline-container-org5086122" class="outline-2">
<h2 id="org5086122"><span class="section-number-2">2.</span> 新标准</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-fundamental">+=====================+=================+==================+
| Packet Type         | Encryption Keys | PN Space         |
+=====================+=================+==================+
| Initial             | Initial secrets | Initial          |
+=====================+-----------------+------------------+
| 0-RTT Protected     | 0-RTT           | Application data |
+=====================+-----------------+------------------+
| Handshake           | Handshake       | Handshake        |
+=====================+-----------------+------------------+
| Retry               | Retry           | N/A              |
+=====================+-----------------+------------------+
| Version Negotiation | N/A             | N/A              |
+=====================+-----------------+------------------+
| Short Header        | 1-RTT           | Application data |
+=====================+-----------------+------------------+

          Table 1: Encryption Keys by Packet Type

</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:54</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
