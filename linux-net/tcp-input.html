<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2022-05-03 Tue 21:23 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TCP的输入</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="nandfan" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
	     margin-bottom: .2em; }
  .subtitle { text-align: center;
	      font-size: medium;
	      font-weight: bold;
	      margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
	    padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">TCP的输入</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7311229">1. 引言</a></li>
<li><a href="#org843b14c">2. TCP接收的总入口</a>
<ul>
<li><a href="#orgb5e2ad7">2.1. 接收到prequeue队列</a></li>
<li><a href="#org889fdbb">2.2. 有效TCP段的处理</a></li>
</ul>
</li>
<li><a href="#org72d54af">3. 报文的过滤</a>
<ul>
<li><a href="#org6c0b6b7">3.1. 过滤器的数据结构</a>
<ul>
<li><a href="#org6a44077">3.1.1. sock_fprog结构</a></li>
<li><a href="#orgc7c2c77">3.1.2. sock_filter结构</a></li>
<li><a href="#org89ee319">3.1.3. sk_filter结构</a></li>
</ul>
</li>
<li><a href="#org474c286">3.2. 安装过滤器</a></li>
<li><a href="#org6d279fa">3.3. 卸载过滤器</a></li>
<li><a href="#org945dc1c">3.4. 过滤执行</a></li>
</ul>
</li>
<li><a href="#orgb2299ae">4. ESTABLISHED状态的接收</a>
<ul>
<li><a href="#orgfc1f5ee">4.1. 首部预测</a>
<ul>
<li><a href="#orgb24c113">4.1.1. 设置预测标志：tcp_fast_path_check()</a></li>
<li><a href="#org00c7065">4.1.2. 预测标志</a></li>
<li><a href="#org367cff9">4.1.3. 时间戳选项与PAWS检测</a></li>
</ul>
</li>
<li><a href="#org4a88fe3">4.2. 接收处理无负荷的ACK段</a></li>
<li><a href="#org755e744">4.3. 执行快速路径</a></li>
<li><a href="#org023459d">4.4. 执行慢速路径</a></li>
<li><a href="#org74d91f3">4.5. 数据从内核空间复制到用户空间</a>
<ul>
<li><a href="#org01b1d83">4.5.1. 主动复制数据到用户空间</a></li>
<li><a href="#org756be06">4.5.2. 不进行校验和检查的复制</a></li>
<li><a href="#org08953e8">4.5.3. 进行校验和检查的复制</a></li>
</ul>
</li>
<li><a href="#orgc32e939">4.6. 通过调节接收窗口进行流量控制</a>
<ul>
<li><a href="#org3404429">4.6.1. 接收方RTT的计算</a>
<ul>
<li><a href="#org3ecfad7">4.6.1.1. tcp_rcv_rtt_measure()</a></li>
<li><a href="#org530299b">4.6.1.2. tcp_rcv_rtt_measure_ts</a></li>
<li><a href="#org462dc0c">4.6.1.3. tcp_rcv_rtt_update()</a></li>
</ul>
</li>
<li><a href="#orgede2879">4.6.2. 调整接收缓存和接收窗口大小</a></li>
</ul>
</li>
<li><a href="#org4b0b19a">4.7. 确定是否需要发送ACK段（用于接收的数据从内核空间复制到用户空间时）</a></li>
</ul>
</li>
<li><a href="#org8a77bd4">5. TCP选项的处理</a>
<ul>
<li><a href="#orge9a3691">5.1. 慢速路径中快速解析TCP选项</a></li>
<li><a href="#org65fcb15">5.2. 全面解析TCP选项</a></li>
</ul>
</li>
<li><a href="#org2c4f65a">6. 慢速路径的数据处理</a>
<ul>
<li><a href="#org0cb43cb">6.1. 接收处理预期的段</a></li>
<li><a href="#orgc321434">6.2. 接收处理在接收窗口之外的段</a></li>
<li><a href="#orgc9310a6">6.3. 接收处理乱序的段</a></li>
<li><a href="#org1566714">6.4. tcp_ofo_queue()</a></li>
</ul>
</li>
<li><a href="#org788c577">7. 带外数据处理</a>
<ul>
<li><a href="#orgcf48485">7.1. 检测紧急指针</a></li>
<li><a href="#orgd960c78">7.2. 读取带外数据</a></li>
</ul>
</li>
<li><a href="#org829dcf4">8. SACK信息</a>
<ul>
<li><a href="#org0b562e5">8.1. SACK允许选项</a></li>
<li><a href="#orgc1dfdac">8.2. SACK选项</a></li>
<li><a href="#orge1f8254">8.3. SACK的产生</a></li>
<li><a href="#orga2edb70">8.4. 发送方对SACK的响应</a></li>
<li><a href="#org2dee450">8.5. 实现</a>
<ul>
<li><a href="#orgd0d45cb">8.5.1. 调整SACK块</a></li>
<li><a href="#orgaced734">8.5.2. 构建SACK选项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org338a863">9. 确认的发送</a>
<ul>
<li><a href="#orgcb60827">9.1. 快速确认模式</a>
<ul>
<li><a href="#orgf2f6377">9.1.1. 进入快速确认模式</a></li>
<li><a href="#orgde38da0">9.1.2. 检测当前的模式</a></li>
</ul>
</li>
<li><a href="#orgd97dc91">9.2. 处理数据接收事件</a></li>
<li><a href="#orgd3bf2ee">9.3. 发送确认紧急程度和状态</a>
<ul>
<li><a href="#org3ed5b80">9.3.1. ICSK_ACK_SCHED</a></li>
<li><a href="#org28a950c">9.3.2. ICSK_ACK_PUSHED和ICSK_ACK_PUSHED2状态</a></li>
<li><a href="#org27a6f03">9.3.3. 清除发送确认紧急程度和状态标志</a></li>
</ul>
</li>
<li><a href="#orgd6e1437">9.4. 延迟或快速确认</a></li>
</ul>
</li>
<li><a href="#org16f8a64">10. recvmsg系统调用在TCP的实现</a>
<ul>
<li><a href="#org547f832">10.1. 套接口层实现</a></li>
<li><a href="#org33f09d4">10.2. 传输接口层的实现</a></li>
</ul>
</li>
<li><a href="#orgb640551">11. sk_backlog_rcv接口</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7311229" class="outline-2">
<h2 id="org7311229"><span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
TCP发送方将段发送出去后，会进行跟踪，直到得到接收方的确认为止。因此，当接收方受到一个段后，会根据情况将其添加到接收队列或prequeue队列，或者后备队列。
</p>

<p>
TCP传输控制块有三个有关接收的队列，即接收队列、prequeue队列和后备队列。启用tcp_low_latency时，TCP传输控制块在软中段中接收并处理TCP段，然后将其插入到接收队列中，等待用户进程从接收队列中获取TCP段后复制到用户空间中，最终删除并释放。
</p>

<p>
不启用tcp_low_latency能够提高TCP/IP协议栈的吞吐量及反应速度，TCP传输控制块在软中段中将TCP段添加到prequeue队列中，然后立即处理prequeue队列中的段，如果用户进程正在读取数据，则可以直接复制数据到用户空间的缓冲区中，否则添加到接收队列中，然后从软中断中返回。在多数情况下有机会处理prequeue队列中的段，但只有用户进程在进行recv类系统调用返回前，才在软中断中复制数据到用户空间的缓存中。
</p>

<p>
在用户进程因操作传输控制块而将其锁定时，无论是否启用tcp_low_latency,都会将未处理的TCP段添加到后备队列中，一旦用户进程解锁传输控制块，就会立即处理后备队列，将TCP段处理之后添加到接收队列中。
</p>

<p>
sock结构中的sk_receive_queue成员就是TCP的接收队列。通常情况下，接收的tcp段都会缓存在这里，等待用户进程主动读取。
</p>


<div class="figure">
<p><img src="ditaa/tcp-input/skb-list.png" alt="skb-list.png" />
</p>
</div>

<p>
TCP传输控制块中的sk_receive_queue是个双向链表的表头，该链表用来存储已接收待复制数据到用户空间的SKB。在TCP传输控制块中ucopy成员是用来描述用户空间的。在未启用tcp_low_latency时，如果数据可以从内核空间直接复制到用户空间，则需要从该字段获取有关用户空间的信息。
</p>

<p>
当接收方将数据从内核空间复制到用户空间后，需要更新接收窗口，删除并释放已经读取的段，以便有空间接收新数据到缓存中。
</p>


<div class="figure">
<p><img src="image/tcp-input/tcp-recv-call.png" alt="tcp-recv-call.png" />
</p>
<p><span class="figure-number">Figure 2: </span>TCP接收过程调用及队列关系</p>
</div>
</div>
</div>



<div id="outline-container-org843b14c" class="outline-2">
<h2 id="org843b14c"><span class="section-number-2">2</span> TCP接收的总入口</h2>
<div class="outline-text-2" id="text-2">
<p>
当IP层接收到报文，或由多个分片组装成一个完整的IP数据报后，会调用该报文对应的传输层接收函数，传递给传输层处理。
</p>

<p>
tcp_v4_rcv()是TCP接收数据的总入口。首先对TCP段进行简单的校验，如TCP首部长度、校验和等，此时还不清楚该TCP段的宿主，即还不清楚将该段传递给哪个TCP传输控制块。然后根据源地址、端口、目的地址、端口查找所属的传输控制块。最后调用tcp_v4_do_rcv()将该TCP段接收到所属的传输控制块的接收队列中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_v4_rcv</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ret</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#19981;&#26159;&#21040;&#26412;&#22320;&#30340;&#25968;&#25454;&#25253;&#65292;&#30452;&#25509;&#20002;&#24323;</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;pkt_type != PACKET_HOST)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_it</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Count it even if it's bad</span><span style="color: #8B8878;"> */</span>
	TCP_INC_STATS_BH(TCP_MIB_INSEGS);
	<span style="color: #CDC673;">/** &#22914;&#26524;TCP&#27573;&#22312;&#20256;&#36755;&#36807;&#31243;&#20013;&#21457;&#29983;&#20998;&#29255;&#65292;&#21017;&#21040;&#36798;&#26412;&#22320;&#21518;&#20250;&#22312;IP&#23618;&#37325;&#26032;&#32452;&#35013;&#12290;</span>
<span style="color: #CDC673;">        &#32452;&#35013;&#23436;&#25104;&#21518;&#65292;&#25253;&#25991;&#20998;&#29255;&#37117;&#23384;&#20648;&#22312;&#20998;&#29255;&#38142;&#34920;&#20013;&#12290;&#22312;&#27492;&#38656;&#25226;&#23384;&#20648;&#22312;&#20998;&#29255;&#20013;&#30340;&#25253;&#25991;&#22797;&#21046;&#21040;SKB&#30340;&#32447;&#24615;&#23384;&#20648;&#21306;&#22495;&#12290;</span>
<span style="color: #CDC673;">        &#22914;&#26524;&#21457;&#29983;&#24322;&#24120;&#65292;&#21017;&#20002;&#24323;&#35813;&#25253;&#25991;&#12290;*/</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>)))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_it</span>;

	th = skb-&gt;h.th;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#39318;&#37096;&#38271;&#24230;&#23567;&#20110;&#19981;&#24102;&#36873;&#39033;&#30340;TCP&#39318;&#37096;&#38271;&#24230;&#65292;&#21017;&#25968;&#25454;&#24322;&#24120;&#65292;&#20002;&#24323;</span>
	<span style="color: #FF1493;">if</span> (th-&gt;doff &lt; <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) / 4)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">bad_packet</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#26597;&#25972;&#20010;TCP&#27573;&#38271;&#24230;&#21644;TCP&#39318;&#37096;&#38271;&#24230;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, th-&gt;doff * 4))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_it</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">An explanation is required here, I think.</span>
<span style="color: #8B8878;">         * Packet length and doff are validated by header prediction,</span>
<span style="color: #8B8878;">         * provided case of th-&gt;doff==0 is eliminated.</span>
<span style="color: #8B8878;">         * So, we defer the checks.</span><span style="color: #8B8878;"> */</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26657;&#39564;&#21644;</span>
	<span style="color: #FF1493;">if</span> ((skb-&gt;ip_summed != CHECKSUM_UNNECESSARY &amp;&amp;
	     tcp_v4_checksum_init(skb)))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">bad_packet</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;TCP&#39318;&#37096;&#30340;&#20449;&#24687;&#26469;&#35774;&#32622;TCP&#25511;&#21046;&#22359;&#30340;&#20540;&#12290;</span>
	th = skb-&gt;h.th;
	TCP_SKB_CB(skb)-&gt;seq = ntohl(th-&gt;seq);
	TCP_SKB_CB(skb)-&gt;end_seq = (TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin +
				    skb-&gt;len - th-&gt;doff * 4);
	TCP_SKB_CB(skb)-&gt;ack_seq = ntohl(th-&gt;ack_seq);
	TCP_SKB_CB(skb)-&gt;when    = 0;
	TCP_SKB_CB(skb)-&gt;flags   = skb-&gt;nh.iph-&gt;tos;
	TCP_SKB_CB(skb)-&gt;sacked  = 0;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#22320;&#22336;&#31471;&#21475;&#65292;&#20174;ehash&#65288;&#24050;&#32463;&#24314;&#31435;&#36830;&#25509;&#65289;&#25110;&#32773;bhash&#65288;&#30417;&#21548;&#29366;&#24577;&#65289;&#25955;&#21015;&#34920;&#26597;&#25214;</span>
	sk = __inet_lookup(&amp;tcp_hashinfo, skb-&gt;nh.iph-&gt;saddr, th-&gt;source,
			   skb-&gt;nh.iph-&gt;daddr, th-&gt;dest,
			   inet_iif(skb));

	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sk)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">no_tcp_socket</span>;

<span style="color: #AF87FF;">process</span>: <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36755;&#25511;&#21046;&#22359;&#22788;&#20110;TCP_TIME_WAIT&#29366;&#24577;</span>
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state == TCP_TIME_WAIT)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">do_time_wait</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214;IPSec&#31574;&#30053;&#25968;&#25454;&#24211;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_and_relse</span>;
	nf_reset(skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;SKB&#20013;&#21644;netfilter&#30456;&#20851;&#30340;&#25104;&#21592;&#12290;</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#23433;&#35013;&#20102;&#36807;&#28388;&#22120;&#65292;&#21017;&#36827;&#34892;&#36807;&#28388;&#65292;&#31526;&#21512;&#26465;&#20214;&#30340;&#25165;&#33021;&#25918;&#34892;</span>
	<span style="color: #FF1493;">if</span> (sk_filter(sk, skb))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_and_relse</span>;

	skb-&gt;dev = <span style="color: #AF87FF;">NULL</span>;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27492;&#26102;&#24050;&#32463;&#19981;&#38656;&#35201;dev</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;TCP&#27573;&#21069;&#38656;&#35201;&#21152;&#38145;&#65292;&#20197;&#21516;&#27493;&#23545;&#20256;&#36755;&#25511;&#21046;&#22359;&#25509;&#25910;&#38431;&#21015;&#30340;&#35775;&#38382;&#12290;</span>
	bh_lock_sock_nested(sk);
	ret = 0;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sock_owned_by_user(sk)) { <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#27492;&#26102;&#27809;&#26377;&#36827;&#31243;&#35775;&#38382;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;</span>
<span style="color: #8B8878;">        &#21017;&#21487;&#20197;&#35843;&#29992; tcp_v4_do_rcv()&#36827;&#34892;&#27491;&#24120;&#25509;&#25910;</span><span style="color: #8B8878;">  */</span>
<span style="color: #FF1493;">#ifdef</span> CONFIG_NET_DMA
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;ucopy.dma_chan &amp;&amp; tp-&gt;ucopy.pinned_list)
			tp-&gt;ucopy.dma_chan = get_softnet_dma();
		<span style="color: #FF1493;">if</span> (tp-&gt;ucopy.dma_chan)
			ret = tcp_v4_do_rcv(sk, skb);
		<span style="color: #FF1493;">else</span>
<span style="color: #FF1493;">#endif</span>
		{
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tcp_prequeue(sk, skb))
			ret = tcp_v4_do_rcv(sk, skb);
		}
	} <span style="color: #FF1493;">else</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21542;&#21017;&#28155;&#21152;&#21040;&#21518;&#22791;&#38431;&#21015; sk_backlog &#20013;</span>
		sk_add_backlog(sk, skb);
	bh_unlock_sock(sk);

	sock_put(sk);

	<span style="color: #FF1493;">return</span> ret;

<span style="color: #AF87FF;">no_tcp_socket</span>: <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#27809;&#26377;&#21019;&#24314;&#20256;&#36755;&#25511;&#21046;&#22359;&#25509;&#25910;&#21040;&#25253;&#25991;&#30340;&#24773;&#20917;&#65292;&#36890;&#24120;&#21709;&#24212;RST&#27573;&#12290;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>xfrm4_policy_check(<span style="color: #AF87FF;">NULL</span>, XFRM_POLICY_IN, skb))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_it</span>;

	<span style="color: #FF1493;">if</span> (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete(skb)) {
<span style="color: #AF87FF;">bad_packet</span>:
		TCP_INC_STATS_BH(TCP_MIB_INERRS);
	} <span style="color: #FF1493;">else</span> {
		tcp_v4_send_reset(<span style="color: #AF87FF;">NULL</span>, skb);
	}

<span style="color: #AF87FF;">discard_it</span>:
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Discard frame.</span><span style="color: #8B8878;"> */</span>
	kfree_skb(skb);
	<span style="color: #FF1493;">return</span> 0;

<span style="color: #AF87FF;">discard_and_relse</span>:
	sock_put(sk);
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_it</span>;

<span style="color: #AF87FF;">do_time_wait</span>:
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>xfrm4_policy_check(<span style="color: #AF87FF;">NULL</span>, XFRM_POLICY_IN, skb)) {
		inet_twsk_put(inet_twsk(sk));
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_it</span>;
	}

	<span style="color: #FF1493;">if</span> (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete(skb)) {
		TCP_INC_STATS_BH(TCP_MIB_INERRS);
		inet_twsk_put(inet_twsk(sk));
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_it</span>;
	}
	<span style="color: #FF1493;">switch</span> (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
	<span style="color: #FF1493;">case</span> TCP_TW_SYN: {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk2</span> = inet_lookup_listener(&amp;tcp_hashinfo,
							skb-&gt;nh.iph-&gt;daddr,
							th-&gt;dest,
							inet_iif(skb));
		<span style="color: #FF1493;">if</span> (sk2) {
			inet_twsk_deschedule(inet_twsk(sk), &amp;tcp_death_row);
			inet_twsk_put(inet_twsk(sk));
			sk = sk2;
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">process</span>;
		}
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Fall through to ACK</span><span style="color: #8B8878;"> */</span>
	}
	<span style="color: #FF1493;">case</span> TCP_TW_ACK:
		tcp_v4_timewait_ack(sk, skb);
		<span style="color: #FF1493;">break</span>;
	<span style="color: #FF1493;">case</span> TCP_TW_RST:
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">no_tcp_socket</span>;
	<span style="color: #FF1493;">case</span> TCP_TW_SUCCESS:;
	}
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_it</span>;
}
</pre>
</div>
</div>


<div id="outline-container-orgb5e2ad7" class="outline-3">
<h3 id="orgb5e2ad7"><span class="section-number-3">2.1</span> 接收到prequeue队列</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在未启用tcp_low_latency时，如果用户进程正在读取数据，则将接收到的TCP段直接加入到prequeue队列中，只有当prequeue队列消耗的内存大于接收缓冲区时，才会立即处理prequeue队列中的段，才能在软中断中复制数据到用户空间中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Packet is added to VJ-style prequeue for processing in process</span>
<span style="color: #8B8878;"> * context, if a reader task is waiting. Apparently, this exciting</span>
<span style="color: #8B8878;"> * idea (VJ's mail "Re: query about TCP header on tcp-ip" of 07 Sep 93)</span>
<span style="color: #8B8878;"> * failed somewhere. Latency? Burstiness? Well, at least now we will</span>
<span style="color: #8B8878;"> * see, why it failed. 8)8)                               --ANK</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> * NOTE: is this not too big to inline?</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_prequeue</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24517;&#39035;&#22312;&#26410;&#21551;&#29992;tcp_low_latency,&#19988;&#29992;&#25143;&#36827;&#31243;&#27491;&#22312;&#35835;&#21462;&#25968;&#25454;&#30340;&#24773;&#20917;&#19979;&#65292;&#25165;&#33021;&#28155;&#21152;&#21040;prequeue&#38431;&#21015;&#12290;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sysctl_tcp_low_latency &amp;&amp; tp-&gt;ucopy.task) {
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28155;&#21152;&#21040;prequeue&#38431;&#21015;&#12290;</span>
		__skb_queue_tail(&amp;tp-&gt;ucopy.prequeue, skb);
		tp-&gt;ucopy.memory += skb-&gt;truesize;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;prequeue&#38431;&#21015;&#28040;&#32791;&#30340;&#20869;&#23384;</span>
		<span style="color: #FF1493;">if</span> (tp-&gt;ucopy.memory &gt; sk-&gt;sk_rcvbuf) {  <span style="color: #8B8878;">/*</span><span style="color: #8B8878;">prequeue&#38431;&#21015;&#28040;&#32791;&#30340;&#20869;&#23384;&#36229;&#36807;&#25509;&#25910;&#32531;&#23384;&#19978;&#38480;&#65292;</span>
<span style="color: #8B8878;">                &#21017;&#31435;&#21051;&#22788;&#29702;prequeue&#38431;&#21015;&#19978;&#30340;&#27573;</span><span style="color: #8B8878;"> */</span>
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb1</span>;

			BUG_ON(sock_owned_by_user(sk));

			<span style="color: #FF1493;">while</span> ((skb1 = __skb_dequeue(&amp;tp-&gt;ucopy.prequeue)) != <span style="color: #AF87FF;">NULL</span>) {
				sk-&gt;sk_backlog_rcv(sk, skb1);
				NET_INC_STATS_BH(LINUX_MIB_TCPPREQUEUEDROPPED);
			}

			tp-&gt;ucopy.memory = 0;
		} <span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (skb_queue_len(&amp;tp-&gt;ucopy.prequeue) == 1) { <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#27809;&#36229;&#36807;&#25509;&#25910;&#32531;&#23384;&#19978;&#38480;&#65292;&#19988;prequeue&#38431;&#21015;&#20013;&#21482;&#23384;&#22312;</span>
<span style="color: #8B8878;">                &#19968;&#20010;SKB</span><span style="color: #8B8878;"> */</span>
			wake_up_interruptible(sk-&gt;sk_sleep);
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>inet_csk_ack_scheduled(sk))  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#26080;&#38656;&#21457;&#36865;ACK&#65292;&#21017;&#22797;&#20301;&#37325;&#26032;&#21551;&#21160;&#24310;&#26102;&#30830;&#35748;&#23450;&#26102;&#22120;&#12290;</span>
				inet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,
							  (3 * TCP_RTO_MIN) / 4,
							  TCP_RTO_MAX);
		}
		<span style="color: #FF1493;">return</span> 1;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#34920;&#31034;&#24050;&#32463;&#28155;&#21152;&#21040;prequeue&#38431;&#21015;&#25110;&#32773;&#24050;&#32463;&#34987;&#22788;&#29702;</span>
	}
	<span style="color: #FF1493;">return</span> 0; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#34920;&#31034;&#26410;&#34987;&#22788;&#29702;&#65292;&#38656;&#35201;&#32487;&#32493;&#25509;&#25910;&#22788;&#29702;</span>
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org889fdbb" class="outline-3">
<h3 id="org889fdbb"><span class="section-number-3">2.2</span> 有效TCP段的处理</h3>
<div class="outline-text-3" id="text-2-2">
<p>
TCP传输层接收到段之后，经过简单校验，并查找到该段所属的传输控制块后，除非处于FIN_WAIT_2或TIME_WAIT状态，否则都会调用tcp_v4_do_rcv()作具体的处理。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">The socket must have it's spinlock held when we get</span>
<span style="color: #8B8878;"> * here.</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> * We have a potential double-lock case here, so even when</span>
<span style="color: #8B8878;"> * doing backlog processing we use the BH locking scheme.</span>
<span style="color: #8B8878;"> * This is because we cannot sleep with the original spinlock</span>
<span style="color: #8B8878;"> * held.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_v4_do_rcv</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">rsk</span>;
<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         * We really want to reject the packet as early as possible</span>
<span style="color: #8B8878;">         * if:</span>
<span style="color: #8B8878;">         *  o We're expecting an MD5'd packet and this is no MD5 tcp option</span>
<span style="color: #8B8878;">         *  o There is an MD5 option and we're not expecting one</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">if</span> (tcp_v4_inbound_md5_hash(sk, skb))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29366;&#24577;&#20026;TCP_ESTABLISHED,&#21017;&#35843;&#29992;tcp_rcv_established()&#25509;&#25910;&#22788;&#29702;&#12290;</span>
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state == TCP_ESTABLISHED) { <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Fast path</span><span style="color: #8B8878;"> */</span>
		TCP_CHECK_TIMER(sk);
		<span style="color: #FF1493;">if</span> (tcp_rcv_established(sk, skb, skb-&gt;h.th, skb-&gt;len)) {
			rsk = sk;
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">reset</span>;
		}
		TCP_CHECK_TIMER(sk);
		<span style="color: #FF1493;">return</span> 0;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26657;&#39564;&#25253;&#25991;&#30340;&#38271;&#24230;&#21644;&#26657;&#39564;&#30721;&#65292;&#22914;&#26524;&#22833;&#36133;&#21017;&#36339;&#36716;&#21040;csum_err&#22788;&#32479;&#35745;&#21518;&#20002;&#24323;</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;len &lt; (skb-&gt;h.th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete(skb))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">csum_err</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#34987;&#21160;&#25171;&#24320;&#65292;&#21017;&#26159;&#22788;&#29702;&#19977;&#27425;&#25569;&#25163;&#30340;&#26368;&#21518;&#19968;&#27425;&#25569;&#25163;&#30340;ACK&#27573;&#65292;&#24314;&#31435;&#36830;&#25509;</span>
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state == TCP_LISTEN) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">nsk</span> = tcp_v4_hnd_req(sk, skb);
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>nsk)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;

		<span style="color: #FF1493;">if</span> (nsk != sk) {
			<span style="color: #FF1493;">if</span> (tcp_child_process(sk, nsk, skb)) {
				rsk = nsk;
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">reset</span>;
			}
			<span style="color: #FF1493;">return</span> 0;
		}
	}

	TCP_CHECK_TIMER(sk);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#38500;&#20102;ESTABLISHED &#21644; TIME_WAIT&#29366;&#24577;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#22914;&#26524;&#22788;&#29702;&#20986;&#38169;&#65292;&#21017;&#21457;&#36865;RST&#27573;</span>
	<span style="color: #FF1493;">if</span> (tcp_rcv_state_process(sk, skb, skb-&gt;h.th, skb-&gt;len)) {
		rsk = sk;
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">reset</span>;
	}
	TCP_CHECK_TIMER(sk);
	<span style="color: #FF1493;">return</span> 0;

<span style="color: #AF87FF;">reset</span>:
	tcp_v4_send_reset(rsk, skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;reset</span>
<span style="color: #AF87FF;">discard</span>:
	kfree_skb(skb);
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Be careful here. If this function gets more complicated and</span>
<span style="color: #8B8878;">         * gcc suffers from register pressure on the x86, sk (in %ebx)</span>
<span style="color: #8B8878;">         * might be destroyed here. This current version compiles correctly,</span>
<span style="color: #8B8878;">         * but you have been warned.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">return</span> 0;

<span style="color: #AF87FF;">csum_err</span>:
	TCP_INC_STATS_BH(TCP_MIB_INERRS);
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org72d54af" class="outline-2">
<h2 id="org72d54af"><span class="section-number-2">3</span> 报文的过滤</h2>
<div class="outline-text-2" id="text-3">
<p>
现在无论是PF_PACKET类型的套接口还是PF_INET类型的套接口，Linux都支持内核过滤。内核允许把过滤器直接挂接到PF_PACKET或者PF_INET类型的套接口处理例程中。当确定了接收到的包所属的传输层套接口后，调用过滤函数，TCP和UDP中过滤函数为sk_filter()。
</p>
</div>

<div id="outline-container-org6c0b6b7" class="outline-3">
<h3 id="org6c0b6b7"><span class="section-number-3">3.1</span> 过滤器的数据结构</h3>
<div class="outline-text-3" id="text-3-1">
<p>
设置BPF过滤器是通过setsockopt调用来完成的，格式如下：
    <code>setsockopt(s, SOL_SOCKET, SO_ATTACH_FILTER, &amp;Filter, sizeof(Filter))</code>;
</p>
</div>

<div id="outline-container-org6a44077" class="outline-4">
<h4 id="org6a44077"><span class="section-number-4">3.1.1</span> sock_fprog结构</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
setsockopt函数的第四个参数Filter为sock_fprog结构类型。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_fprog</span>       <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Required for SO_ATTACH_FILTER.</span><span style="color: #8B8878;"> */</span>
{
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">short</span>          <span style="color: #FF8C00;">len</span>;      <span style="color: #8B8878;">//</span><span style="color: #8B8878;">filter&#25351;&#21521;&#30340;sock_filter&#32467;&#26500;&#25968;&#32452;&#30340;&#38271;&#24230;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_filter</span> <span style="color: #5FD7FF;">__user</span> *<span style="color: #FF8C00;">filter</span>;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25351;&#21521;&#30340;sock_filter&#32467;&#26500;&#25968;&#32452;</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc7c2c77" class="outline-4">
<h4 id="orgc7c2c77"><span class="section-number-4">3.1.2</span> sock_filter结构</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
sock_filter结构为BPF过滤代码，结构定义如下：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      Try and keep these values and structures similar to BSD, especially</span>
<span style="color: #8B8878;"> *      the BPF code definitions which need to match so you can share filters</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_filter</span>      <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Filter block</span><span style="color: #8B8878;"> */</span>
{
	<span style="color: #5FD7FF;">__u16</span>   <span style="color: #FF8C00;">code</span>;   <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25351;&#20196;&#32534;&#30721;&#65292; &#21160;&#20316;&#21253;&#25324; &#27604;&#36739; &#20559;&#31227; &#36820;&#22238;</span><span style="color: #8B8878;">  */</span>
	<span style="color: #5FD7FF;">__u8</span>    <span style="color: #FF8C00;">jt</span>;     <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#27604;&#36739;&#25805;&#20316;&#25104;&#21151;&#21518;&#65292;&#36339;&#36716;&#21040;&#25351;&#20196;&#25968;&#25454;jt&#22788;&#65292;&#20570;&#19979;&#19968;&#27493;&#36807;&#28388;&#25805;&#20316;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">__u8</span>    <span style="color: #FF8C00;">jf</span>;     <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#27604;&#36739;&#25805;&#20316;&#22833;&#36133;&#21518;&#65292;&#36339;&#36716;&#21040;&#25351;&#20196;&#25968;&#32452;jf&#22788;&#65292;&#20570;&#19979;&#19968;&#27493;&#36807;&#28388;&#28818;&#20316;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">__u32</span>   <span style="color: #FF8C00;">k</span>;      <span style="color: #CDC673;">/** &#24403;&#21160;&#20316;code&#20026;&#20559;&#31227;&#26102;&#65292;k&#26159;&#24403;&#21069;&#35835;&#21462;&#25968;&#25454;&#21253;&#30340;&#20559;&#31227;&#37327;&#65292;&#21333;&#20301;&#26159; &#23383;&#33410; &#25110; &#23383; &#25110; &#21452;&#23383;</span>
<span style="color: #CDC673;">                              &#24403;&#21160;&#20316;code&#20026;&#27604;&#36739;&#26102;&#65292;k&#26159;&#19982;&#25351;&#38024;&#25351;&#21521;&#30340;&#25968;&#25454;&#21253;&#24403;&#21069;&#20301;&#32622;&#27604;&#36739;&#30340;&#20540;*/</span>
};
</pre>
</div>

<p>
以下是一个示例：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ tcpdump -d host 192.168.1.2
Warning: assuming Ethernet
(000) ldh      [12]
(001) jeq      <span style="color: #8B8878;">#</span><span style="color: #8B8878;">0x800           jt 2    jf 6</span>
(002) ld       [26]
(003) jeq      <span style="color: #8B8878;">#</span><span style="color: #8B8878;">0xc0a80102      jt 12   jf 4</span>
(004) ld       [30]
(005) jeq      <span style="color: #8B8878;">#</span><span style="color: #8B8878;">0xc0a80102      jt 12   jf 13</span>
(006) jeq      <span style="color: #8B8878;">#</span><span style="color: #8B8878;">0x806           jt 8    jf 7</span>
(007) jeq      <span style="color: #8B8878;">#</span><span style="color: #8B8878;">0x8035          jt 8    jf 13</span>
(008) ld       [28]
(009) jeq      <span style="color: #8B8878;">#</span><span style="color: #8B8878;">0xc0a80102      jt 12   jf 10</span>
(010) ld       [38]
(011) jeq      <span style="color: #8B8878;">#</span><span style="color: #8B8878;">0xc0a80102      jt 12   jf 13</span>
(012) ret      <span style="color: #8B8878;">#</span><span style="color: #8B8878;">262144</span>
(013) ret      <span style="color: #8B8878;">#</span><span style="color: #8B8878;">0</span>
</pre>
</div>

<ul class="org-ul">
<li>0-1 确定过滤的是不是IP报</li>
<li>2-5 确定过滤的IP包源地址或目的地址是不是191.168.1.2</li>
<li>6-7 确定过滤的包是ARP还是RARP包</li>
<li>8-11 确定过滤的ARP/RARP包源地址或目的地址是不是192.168.1.2</li>
<li>12 如果比较成功，则跳转到此，将数据包中前96个字节传递给用户进程</li>
<li>13 如果比较失败，则丢弃</li>
</ul>

<p>
注意： 不同的协议，地址值在帧中的偏移值是不同的，所以在以上比较指令之前的一个指令通常是调整当前的偏移。
</p>

<p>
要把以上的过滤规则安装到系统中，实际上也不必手动编写sock_filter结构数组中的过滤编码，使用 <code>tcpdump -dd host 192.168.1.2命令便可以实现</code> ，然后复制到代码中即可，如下所示：
</p>

<div class="org-src-container">
<pre class="src src-c">$ tcpdump -dd host 192.168.1.2
Warning: assuming Ethernet
{ 0x28, 0, 0, 0x0000000c },
{ 0x15, 0, 4, 0x00000800 },
{ 0x20, 0, 0, 0x0000001a },
{ 0x15, 8, 0, 0xc0a80102 },
{ 0x20, 0, 0, 0x0000001e },
{ 0x15, 6, 7, 0xc0a80102 },
{ 0x15, 1, 0, 0x00000806 },
{ 0x15, 0, 5, 0x00008035 },
{ 0x20, 0, 0, 0x0000001c },
{ 0x15, 2, 0, 0xc0a80102 },
{ 0x20, 0, 0, 0x00000026 },
{ 0x15, 0, 1, 0xc0a80102 },
{ 0x6, 0, 0, 0x00040000 },
{ 0x6, 0, 0, 0x00000000 },
</pre>
</div>
</div>
</div>

<div id="outline-container-org89ee319" class="outline-4">
<h4 id="org89ee319"><span class="section-number-4">3.1.3</span> sk_filter结构</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
sk_filter结构可以说是与sock_fprog结构相对应的。安装过滤器时，过滤规则会从用户空间的sk_filter结构中复制到内核空间的sk_filter结构中。只是sk_filter结构只能在内核中使用，并且除了存储过滤规则之外，还多了一些其他的成员，定义如下：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_filter</span>
{
	<span style="color: #5FD7FF;">atomic_t</span>                <span style="color: #FF8C00;">refcnt</span>;      <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24341;&#29992;&#35745;&#25968;&#65292;&#21487;&#33021;&#23384;&#22312;&#22810;&#20010;&#20256;&#36755;&#25511;&#21046;&#22359;&#20849;&#20139;&#19968;&#20010;&#36807;&#28388;&#35268;&#21017;</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span>            <span style="color: #FF8C00;">len</span>;    <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36807;&#28388;&#35268;&#21017;sock_filter&#32467;&#26500;&#25968;&#32452;&#30340;&#38271;&#24230;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rcu_head</span>         <span style="color: #FF8C00;">rcu</span>;   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21368;&#36733;&#36807;&#28388;&#22120;&#26102;&#65292;&#29992;&#35813;&#25104;&#21592;&#20316;&#20026;&#38142;&#34920;&#33410;&#28857;&#21152;&#20837;&#21040;rcu_bh_data&#38142;&#34920;&#20013;&#65292;&#20043;&#21518;&#22312;&#36866;&#24403;&#30340;&#26102;&#20505;&#25165;&#30495;&#27491;&#30340;&#37322;&#25918;&#12290;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_filter</span>      <span style="color: #FF8C00;">insns</span>[0]; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23384;&#20648;&#36807;&#28388;&#35268;&#21017;&#30340;&#25968;&#32452;&#22320;&#22336;&#12290;</span>
};
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org474c286" class="outline-3">
<h3 id="org474c286"><span class="section-number-3">3.2</span> 安装过滤器</h3>
<div class="outline-text-3" id="text-3-2">
<p>
安装过滤器是通过setsockopt系统调用进行，主要从用户空间复制过滤规则到内核空间，然后安装到对应的传输控制块上。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">sock_setsockopt</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">socket</span> *<span style="color: #FF8C00;">sock</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">level</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">optname</span>,
		    <span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">__user</span> *optval, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">optlen</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>=sock-&gt;sk;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_filter</span> *<span style="color: #FF8C00;">filter</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #FF1493;">switch</span>(optname)
	{
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
		<span style="color: #FF1493;">case</span> SO_ATTACH_FILTER:
			ret = -EINVAL;
			<span style="color: #FF1493;">if</span> (optlen == <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_fprog</span>)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26657;&#39564;&#21442;&#25968;&#30340;&#26377;&#25928;&#24615;</span>
				<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_fprog</span> <span style="color: #FF8C00;">fprog</span>;
				ret = -EFAULT;
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;sock_fprog&#32467;&#26500;&#22797;&#21046;&#21040;&#20869;&#26680;&#31354;&#38388;</span>
				<span style="color: #FF1493;">if</span> (copy_from_user(&amp;fprog, optval, <span style="color: #FF1493;">sizeof</span>(fprog)))
					<span style="color: #FF1493;">break</span>;
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36890;&#36807;sk_attach_filter&#23433;&#35013;&#36807;&#28388;&#22120;</span>
				ret = sk_attach_filter(&amp;fprog, sk);
			}
			<span style="color: #FF1493;">break</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
}
</pre>
</div>

<p>
sk_attach_filter()为套接口安装过滤器，参数fprog为待安装的过滤器，sk为安装的目标传输控制块。返回0表示成功。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;"> *      sk_attach_filter - attach a socket filter</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@fprog</span><span style="color: #CDC673;">: the filter program</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@sk</span><span style="color: #CDC673;">: the socket to use</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> * Attach the user's filter code. We first run some sanity checks on</span>
<span style="color: #CDC673;"> * it to make sure it does not explode on us later. If an error</span>
<span style="color: #CDC673;"> * occurs or there is insufficient memory for the filter a negative</span>
<span style="color: #CDC673;"> * errno code is returned. On success the return is zero.</span>
<span style="color: #CDC673;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">sk_attach_filter</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_fprog</span> *<span style="color: #FF8C00;">fprog</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_filter</span> *<span style="color: #FF8C00;">fp</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">fsize</span> = <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_filter</span>) * fprog-&gt;len;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#30830;&#20445;&#26377;&#26032;&#30340;&#36807;&#28388;&#22120;&#24182;&#19988;&#25968;&#37327;&#27491;&#30830;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (fprog-&gt;filter == <span style="color: #AF87FF;">NULL</span>)
		<span style="color: #FF1493;">return</span> -EINVAL;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20026;&#20256;&#36755;&#25511;&#21046;&#22359;&#20998;&#37197;&#29992;&#20110;&#20445;&#23384;&#24453;&#23433;&#35013;&#30340;&#36807;&#28388;&#22120;&#30340;&#32531;&#23384;</span>
	fp = sock_kmalloc(sk, fsize+<span style="color: #FF1493;">sizeof</span>(*fp), GFP_KERNEL);
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>fp)
		<span style="color: #FF1493;">return</span> -ENOMEM;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#36807;&#28388;&#22120;&#20174;&#29992;&#25143;&#31354;&#38388;&#22797;&#21046;&#21040;&#26032;&#20998;&#37197;&#30340;&#32531;&#23384;&#20013;</span>
	<span style="color: #FF1493;">if</span> (copy_from_user(fp-&gt;insns, fprog-&gt;filter, fsize)) {
		sock_kfree_s(sk, fp, fsize+<span style="color: #FF1493;">sizeof</span>(*fp));
		<span style="color: #FF1493;">return</span> -EFAULT;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22686;&#21152;&#24341;&#29992;</span>
	atomic_set(&amp;fp-&gt;refcnt, 1);
	fp-&gt;len = fprog-&gt;len; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#36807;&#28388;&#22120;&#38271;&#24230;</span>
	<span style="color: #CDC673;">/** &#35843;&#29992;</span><span style="color: #AF87FF;">sk_chk_filter()</span><span style="color: #CDC673;">&#23545;&#36807;&#28388;&#22120;&#36827;&#34892;&#21512;&#27861;&#24615;&#26816;&#26597;&#65292;&#20027;&#35201;&#26159;&#26816;&#26597;&#25805;&#20316;&#20195;&#30721;&#26159;&#21542;&#22312;&#23450;&#20041;&#30340;&#33539;&#22260;&#20869;&#65292;</span>
<span style="color: #CDC673;">        &#20063;&#23601;&#26159;&#26816;&#26597;&#20195;&#30721;&#20013;&#26159;&#21542;&#23384;&#22312;&#26410;&#30693;&#30340;&#25351;&#20196;&#12290;&#22914;&#26524;&#26816;&#26597;&#27491;&#24120;&#65292;&#23601;&#21487;&#20197;&#23433;&#35013;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;sk_filter&#19978;&#12290;</span>
<span style="color: #CDC673;">        &#22914;&#26524;&#21407;&#20808;&#23384;&#22312;&#36807;&#28388;&#22120;&#65292;&#21017;&#21462;&#20986;&#24182;&#37322;&#25918;*/</span>
	err = sk_chk_filter(fp-&gt;insns, fp-&gt;len);
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>err) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_filter</span> *<span style="color: #FF8C00;">old_fp</span>;

		rcu_read_lock_bh();
		old_fp = rcu_dereference(sk-&gt;sk_filter);
		rcu_assign_pointer(sk-&gt;sk_filter, fp);
		rcu_read_unlock_bh();
		fp = old_fp;
	}

	<span style="color: #FF1493;">if</span> (fp)
		sk_filter_release(sk, fp);
	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org6d279fa" class="outline-3">
<h3 id="org6d279fa"><span class="section-number-3">3.3</span> 卸载过滤器</h3>
<div class="outline-text-3" id="text-3-3">
<p>
卸载过滤器也是通过setsockopt系统调用。
    <code>setsockopt(s, SOL_SOCKET, SO_DETACH_FILTER, &amp;dummy, sizeof(dummy))</code>;
</p>

<p>
卸载过滤器的setsockopt系统调用参数比较简单，只需关注前三个，后两个是为了符合系统调用参数格式。setsockopt系统调用的实现中会对optlen做检测，不能小雨一个整形字长，因此不能使用NULL,而形如int dummy就可以。
</p>

<p>
卸载过滤器也比较简单，从传输控制块上移出过滤器并释放。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">sock_setsockopt</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">socket</span> *<span style="color: #FF8C00;">sock</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">level</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">optname</span>,
		    <span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">__user</span> *optval, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">optlen</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>=sock-&gt;sk;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_filter</span> *<span style="color: #FF8C00;">filter</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #FF1493;">case</span> SO_DETACH_FILTER:
		rcu_read_lock_bh();
		filter = rcu_dereference(sk-&gt;sk_filter);
		<span style="color: #FF1493;">if</span> (filter) {
			rcu_assign_pointer(sk-&gt;sk_filter, <span style="color: #AF87FF;">NULL</span>);
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27492;&#22788;&#19981;&#20250;&#30495;&#27491;&#37322;&#25918;&#36807;&#28388;&#22120;&#36164;&#28304;&#65292;&#32780;&#26159;&#23558;&#24102;&#37322;&#25918;&#30340;&#36807;&#28388;&#22120;&#25346;&#36733;&#21040;&#31995;&#32479;&#30340;rcu_bh_data&#20013;&#65292;&#22312;&#36866;&#24403;&#30340;&#26102;&#21051;&#36890;&#36807;&#22238;&#35843;&#37322;&#25918;</span>
			sk_filter_release(sk, filter);
			rcu_read_unlock_bh();
			<span style="color: #FF1493;">break</span>;
		}
		rcu_read_unlock_bh();
		ret = -ENONET;
		<span style="color: #FF1493;">break</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
}

<span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;"> *      sk_filter_release: Release a socket filter</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@sk</span><span style="color: #CDC673;">: socket</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@fp</span><span style="color: #CDC673;">: filter to remove</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> *      Remove a filter from a socket and release its resources.</span>
<span style="color: #CDC673;"> */</span>

<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">sk_filter_release</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_filter</span> *<span style="color: #FF8C00;">fp</span>)
{
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">size</span> = sk_filter_len(fp); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#36807;&#28388;&#22120;&#30340;&#22823;&#23567;</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#25972;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;sk_omem_alloc</span>
	atomic_sub(size, &amp;sk-&gt;sk_omem_alloc);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36882;&#20943;&#36807;&#28388;&#22120;&#30340;&#24341;&#29992;&#35745;&#25968;&#65292;&#22914;&#26524;&#36882;&#20943;&#21518;&#19981;&#20026;0&#65292;&#21017;&#36824;&#26377;&#24341;&#29992;&#65292;&#21017;&#23558;&#20854;&#25346;&#36733;&#21040;rcu_bh_data,&#20043;&#21518;&#36890;&#36807;sk_filter_rcv_free&#37322;&#25918;</span>
	<span style="color: #FF1493;">if</span> (atomic_dec_and_test(&amp;fp-&gt;refcnt))
		call_rcu_bh(&amp;fp-&gt;rcu, sk_filter_rcu_free);
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org945dc1c" class="outline-3">
<h3 id="org945dc1c"><span class="section-number-3">3.4</span> 过滤执行</h3>
<div class="outline-text-3" id="text-3-4">
<p>
sk_filter()封装了套接口层的过滤器sk_run_filter()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;"> *      sk_filter - run a packet through a socket filter</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@sk</span><span style="color: #CDC673;">: sock associated with &amp;sk_buff</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@skb</span><span style="color: #CDC673;">: buffer to filter</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@needlock</span><span style="color: #CDC673;">: set to 1 if the sock is not locked by caller.</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> * Run the filter code and then cut skb-&gt;data to correct size returned by</span>
<span style="color: #CDC673;"> * sk_run_filter. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller</span>
<span style="color: #CDC673;"> * than pkt_len we keep whole skb-&gt;data. This is the socket level</span>
<span style="color: #CDC673;"> * wrapper to sk_run_filter. It returns 0 if the packet should</span>
<span style="color: #CDC673;"> * be accepted or -EPERM if the packet should be tossed.</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> */</span>

<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">sk_filter</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_filter</span> *<span style="color: #FF8C00;">filter</span>;

	err = security_sock_rcv_skb(sk, skb);
	<span style="color: #FF1493;">if</span> (err)
		<span style="color: #FF1493;">return</span> err;

	rcu_read_lock_bh();
	filter = sk-&gt;sk_filter;
	<span style="color: #FF1493;">if</span> (filter) {<span style="color: #CDC673;">/** &#22914;&#26524;&#23433;&#35013;&#20102;&#36807;&#28388;&#22120;&#65292;&#21017;&#35843;&#29992;sk_run_filter&#36807;&#28388;&#12290;</span>
<span style="color: #CDC673;">        &#35813;&#20989;&#25968;&#30340;&#23454;&#29616;&#31867;&#20284;&#27719;&#32534;&#31243;&#24207;&#30340;&#35299;&#37322;&#22120;&#65292;&#36827;&#34892;&#25968;&#25454;&#30340;&#27604;&#36739;&#21160;&#20316;&#12290;&#36820;&#22238;&#20540;&#20026;0&#34920;&#31034;&#24453;&#36807;&#28388;&#30340;&#25968;&#25454;&#21253;&#19981;&#31526;&#21512;&#36807;&#28388;&#35268;&#21017;&#65292;&#38656;&#20002;&#24323;&#12290;</span>
<span style="color: #CDC673;">        &#38750;0&#34920;&#26126;&#25968;&#25454;&#21253;&#20013;&#21069;pkt_len&#20010;&#23383;&#33410;&#21487;&#20197;&#32487;&#32493;&#24448;&#19979;&#22788;&#29702;&#65292;&#20256;&#36882;&#32473;&#29992;&#25143;&#36827;&#31243;*/</span>
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">pkt_len</span> = sk_run_filter(skb, filter-&gt;insns,
				filter-&gt;len);
		err = pkt_len ? pskb_trim(skb, pkt_len) : -EPERM; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36890;&#36807;&#36820;&#22238;&#20540;&#21028;&#26029;&#26159;&#20002;&#24323;&#36824;&#26159;&#25918;&#34892;</span>
	}
	rcu_read_unlock_bh();

	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgb2299ae" class="outline-2">
<h2 id="orgb2299ae"><span class="section-number-2">4</span> ESTABLISHED状态的接收</h2>
<div class="outline-text-2" id="text-4">
<p>
tcp_rcv_established()是ESTABLISHED状态下的输入处理函数，为了高效的处理接收到的段，对TCP段处理提供了两种路径。
</p>
<ul class="org-ul">
<li>快速路径：用于处理预期、理想情形下的输入段。正常情况下，TCP连接最常见的情形应该被尽可能的检测并最优化处理，而无需检测一些边缘的情形。</li>
<li>慢速路径：用于所有和预期、理想不对应的且需要进一步处理的段。例如接收段存在除时间戳选项之外选项的段。</li>
</ul>

<p>
通过研究表明，在局域网内通过TCP连接输入的所有数据包中95%以上都执行了快速路径，而在广域网上达到了80%，因此两种路径的区分很有必要。
</p>
</div>

<div id="outline-container-orgfc1f5ee" class="outline-3">
<h3 id="orgfc1f5ee"><span class="section-number-3">4.1</span> 首部预测</h3>
<div class="outline-text-3" id="text-4-1">
<p>
TCP发送是按照序号发送，在网络通信通常的情况下，接收方也是按着发送的顺序接收TCP段。因此首部预测算法通过处理两种常见现象，简化单向数据传输的实现：
</p>
<ul class="org-ul">
<li>如果TCP发送数据，连接上等待接收的下一个段是已发送数据的ACK。</li>
<li>如果TCP接收数据，连接上等待接收的下一个段是顺序到达的数据段。</li>
</ul>

<p>
在以上两种情况下，可以判断收到的段是不是等待接收的段，这也是首部预测的必要条件。如果是，则立即处理，这会比执行慢速路径要快的多。
</p>
</div>

<div id="outline-container-orgb24c113" class="outline-4">
<h4 id="orgb24c113"><span class="section-number-4">4.1.1</span> 设置预测标志：tcp_fast_path_check()</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
设置首部预测标志需要满足以下条件：
</p>
<ol class="org-ol">
<li>缓存乱序队列为空，说明网络比较畅通。</li>
<li>接收窗口不为0，说明当前还能接收数据。</li>
<li>当前已使用的接收缓存没有达到上限，也说明目前还能接收数据。</li>
<li>没有接收到紧急指针，快速路径不处理带外数据。</li>
</ol>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_fast_path_check</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span>)
{
	<span style="color: #FF1493;">if</span> (skb_queue_empty(&amp;tp-&gt;out_of_order_queue) &amp;&amp;
	    tp-&gt;rcv_wnd &amp;&amp;
	    atomic_read(&amp;sk-&gt;sk_rmem_alloc) &lt; sk-&gt;sk_rcvbuf &amp;&amp;
	    <span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;urg_data)
		tcp_fast_path_on(tp);
}

<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__tcp_fast_path_on</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span>, <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">snd_wnd</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#30001;&#20110;&#39318;&#37096;&#39044;&#27979;&#26631;&#24535;&#38656;&#35201;&#30452;&#25509;&#19982;TCP&#39318;&#37096;&#30340;&#23383;&#27573;&#20540;&#27604;&#36739;&#65292;&#25152;&#20197;&#20351;&#29992;&#32593;&#32476;&#23383;&#33410;&#24207;</span>
	<span style="color: #CDC673;">/** &#23558;TCP&#39318;&#37096;&#38271;&#24230;tcp_header_len&#24038;&#31227;26&#20301;&#12290;</span>
<span style="color: #CDC673;">        &#31561;&#21516;&#20110;&#39318;&#20808;&#23558;tcp_header_len&#24038;&#31227;&#20004;&#20301;&#65292;&#24471;&#21040;&#30340;&#38271;&#24230;&#20540;&#35774;&#32622;&#21040;TCP&#39318;&#37096;&#23545;&#24212;&#30340;32&#20301;&#23383;&#30340;27-31&#20301;&#65288;&#24038;&#31227;28&#65289;&#65292;&#20248;&#21270;&#21518;&#23601;&#26159;&#24038;&#31227;26&#20301;&#12290;</span>
<span style="color: #CDC673;">        &#28982;&#21518;&#35774;&#32622;ACK&#26631;&#24535;&#65292;&#20197;&#21450;&#23545;&#26041;&#30340;&#25509;&#25910;&#31383;&#21475;&#22823;&#23567;&#12290;&#21442;&#35265;TCP&#39318;&#37096;&#22270;*/</span>
	tp-&gt;pred_flags = htonl((tp-&gt;tcp_header_len &lt;&lt; 26) |
			       ntohl(TCP_FLAG_ACK) |
			       snd_wnd);

}
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23545;__tcp_fast_path_on&#20989;&#25968;&#30340;&#23553;&#35013;&#65292;&#25552;&#20379;&#21457;&#36865;&#31383;&#21475;&#22823;&#23567;&#65292;&#30001;snd_wnd&#21644;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#35745;&#31639;&#24471;&#21040;</span>
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_fast_path_on</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span>)
{
	__tcp_fast_path_on(tp, tp-&gt;snd_wnd &gt;&gt; tp-&gt;rx_opt.snd_wscale);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org00c7065" class="outline-4">
<h4 id="org00c7065"><span class="section-number-4">4.1.2</span> 预测标志</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
预测标志存储在tcp_sock结构的pred_flags成员中，是首部预测的条件之一，属于必要条件，如果与预测标志不符，则只能执行慢速路径。预测标志是32位无符号整数，如下图：
</p>


<div class="figure">
<p><img src="image/tcp-input/tcp-pred-flags.png" alt="tcp-pred-flags.png" />
</p>
<p><span class="figure-number">Figure 3: </span>预测标志格式</p>
</div>

<p>
预测标志主要用来检测TCP首部的第四个32位字，两者是一一对应的：
</p>

<div class="figure">
<p><img src="image/tcp-input/tcp-hdr-4th32.png" alt="tcp-hdr-4th32.png" />
</p>
<p><span class="figure-number">Figure 4: </span>TCP首部的第4个32位字</p>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      TCP receive function for the ESTABLISHED state.</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> *      It is split into a fast path and a slow path. The fast path is</span>
<span style="color: #8B8878;"> *      disabled when:</span>
<span style="color: #8B8878;"> *      - A zero window was announced from us - zero window probing</span>
<span style="color: #8B8878;"> *        is only handled properly in the slow path.</span>
<span style="color: #8B8878;"> *      - Out of order segments arrived.</span>
<span style="color: #8B8878;"> *      - Urgent data is expected.</span>
<span style="color: #8B8878;"> *      - There is no buffer space left</span>
<span style="color: #8B8878;"> *      - Unexpected TCP flags/window values/header lengths are received</span>
<span style="color: #8B8878;"> *        (detected by checking the TCP header against pred_flags)</span>
<span style="color: #8B8878;"> *      - Data is sent in both directions. Fast path only supports pure senders</span>
<span style="color: #8B8878;"> *        or pure receivers (this means either the sequence number or the ack</span>
<span style="color: #8B8878;"> *        value must stay constant)</span>
<span style="color: #8B8878;"> *      - Unexpected TCP option.</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> *      When these conditions are not satisfied it drops into a standard</span>
<span style="color: #8B8878;"> *      receive procedure patterned after RFC793 to handle all cases.</span>
<span style="color: #8B8878;"> *      The first three cases are guaranteed by proper pred_flags setting,</span>
<span style="color: #8B8878;"> *      the rest is checked inline. Fast processing is turned on in</span>
<span style="color: #8B8878;"> *      tcp_data_queue when everything is OK.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_rcv_established</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);

	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         *      Header prediction.</span>
<span style="color: #8B8878;">         *      The code loosely follows the one in the famous</span>
<span style="color: #8B8878;">         *      "30 instruction TCP receive" Van Jacobson mail.</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         *      Van's trick is to deposit buffers into socket queue</span>
<span style="color: #8B8878;">         *      on a device interrupt, to call tcp_recv function</span>
<span style="color: #8B8878;">         *      on the receive process context and checksum and copy</span>
<span style="color: #8B8878;">         *      the buffer to user space. smart...</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         *      Our current scheme is not silly either but we take the</span>
<span style="color: #8B8878;">         *      extra cost of the net_bh soft interrupt processing...</span>
<span style="color: #8B8878;">         *      We do checksum and copy also but from device to kernel.</span>
<span style="color: #8B8878;">         */</span>

	tp-&gt;rx_opt.saw_tstamp = 0;

	<span style="color: #8B8878;">/*      </span><span style="color: #8B8878;">pred_flags is 0xS?10 &lt;&lt; 16 + snd_wnd</span>
<span style="color: #8B8878;">         *      if header_prediction is to be made</span>
<span style="color: #8B8878;">         *      'S' will always be tp-&gt;tcp_header_len &gt;&gt; 2</span>
<span style="color: #8B8878;">         *      '?' will be 0 for the fast path, otherwise pred_flags is 0 to</span>
<span style="color: #8B8878;">         *  turn it off (when there are holes in the receive</span>
<span style="color: #8B8878;">         *       space for instance)</span>
<span style="color: #8B8878;">         *      PSH flag is ignored.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #CDC673;">/** tcp_flag_word(th) &#39318;&#20808;&#33719;&#21462;TCP&#39318;&#37096;&#20013;&#30340;&#31532;4&#20010;32&#20301;&#23383;&#65292;&#28982;&#21518;&#21644;TCP_HP_BITS&#20570;&#19982;&#25805;&#20316;&#65292;</span>
<span style="color: #CDC673;">        &#23631;&#34109;&#20445;&#30041;&#20301;&#21644;PSH,&#26368;&#21518;&#21644;&#39044;&#27979;&#26631;&#24535;&#20316;&#27604;&#36739;&#65292;&#22914;&#26524;&#36890;&#36807;&#21017;&#36827;&#34892;&#39318;&#37096;&#39044;&#27979;&#30340;&#20854;&#20182;&#27604;&#36739;&#65292;</span>
<span style="color: #CDC673;">        &#21542;&#21017;&#25191;&#34892;&#24930;&#36895;&#36335;&#24452;&#12290;</span>

<span style="color: #CDC673;">        &#22312;&#20247;&#22810;&#26631;&#24535;&#20301;&#20013;&#65292;32&#20301;&#30340;&#30830;&#35748;&#24207;&#21495;&#23383;&#27573;&#21644;ACK&#26631;&#24535;&#24635;&#26159;TCP&#39318;&#37096;&#30340;&#19968;&#37096;&#20998;&#65292;</span>
<span style="color: #CDC673;">        &#22240;&#27492;&#21457;&#36865;ACK&#26080;&#38656;&#20219;&#20309;&#20195;&#20215;&#65292;&#19968;&#26086;&#19968;&#20010;&#36830;&#25509;&#24314;&#31435;&#36215;&#26469;&#65292;ACK&#26631;&#24535;&#24635;&#26159;&#34987;&#35774;&#32622;&#20026;1&#12290;</span>
<span style="color: #CDC673;">        &#32780;PSH&#26631;&#24535;&#20301;&#26159;&#29992;&#26469;&#36890;&#30693;&#23545;&#26041;&#23613;&#24555;&#25509;&#25910;&#30340;&#65292;&#22240;&#27492;&#22312;&#39044;&#27979;&#26631;&#24535;&#20013;&#20250;&#24573;&#30053;PSH&#12290;</span>
<span style="color: #CDC673;">        &#24403;&#39044;&#27979;&#26631;&#24535;&#20026;0&#26102;&#65292;&#34920;&#31034;&#20851;&#38381;&#20102;&#39318;&#37096;&#39044;&#27979;&#65292;&#24517;&#39035;&#25191;&#34892;&#24930;&#36895;&#36335;&#24452;*/</span>
	<span style="color: #FF1493;">if</span> ((tcp_flag_word(th) &amp; TCP_HP_BITS) == tp-&gt;pred_flags &amp;&amp;
		TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) {<span style="color: #CDC673;">/** &#26412;&#27425;&#25509;&#25910;&#21040;TCP&#27573;&#30340;&#24207;&#21495; &#19982; &#31561;&#24453;&#25509;&#25910;&#30340;&#19979;&#19968;&#20010;&#27573;&#30340;&#24207;&#21495;&#27604;&#36739;&#12290;</span>
<span style="color: #CDC673;">                &#30456;&#31561;&#21017;&#32487;&#32493;&#39318;&#37096;&#39044;&#27979;&#30340;&#20854;&#20182;&#27604;&#36739;&#65292;&#21542;&#21017;&#36208;&#24930;&#36895;&#36335;&#24452;*/</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-org367cff9" class="outline-4">
<h4 id="org367cff9"><span class="section-number-4">4.1.3</span> 时间戳选项与PAWS检测</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
通过首部预测后，如果带有时间戳，还需要对时间戳检测。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">tcp_header_len</span> = tp-&gt;tcp_header_len;

<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Timestamp header prediction: tcp_header_len</span>
<span style="color: #8B8878;"> * is automatically equal to th-&gt;doff*4 due to pred_flags</span>
<span style="color: #8B8878;"> * match.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36890;&#36807;TCP&#39318;&#37096;&#38271;&#24230;&#26469;&#26816;&#27979;TCP&#39318;&#37096;&#20013;&#26159;&#21542;&#21482;&#23384;&#22312;&#26102;&#38388;&#25139;&#36873;&#39033;</span>
<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Check timestamp</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">if</span> (tcp_header_len == <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) + TCPOLEN_TSTAMP_ALIGNED) {
	<span style="color: #5FD7FF;">__be32</span> *<span style="color: #FF8C00;">ptr</span> = (<span style="color: #5FD7FF;">__be32</span> *)(th + 1);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">No? Slow path!</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21482;&#36890;&#36807;&#26102;&#38388;&#21028;&#26029;&#26102;&#38388;&#25139;&#36873;&#39033;&#19981;&#20005;&#35880;&#65292;&#20877;&#27425;&#26816;&#27979;&#26102;&#38388;&#25139;</span>
	<span style="color: #FF1493;">if</span> (*ptr != htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16)
			  | (TCPOPT_TIMESTAMP &lt;&lt; 8) | TCPOLEN_TIMESTAMP))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">slow_path</span>;
	<span style="color: #CDC673;">/** &#33719;&#21462;&#26102;&#38388;&#25139;&#65292;&#28982;&#21518;&#23558;&#33719;&#21462;&#21040;&#30340;&#26102;&#38388;&#25139;&#20540;&#21644;&#19979;&#19968;&#20010;&#21457;&#36865;&#30340;TCP&#27573;&#30340;&#26102;&#38388;&#25139;&#22238;&#26174;&#20540;&#30456;&#27604;&#65292;</span>
<span style="color: #CDC673;">        &#20570;PAWS&#26816;&#27979;&#65292;&#22914;&#26524;&#21069;&#32773;&#27604;&#21518;&#32773;&#23567;&#65292;&#21017;&#26102;&#38388;&#25139;&#20540;&#36807;&#26089;&#65292;&#21457;&#29983;&#24207;&#21495;&#22238;&#21367;&#65292;&#36208;&#24930;&#36895;&#36335;&#24452;*/</span>
	tp-&gt;rx_opt.saw_tstamp = 1;
	++ptr;
	tp-&gt;rx_opt.rcv_tsval = ntohl(*ptr);
	++ptr;
	tp-&gt;rx_opt.rcv_tsecr = ntohl(*ptr);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">If PAWS failed, check it more carefully in slow path</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> ((s32)(tp-&gt;rx_opt.rcv_tsval - tp-&gt;rx_opt.ts_recent) &lt; 0)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">slow_path</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">DO NOT update ts_recent here, if checksum fails</span>
<span style="color: #8B8878;">         * and timestamp was corrupted part, it will result</span>
<span style="color: #8B8878;">         * in a hung connection since we will drop all</span>
<span style="color: #8B8878;">         * future packets due to the PAWS test.</span>
<span style="color: #8B8878;">         */</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4a88fe3" class="outline-3">
<h3 id="org4a88fe3"><span class="section-number-3">4.2</span> 接收处理无负荷的ACK段</h3>
<div class="outline-text-3" id="text-4-2">
<p>
TCP在ESTASBLISHED状态下传输的数据，一般都是有负荷的段，因为ACK无需任何代价，因此已接收的段的ACK,一般都是在带有负荷的段中携带。如果没有数据发送，也只能发送一个无负荷的ACK段。因此接收TCP段时，需要判断是否有负荷。
</p>

<div class="org-src-container">
<pre class="src src-c">
<span style="color: #FF1493;">if</span> (len &lt;= tcp_header_len) {
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Bulk data transfer: sender</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (len == tcp_header_len) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Predicted packet is in window by definition.</span>
<span style="color: #8B8878;">                 * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.</span>
<span style="color: #8B8878;">                 * Hence, check seq&lt;=rcv_wup reduces to:</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #CDC673;">/** &#22914;&#26524;TCP&#39318;&#37096;&#20013;&#26377;&#26102;&#38388;&#25139;&#19988;&#25509;&#25910;&#30340;&#27573;&#37117;&#24050;&#32463;&#30830;&#35748;&#65292;&#21017;&#20445;&#23384;&#26102;&#38388;&#25139;&#65292;</span>
<span style="color: #CDC673;">                &#29992;&#20110;&#21457;&#36865;&#19979;&#19968;&#20010;&#27573;&#30340;&#26102;&#38388;&#25139;&#22238;&#26174;*/</span>
		<span style="color: #FF1493;">if</span> (tcp_header_len ==
		    (<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) + TCPOLEN_TSTAMP_ALIGNED) &amp;&amp;
		    tp-&gt;rcv_nxt == tp-&gt;rcv_wup)
			tcp_store_ts_recent(tp);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We know that such packets are checksummed</span>
<span style="color: #8B8878;">                 * on entry.</span>
<span style="color: #8B8878;">                 */</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;ACK</span>
		tcp_ack(sk, skb, 0);
		__kfree_skb(skb);
		tcp_data_snd_check(sk, tp);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;&#26159;&#21542;&#38656;&#35201;&#21457;&#36865;&#25968;&#25454;</span>
		<span style="color: #FF1493;">return</span> 0;
	} <span style="color: #FF1493;">else</span> { <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Header too small</span><span style="color: #8B8878;"> */</span>
		TCP_INC_STATS_BH(TCP_MIB_INERRS);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
	}
</pre>
</div>
</div>
</div>


<div id="outline-container-org755e744" class="outline-3">
<h3 id="org755e744"><span class="section-number-3">4.3</span> 执行快速路径</h3>
<div class="outline-text-3" id="text-4-3">
<p>
通过首部预测后，说明收到的是预期的段，开始处理负荷部分数据。TCP接收数据的目的是把数据复制给用户进程，因此如果可以会尽量的吧数据复制到用户空间。实在不行，再将数据缓存，等待用户进程读取。
</p>


<div class="figure">
<p><img src="image/tcp-input/tcp-fast-path.png" alt="tcp-fast-path.png" />
</p>
<p><span class="figure-number">Figure 5: </span>执行快速路径</p>
</div>

<div class="org-src-container">
<pre class="src src-c">                } <span style="color: #FF1493;">else</span> {
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">eaten</span> = 0;
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">copied_early</span> = 0;
			<span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;">                        &#21028;&#26029;&#26159;&#21542;&#21487;&#20197;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65306;</span>
<span style="color: #CDC673;">                        1. &#27491;&#22312;&#25509;&#25910;&#30340;&#27573;&#30340;&#24207;&#21495;&#26159;&#21542;&#19982;&#23578;&#26410;&#20174;&#20869;&#26680;&#31354;&#38388;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#30340;&#27573;&#26368;&#21069;&#38754;&#30340;&#24207;&#21495;&#30456;&#31561;&#65292;&#21363;&#25509;&#25910;&#38431;&#21015;&#20026;&#31354;&#12290;</span>
<span style="color: #CDC673;">                        2. TCP&#27573;&#20013;&#30340;&#29992;&#25143;&#25968;&#25454;&#38271;&#24230;&#23567;&#20110;&#29992;&#25143;&#31354;&#38388;&#32531;&#23384;&#30340;&#21097;&#20313;&#21487;&#20351;&#29992;&#37327;&#12290;</span>
<span style="color: #CDC673;">                        &#28385;&#36275;&#20197;&#19978;&#20004;&#20010;&#26465;&#20214;&#65292;&#21017;&#21482;&#33021;&#35828;&#26126;&#28385;&#36275;&#20102;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#30340;&#24517;&#35201;&#26465;&#20214;&#12290;</span>
<span style="color: #CDC673;">                        */</span>
			<span style="color: #FF1493;">if</span> (tp-&gt;copied_seq == tp-&gt;rcv_nxt &amp;&amp;
			    len - tcp_header_len &lt;= tp-&gt;ucopy.len) {
<span style="color: #FF1493;">#ifdef</span> CONFIG_NET_DMA
				<span style="color: #FF1493;">if</span> (tcp_dma_try_early_copy(sk, skb, tcp_header_len)) {
					copied_early = 1;
					eaten = 1;
				}
<span style="color: #FF1493;">#endif</span>
<span style="color: #CDC673;">/** &#21482;&#26377;&#24403;&#29992;&#25143;&#36827;&#31243;&#27491;&#22312;&#35843;&#29992;recv&#31867;&#31995;&#32479;&#35843;&#29992;&#20174;&#20869;&#26680;&#35835;&#21462;&#25968;&#25454;&#26102;&#65288;&#29992;&#25143;&#36827;&#31243;&#30561;&#30496;&#65289;&#65292;</span>
<span style="color: #CDC673;">&#19988;&#20256;&#36755;&#23618;&#34987;&#29992;&#25143;&#36827;&#31243;&#38145;&#23450;&#65292;&#21551;&#29992;I/O&#21152;&#36895;&#20197;&#32593;&#32476;DMA&#26041;&#24335;&#22797;&#21046;&#25968;&#25454;&#22833;&#36133;&#26102;&#65292;&#25165;&#21487;&#20197;&#30452;&#25509;</span>
<span style="color: #CDC673;">&#23558;&#25968;&#25454;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;*/</span>
				<span style="color: #FF1493;">if</span> (tp-&gt;ucopy.task == current &amp;&amp; sock_owned_by_user(sk) &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>copied_early) {
					__set_current_state(TASK_RUNNING);

					<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tcp_copy_to_iovec(sk, skb, tcp_header_len))
						eaten = 1;
				}
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#22797;&#21046;&#25968;&#25454;&#21040;&#29992;&#25143;&#31354;&#38388;&#25104;&#21151;&#65292;&#21017;&#26356;&#26032;&#26102;&#38388;&#25139;&#12289;&#24448;&#36820;&#26102;&#38388;&#20197;&#21450;&#31561;&#24453;&#25509;&#25910;&#30340;&#19979;&#19968;&#20010;TCP&#27573;&#30340;&#24207;&#21495;&#12290;</span>
				<span style="color: #FF1493;">if</span> (eaten) {
					<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Predicted packet is in window by definition.</span>
<span style="color: #8B8878;">                                         * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.</span>
<span style="color: #8B8878;">                                         * Hence, check seq&lt;=rcv_wup reduces to:</span>
<span style="color: #8B8878;">                                         */</span>
					<span style="color: #FF1493;">if</span> (tcp_header_len ==
					    (<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) +
					     TCPOLEN_TSTAMP_ALIGNED) &amp;&amp;
					    tp-&gt;rcv_nxt == tp-&gt;rcv_wup)
						tcp_store_ts_recent(tp);

					tcp_rcv_rtt_measure_ts(sk, skb);

					__skb_pull(skb, tcp_header_len);
					tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
					NET_INC_STATS_BH(LINUX_MIB_TCPHPHITSTOUSER);
				}
<span style="color: #CDC673;">/** &#32769;&#29256;&#26412;&#30340;</span><span style="color: #AF87FF;">tcp_clenaup_rbuf()</span><span style="color: #CDC673;">&#20027;&#35201;&#29992;&#26469;&#28165;&#29702;&#25509;&#25910;&#32531;&#23384;&#65292;&#29616;&#22312;&#30340;&#21151;&#33021;&#19982;&#20989;&#25968;&#21517;&#31216;&#24050;&#32463;&#19981;&#31526;&#20102;&#12290;</span>
<span style="color: #CDC673;">&#22914;&#26524;&#26377;&#24517;&#35201;&#31435;&#21363;&#21457;&#36865;ACK&#27573;&#65292;&#21017;&#21457;&#36865;ACK,&#22312;&#27492;&#65292;&#22914;&#26524;&#36890;&#36807;I/O&#21152;&#36895;&#30452;&#25509;&#23558;&#25968;&#25454;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65292;</span>
<span style="color: #CDC673;">&#21017;&#38656;&#35201;&#30830;&#23450;&#26159;&#21542;&#21457;&#36865;ACK&#27573;*/</span>
				<span style="color: #FF1493;">if</span> (copied_early)
					tcp_cleanup_rbuf(sk, skb-&gt;len);
			}
<span style="color: #CDC673;">/** &#22914;&#26524;&#27809;&#26377;&#23558;&#25968;&#25454;&#30452;&#25509;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65292;&#25110;&#32773;&#22797;&#21046;&#22833;&#36133;&#65292;&#21017;&#23545;&#25968;&#25454;&#36827;&#34892;&#26657;&#39564;&#21644;&#26816;&#27979;*/</span>
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>eaten) {
				<span style="color: #FF1493;">if</span> (tcp_checksum_complete_user(sk, skb))
					<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">csum_error</span>;

				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Predicted packet is in window by definition.</span>
<span style="color: #8B8878;">                                 * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.</span>
<span style="color: #8B8878;">                                 * Hence, check seq&lt;=rcv_wup reduces to:</span>
<span style="color: #8B8878;">                                 */</span>
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#30340;&#27573;&#37117;&#24050;&#32463;&#30830;&#35748;&#65292;&#21017;&#26356;&#26032;&#26102;&#38388;&#25139;</span>
				<span style="color: #FF1493;">if</span> (tcp_header_len ==
				    (<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) + TCPOLEN_TSTAMP_ALIGNED) &amp;&amp;
				    tp-&gt;rcv_nxt == tp-&gt;rcv_wup)
					tcp_store_ts_recent(tp);

				tcp_rcv_rtt_measure_ts(sk, skb);
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#25972;&#20010;SKB&#32531;&#20914;&#21306;&#24635;&#38271;&#24230;&#36229;&#36807;&#39044;&#20998;&#37197;&#32531;&#23384;&#38271;&#24230;&#65292;&#21017;&#25191;&#34892;&#24930;&#36895;&#36335;&#24452;</span>
				<span style="color: #FF1493;">if</span> ((<span style="color: #5FD7FF;">int</span>)skb-&gt;truesize &gt; sk-&gt;sk_forward_alloc)
					<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">step5</span>;

				NET_INC_STATS_BH(LINUX_MIB_TCPHPHITS);

<span style="color: #CDC673;">/** &#21024;&#38500;SKB&#20013;&#30340;TCP&#39318;&#37096;&#65292;&#28982;&#21518;&#23558;&#25968;&#25454;&#25253;&#28155;&#21152;&#21040;&#25509;&#25910;&#38431;&#21015;&#20013;&#32531;&#23384;&#36215;&#26469;&#65292;&#31561;&#24453;&#36827;&#31243;&#20027;&#21160;&#35835;&#21462;&#12290;</span>
<span style="color: #CDC673;">&#35774;&#32622;&#35813;SKB&#30340;&#23487;&#20027;&#12289;&#37322;&#25918;&#22238;&#35843;&#20989;&#25968;&#65292;&#26356;&#26032;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#24050;&#20351;&#29992;&#25509;&#25910;&#32531;&#23384;&#24635;&#37327;&#21450;&#39044;&#20998;&#37197;&#32531;&#23384;&#38271;&#24230;&#65292;</span>
<span style="color: #CDC673;">&#27492;&#26102;&#35813;&#22871;&#25509;&#21475;&#24050;&#23646;&#20110;&#24403;&#21069;&#20256;&#36755;&#25511;&#21046;&#22359;&#20102;&#12290;*/</span>
				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Bulk data transfer: receiver</span><span style="color: #8B8878;"> */</span>
				__skb_pull(skb,tcp_header_len);
				__skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);
				sk_stream_set_owner_r(skb, sk);
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#19979;&#19968;&#20010;&#39044;&#26399;&#30340;TCP&#27573;&#24207;&#21495;</span>
				tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
			}
<span style="color: #CDC673;">/** &#26356;&#26032;&#24310;&#26102;&#30830;&#35748;&#25511;&#21046;&#22359;&#65292;&#21516;&#26102;&#26681;&#25454;&#26465;&#20214;&#36827;&#34892;&#24555;&#36895;&#30830;&#35748;&#25110;&#24310;&#26102;&#30830;&#35748;*/</span>
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24310;&#26102;&#30830;&#35748;&#25511;&#21046;&#22359;&#30340;&#26356;&#26032;</span>
			tcp_event_data_recv(sk, tp, skb);
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#21040;&#27573;&#30340;ACK&#24207;&#21495;&#19981;&#31561;&#20110;&#26368;&#26089;&#26410;&#30830;&#35748;&#27573;&#30340;&#24207;&#21495;&#65292;&#21017;&#35843;&#29992;tcp_ack&#22788;&#29702;&#65292;&#28982;&#21518;&#36755;&#20986;&#21457;&#36865;&#38431;&#21015;&#30340;&#27573;</span>
			<span style="color: #FF1493;">if</span> (TCP_SKB_CB(skb)-&gt;ack_seq != tp-&gt;snd_una) {
				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Well, only one small jumplet in fast path...</span><span style="color: #8B8878;"> */</span>
				tcp_ack(sk, skb, FLAG_DATA);
				tcp_data_snd_check(sk, tp);
				<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>inet_csk_ack_scheduled(sk))
					<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">no_ack</span>;
			}
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#26465;&#20214;&#20316;&#24555;&#36895;&#30830;&#35748;&#25110;&#24310;&#26102;&#30830;&#35748;&#25805;&#20316;</span>
			__tcp_ack_snd_check(sk, 0);
<span style="color: #AF87FF;">no_ack</span>:
<span style="color: #FF1493;">#ifdef</span> CONFIG_NET_DMA
			<span style="color: #FF1493;">if</span> (copied_early)
				__skb_queue_tail(&amp;sk-&gt;sk_async_wait_queue, skb);
			<span style="color: #FF1493;">else</span>
<span style="color: #FF1493;">#endif</span>
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#24050;&#32463;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65292;&#21017;&#37322;&#25918;&#35813;SKB&#12290;</span>
<span style="color: #8B8878;">                        &#21542;&#21017;&#35828;&#26126;&#25968;&#25454;&#24050;&#32463;&#23601;&#32490;&#65292;&#21796;&#37266;&#24403;&#21069;&#22871;&#25509;&#21475;&#30340;&#36827;&#31243;&#31561;&#24453;&#38431;&#21015;fasync_list&#19978;&#30340;&#36827;&#31243;&#65292;&#36890;&#30693;&#20854;&#35835;&#21462;&#25968;&#25454;</span><span style="color: #8B8878;">*/</span>
			<span style="color: #FF1493;">if</span> (eaten)
				__kfree_skb(skb);
			<span style="color: #FF1493;">else</span>
				sk-&gt;sk_data_ready(sk, 0);
			<span style="color: #FF1493;">return</span> 0;
		}
	}
</pre>
</div>
</div>
</div>

<div id="outline-container-org023459d" class="outline-3">
<h3 id="org023459d"><span class="section-number-3">4.4</span> 执行慢速路径</h3>
<div class="outline-text-3" id="text-4-4">
<p>
如果不满足快速路径条件俺，则数据报走慢速路径，需要全面的检验。
</p>


<div class="figure">
<p><img src="image/tcp-input/tcp-slow-path.png" alt="tcp-slow-path.png" />
</p>
<p><span class="figure-number">Figure 6: </span>执行慢速路径</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #AF87FF;">slow_path</span>:
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;&#38271;&#24230;&#21644;&#26657;&#39564;&#21644;</span>
	<span style="color: #FF1493;">if</span> (len &lt; (th-&gt;doff&lt;&lt;2) || tcp_checksum_complete_user(sk, skb))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">csum_error</span>;
	<span style="color: #CDC673;">/** &#35843;&#29992;</span><span style="color: #AF87FF;">tcp_fast_parse_options()</span><span style="color: #CDC673;">&#35299;&#26512;TCP&#36873;&#39033;&#65292;&#24182;&#26816;&#26597;&#26102;&#38388;&#25139;&#36873;&#39033;&#12290;&#22914;&#26524;&#39318;&#37096;&#20013;&#23384;&#22312;&#26102;&#38388;&#25139;&#36873;&#39033;&#65292;&#20294;PAWS&#26816;&#39564;&#22833;&#36133;&#65292;</span>
<span style="color: #CDC673;">        &#24182;&#19988;&#19981;&#23384;&#22312;RST&#26631;&#24535;&#65292;&#21017;&#36824;&#38656;&#21457;&#36865;DACK&#32473;&#23545;&#31471;&#65292;&#35828;&#26126;&#25509;&#25910;&#21040;&#30340;TCP&#27573;&#24050;&#32463;&#30830;&#35748;&#36807;&#65292;&#28982;&#21518;&#20002;&#24323;&#35813;&#25968;&#25454;&#21253;&#12290;*/</span>
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         * RFC1323: H1. Apply PAWS check first.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">if</span> (tcp_fast_parse_options(skb, th, tp) &amp;&amp; tp-&gt;rx_opt.saw_tstamp &amp;&amp;
	    tcp_paws_discard(sk, skb)) {
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>th-&gt;rst) {
			NET_INC_STATS_BH(LINUX_MIB_PAWSESTABREJECTED);
			tcp_send_dupack(sk, skb);
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
		}
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Resets are accepted even if PAWS failed.</span>

<span style="color: #8B8878;">                   ts_recent update must be made after we are sure</span>
<span style="color: #8B8878;">                   that the packet is in window.</span>
<span style="color: #8B8878;">                 */</span>
	}

	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         *      Standard slow path.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #CDC673;">/** &#35843;&#29992;</span><span style="color: #AF87FF;">tcp_sequence()</span><span style="color: #CDC673;">&#26816;&#27979;&#25509;&#25910;&#21040;&#30340;&#27573;&#24207;&#21495;&#26159;&#21542;&#22312;&#25509;&#25910;&#31383;&#21475;&#20869;&#65292;&#22914;&#26524;&#19981;&#26159;&#65292;&#21017;&#20002;&#24323;&#35813;&#25968;&#25454;&#21253;&#12290;&#22914;&#26524;&#19981;&#26159;&#22797;&#20301;&#27573;&#65288;TCP</span>
<span style="color: #CDC673;">        &#39318;&#37096;&#20013;&#23384;&#22312;RST&#26631;&#24535;&#65289;&#65292;&#21017;&#36824;&#38656;&#21457;&#36865;DACK&#32473;&#23545;&#31471;&#65292;&#35828;&#26126;&#25509;&#25910;&#21040;&#30340;TCP&#27573;&#19981;&#20877;&#25509;&#25910;&#31383;&#21475;&#20869;&#12290;*/</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">RFC793, page 37: "In all states except SYN-SENT, all reset</span>
<span style="color: #8B8878;">                 * (RST) segments are validated by checking their SEQ-fields."</span>
<span style="color: #8B8878;">                 * And page 69: "If an incoming segment is not acceptable,</span>
<span style="color: #8B8878;">                 * an acknowledgment should be sent in reply (unless the RST bit</span>
<span style="color: #8B8878;">                 * is set, if so drop the segment and return)".</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>th-&gt;rst)
			tcp_send_dupack(sk, skb);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#30340;&#27573;&#26159;&#22797;&#20301;&#27573;</span>
	<span style="color: #FF1493;">if</span>(th-&gt;rst) {
		tcp_reset(sk);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#39318;&#37096;&#20013;&#23384;&#22312;&#26102;&#38388;&#25139;&#36873;&#39033;&#19988;&#26377;&#25928;&#65292;&#21017;&#20445;&#23384;&#35813;&#26102;&#38388;&#25139;</span>
	<span style="color: #87D700;">tcp_replace_ts_recent</span>(tp, <span style="color: #5FD7FF;">TCP_SKB_CB</span>(<span style="color: #FF8C00;">skb</span>)-&gt;seq);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24050;&#24314;&#31435;&#36830;&#25509;&#30340;TCP&#25910;&#21040;SYN&#27573;&#65292;&#21017;&#35748;&#20026;&#23545;&#31471;&#21457;&#36865;&#20102;&#38169;&#35823;&#20449;&#24687;&#65292;&#25191;&#34892;tcp_reset()</span>
	<span style="color: #FF1493;">if</span> (th-&gt;syn &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) {
		TCP_INC_STATS_BH(TCP_MIB_INERRS);
		NET_INC_STATS_BH(LINUX_MIB_TCPABORTONSYN);
		tcp_reset(sk);
		<span style="color: #FF1493;">return</span> 1;
	}

<span style="color: #AF87FF;">step5</span>:
	<span style="color: #FF1493;">if</span>(th-&gt;ack) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#39318;&#37096;&#35774;&#32622;&#20102;ACK&#26631;&#35760;&#65288;&#36890;&#24120;&#37117;&#20250;&#35774;&#32622;&#65289;&#65292;&#21017;&#35843;&#29992;tcp_ack()&#22788;&#29702;&#12290;</span>
		<span style="color: #87D700;">tcp_ack</span>(sk, skb, FLAG_SLOWPATH);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#37319;&#26679;&#12289;&#26356;&#26032;&#25509;&#25910;&#26041;&#30340;RTT&#12290;</span>
	<span style="color: #87D700;">tcp_rcv_rtt_measure_ts</span>(sk, skb);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#24102;&#22806;&#25968;&#25454;</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Process urgent data.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #87D700;">tcp_urg</span>(sk, skb, th);
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">TCP&#27573;&#30340;&#36127;&#33655;&#37096;&#20998;&#30001;tcp_data_queue()&#22788;&#29702;&#65292;&#21253;&#25324;&#26816;&#26597;&#25509;&#25910;&#32531;&#23384;&#21306;&#26159;&#21542;&#26377;&#36275;&#22815;&#30340;&#31354;&#38388;&#65292;</span>
<span style="color: #8B8878;">        &#23558;SKB&#25554;&#20837;&#21040;&#25509;&#25910;&#38431;&#21015;&#25110;&#32773;&#20081;&#24207;&#38431;&#21015;</span><span style="color: #8B8878;">*/</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">step 7: process the segment text</span><span style="color: #8B8878;"> */</span>
	<span style="color: #87D700;">tcp_data_queue</span>(sk, skb);
	<span style="color: #CDC673;">/** &#26368;&#21518;&#35843;&#29992;</span><span style="color: #AF87FF;">tcp_data_snd_check()</span><span style="color: #CDC673;">&#26816;&#26597;&#26159;&#21542;&#26377;&#25968;&#25454;&#35201;&#21457;&#36865;&#65292;</span>
<span style="color: #CDC673;">        &#35843;&#29992;</span><span style="color: #AF87FF;">tcp_ack_snd_check()</span><span style="color: #CDC673;">&#26816;&#26597;&#26159;&#21542;&#26377;ACK&#38656;&#35201;&#21457;&#36865;&#65288;&#24555;&#36895;&#30830;&#35748;&#25110;&#32773;&#24310;&#36831;&#30830;&#35748;&#65289;*/</span>
	<span style="color: #87D700;">tcp_data_snd_check</span>(sk, tp);
	<span style="color: #87D700;">tcp_ack_snd_check</span>(sk);
	<span style="color: #FF1493;">return</span> 0;

<span style="color: #AF87FF;">csum_error</span>:
	<span style="color: #87D700;">TCP_INC_STATS_BH</span>(TCP_MIB_INERRS);

<span style="color: #AF87FF;">discard</span>:
	<span style="color: #87D700;">__kfree_skb</span>(skb);
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org74d91f3" class="outline-3">
<h3 id="org74d91f3"><span class="section-number-3">4.5</span> 数据从内核空间复制到用户空间</h3>
<div class="outline-text-3" id="text-4-5">
<p>
用户空间缓存由tcp_sock结构的ucopy成员描述，其类型也是由多个成员组成的结构，其中的iov是复制过程中最重要的成员，它指向描述用户进程提供的缓存区信息数组。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">A word of warning: Our uio structure will clash with the C library one (which is now obsolete). Remove the C</span>
<span style="color: #8B8878;">   library one from sys/uio.h if you have a very old library set</span><span style="color: #8B8878;"> */</span>

<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iovec</span>
{
	<span style="color: #5FD7FF;">void</span> <span style="color: #FF8C00;">__user</span> *iov_base;  <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25351;&#21521;&#29992;&#25143;&#31354;&#38388;&#32531;&#23384;&#21306;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">__kernel_size_t</span> <span style="color: #FF8C00;">iov_len</span>; <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#29992;&#25143;&#31354;&#38388;&#32531;&#23384;&#21306;&#38271;&#24230;</span><span style="color: #8B8878;"> */</span>
};
</pre>
</div>
</div>

<div id="outline-container-org01b1d83" class="outline-4">
<h4 id="org01b1d83"><span class="section-number-4">4.5.1</span> 主动复制数据到用户空间</h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
TCP接收到数据后，如果数据正常，就要把数据复制给用户进程。在多数情况下，用户进程调用recvmsg系统调用接收数据。除此之外，还有一种情况会将接收到的数据主动复制到用户空间：TCP正在接收的段的序号与尚未从内核空间复制到用户空空间的段的最前序号相等，TCP段中的用户数据长度小于用户空间缓存剩余的可使用量，且用户进程正在调用recv等系统调用从内核空间读取数据（用户进程正在睡眠），传输层被用户进程锁定，这种情况下直接将数据复制给用户空间。
</p>

<p>
tcp_copy_to_iovec()在接收到的数据主动复制到用户空间时调用。tcp_copy_to_iovec()只是对 skb_copy_datagram_iovec()和skb_copy_and_csum_datagram_iovec()做了封装。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_copy_to_iovec</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">hlen</span><span style="color: #8B8878;">/*</span><span style="color: #8B8878;">TCP&#39318;&#37096;&#38271;&#24230;</span><span style="color: #8B8878;">*/</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">chunk</span> = skb-&gt;len - hlen;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24453;&#22797;&#21046;&#25968;&#25454;&#30340;&#38271;&#24230;</span>
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;

	local_bh_enable();
	<span style="color: #FF1493;">if</span> (skb-&gt;ip_summed==CHECKSUM_UNNECESSARY) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#26159;&#21542;&#25351;&#23450;&#20102;CHECKSUM_UNNECESSARY&#26631;&#24535;&#26469;&#20915;&#23450;&#26159;&#21542;&#25191;&#34892;&#26657;&#39564;&#21644;&#30340;&#26816;&#26597;</span>
		err = skb_copy_datagram_iovec(skb, hlen, tp-&gt;ucopy.iov, chunk);
	<span style="color: #FF1493;">else</span>
		err = skb_copy_and_csum_datagram_iovec(skb, hlen,
						       tp-&gt;ucopy.iov);

	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>err) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22797;&#21046;&#25104;&#21151;&#65292;&#26356;&#26032;&#29992;&#25143;&#31354;&#38388;&#32531;&#23384;&#21306;&#38271;&#24230;&#12289;&#24050;&#32463;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#30340;&#24207;&#21495;</span>
		tp-&gt;ucopy.len -= chunk;
		tp-&gt;copied_seq += chunk;
		tcp_rcv_space_adjust(sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#25972;TCP&#25509;&#25910;&#32531;&#20914;&#21306;&#30340;&#22823;&#23567;</span>
	}

	local_bh_disable();
	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org756be06" class="outline-4">
<h4 id="org756be06"><span class="section-number-4">4.5.2</span> 不进行校验和检查的复制</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
skb_copy_datagram_iovec()不对SKB中的数据作校验和检查，直接复制。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;"> *      skb_copy_datagram_iovec - Copy a datagram to an iovec.</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@skb</span><span style="color: #CDC673;">: buffer to copy</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@offset</span><span style="color: #CDC673;">: &#22797;&#21046;&#30340;&#36215;&#22987;&#20301;&#32622;&#20559;&#31227;</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@to</span><span style="color: #CDC673;">: &#25351;&#21521;&#29992;&#25143;&#31354;&#38388;&#32531;&#23384;&#21306;&#30340;&#25351;&#38024;</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@len</span><span style="color: #CDC673;">: &#28304;SKB&#20013;&#30340;&#25968;&#25454;&#38271;&#24230;</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> *      Note: the iovec is modified during the copy.</span>
<span style="color: #CDC673;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">skb_copy_datagram_iovec</span>(<span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">offset</span>,
			    <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iovec</span> *<span style="color: #FF8C00;">to</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">start</span> = skb_headlen(skb);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>, <span style="color: #FF8C00;">copy</span> = start - offset;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Copy header.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (copy &gt; 0) {  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38500;&#20102;TCP&#39318;&#37096;&#22806;&#65292;&#36824;&#26377;&#20854;&#20182;&#25968;&#25454;&#25165;&#33021;&#22797;&#21046;</span>
		<span style="color: #FF1493;">if</span> (copy &gt; len)
			copy = len;
		<span style="color: #FF1493;">if</span> (memcpy_toiovec(to, skb-&gt;data + offset, copy))  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22797;&#21046;&#25968;&#25454;</span>
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">fault</span>;
		<span style="color: #FF1493;">if</span> ((len -= copy) == 0) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#36824;&#26377;&#25968;&#25454;&#31561;&#24453;&#22797;&#21046;</span>
			<span style="color: #FF1493;">return</span> 0;
		offset += copy;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#25972;&#20559;&#31227;&#65292;&#20934;&#22791;&#32487;&#32493;&#22797;&#21046;</span>
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Copy paged appendix. Hmm... why does this look so complicated?</span><span style="color: #8B8878;"> */</span>
	<span style="color: #CDC673;">/** &#22797;&#21046;SG&#31867;&#22411;&#30340;&#32858;&#21512;&#20998;&#25955;I/O&#25968;&#25454;&#21306;&#20013;&#30340;&#25968;&#25454;*/</span>
	<span style="color: #FF1493;">for</span> (i = 0; i &lt; skb_shinfo(skb)-&gt;nr_frags; i++) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24490;&#29615;&#22788;&#29702;&#25903;&#25345;&#32858;&#21512;&#20998;&#25955;I/O&#30340;&#25968;&#25454;&#22359;&#32531;&#23384;&#21306;</span>
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">end</span>;

		BUG_TRAP(start &lt;= offset + len);

		end = start + skb_shinfo(skb)-&gt;frags[i].size;
		<span style="color: #FF1493;">if</span> ((copy = end - offset) &gt; 0) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24403;&#21069;&#32531;&#23384;&#21306;&#26159;&#21542;&#23384;&#22312;&#21487;&#22797;&#21046;&#30340;&#25968;&#25454;</span>
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;
			<span style="color: #5FD7FF;">u8</span>  *<span style="color: #FF8C00;">vaddr</span>;
			<span style="color: #5FD7FF;">skb_frag_t</span> *<span style="color: #FF8C00;">frag</span> = &amp;skb_shinfo(skb)-&gt;frags[i];
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> *<span style="color: #FF8C00;">page</span> = frag-&gt;page;

			<span style="color: #FF1493;">if</span> (copy &gt; len)
				copy = len;
			vaddr = kmap(page);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#39029;&#38754;&#30340;&#34394;&#25311;&#22320;&#22336;&#65292;&#29992;&#26469;&#22797;&#21046;&#25968;&#25454;</span>
			err = memcpy_toiovec(to, vaddr + frag-&gt;page_offset +
					     offset - start, copy);
			kunmap(page);
			<span style="color: #FF1493;">if</span> (err)
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">fault</span>;
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>(len -= copy)) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#36824;&#26377;&#25968;&#25454;&#31561;&#24453;&#22797;&#21046;</span>
				<span style="color: #FF1493;">return</span> 0;
			offset += copy;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#25972;&#20559;&#31227;&#65292;&#32487;&#32493;&#22797;&#21046;</span>
		}
		start = end;
	}
	<span style="color: #CDC673;">/** &#22797;&#21046;FRAGLIST&#31867;&#22411;&#30340;&#32858;&#21512;&#20998;&#25955;I/O&#25968;&#25454;&#21306;&#20013;&#30340;&#25968;&#25454;*/</span>
	<span style="color: #FF1493;">if</span> (skb_shinfo(skb)-&gt;frag_list) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">list</span> = skb_shinfo(skb)-&gt;frag_list;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36941;&#21382;frag_list&#38142;&#34920;</span>
		<span style="color: #FF1493;">for</span> (; list; list = list-&gt;next) {
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">end</span>;

			BUG_TRAP(start &lt;= offset + len);

			end = start + list-&gt;len;
			<span style="color: #FF1493;">if</span> ((copy = end - offset) &gt; 0) {
				<span style="color: #FF1493;">if</span> (copy &gt; len)
					copy = len;
				<span style="color: #FF1493;">if</span> (skb_copy_datagram_iovec(list,
							    offset - start,
							    to, copy))
					<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">fault</span>;
				<span style="color: #FF1493;">if</span> ((len -= copy) == 0)
					<span style="color: #FF1493;">return</span> 0;
				offset += copy;
			}
			start = end;
		}
	}
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>len) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20026;0 &#35828;&#26126;&#24050;&#32463;&#22797;&#21046;&#30340;&#25968;&#25454;&#38271;&#24230;&#21644;&#24453;&#22797;&#21046;&#25968;&#25454;&#38271;&#24230;&#30456;&#31561;</span>
		<span style="color: #FF1493;">return</span> 0;

<span style="color: #AF87FF;">fault</span>:
	<span style="color: #FF1493;">return</span> -EFAULT;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org08953e8" class="outline-4">
<h4 id="org08953e8"><span class="section-number-4">4.5.3</span> 进行校验和检查的复制</h4>
<div class="outline-text-4" id="text-4-5-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;"> *      skb_copy_and_csum_datagram_iovec - Copy and checkum skb to user iovec.</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@skb</span><span style="color: #CDC673;">: skbuff</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@hlen</span><span style="color: #CDC673;">: hardware length</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@iov</span><span style="color: #CDC673;">: io vector</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> *      Caller _must_ check that skb will fit to this iovec.</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> *      Returns: 0       - success.</span>
<span style="color: #CDC673;"> *               -EINVAL - checksum failure.</span>
<span style="color: #CDC673;"> *               -EFAULT - fault during copy. Beware, in this case iovec</span>
<span style="color: #CDC673;"> *                         can be modified!</span>
<span style="color: #CDC673;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">skb_copy_and_csum_datagram_iovec</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,
				     <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">hlen</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iovec</span> *<span style="color: #FF8C00;">iov</span>)
{
	<span style="color: #5FD7FF;">__wsum</span> <span style="color: #FF8C00;">csum</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">chunk</span> = skb-&gt;len - hlen;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#22797;&#21046;&#25968;&#25454;&#30340;&#38271;&#24230;</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Skip filled elements.</span>
<span style="color: #8B8878;">         * Pretty silly, look at memcpy_toiovec, though 8)</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">while</span> (<span style="color: #CDC673; font-weight: bold;">!</span>iov-&gt;iov_len) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36941;&#21382;&#29992;&#25143;&#31354;&#38388;&#20474;&#32531;&#23384;&#21306;&#25968;&#32452;&#65292;&#30452;&#21040;&#25214;&#21040;&#26377;&#21097;&#20313;&#31354;&#38388;&#30340;&#32531;&#23384;&#21306;</span>
		iov++;

	<span style="color: #FF1493;">if</span> (iov-&gt;iov_len &lt; chunk) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24403;&#21069;&#32531;&#23384;&#21306;&#38271;&#24230;&#23567;&#20110;&#24403;&#21069;&#25972;&#20010;SKB&#25968;&#25454;&#38271;&#24230;&#65292;&#21017;&#22797;&#21046;&#37096;&#20998;</span>
		<span style="color: #FF1493;">if</span> (__skb_checksum_complete(skb))
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">csum_error</span>;
		<span style="color: #FF1493;">if</span> (skb_copy_datagram_iovec(skb, hlen, iov, chunk))
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">fault</span>;
	} <span style="color: #FF1493;">else</span> {  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24403;&#21069;&#32531;&#23384;&#21306;&#33021;&#22815;&#22797;&#21046;&#25972;&#20010;SKB&#30340;&#25968;&#25454;</span>
		csum = csum_partial(skb-&gt;data, hlen, skb-&gt;csum);
		<span style="color: #FF1493;">if</span> (skb_copy_and_csum_datagram(skb, hlen, iov-&gt;iov_base,
					       chunk, &amp;csum))
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">fault</span>;
		<span style="color: #FF1493;">if</span> (csum_fold(csum))
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">csum_error</span>;
		<span style="color: #FF1493;">if</span> (unlikely(skb-&gt;ip_summed == CHECKSUM_COMPLETE))
			netdev_rx_csum_fault(skb-&gt;dev);
		iov-&gt;iov_len -= chunk;
		iov-&gt;iov_base += chunk;
	}
	<span style="color: #FF1493;">return</span> 0;
<span style="color: #AF87FF;">csum_error</span>:
	<span style="color: #FF1493;">return</span> -EINVAL;
<span style="color: #AF87FF;">fault</span>:
	<span style="color: #FF1493;">return</span> -EFAULT;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgc32e939" class="outline-3">
<h3 id="orgc32e939"><span class="section-number-3">4.6</span> 通过调节接收窗口进行流量控制</h3>
<div class="outline-text-3" id="text-4-6">
<p>
除了通过发送方的拥塞窗口进行流量控制外，实际上，接收方也可以通过调整通告的接收窗口大小来进行流量的控制。这和通过发送方的拥塞窗口来进行流量控制差异较大。
</p>

<p>
通过调节接收窗口进行流量控制，理想情况下，通告的接收窗口大小应该是往返时间内，接收方接收到的数据量和发送方发送的数据量中的较大值。要计算这个值，接收方必须知道当前连接的RTT,但RTT一般不会提供给接收方，因为RTT通常是发送方估算的从发送TCP段到接收到ACK的时间，所以接收方徐通过时间戳或其他方法来得到RTT。如果两个主机之间没有或只有很少量的数据通信，则也很难准确的推算出RTT。
</p>

<p>
M.Fisk和W.Feng提出了一种测量连接RTT和合适通告接收窗口的方法，他们称该方法为DRS（Dynamic Right-Sizing）。这种方法测量一个环回时间内接收的数据量，然后将接收缓存的大小设置为恰好两倍于该数值。测量和调整每RTT进行一次。
</p>
</div>

<div id="outline-container-org3404429" class="outline-4">
<h4 id="org3404429"><span class="section-number-4">4.6.1</span> 接收方RTT的计算</h4>
<div class="outline-text-4" id="text-4-6-1">
<p>
对于发送的TCP段中没有时间戳选项的情况：首先发送端不可能在一个其通告的RTT期间发送大于一个通告窗口的数据。假设s为发送的确认段的确认序号，w是发送确认段时通告的接收窗口，由此可以得出，RTT是从发送上一个确认到接收到序号为s+w+1段的时间间隔，保留最小值，即只有当新的采样值比原来保存的值小时才更新。如果通过时间戳选项测算出的RTT是有效的，则优先使用，否则使用上述采样得到的最小值。
</p>
</div>

<div id="outline-container-org3ecfad7" class="outline-5">
<h5 id="org3ecfad7"><span class="section-number-5">4.6.1.1</span> tcp_rcv_rtt_measure()</h5>
<div class="outline-text-5" id="text-4-6-1-1">
<p>
tcp_rcv_rtt_measure()实现了在没有时间戳选项的情况下采样RTT，该函数在接收到带有负载的TCP段时被调用，由于其优先级比较低，因此不会覆盖有时间戳时采样得到的RTT。需要说明的是，即使段中存在时间戳选项，但如果TCP发送方并不是一直有数据发送，即流量较小，也会采用这种方法采样RTT，因为流量较小时，通过时间戳采样的得到的值可能会偏大。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_rcv_rtt_measure</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#26159;&#31532;&#19968;&#27425;&#25509;&#25910;&#21040;&#25968;&#25454;&#25110;&#32773;&#31532;&#19968;&#27425;&#37319;&#29992;&#27492;&#26041;&#27861;&#65292;&#21017;&#19981;&#33021;&#37319;&#26679;RTT,&#36339;&#36716;&#24182;&#35760;&#24405;&#26102;&#38388;&#20197;&#21450;&#35774;&#32622;&#19979;&#27425;&#36827;&#34892;RTT&#37319;&#26679;&#30340;&#28857;</span>
	<span style="color: #FF1493;">if</span> (tp-&gt;rcv_rtt_est.time == 0)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">new_measure</span>;
	<span style="color: #CDC673;">/** &#26816;&#27979;&#26159;&#21542;&#24050;&#32463;&#21040;&#36798;&#36827;&#34892;RTT&#37319;&#26679;&#30340;&#28857;&#65292;&#21363;&#19978;&#27425;&#37319;&#26679;&#23436;&#21518;&#25509;&#25910;&#23436;&#19968;&#20010;&#25509;&#25910;&#31383;&#21475;&#25968;&#37327;&#30340;&#25968;&#25454;&#12290;</span>
<span style="color: #CDC673;">        &#22914;&#26524;&#27599;&#21040;&#65292;&#21017;&#30452;&#25509;&#36864;&#20986;&#65292;&#21542;&#21017;&#35843;&#29992;</span><span style="color: #AF87FF;">tcp_rcv_rtt_update()</span><span style="color: #CDC673;">&#37319;&#26679;&#12290;*/</span>
	<span style="color: #FF1493;">if</span> (before(tp-&gt;rcv_nxt, tp-&gt;rcv_rtt_est.seq))
		<span style="color: #FF1493;">return</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#37319;&#26679;&#12290;</span>
	tcp_rcv_rtt_update(tp,
			   jiffies - tp-&gt;rcv_rtt_est.time, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">RTT&#30340;&#37319;&#26679;</span>
			   1); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#34920;&#31034;&#19981;&#23545;RTT&#30340;&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;</span>

<span style="color: #AF87FF;">new_measure</span>:
	tp-&gt;rcv_rtt_est.seq = tp-&gt;rcv_nxt + tp-&gt;rcv_wnd;
	tp-&gt;rcv_rtt_est.time = tcp_time_stamp;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org530299b" class="outline-5">
<h5 id="org530299b"><span class="section-number-5">4.6.1.2</span> tcp_rcv_rtt_measure_ts</h5>
<div class="outline-text-5" id="text-4-6-1-2">
<p>
目前TCP的实现，除非使用首部压缩，否则都会带有时间戳，Linux也实现了TCP时间戳选项。如果使用时间戳，则每个段的TCP首部都会有一个32位的发送时间戳，同时还有一个32位的用于回显的接收时间戳。用当前时间减去最近收到的数据段上的回显时间戳就能得到RTT的上限。RTT依赖接收到的包大小，但只在接收到的是一个全尺寸的段时才会被限制。
</p>

<p>
tcp_rcv_rtt_measure_ts()实现在支持时间戳选项的情况下采样RTT,该函数在接收到带有负载的TCP段时被调用，但回避tcp_rcv_rtt_measure()先被调用，因此在接收到带有时间戳选项的段时，优先进行RTT采样。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_rcv_rtt_measure_ts</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #CDC673;">/** &#26159;&#21542;&#25509;&#25910;&#21040;&#26102;&#38388;&#25139;&#65292;&#26159;&#21542;&#22312;&#31283;&#23450;&#27969;&#37327;&#19979;&#25509;&#25910;&#21040;&#30340;&#65288;&#36890;&#36807;&#23558;&#25509;&#25910;&#21040;&#30340;&#27573;&#30340;&#36127;&#33655;&#19982;&#25509;&#25910;&#26041;&#30340;MSS&#30456;&#27604;&#24471;&#21040;&#65289;&#12290;</span>
<span style="color: #CDC673;">        &#28385;&#36275;&#26465;&#20214;&#65292;&#21017;&#35843;&#29992;</span><span style="color: #AF87FF;">tcp_rcv_rtt_update()</span><span style="color: #CDC673;">&#37319;&#26679;*/</span>
	<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.rcv_tsecr &amp;&amp;
	    (TCP_SKB_CB(skb)-&gt;end_seq -
	     TCP_SKB_CB(skb)-&gt;seq &gt;= inet_csk(sk)-&gt;icsk_ack.rcv_mss))
		tcp_rcv_rtt_update(tp, tcp_time_stamp - tp-&gt;rx_opt.rcv_tsecr,<span style="color: #8B8878;">//</span><span style="color: #8B8878;">RTT&#30340;&#37319;&#26679;</span>
		0); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">0&#34920;&#31034;&#38656;&#35201;&#36827;&#34892;&#24494;&#35843;</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org462dc0c" class="outline-5">
<h5 id="org462dc0c"><span class="section-number-5">4.6.1.3</span> tcp_rcv_rtt_update()</h5>
<div class="outline-text-5" id="text-4-6-1-3">
<p>
无论是采样是否是通过时间戳进行采样，最后更新RTT时都会调用tcp_rcv_rtt_update()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Receiver "autotuning" code.</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> * The algorithm for RTT estimation w/o timestamps is based on</span>
<span style="color: #8B8878;"> * Dynamic Right-Sizing (DRS) by Wu Feng and Mike Fisk of LANL.</span>
<span style="color: #8B8878;"> * <a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">&lt;http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">
</a><span style="color: #8B8878;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> *</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">
</a><span style="color: #8B8878;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> * More detail on this code can be found at</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">
</a><span style="color: #8B8878;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">
</a><span style="color: #8B8878;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> * though this reference is out of date.  A new paper</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">
</a><span style="color: #8B8878;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> * is pending.</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">
</a><span style="color: #8B8878;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> */</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">
</a><span style="color: #FF1493;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">static</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> </a><span style="color: #5FD7FF;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">void</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> </a><span style="color: #87D700;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">tcp_rcv_rtt_update</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">(</a><span style="color: #FF1493;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">struct</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> </a><span style="color: #5FD7FF;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">tcp_sock</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> *</a><span style="color: #FF8C00;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">tp</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">,
</a><span style="color: #5FD7FF;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">u32</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> </a><span style="color: #FF8C00;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">sample</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">,  </a><span style="color: #8B8878;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">//</a></span><span style="color: #8B8878;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">&#24471;&#21040;&#30340;RTT&#37319;&#26679;</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">
</a><span style="color: #5FD7FF;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">int</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> </a><span style="color: #FF8C00;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">win_dep</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">) </a><span style="color: #8B8878;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">//</a></span><span style="color: #8B8878;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">
{
</a>        <span style="color: #5FD7FF;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">u32</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> </a><span style="color: #FF8C00;"><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-">new_sample</a></span><a href="http://www.lanl.gov/radiant/website/pubs/drs/lacsi2001.ps&gt;
 *
 * More detail on this code can be found at
 * &lt;http://www.psc.edu/~jheffner/senior_thesis.ps&gt;,
 * though this reference is out of date.  A new paper
 * is pending.
 */
static void tcp_rcv_rtt_update(struct tcp_sock *tp,
u32 sample,  //&#24471;&#21040;&#30340;RTT&#37319;&#26679;
int win_dep) //&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#23545;RTT&#37319;&#26679;&#36827;&#34892;&#24494;&#35843;&#65292;1&#20026;&#19981;&#24494;&#35843;&#65292;0&#26159;&#24494;&#35843;
{
	u32 new_sample = tp-"> = tp-&gt;</a>rcv_rtt_est.rtt;
	<span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">m</span> = sample;

	<span style="color: #FF1493;">if</span> (m == 0) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#26412;&#27425;&#37319;&#26679;RTT&#20026;0,&#21017;&#25913;&#20026;1</span>
		m = 1;

	<span style="color: #FF1493;">if</span> (new_sample != 0) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">If we sample in larger samples in the non-timestamp</span>
<span style="color: #8B8878;">                 * case, we could grossly overestimate the RTT especially</span>
<span style="color: #8B8878;">                 * with chatty applications or bulk transfer apps which</span>
<span style="color: #8B8878;">                 * are stalled on filesystem I/O.</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 * Also, since we are only going for a minimum in the</span>
<span style="color: #8B8878;">                 * non-timestamp case, we do not smooth things out</span>
<span style="color: #8B8878;">                 * else with timestamps disabled convergence takes too</span>
<span style="color: #8B8878;">                 * long.</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>win_dep) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24494;&#35843;RTT&#37319;&#26679;&#65292;&#35745;&#31639;&#20844;&#24335;&#65306;(rtt=rtt+(sample-rtt)/8))</span>
			m -= (new_sample &gt;&gt; 3);
			new_sample += m;
		} <span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (m &lt; new_sample) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19981;&#23545;RTT&#37319;&#26679;&#24494;&#35843;&#65292;&#22914;&#26524;&#23567;&#20110;&#21407;&#20808;&#30340;RTT,&#21017;&#23558;RTT&#20056;&#20197;8&#21518;&#20445;&#23384;&#65292;&#26041;&#20415;&#21518;&#32493;&#26356;&#26032;RTT&#12290;</span>
			new_sample = m &lt;&lt; 3;
	} <span style="color: #FF1493;">else</span> {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">No previous measure.</span><span style="color: #8B8878;"> */</span>
		new_sample = m &lt;&lt; 3;
	}

	<span style="color: #FF1493;">if</span> (tp-&gt;rcv_rtt_est.rtt != new_sample)  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20445;&#23384;&#30340;RTT&#19982;&#35745;&#31639;&#30340;&#26032;RTT&#19981;&#31561;&#65292;&#21017;&#26356;&#26032;</span>
		tp-&gt;rcv_rtt_est.rtt = new_sample;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgede2879" class="outline-4">
<h4 id="orgede2879"><span class="section-number-4">4.6.2</span> 调整接收缓存和接收窗口大小</h4>
<div class="outline-text-4" id="text-4-6-2">
<p>
在把数据从接收缓存区复制到用户空间后，接收缓存占用的空间会被释放，因此需要调整TCP接收缓存的大小。tcp_rcv_space_adjust()就是用来完成该功能的，该函数只在数据从TCP接收缓存复制到用户空间后才会被调用。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * This function should be called every time data is copied to user space.</span>
<span style="color: #8B8878;"> * It calculates the appropriate TCP receive buffer space.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_rcv_space_adjust</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">time</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">space</span>;
	<span style="color: #CDC673;">/** &#22914;&#26524;&#26159;&#39318;&#27425;&#35843;&#25972;&#25805;&#20316;&#65292;&#21363;&#25509;&#25910;&#21040;&#31532;&#19968;&#20010;&#25658;&#24102;&#29992;&#25143;&#25968;&#25454;&#30340;&#27573;&#65292;&#21017;&#26080;&#38656;&#35843;&#25972;&#25509;&#25910;&#32531;&#23384;&#65292;</span>
<span style="color: #CDC673;">        &#32780;&#26159;&#30452;&#25509;&#35760;&#24405;&#24050;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#30340;TCP&#24207;&#21495;&#21644;&#26368;&#36817;&#19968;&#27425;&#35843;&#25972;&#26102;&#38388;&#21518;&#36820;&#22238;&#12290;*/</span>
	<span style="color: #FF1493;">if</span> (tp-&gt;rcvq_space.time == 0)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">new_measure</span>;

	time = tcp_time_stamp - tp-&gt;rcvq_space.time;
	<span style="color: #FF1493;">if</span> (time &lt; (tp-&gt;rcv_rtt_est.rtt &gt;&gt; 3) || <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36317;&#31163;&#19978;&#27425;&#35843;&#25972;&#26102;&#38388;&#30701;&#20110;&#25509;&#25910;&#26041;RTT&#30340;1/8&#65292;</span>
	    tp-&gt;rcv_rtt_est.rtt == 0)   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25110;&#32773;&#23578;&#26410;&#35745;&#31639;&#20986;&#25509;&#25910;&#26041;RTT&#12290;</span>
		<span style="color: #FF1493;">return</span>;   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21017;&#26080;&#38656;&#35843;&#25972;&#25509;&#25910;&#32531;&#23384;&#21644;&#25509;&#25910;&#31383;&#21475;&#22823;&#23567;</span>

	<span style="color: #CDC673;">/** &#20004;&#20493;&#30340;&#24448;&#36820;&#26102;&#38388;&#20869;&#25509;&#25910;&#26041;&#24212;&#29992;&#31243;&#24207;&#25509;&#25910;&#30340;&#25968;&#25454;&#37327;&#65292;&#19982;&#21457;&#36865;&#26041;&#19968;&#20010;&#24448;&#36820;&#26102;&#38388;&#20869;&#21457;&#36865;&#30340;&#25968;&#25454;&#37327;&#65292;</span>
<span style="color: #CDC673;">        &#21462;&#36739;&#22823;&#20540;&#20316;&#20026;&#25509;&#25910;&#26041;&#25509;&#25910;&#31383;&#21475;&#30340;&#19978;&#38480; */</span>
	space = 2 * (tp-&gt;copied_seq - tp-&gt;rcvq_space.seq);
	space = max(tp-&gt;rcvq_space.space, space);

	<span style="color: #FF1493;">if</span> (tp-&gt;rcvq_space.space != space) {
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">rcvmem</span>;
		tp-&gt;rcvq_space.space = space;

	<span style="color: #CDC673;">/** &#22914;&#26524;&#21551;&#29992;&#20102;tcp_moderate_rcvbuf&#65292;&#24182;&#19988;&#25509;&#25910;&#32531;&#23384;&#27809;&#26377;&#19978;&#38145;&#65292;&#21017;&#21487;&#20197;&#35843;&#25972;&#25509;&#25910;&#32531;&#23384;&#21644;&#25509;&#25910;&#31383;&#21475;&#22823;&#23567;*/</span>
		<span style="color: #FF1493;">if</span> (sysctl_tcp_moderate_rcvbuf &amp;&amp;
		    <span style="color: #CDC673; font-weight: bold;">!</span>(sk-&gt;sk_userlocks &amp; SOCK_RCVBUF_LOCK)) {
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">new_clamp</span> = space;

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Receive space grows, normalize in order to</span>
<span style="color: #8B8878;">                         * take into account packet headers and sk_buff</span>
<span style="color: #8B8878;">                         * structure overhead.</span>
<span style="color: #8B8878;">                         */</span>
			space /= tp-&gt;advmss;
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>space)
				space = 1;
			rcvmem = (tp-&gt;advmss + MAX_TCP_HEADER +
				  16 + <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span>));
			<span style="color: #FF1493;">while</span> (tcp_win_from_space(rcvmem) &lt; tp-&gt;advmss)
				rcvmem += 128;
			space *= rcvmem;
			space = min(space, sysctl_tcp_rmem[2]);
			<span style="color: #FF1493;">if</span> (space &gt; sk-&gt;sk_rcvbuf) {
				sk-&gt;sk_rcvbuf = space;

				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Make the window clamp follow along.</span><span style="color: #8B8878;">  */</span>
				tp-&gt;window_clamp = new_clamp;
			}
		}
	}

<span style="color: #AF87FF;">new_measure</span>:
	tp-&gt;rcvq_space.seq = tp-&gt;copied_seq;
	tp-&gt;rcvq_space.time = tcp_time_stamp;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4b0b19a" class="outline-3">
<h3 id="org4b0b19a"><span class="section-number-3">4.7</span> 确定是否需要发送ACK段（用于接收的数据从内核空间复制到用户空间时）</h3>
<div class="outline-text-3" id="text-4-7">
<p>
tcp_cleanup_rbuf()通常会在将接收队列中的数据复制到用户空间后被调用，为满负荷的段清理接收缓存区，然后根据需要确定是否发送ACK段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Clean up the receive buffer for full frames taken by the user,</span>
<span style="color: #8B8878;"> * then send an ACK if necessary.  COPIED is the number of bytes</span>
<span style="color: #8B8878;"> * tcp_recvmsg has given to the user so far, it speeds up the</span>
<span style="color: #8B8878;"> * calculation of whether or not we must ACK for the sake of</span>
<span style="color: #8B8878;"> * a window update.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_cleanup_rbuf</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">copied</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">time_to_ack</span> = 0;
	<span style="color: #CDC673;">/** &#22312;&#38656;&#35201;&#21521;&#23545;&#26041;&#21457;&#36865;ACK&#26102;&#65292;&#28385;&#36275;&#20197;&#19979;&#26465;&#20214;&#20043;&#19968;&#65292;&#21017;&#38656;&#35201;&#31435;&#21363;&#21457;&#36865;ACK&#65306;</span>
<span style="color: #CDC673;">          + icsk-&gt;icsk_ack.blocked&#20026;1</span>
<span style="color: #CDC673;">          + &#25509;&#25910;&#31383;&#21475;&#20013;&#26377;&#19968;&#20010;&#20197;&#19978;&#30340;&#20840;&#23610;&#23544;&#27573;&#36824;&#27809;&#26377;&#32473;&#23545;&#26041;&#30830;&#35748;</span>
<span style="color: #CDC673;">          + &#22797;&#21046;&#21040;&#29992;&#25143;&#36827;&#31243;&#31354;&#38388;&#30340;&#25968;&#25454;&#20004;&#22823;&#20110;0&#65292;&#19988;&#21457;&#36865;&#30830;&#35748;&#32039;&#24613;&#24230;&#20026;ICSK_ACK_PUSHED2&#65292;</span>
<span style="color: #CDC673;">            &#25110;&#32773;&#21457;&#36865;&#30830;&#35748;&#32039;&#24613;&#31243;&#24230;&#20026;ICSK_ACK_PUSHED2&#24182;&#19988;pingpong&#20026;0&#12290;*/</span>
	<span style="color: #FF1493;">if</span> (inet_csk_ack_scheduled(sk)) {
		<span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
		   <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Delayed ACKs frequently hit locked sockets during bulk</span>
<span style="color: #8B8878;">                    * receive.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (icsk-&gt;icsk_ack.blocked ||
		    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Once-per-two-segments ACK was not sent by tcp_input.c</span><span style="color: #8B8878;"> */</span>
		    tp-&gt;rcv_nxt - tp-&gt;rcv_wup &gt; icsk-&gt;icsk_ack.rcv_mss ||
		    <span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                     * If this read emptied read buffer, we send ACK, if</span>
<span style="color: #8B8878;">                     * connection is not bidirectional, user drained</span>
<span style="color: #8B8878;">                     * receive buffer and there was a small segment</span>
<span style="color: #8B8878;">                     * in queue.</span>
<span style="color: #8B8878;">                     */</span>
		    (copied &gt; 0 &amp;&amp;
		     ((icsk-&gt;icsk_ack.pending &amp; ICSK_ACK_PUSHED2) ||
		      ((icsk-&gt;icsk_ack.pending &amp; ICSK_ACK_PUSHED) &amp;&amp;
		       <span style="color: #CDC673; font-weight: bold;">!</span>icsk-&gt;icsk_ack.pingpong)) &amp;&amp;
		      <span style="color: #CDC673; font-weight: bold;">!</span>atomic_read(&amp;sk-&gt;sk_rmem_alloc)))
			time_to_ack = 1;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We send an ACK if we can now advertise a non-zero window</span>
<span style="color: #8B8878;">         * which has been raised "significantly".</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         * Even if window raised up to infinity, do not send window open ACK</span>
<span style="color: #8B8878;">         * in states, where we will not receive more. It is useless.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #CDC673;">/** &#22914;&#26524;&#24403;&#21069;&#30340;&#25509;&#25910;&#31383;&#21475;&#26082;&#23567;&#20110;&#25509;&#25910;&#31383;&#21475;&#19978;&#38480;&#30340;&#19968;&#21322;&#65292;&#21448;&#23567;&#20110;&#25509;&#25910;&#32531;&#20914;&#21306;&#22823;&#23567;&#30340;&#19968;&#21322;&#65292;&#21017;&#20063;&#38656;&#35201;&#31435;&#21363;&#21457;&#36865;ACK*/</span>
	<span style="color: #FF1493;">if</span> (copied &gt; 0 &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>time_to_ack &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>(sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)) {
		<span style="color: #5FD7FF;">__u32</span> <span style="color: #FF8C00;">rcv_window_now</span> = tcp_receive_window(tp);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Optimize, __tcp_select_window() is not cheap.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (2*rcv_window_now &lt;= tp-&gt;window_clamp) {
			<span style="color: #5FD7FF;">__u32</span> <span style="color: #FF8C00;">new_window</span> = __tcp_select_window(sk);

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Send ACK now, if this read freed lots of space</span>
<span style="color: #8B8878;">                         * in our buffer. Certainly, new_window is new window.</span>
<span style="color: #8B8878;">                         * We can advertise it now, if it is not less than current one.</span>
<span style="color: #8B8878;">                         * "Lots" means "at least twice" here.</span>
<span style="color: #8B8878;">                         */</span>
			<span style="color: #FF1493;">if</span> (new_window &amp;&amp; new_window &gt;= 2 * rcv_window_now)
				time_to_ack = 1;
		}
	}
	<span style="color: #FF1493;">if</span> (time_to_ack) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#26631;&#24535;&#30830;&#23450;&#26159;&#21542;&#31435;&#21363;&#21457;&#36865;ACK</span>
		tcp_send_ack(sk);
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org8a77bd4" class="outline-2">
<h2 id="org8a77bd4"><span class="section-number-2">5</span> TCP选项的处理</h2>
<div class="outline-text-2" id="text-5">
<p>
TCP在ESTABLISHED状态下执行快速路径法时，由于TCP首部只存在时间戳选项，处理较为简单。其他情况则比较复杂。
</p>

<p>
tcp_fast_parse_options()用于快速路径的选项解析，其他情况调用tcp_parse_options()。
</p>
</div>

<div id="outline-container-orge9a3691" class="outline-3">
<h3 id="orge9a3691"><span class="section-number-3">5.1</span> 慢速路径中快速解析TCP选项</h3>
<div class="outline-text-3" id="text-5-1">
<p>
执行慢速路径时，可能并不是由于TCP首部中的选项没有通过首部预测，在ESTABLISED状态下收到的数据，多数情况下都只存在时间戳选项。因此在慢速路径处理时，首先快速解析TCP选项，只获取时间戳，如果首部中存在多种选项，在调用tcp_parse_options()做全面解析。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Fast parse options. This hopes to only see timestamps.</span>
<span style="color: #8B8878;"> * If it is wrong it falls back on tcp_parse_options().</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_fast_parse_options</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span>,
				  <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span>)
{
	<span style="color: #FF1493;">if</span> (th-&gt;doff == <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>)&gt;&gt;2) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">dott&#23384;&#20648;&#30340;&#26159;&#20197;4&#23383;&#33410;&#20026;&#21333;&#20301;&#30340;&#38271;&#24230;&#65292;&#22914;&#26524;&#30456;&#31561;&#65292;&#21017;&#19981;&#21253;&#25324;&#36873;&#39033;</span>
		tp-&gt;rx_opt.saw_tstamp = 0;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#34920;&#31034;&#19981;&#23384;&#22312;&#26102;&#38388;&#25139;</span>
		<span style="color: #FF1493;">return</span> 0;
	} <span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.tstamp_ok &amp;&amp;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">tstamp_ok&#21344;1&#20301;&#65292;&#35813;&#20540;&#20026;1,&#34920;&#31034;SYN&#27573;&#20013;&#23384;&#22312;&#26102;&#38388;&#25139;&#36873;&#39033;</span>
		   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#39564;&#35777;&#38271;&#24230;,&#26159;&#21542;&#31561;&#20110;&#21482;&#21253;&#21547;&#26102;&#38388;&#25139;&#30340;&#39318;&#37096;&#38271;&#24230;</span>
		   th-&gt;doff == (<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>)&gt;&gt;2)+(TCPOLEN_TSTAMP_ALIGNED&gt;&gt;2)) {
		<span style="color: #5FD7FF;">__be32</span> *<span style="color: #FF8C00;">ptr</span> = (<span style="color: #5FD7FF;">__be32</span> *)(th + 1);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21028;&#26029;&#26102;&#38388;&#25139;&#36873;&#39033;&#30340;&#31532;&#19968;&#20010;32&#20301;&#26159;&#21542;&#31526;&#21512;&#26684;&#24335;</span>
		<span style="color: #FF1493;">if</span> (*ptr == htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16)
				  | (TCPOPT_TIMESTAMP &lt;&lt; 8) | TCPOLEN_TIMESTAMP)) {
			tp-&gt;rx_opt.saw_tstamp = 1;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#20026;1,&#34920;&#31034;&#23384;&#22312;&#26102;&#38388;&#25139;</span>
			++ptr;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19979;&#19968;&#20010;32&#20301;&#34920;&#31034;&#26102;&#38388;&#25139;&#20540;</span>
			tp-&gt;rx_opt.rcv_tsval = ntohl(*ptr);
			++ptr; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19979;&#19968;&#20010;32&#20301;&#34920;&#31034;&#26102;&#38388;&#25139;&#22238;&#26174;&#24212;&#31572;</span>
			tp-&gt;rx_opt.rcv_tsecr = ntohl(*ptr);
			<span style="color: #FF1493;">return</span> 1;
		}
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#26377;&#20854;&#20182;TCP&#36873;&#39033;&#65292;&#21017;&#36890;&#36807;tcp_parse_options()&#35299;&#26512;</span>
	tcp_parse_options(skb, &amp;tp-&gt;rx_opt, 1);
	<span style="color: #FF1493;">return</span> 1;
}
</pre>
</div>


<div class="figure">
<p><img src="image/tcp-input/tcp-tstamp.png" alt="tcp-tstamp.png" />
</p>
<p><span class="figure-number">Figure 7: </span>时间戳选项格式</p>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> TCP选项的宏</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">宏名称</th>
<th scope="col" class="org-right">值</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">TCPOPT_NOP</td>
<td class="org-right">1</td>
<td class="org-left">空操作，做填充用</td>
</tr>

<tr>
<td class="org-left">TCPOPT_TIMESTAMP</td>
<td class="org-right">8</td>
<td class="org-left">时间戳选项</td>
</tr>

<tr>
<td class="org-left">TCPOLEN_TIMESTAMP</td>
<td class="org-right">10</td>
<td class="org-left">时间戳选项长度</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org65fcb15" class="outline-3">
<h3 id="org65fcb15"><span class="section-number-3">5.2</span> 全面解析TCP选项</h3>
<div class="outline-text-3" id="text-5-2">
<p>
tcp_parse_options()解析TCP选项，但通常只在分析SYN和SYN+ACK段时被调用，此外慢速路径中，如果调用tcp_fast_parse_options()失败，也可能在建立连接后在调用。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Look for tcp options. Normally only called on SYN and SYNACK packets.</span>
<span style="color: #8B8878;"> * But, this can also be called on packets in the established flow when</span>
<span style="color: #8B8878;"> * the fast version below fails.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_parse_options</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_options_received</span> *<span style="color: #FF8C00;">opt_rx</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">estab</span>)
{
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">ptr</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span> = skb-&gt;h.th;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">length</span>=(th-&gt;doff*4)-<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;&#36873;&#39033;&#38271;&#24230;</span>

	ptr = (<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *)(th + 1); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31227;&#21160;&#21040;&#36873;&#39033;&#21518;&#39318;&#23383;&#33410;</span>
	opt_rx-&gt;saw_tstamp = 0;

	<span style="color: #FF1493;">while</span>(length&gt;0) {
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">opcode</span>=*ptr++; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#39318;&#23383;&#33410;&#21518;&#65292;&#25351;&#21521;&#19979;&#20010;&#23383;&#33410;</span>
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">opsize</span>;

		<span style="color: #FF1493;">switch</span> (opcode) {
			<span style="color: #FF1493;">case</span> TCPOPT_EOL: <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36873;&#39033;&#34920;&#32467;&#26463;</span>
				<span style="color: #FF1493;">return</span>;
			<span style="color: #FF1493;">case</span> TCPOPT_NOP:        <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Ref: RFC 793 section 3.1</span><span style="color: #8B8878;"> */</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31354;&#25805;&#20316;&#65292;&#22635;&#20805;&#29992;&#65292;&#22240;&#27492;&#36873;&#39033;&#38271;&#24230;&#20943;1</span>
				length--;
				<span style="color: #FF1493;">continue</span>;
			<span style="color: #FF1493;">default</span>:
				opsize=*ptr++;   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#36873;&#39033;&#38271;&#24230;&#65292;&#24182;&#26816;&#27979;&#21512;&#27861;&#24615;</span>
				<span style="color: #FF1493;">if</span> (opsize &lt; 2) <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">"silly options"</span><span style="color: #8B8878;"> */</span>
					<span style="color: #FF1493;">return</span>;
				<span style="color: #FF1493;">if</span> (opsize &gt; length)
					<span style="color: #FF1493;">return</span>; <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">don't parse partial options</span><span style="color: #8B8878;"> */</span>
				<span style="color: #FF1493;">switch</span>(opcode) {
				<span style="color: #FF1493;">case</span> TCPOPT_MSS: <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35813;&#36873;&#39033;&#29992;&#26469;&#36890;&#21578;&#26368;&#22823;&#27573;&#38271;&#24230;&#65288;MSS&#65289;&#65292;&#36873;&#39033;&#26684;&#24335;&#22914;&#19979;&#65306;</span>
</pre>
</div>

<div class="figure">
<p><img src="image/tcp-input/max-mss-opt.png" alt="max-mss-opt.png" />
</p>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">//</span><span style="color: #8B8878;">MSS&#36873;&#39033;&#21482;&#33021;&#20986;&#29616;&#22312;SYN&#27573;&#65292;&#21442;&#25968;estab&#24212;&#35813;&#20026;0</span>
				<span style="color: #FF1493;">if</span>(opsize==TCPOLEN_MSS &amp;&amp; th-&gt;syn &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>estab) {
					<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#26368;&#22823;&#27573;&#38271;&#24230;MSS</span>
					<span style="color: #5FD7FF;">u16</span> <span style="color: #FF8C00;">in_mss</span> = ntohs(get_unaligned((<span style="color: #5FD7FF;">__be16</span> *)ptr));
					<span style="color: #FF1493;">if</span> (in_mss) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">user_mss&#26159;&#29992;&#25143;&#36890;&#36807;setsockopt&#65288;&#65289;&#30340;TCP_MAXSEG&#36873;&#39033;&#35774;&#32622;&#30340;&#65292;mss_clamp&#21462;&#36873;&#39033;MSS&#21644;user_mss&#30340;&#36739;&#23567;&#20540;</span>
						<span style="color: #FF1493;">if</span> (opt_rx-&gt;user_mss &amp;&amp; opt_rx-&gt;user_mss &lt; in_mss)
							in_mss = opt_rx-&gt;user_mss;
						opt_rx-&gt;mss_clamp = in_mss;
					}
				}
				<span style="color: #FF1493;">break</span>;
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">TCPOPT_WINDOW&#26159;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#65292;&#21482;&#33021;&#20986;&#29616;&#22312;SYN&#27573;</span>
			<span style="color: #FF1493;">case</span> TCPOPT_WINDOW:
				<span style="color: #FF1493;">if</span>(opsize==TCPOLEN_WINDOW &amp;&amp; th-&gt;syn &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>estab)
					<span style="color: #FF1493;">if</span> (sysctl_tcp_window_scaling) {
						<span style="color: #5FD7FF;">__u8</span> <span style="color: #FF8C00;">snd_wscale</span> = *(<span style="color: #5FD7FF;">__u8</span> *) ptr;
						opt_rx-&gt;wscale_ok = 1; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#34920;&#31034;SYN&#27573;&#20013;&#21253;&#21547;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#36873;&#39033;</span>
						<span style="color: #FF1493;">if</span> (snd_wscale &gt; 14) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20301;&#31227;&#19981;&#33021;&#22823;&#20110;14</span>
							<span style="color: #FF1493;">if</span>(net_ratelimit())
								printk(KERN_INFO <span style="color: #CDC673;">"tcp_parse_options: Illegal window "</span>
								       <span style="color: #CDC673;">"scaling value %d &gt;14 received.\n"</span>,
								       snd_wscale);
							snd_wscale = 14;
						}
						opt_rx-&gt;snd_wscale = snd_wscale;
					}
				<span style="color: #FF1493;">break</span>;
</pre>
</div>

<div class="figure">
<p><img src="image/tcp-input/snd-wscale-opt.png" alt="snd-wscale-opt.png" />
</p>
</div>
<div class="org-src-container">
<pre class="src src-c">                                <span style="color: #FF1493;">case</span> TCPOPT_TIMESTAMP: <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26102;&#38388;&#25139;</span>
					<span style="color: #FF1493;">if</span>(opsize==TCPOLEN_TIMESTAMP) {
						<span style="color: #FF1493;">if</span> ((estab &amp;&amp; opt_rx-&gt;tstamp_ok) ||
						    (<span style="color: #CDC673; font-weight: bold;">!</span>estab &amp;&amp; sysctl_tcp_timestamps)) {
							opt_rx-&gt;saw_tstamp = 1;
							opt_rx-&gt;rcv_tsval = ntohl(get_unaligned((<span style="color: #5FD7FF;">__be32</span> *)ptr));
							opt_rx-&gt;rcv_tsecr = ntohl(get_unaligned((<span style="color: #5FD7FF;">__be32</span> *)(ptr+4)));
						}
					}
					<span style="color: #FF1493;">break</span>;
				<span style="color: #FF1493;">case</span> TCPOPT_SACK_PERM: <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20801;&#35768;SACK&#36873;&#39033;&#65292;&#21482;&#33021;&#20986;&#29616;&#22312;SYN&#27573;</span>
					<span style="color: #FF1493;">if</span>(opsize==TCPOLEN_SACK_PERM &amp;&amp; th-&gt;syn &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>estab) {
						<span style="color: #FF1493;">if</span> (sysctl_tcp_sack) {
							opt_rx-&gt;sack_ok = 1; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#34920;&#31034;&#20801;&#35768;SACK&#36873;&#39033;</span>
							tcp_sack_reset(opt_rx);
						}
					}
					<span style="color: #FF1493;">break</span>;

				<span style="color: #FF1493;">case</span> TCPOPT_SACK:
					<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#36873;&#39033;&#38271;&#24230;&#21253;&#21547;kind&#12289;length&#23383;&#27573;&#20197;&#21450;&#19968;&#20010;&#25110;&#22810;&#20010;&#24038;&#21491;&#36793;&#30028;&#20540;&#23545;&#65292;</span>
<span style="color: #8B8878;">                                        &#19988;&#20943;&#21435;kind&#21644;length&#23383;&#27573;&#38271;&#24230;&#21518;&#33021;&#34987;&#24038;&#21491;&#36793;&#30028;&#20540;&#23545;&#25972;&#38500;&#65292;&#19988;&#20801;&#35768;SACK&#65292;</span>
<span style="color: #8B8878;">                                        &#21017;&#23558;tcp_skb_cb&#30340;sacked&#38459;&#26029;&#25351;&#21521;&#36825;&#20123;&#24038;&#21491;&#36793;&#30028;&#20540;&#23545;&#30340;&#24320;&#22987;&#22788;</span><span style="color: #8B8878;">*/</span>
					<span style="color: #FF1493;">if</span>((opsize &gt;= (TCPOLEN_SACK_BASE + TCPOLEN_SACK_PERBLOCK)) &amp;&amp;
					   <span style="color: #CDC673; font-weight: bold;">!</span>((opsize - TCPOLEN_SACK_BASE) % TCPOLEN_SACK_PERBLOCK) &amp;&amp;
					   opt_rx-&gt;sack_ok) {
						TCP_SKB_CB(skb)-&gt;sacked = (ptr - 2) - (<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *)th;
					}
<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
				<span style="color: #FF1493;">case</span> TCPOPT_MD5SIG:
					<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                                         * The MD5 Hash has already been</span>
<span style="color: #8B8878;">                                         * checked (see tcp_v{4,6}_do_rcv()).</span>
<span style="color: #8B8878;">                                         */</span>
					<span style="color: #FF1493;">break</span>;
<span style="color: #FF1493;">#endif</span>
				};
				ptr+=opsize-2;
				length-=opsize;
		};
	}
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org2c4f65a" class="outline-2">
<h2 id="org2c4f65a"><span class="section-number-2">6</span> 慢速路径的数据处理</h2>
<div class="outline-text-2" id="text-6">
<p>
慢速路径的数据接收处理比较复杂，需要处理预期的（可以直接的缓存到接收队列中或直接复制到用户空间的数据）、乱序的（序号在接收窗口之内，但不是预期的）、接收窗口之外的数据，等等。
</p>


<div class="figure">
<p><img src="image/tcp-input/tcp-data-queue.png" alt="tcp-data-queue.png" />
</p>
<p><span class="figure-number">Figure 10: </span>tcp_data_queue()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_data_queue</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span> = skb-&gt;h.th;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">eaten</span> = -1;

	<span style="color: #FF1493;">if</span> (TCP_SKB_CB(skb)-&gt;seq == TCP_SKB_CB(skb)-&gt;end_seq) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#35813;&#27573;&#27809;&#26377;&#36127;&#36733;&#65292;&#21017;&#20002;&#24323;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;

	__skb_pull(skb, th-&gt;doff*4); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21024;&#38500;TCP&#39318;&#37096;</span>
	<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#20808;&#22788;&#29702;CWR&#26631;&#24535;&#65292;&#22312;&#19981;&#32771;&#34385;ECE&#26631;&#24535;&#30340;&#24773;&#20917;&#19979;&#65292;&#22914;&#26524;&#25509;&#25910;&#21040;&#30340;&#30340;TCP&#39318;&#37096;&#23384;&#22312;CWR&#26631;&#24535;&#65292;&#35828;&#26126;&#21457;&#36865;&#26041;&#20570;&#20102;&#25317;&#22622;&#22788;&#29702;&#65292;</span>
<span style="color: #8B8878;">        &#22240;&#27492;&#21487;&#20197;&#21435;&#25481;&#26631;&#35782;&#25509;&#25910;&#21040;&#30340;&#27573;&#32463;&#21382;&#20102;&#25317;&#22622;&#30340;&#26631;&#24535;TCP_ECN_DEMAND_CWR.</span><span style="color: #8B8878;">*/</span>
	TCP_ECN_accept_cwr(tp, skb);
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">dsack&#32622;&#20301;&#65292;&#35828;&#26126;&#19978;&#27425;&#21457;&#36865;&#30340;&#27573;&#20013;&#23384;&#22312;SACK&#36873;&#39033;&#21450;D-SACK,&#22240;&#27492;&#38656;&#35201;&#25226;dsack&#22797;&#20301;&#65292;&#22240;&#20026;&#30446;&#21069;&#36824;&#19981;&#28165;&#26970;&#19979;&#27425;&#38656;&#35201;</span>
<span style="color: #8B8878;">        &#21457;&#36865;&#30340;SACK&#36873;&#39033;&#20013;&#26159;&#21542;&#23384;&#22312;D-SACK&#12290;&#21516;&#26102;&#65292;&#21021;&#22987;&#21270;&#26631;&#35782;&#19979;&#19968;&#20010;&#21457;&#36865;&#27573;SACK&#36873;&#39033;&#20013;SACK&#25968;&#32452;&#22823;&#23567;&#30340;eff_sacks,</span>
<span style="color: #8B8878;">        &#20197;&#35745;&#31639;&#24471;&#21040;&#30340;SACK&#22359;&#25968;&#21644;&#65288;4-tp-&gt;opt.tstamp_ok&#65289;&#20004;&#32773;&#20013;&#36739;&#23567;&#20540;&#20316;&#20026;&#21021;&#22987;&#20540;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.dsack) {
		tp-&gt;rx_opt.dsack = 0;
		tp-&gt;rx_opt.eff_sacks = min_t(<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span>, tp-&gt;rx_opt.num_sacks,
						    4 - tp-&gt;rx_opt.tstamp_ok);
	}
</pre>
</div>
</div>

<div id="outline-container-org0cb43cb" class="outline-3">
<h3 id="org0cb43cb"><span class="section-number-3">6.1</span> 接收处理预期的段</h3>
<div class="outline-text-3" id="text-6-1">
<p>
虽然是在慢速路径，但很有可能还是处理的预期的段，因此比较接收段的序号是否是预期的接收序号，如果是，则可以缓存到接收队列中，或直接复制到用户空间中，和快速路径的处理相似。除此之外，还需处理其他情况，如SACK选项，其他标识为等。
</p>
<div class="org-src-container">
<pre class="src src-c">        <span style="color: #8B8878;">/*  </span><span style="color: #8B8878;">Queue data for delivery to the user.</span>
<span style="color: #8B8878;">         *  Packets in sequence go to the receive queue.</span>
<span style="color: #8B8878;">         *  Out of sequence packets to the out_of_order_queue.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">if</span> (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24207;&#21495;&#26159;&#21542;&#26159;&#39044;&#26399;&#25509;&#25910;&#24207;&#21495;</span>
		<span style="color: #FF1493;">if</span> (tcp_receive_window(tp) == 0) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#31383;&#21475;&#26159;&#21542;&#36824;&#26377;&#31354;&#38388;</span>
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out_of_window</span>;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19981;&#33021;&#25509;&#25910;&#65292;&#36339;&#36716;&#24182;&#21457;&#36865;ACK&#65292;&#35753;&#23545;&#27573;&#30693;&#36947;&#25509;&#25910;&#26041;&#25509;&#25910;&#31383;&#21475;&#20026;0&#65292;&#28982;&#21518;&#20002;&#24323;</span>

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Ok. In sequence. In window.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#21487;&#20197;&#30452;&#25509;&#22797;&#21046;&#21040;&#36827;&#31243;&#30340;&#29992;&#25143;&#31354;&#38388;</span>
		<span style="color: #FF1493;">if</span> (tp-&gt;ucopy.task == current &amp;&amp;
		    tp-&gt;copied_seq == tp-&gt;rcv_nxt &amp;&amp; tp-&gt;ucopy.len &amp;&amp;
		    sock_owned_by_user(sk) &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;urg_data) {
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;&#21487;&#20197;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#30340;&#38271;&#24230;</span>
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">chunk</span> = min_t(<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span>, skb-&gt;len,
							tp-&gt;ucopy.len);
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21796;&#37266;&#24403;&#21069;&#35835;&#21462;&#22871;&#25509;&#21475;&#30340;&#36827;&#31243;&#65292;&#24403;&#31995;&#32479;&#23436;&#25104;&#36825;&#27425;&#36719;&#20013;&#27573;&#21518;&#65292;&#35813;&#36827;&#31243;&#26377;&#26426;&#20250;&#36816;&#34892;</span>
			__set_current_state(TASK_RUNNING);

			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#25968;&#25454;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65292;&#24182;&#26356;&#26032;&#29992;&#25143;&#31354;&#38388;&#21097;&#20313;&#30340;&#21487;&#20351;&#29992;&#32531;&#23384;&#38271;&#24230;&#12289;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#30340;&#24207;&#21495;&#31561;</span>
			local_bh_enable();
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb_copy_datagram_iovec(skb, 0, tp-&gt;ucopy.iov, chunk)) {
				tp-&gt;ucopy.len -= chunk;
				tp-&gt;copied_seq += chunk;
				eaten = (chunk == skb-&gt;len &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>th-&gt;fin);
				tcp_rcv_space_adjust(sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21028;&#26029;&#26159;&#21542;&#38656;&#35201;&#26356;&#26032;&#25509;&#25910;&#32531;&#23384;&#21644;&#25509;&#25910;&#31383;&#21475;</span>
			}
			local_bh_disable();
		}

		<span style="color: #FF1493;">if</span> (eaten &lt;= 0) {  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27809;&#26377;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65292;&#21017;&#38656;&#35201;&#32531;&#23384;&#21040;&#25509;&#25910;&#38431;&#21015;</span>
<span style="color: #AF87FF;">queue_and_out</span>:
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#25509;&#25910;&#32531;&#23384;&#22823;&#23567;&#19981;&#22815;&#65292;&#21017;&#20002;&#24323;</span>
			<span style="color: #FF1493;">if</span> (eaten &lt; 0 &amp;&amp;
			    (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf ||
			     <span style="color: #CDC673; font-weight: bold;">!</span>sk_stream_rmem_schedule(sk, skb))) {
				<span style="color: #FF1493;">if</span> (tcp_prune_queue(sk) &lt; 0 ||
				    <span style="color: #CDC673; font-weight: bold;">!</span>sk_stream_rmem_schedule(sk, skb))
					<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
			}
			sk_stream_set_owner_r(skb, sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#35813;SKB&#30340;&#23487;&#20027;</span>
			__skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28155;&#21152;&#21040;&#25509;&#25910;&#38431;&#21015;&#38431;&#23614;</span>
		}
		tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#19979;&#20010;&#39044;&#26399;&#25509;&#25910;&#27573;&#30340;&#24207;&#21495;</span>
		<span style="color: #FF1493;">if</span>(skb-&gt;len) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">skb&#23384;&#22312;&#25968;&#25454;</span>
			tcp_event_data_recv(sk, tp, skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#19968;&#20123;&#25968;&#25454;&#25509;&#25910;&#30456;&#20851;&#30340;&#25805;&#20316;&#65288;&#24310;&#26102;ACK&#12289;ECN&#26631;&#24535;&#31561;&#65289;</span>
		<span style="color: #FF1493;">if</span>(th-&gt;fin)
			tcp_fin(skb, sk, th);
		<span style="color: #CDC673;">/** &#26816;&#27979;&#32531;&#23384;&#20081;&#24207;&#38431;&#21015;&#20013;&#26159;&#21542;&#23384;&#22312;&#21487;&#20197;&#30830;&#35748;&#30340;&#27573; */</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb_queue_empty(&amp;tp-&gt;out_of_order_queue)) {
			tcp_ofo_queue(sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#21487;&#20197;&#30830;&#35748;&#30340;&#27573;&#20174;&#20081;&#24207;&#38431;&#21015;&#36716;&#31227;&#21040;&#25509;&#25910;&#38431;&#21015;</span>

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">RFC2581. 4.2. SHOULD send immediate ACK, when</span>
<span style="color: #8B8878;">                         * gap in queue is filled.</span>
<span style="color: #8B8878;">                         */</span>
			<span style="color: #FF1493;">if</span> (skb_queue_empty(&amp;tp-&gt;out_of_order_queue))
				inet_csk(sk)-&gt;icsk_ack.pingpong = 0;
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24453;&#22238;&#22797;&#30340;ACK&#27573;&#20013;&#23384;&#22312;SACK&#36873;&#39033;&#65292;&#21017;&#26681;&#25454;&#25509;&#25910;&#21040;&#30340;&#27573;&#35843;&#25972;&#29992;&#25143;&#26500;&#25104;SACK&#36873;&#39033;&#30340;selective_acks&#25968;&#32452;&#12290;</span>
		<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.num_sacks)
			tcp_sack_remove(tp);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#28385;&#36275;&#26465;&#20214;&#65292;&#37325;&#26032;&#35774;&#32622;TCP&#39318;&#37096;&#39044;&#27979;&#26631;&#24535;</span>
		tcp_fast_path_check(sk, tp);

		<span style="color: #FF1493;">if</span> (eaten &gt; 0) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#25968;&#25454;&#24050;&#32463;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65292;&#21017;&#37322;&#25918;</span>
			__kfree_skb(skb);
		<span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sock_flag(sk, SOCK_DEAD)) <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#27809;&#26377;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65292;&#19988;&#22871;&#25509;&#21475;&#30340;&#36830;&#25509;&#36824;&#26410;&#26029;&#24320;&#65292;</span>
<span style="color: #8B8878;">                &#21017;&#21796;&#37266;&#31561;&#24453;&#35813;&#22871;&#25509;&#21475;&#30340;&#25152;&#26377;&#36827;&#31243;</span><span style="color: #8B8878;">*/</span>
			sk-&gt;sk_data_ready(sk, 0);
		<span style="color: #FF1493;">return</span>;
	}

</pre>
</div>
</div>
</div>

<div id="outline-container-orgc321434" class="outline-3">
<h3 id="orgc321434"><span class="section-number-3">6.2</span> 接收处理在接收窗口之外的段</h3>
<div class="outline-text-3" id="text-6-2">
<p>
如果不是预期接收的段，则必定是乱序的段。乱序的段如果在接收窗口内，则可以暂时缓存，如果处于接收窗口之外，则丢弃。
</p>
<div class="org-src-container">
<pre class="src src-c">        <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#25509;&#25910;&#30340;&#27573;&#36807;&#26089;&#65292;&#24050;&#32463;&#30830;&#35748;&#36807;&#20102;&#65292;&#21017;&#22788;&#29702;SACK&#36873;&#39033;&#30340;D-SACK,&#22312;&#19979;&#20010;&#30830;&#35748;&#20013;&#21457;&#36865;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;rcv_nxt)) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">A retransmit, 2nd most common case.  Force an immediate ack.</span><span style="color: #8B8878;"> */</span>
		NET_INC_STATS_BH(LINUX_MIB_DELAYEDACKLOST);
		tcp_dsack_set(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq);

<span style="color: #AF87FF;">out_of_window</span>:  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#24230;ACK,&#35753;&#30830;&#35748;&#27573;&#23613;&#21487;&#33021;&#24555;&#30340;&#21457;&#36865;&#32473;&#21457;&#36865;&#26041;&#65292;&#20351;&#24471;&#21457;&#36865;&#26041;&#23613;&#26089;&#30693;&#36947;&#25509;&#25910;&#21040;&#20102;&#30456;&#21516;&#27573;&#12290;</span>
		tcp_enter_quickack_mode(sk);
		inet_csk_schedule_ack(sk);
<span style="color: #AF87FF;">drop</span>:
		__kfree_skb(skb);
		<span style="color: #FF1493;">return</span>;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Out of window. F.e. zero window probe.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#25509;&#25910;&#30340;&#27573;&#24207;&#21495;&#36807;&#22823;&#65292;&#22788;&#20110;&#25509;&#25910;&#31383;&#21475;&#20043;&#22806;&#65292;&#21017;&#22788;&#29702;&#26041;&#27861;&#36319;&#36807;&#26089;&#30340;&#27573;&#19968;&#26679;</span><span style="color: #8B8878;">*/</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt + tcp_receive_window(tp)))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out_of_window</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36827;&#20837;&#24555;&#36895;&#30830;&#35748;&#27169;&#24335;</span>
	<span style="color: #87D700;">tcp_enter_quickack_mode</span>(sk);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#25509;&#25910;&#30340;&#27573;&#26377;&#19968;&#37096;&#20998;&#24050;&#32463;&#25509;&#25910;&#65292;&#21017;&#20808;&#22788;&#29702;SACK&#36873;&#39033;&#30340;D-SACK&#65292;&#22312;&#19979;&#20010;&#30830;&#35748;&#20013;&#21457;&#36865;&#12290;</span>
	<span style="color: #FF1493;">if</span> (before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Partial packet, seq &lt; rcv_next &lt; end_seq</span><span style="color: #8B8878;"> */</span>
		SOCK_DEBUG(sk, <span style="color: #CDC673;">"partial packet: rcv_next %X seq %X - %X\n"</span>,
			   tp-&gt;rcv_nxt, TCP_SKB_CB(skb)-&gt;seq,
			   TCP_SKB_CB(skb)-&gt;end_seq);

		tcp_dsack_set(tp, TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">If window is closed, drop tail of packet. But after</span>
<span style="color: #8B8878;">                 * remembering D-SACK for its head made in previous line.</span>
<span style="color: #8B8878;">                 *///</span><span style="color: #8B8878;">&#26816;&#27979;&#25509;&#25910;&#31383;&#21475;&#26159;&#21542;&#20026;0</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tcp_receive_window(tp))
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out_of_window</span>;
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">queue_and_out</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36339;&#36716;&#65292;&#25509;&#25910;&#25968;&#25454;</span>
	}

</pre>
</div>
</div>
</div>

<div id="outline-container-orgc9310a6" class="outline-3">
<h3 id="orgc9310a6"><span class="section-number-3">6.3</span> 接收处理乱序的段</h3>
<div class="outline-text-3" id="text-6-3">
<p>
预期的段和在接收窗口之外的段都处理了，最后处理既在接收窗口内又不是预期的段，段的失序接收，可能是网络拥塞造成的。这些段需要暂时缓存，一旦接收到它之前的所有段，既可以把它从乱序队列移到接收队列中，这样发送方就不必重传这些段，节省网络带宽。
</p>



<div class="org-src-container">
<pre class="src src-c">        <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25509;&#25910;&#21040;&#20081;&#24207;&#27573;&#26102;&#65292;&#24456;&#26377;&#21487;&#33021;&#22312;&#20256;&#36755;&#36807;&#31243;&#20013;&#32463;&#21382;&#20102;&#25317;&#22622;&#12290;&#22240;&#27492;&#38656;&#35201;&#26816;&#27979;ECN&#26631;&#24535;&#65292;&#22312;&#32463;&#36807;&#36335;&#30001;&#22120;&#26102;&#65292;</span>
<span style="color: #8B8878;">        &#22914;&#26524;&#36335;&#30001;&#22120;&#25317;&#22622;&#65292;&#21017;&#20250;&#35774;&#32622;ECN&#26631;&#24535;&#65292;&#21521;&#25509;&#25910;&#26041;&#20256;&#36798;&#25317;&#22622;&#20449;&#24687;&#12290; &#22914;&#26524;&#27809;&#26377;&#25317;&#22622;&#65292;&#21017;&#38656;&#35201;&#23613;&#24555;&#36890;&#30693;&#21457;&#36865;&#26041;&#65292;</span>
<span style="color: #8B8878;">        &#20351;&#21457;&#36865;&#26041;&#23613;&#21487;&#33021;&#30340;&#37325;&#20256;&#20002;&#22833;&#30340;&#27573;</span><span style="color: #8B8878;">*/</span>
	<span style="color: #87D700;">TCP_ECN_check_ce</span>(tp, skb);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#32531;&#23384;&#31354;&#38388;&#19981;&#36275;&#26102;&#65292;&#20002;&#24323;&#35813;&#27573;</span>
	<span style="color: #FF1493;">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf ||
	    <span style="color: #CDC673; font-weight: bold;">!</span>sk_stream_rmem_schedule(sk, skb)) {
		<span style="color: #FF1493;">if</span> (tcp_prune_queue(sk) &lt; 0 ||
		    <span style="color: #CDC673; font-weight: bold;">!</span>sk_stream_rmem_schedule(sk, skb))
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Disable header prediction.</span><span style="color: #8B8878;"> */</span>
	tp-&gt;pred_flags = 0;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#21040;&#22833;&#24207;&#30340;&#27573;&#26102;&#65292;&#38656;&#35201;&#28165;&#29702;&#39044;&#27979;&#26631;&#24535;&#65292;&#20081;&#24207;&#26102;&#19981;&#33021;&#25191;&#34892;&#24555;&#36895;&#36335;&#24452;&#27861;</span>
	<span style="color: #87D700;">inet_csk_schedule_ack</span>(sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#21457;&#36865;&#30830;&#35748;&#30340;&#32039;&#24613;&#31243;&#24230;&#65292;&#26631;&#35782;&#26377;&#30830;&#35748;&#21457;&#36865;</span>

	<span style="color: #87D700;">SOCK_DEBUG</span>(sk, <span style="color: #CDC673;">"out of order segment: rcv_next %X seq %X - %X\n"</span>,
		   tp-&gt;rcv_nxt, <span style="color: #5FD7FF;">TCP_SKB_CB</span>(<span style="color: #FF8C00;">skb</span>)-&gt;seq, <span style="color: #5FD7FF;">TCP_SKB_CB</span>(<span style="color: #FF8C00;">skb</span>)-&gt;end_seq);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#35813;SKB&#30340;&#23487;&#20027;</span>
	<span style="color: #87D700;">sk_stream_set_owner_r</span>(skb, sk);
	<span style="color: #CDC673;">/** &#22914;&#26524;&#20081;&#24207;&#38431;&#21015;&#20026;&#31354;&#65292;&#21017;&#35774;&#32622;&#29992;&#20110;&#29983;&#25104;&#30830;&#35748;&#27573;&#30340;SACK&#36873;&#39033;&#30340;&#23646;&#24615;&#65292;&#24182;&#23558;&#20854;&#28155;&#21152;&#21040;&#20081;&#24207;&#38431;&#21015; */</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb_peek(&amp;tp-&gt;out_of_order_queue)) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Initial out of order segment, build 1 SACK.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.sack_ok) {
			tp-&gt;rx_opt.num_sacks = 1;
			tp-&gt;rx_opt.dsack     = 0;
			tp-&gt;rx_opt.eff_sacks = 1;
			tp-&gt;selective_acks[0].start_seq = TCP_SKB_CB(skb)-&gt;seq;
			tp-&gt;selective_acks[0].end_seq =
						TCP_SKB_CB(skb)-&gt;end_seq;
		}
		__skb_queue_head(&amp;tp-&gt;out_of_order_queue,skb);
	} <span style="color: #FF1493;">else</span> {<span style="color: #CDC673;">/** &#22914;&#26524;&#20081;&#24207;&#38431;&#21015;&#19981;&#20026;&#31354;&#65292;&#21017;&#25353;&#24207;&#21495;&#23558;&#20854;&#25554;&#20837;&#21040;&#38431;&#21015;&#65292;</span>
<span style="color: #CDC673;">        &#28982;&#21518;&#37325;&#26032;&#35774;&#32622;&#29992;&#20110;&#29983;&#25104;&#30830;&#35748;&#27573;&#30340;SACK&#36873;&#39033;&#30340;&#23646;&#24615; */</span>

		<span style="color: #CDC673;">/** &#34429;&#28982;&#26159;&#20081;&#24207;&#27573;&#65292;&#20294;&#26159;&#24456;&#21487;&#33021;&#36824;&#26159;&#39034;&#24207;&#25509;&#25910;&#30340;&#65292;</span>
<span style="color: #CDC673;">                &#22240;&#27492;&#26816;&#27979;&#25509;&#25910;&#21040;&#30340;&#20081;&#24207;&#27573;&#21644;&#20081;&#24207;&#38431;&#21015;&#20013;&#26368;&#21518;&#19968;&#20010;&#27573;&#26159;&#21542;&#36830;&#32493;&#65292;</span>
<span style="color: #CDC673;">                &#36830;&#32493;&#65292;&#21017;&#30452;&#25509;&#28155;&#21152;&#21040;&#38431;&#21015;&#23614;&#37096;*/</span>
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb1</span> = tp-&gt;out_of_order_queue.prev;
		<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">seq</span> = TCP_SKB_CB(skb)-&gt;seq;
		<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">end_seq</span> = TCP_SKB_CB(skb)-&gt;end_seq;

		<span style="color: #FF1493;">if</span> (seq == TCP_SKB_CB(skb1)-&gt;end_seq) {
			__skb_append(skb1, skb, &amp;tp-&gt;out_of_order_queue);

			<span style="color: #CDC673;">/** &#21040;&#27492;&#22788;&#65292;&#35828;&#26126;&#26159;&#36830;&#32493;&#30340;&#27573;&#65292;&#22914;&#26524;&#19979;&#20010;&#30830;&#35748;&#30340;SACK&#36873;&#39033;&#20013;&#30340;SACK&#22359;&#25968;&#19981;&#20026;0&#65292;</span>
<span style="color: #CDC673;">                        &#24182;&#19988;&#25509;&#25910;&#27573;&#30340;&#24207;&#21495;&#19982;&#23384;&#20648;&#30340;&#29992;&#20110;&#22238;&#22797;&#23545;&#26041;&#30340;&#31532;&#19968;&#20010;SACK&#20449;&#24687;&#22359;&#30340;end_seq&#30456;&#31561;&#65292;</span>
<span style="color: #CDC673;">                        &#21017;&#30452;&#25509;&#20462;&#25913;&#29992;&#20110;&#22238;&#22797;&#23545;&#26041;&#30340;&#31532;&#19968;&#20010;SACK&#20449;&#24687;&#22359;&#30340;end_seq&#21363;&#21487;&#12290;</span>

<span style="color: #CDC673;">                        &#21542;&#21017;&#65292;&#38656;&#35201;&#36339;&#36716;&#21040;add_sack&#22788;&#65292;&#20462;&#25913;&#22238;&#22797;&#23545;&#26041;&#30340;SACK&#20449;&#24687;&#22359;*/</span>
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;rx_opt.num_sacks ||
			    tp-&gt;selective_acks[0].end_seq != seq)
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">add_sack</span>;

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Common case: data arrive in order after hole.</span><span style="color: #8B8878;"> */</span>
			tp-&gt;selective_acks[0].end_seq = end_seq;
			<span style="color: #FF1493;">return</span>;
		}
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#25509;&#25910;&#21040;&#30340;&#20081;&#24207;&#27573;&#19982;&#20081;&#24207;&#38431;&#21015;&#20013;&#26368;&#21518;&#19968;&#20010;&#27573;&#26159;&#19981;&#36830;&#32493;&#30340;&#65292;&#21017;&#20174;&#23614;&#37096;&#21521;&#21069;&#36941;&#21382;&#20081;&#24207;&#38431;&#21015;&#65292;</span>
<span style="color: #8B8878;">                &#26681;&#25454;&#24207;&#21495;&#25214;&#20986;&#25554;&#20837;&#30340;&#20301;&#32622;&#65292;&#20063;&#23601;&#26159;&#25214;&#21040;&#23567;&#20110;&#25110;&#32773;&#31561;&#20110;&#20081;&#24207;&#27573;&#24207;&#21495;&#30340;&#27573;&#65292;&#25554;&#20837;&#21040;&#35813;&#27573;&#20043;&#21518;</span><span style="color: #8B8878;">*/</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Find place to insert this segment.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">do</span> {
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>after(TCP_SKB_CB(skb1)-&gt;seq, seq))
				<span style="color: #FF1493;">break</span>;
		} <span style="color: #FF1493;">while</span> ((skb1 = skb1-&gt;prev) !=
			 (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span>*)&amp;tp-&gt;out_of_order_queue);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#38656;&#35201;&#26816;&#27979;&#25554;&#20837;&#20301;&#32622;&#21644;&#21069;&#19968;&#20010;&#27573;&#26159;&#21542;&#26377;&#37325;&#21472;&#65292;&#24182;&#25554;&#20837;&#21040;&#20081;&#24207;&#38431;&#21015;&#30340;&#23545;&#24212;&#20301;&#32622;</span><span style="color: #8B8878;">*/</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Do skb overlap to previous one?</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (skb1 != (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span>*)&amp;tp-&gt;out_of_order_queue &amp;&amp;
		    before(seq, TCP_SKB_CB(skb1)-&gt;end_seq)) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19982;&#19978;&#19968;&#20010;&#27573;&#26377;&#37325;&#21472;</span>
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#26597;&#26159;&#21542;&#21253;&#21547;&#22312;&#19978;&#19968;&#20010;&#27573;&#20869;&#65292;&#26159;&#21017;&#20002;&#24323;&#65292;&#24182;&#35774;&#32622;D-SACK&#23646;&#24615;</span>
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>after(end_seq, TCP_SKB_CB(skb1)-&gt;end_seq)) {
				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">All the bits are present. Drop.</span><span style="color: #8B8878;"> */</span>
				__kfree_skb(skb);
				tcp_dsack_set(tp, seq, end_seq);
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">add_sack</span>;
			}
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;&#26159;&#21542;&#21644;&#21069;&#19968;&#20010;&#27573;&#26377;&#37096;&#20998;&#37325;&#21472;</span>
			<span style="color: #FF1493;">if</span> (after(seq, TCP_SKB_CB(skb1)-&gt;seq)) {
				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Partial overlap.</span><span style="color: #8B8878;"> *///</span><span style="color: #8B8878;">&#35774;&#32622;D-SACK&#23646;&#24615;</span>
				tcp_dsack_set(tp, seq, TCP_SKB_CB(skb1)-&gt;end_seq);
			} <span style="color: #FF1493;">else</span> {
				skb1 = skb1-&gt;prev;
			}
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#20081;&#24207;&#27573;&#25554;&#20837;&#23545;&#24212;&#30340;&#20301;&#32622;</span>
		__skb_insert(skb, skb1, skb1-&gt;next, &amp;tp-&gt;out_of_order_queue);
		<span style="color: #CDC673;">/** &#22914;&#26524;&#22312;&#25554;&#20837;&#20301;&#32622;&#21518;&#30340;&#27573;&#34987;&#21253;&#21547;&#22312;&#24403;&#21069;&#25554;&#20837;&#30340;&#27573;&#20869;&#65292;&#21017;&#37322;&#25918;&#36825;&#20123;&#27573;*/</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">And clean segments covered by new one as whole.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">while</span> ((skb1 = skb-&gt;next) != <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20174;&#24403;&#21069;&#20301;&#32622;&#36941;&#21382;&#20081;&#24207;&#38431;&#21015;</span>
		       (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span>*)&amp;tp-&gt;out_of_order_queue &amp;&amp;
		       after(end_seq, TCP_SKB_CB(skb1)-&gt;seq)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214;&#26159;&#21542;&#26377;&#37325;&#21472;</span>
		       <span style="color: #FF1493;">if</span> (before(end_seq, TCP_SKB_CB(skb1)-&gt;end_seq)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#37096;&#20998;&#37325;&#21472;</span>
			       tcp_dsack_extend(tp, TCP_SKB_CB(skb1)-&gt;seq, end_seq); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;D-SACK&#23646;&#24615;</span>
			       <span style="color: #FF1493;">break</span>;
		       }
		       <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21040;&#27492;&#22788;&#35828;&#26126;&#26597;&#25214;&#30340;&#27573;&#34987;&#21253;&#21547;&#22312;&#24403;&#21069;&#27573;&#20869;&#65292;&#21017;&#21024;&#38500;&#25214;&#21040;&#30340;&#27573;</span>
		       __skb_unlink(skb1, &amp;tp-&gt;out_of_order_queue);
		       tcp_dsack_extend(tp, TCP_SKB_CB(skb1)-&gt;seq, TCP_SKB_CB(skb1)-&gt;end_seq);
		       __kfree_skb(skb1);
		}

<span style="color: #AF87FF;">add_sack</span>:       <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;SACK&#22359;</span>
		<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.sack_ok)
			tcp_sack_new_ofo_skb(sk, seq, end_seq);
	}
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org1566714" class="outline-3">
<h3 id="org1566714"><span class="section-number-3">6.4</span> tcp_ofo_queue()</h3>
<div class="outline-text-3" id="text-6-4">
<p>
tcp_ofo_queue()用于处理乱序队列中预期接收的段。检测乱序队列，如果存在过早的段，则设置下次确认的SACK选项。如果存在预期接收的段，则将其转移到接收队列。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">This one checks to see if we can put data from the</span>
<span style="color: #8B8878;"> * out_of_order queue into the receive_queue.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_ofo_queue</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #5FD7FF;">__u32</span> <span style="color: #FF8C00;">dsack_high</span> = tp-&gt;rcv_nxt;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24490;&#29615;&#22788;&#29702;&#20081;&#24207;&#38431;&#21015;&#30340;SKB</span>
	<span style="color: #FF1493;">while</span> ((skb = skb_peek(&amp;tp-&gt;out_of_order_queue)) != <span style="color: #AF87FF;">NULL</span>) {
		<span style="color: #CDC673;">/**  &#20081;&#24207;&#38431;&#21015;&#20013;&#30340;&#27573;&#37117;&#26159;&#25353;&#29031;&#24207;&#21495;&#39034;&#24207;&#23384;&#20648;&#65292;</span>
<span style="color: #CDC673;">                &#22240;&#27492;&#19968;&#26086;&#26576;&#20010;SKB&#20013;&#30340;&#27573;&#24207;&#21495;&#22823;&#20110;&#39044;&#26399;&#25509;&#25910;&#27573;&#30340;&#24207;&#21495;&#65292;&#21363;&#21487;&#32467;&#26463;&#22788;&#29702; */</span>
		<span style="color: #FF1493;">if</span> (after(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt))
			<span style="color: #FF1493;">break</span>;
		<span style="color: #CDC673;">/** &#22914;&#26524;&#26576;&#20010;SKB&#20013;&#30340;&#27573;&#24207;&#21495;&#23567;&#20110;&#39044;&#26399;&#25509;&#25910;&#27573;&#30340;&#24207;&#21495;&#65292;&#21017;&#35828;&#26126;&#33267;&#23569;&#26377;&#19968;&#37096;&#20998;&#27573;</span>
<span style="color: #CDC673;">                &#24050;&#32463;&#25509;&#25910;&#21040;&#65292;&#38656;&#35201;&#22788;&#29702;SACK&#36873;&#39033;&#65292;&#22312;&#19979;&#20010;&#30830;&#35748;&#20013;&#21457;&#36865;*/</span>
		<span style="color: #FF1493;">if</span> (before(TCP_SKB_CB(skb)-&gt;seq, dsack_high)) {
			<span style="color: #5FD7FF;">__u32</span> <span style="color: #FF8C00;">dsack</span> = dsack_high;
			<span style="color: #FF1493;">if</span> (before(TCP_SKB_CB(skb)-&gt;end_seq, dsack_high))
				dsack_high = TCP_SKB_CB(skb)-&gt;end_seq;
			tcp_dsack_extend(tp, TCP_SKB_CB(skb)-&gt;seq, dsack);
		}
		<span style="color: #CDC673;">/** &#22914;&#26524;&#26576;&#20010;SKB&#20013;&#30340;&#27573;&#24050;&#32463;&#20840;&#37096;&#25509;&#25910;&#65292;&#21017;&#35828;&#26126;&#24050;&#32463;&#20840;&#37096;&#30830;&#35748;&#20102;&#65292;</span>
<span style="color: #CDC673;">                &#22240;&#27492;&#21487;&#20197;&#21024;&#38500;&#24182;&#37322;&#25918;&#65292;&#32487;&#32493;&#22788;&#29702;&#19979;&#19968;&#20010;SKB*/</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;rcv_nxt)) {
			SOCK_DEBUG(sk, <span style="color: #CDC673;">"ofo packet was already received \n"</span>);
			__skb_unlink(skb, &amp;tp-&gt;out_of_order_queue);
			__kfree_skb(skb);
			<span style="color: #FF1493;">continue</span>;
		}
		SOCK_DEBUG(sk, <span style="color: #CDC673;">"ofo requeuing : rcv_next %X seq %X - %X\n"</span>,
			   tp-&gt;rcv_nxt, TCP_SKB_CB(skb)-&gt;seq,
			   TCP_SKB_CB(skb)-&gt;end_seq);
		<span style="color: #CDC673;">/**&#21040;&#27492;&#22788;&#65292;&#35828;&#26126;&#24403;&#21069;&#22788;&#29702;&#30340;SKB&#27491;&#26159;&#39044;&#26399;&#25509;&#25910;&#30340;&#27573;&#65292;&#22240;&#27492;&#23558;&#20854;&#20174;&#20081;&#24207;&#38431;&#21015;</span>
<span style="color: #CDC673;">                &#20013;&#31227;&#21160;&#21040;&#25509;&#25910;&#38431;&#21015;&#38431;&#23614;*/</span>
		__skb_unlink(skb, &amp;tp-&gt;out_of_order_queue);
		__skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#19979;&#20010;&#39044;&#26399;&#25509;&#25910;&#27573;&#30340;&#24207;&#21495;</span>
		tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
		<span style="color: #FF1493;">if</span>(skb-&gt;h.th-&gt;fin)
			tcp_fin(skb, sk, skb-&gt;h.th);
	}
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org788c577" class="outline-2">
<h2 id="org788c577"><span class="section-number-2">7</span> 带外数据处理</h2>
<div class="outline-text-2" id="text-7">
<p>
带外数据处理的对象是URG标志置位时的段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">This is the 'fast' part of urgent handling.</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_urg</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Check if we get a new urgent pointer - normally not.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (th-&gt;urg) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#39318;&#37096;&#24102;&#26377;URG&#26631;&#24535;&#65292;&#21017;&#24102;&#22806;&#25968;&#25454;&#20559;&#31227;&#37327;urg_seq&#24212;&#35813;&#19981;&#20026;0&#65292;&#22240;&#27492;&#26816;&#27979;urg_seq&#26159;&#21542;&#27491;&#24120;</span>
		tcp_check_urg(sk,th);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Do we wait for any urgent data? - normally not...</span><span style="color: #8B8878;"> */</span>
	<span style="color: #CDC673;">/** &#22914;&#26524;urg_data&#20026;TCP_URG_NOTYET&#65292;&#21017;&#34920;&#31034;&#20294;&#21069;&#22788;&#29702;&#27573;&#20013;&#30340;&#24102;&#22806;&#25968;&#25454;&#26377;&#25928;&#65292;</span>
<span style="color: #CDC673;">        &#28982;&#21518;&#35835;&#21462;&#24102;&#22806;&#25968;&#25454;&#21040;urg_data&#20013;&#65292;&#24182;&#35774;&#32622;TCP_URG_VALID&#26631;&#24535;&#34920;&#31034;&#29992;&#25143;&#36827;&#31243;&#21487;&#20197;&#35835;&#21462;&#65292;</span>
<span style="color: #CDC673;">        &#20043;&#21518;&#36890;&#30693;&#29992;&#25143;&#36827;&#31243;&#35835;&#21462;*/</span>
	<span style="color: #FF1493;">if</span> (tp-&gt;urg_data == TCP_URG_NOTYET) {
		<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">ptr</span> = tp-&gt;urg_seq - ntohl(th-&gt;seq) + (th-&gt;doff * 4) -
			  th-&gt;syn;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Is the urgent pointer pointing into this packet?</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (ptr &lt; skb-&gt;len) {
			<span style="color: #5FD7FF;">u8</span> <span style="color: #FF8C00;">tmp</span>;
			<span style="color: #FF1493;">if</span> (skb_copy_bits(skb, ptr, &amp;tmp, 1))
				BUG();
			tp-&gt;urg_data = TCP_URG_VALID | tmp;
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sock_flag(sk, SOCK_DEAD))
				sk-&gt;sk_data_ready(sk, 0);
		}
	}
}
</pre>
</div>
</div>


<div id="outline-container-orgcf48485" class="outline-3">
<h3 id="orgcf48485"><span class="section-number-3">7.1</span> 检测紧急指针</h3>
<div class="outline-text-3" id="text-7-1">
<p>
tcp_check_urg()用于检测段中的带外数据是否有效，同时设置带外数据序号以及标志，以便后续根据标志作响应处理。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      This routine is only called when we have urgent data</span>
<span style="color: #8B8878;"> *      signaled. Its the 'slow' part of tcp_urg. It could be</span>
<span style="color: #8B8878;"> *      moved inline now as tcp_urg is only called from one</span>
<span style="color: #8B8878;"> *      place. We handle URGent data wrong. We have to - as</span>
<span style="color: #8B8878;"> *      BSD still doesn't use the correction from RFC961.</span>
<span style="color: #8B8878;"> *      For 1003.1g we should support a new option TCP_STDURG to permit</span>
<span style="color: #8B8878;"> *      either form (or just set the sysctl tcp_stdurg).</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_check_urg</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> * <span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> * <span style="color: #FF8C00;">th</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">ptr</span> = ntohs(th-&gt;urg_ptr);
	<span style="color: #CDC673;">/** &#35745;&#31639;&#24102;&#22806;&#25968;&#25454;&#20301;&#32622;</span>
<span style="color: #CDC673;">        &#20851;&#20110;&#32039;&#24613;&#25351;&#38024;&#26159;&#25351;&#21521;&#24102;&#22806;&#25968;&#25454;&#26368;&#21518;&#19968;&#20010;&#23383;&#33410;&#36824;&#26159;&#26368;&#21518;&#19968;&#20010;&#23383;&#33410;&#30340;&#19979;&#19968;&#20010;&#23383;&#33410;&#26377;&#19968;&#20123;&#20105;&#35770;&#65292;</span>
<span style="color: #CDC673;">        Host Requirements RFC&#30830;&#23450;&#25351;&#21521;&#26368;&#21518;&#19968;&#20010;&#23383;&#33410;&#26159;&#27491;&#30830;&#30340;&#65292;&#28982;&#32780;&#26377;&#24456;&#22810;&#23454;&#29616;&#36824;&#26159;&#38169;&#35823;&#30340;&#65292;</span>
<span style="color: #CDC673;">        &#25152;&#20197;&#20026;&#20102;&#20860;&#23481;&#65292;&#26681;&#25454;sysctl_tcp_stdurg&#20915;&#23450;&#26159;&#21542;&#21521;&#21069;&#31227;&#21160;*/</span>
	<span style="color: #FF1493;">if</span> (ptr &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>sysctl_tcp_stdurg)
		ptr--;
	ptr += ntohl(th-&gt;seq);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Ignore urgent data that we've already seen and read.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #CDC673;">/** &#24102;&#22806;&#25968;&#25454;&#24050;&#32463;&#34987;&#29992;&#25143;&#36827;&#31243;&#35835;&#21462;&#36807;&#25110;&#32773;&#24050;&#32463;&#25509;&#25910;&#36807;&#65292;&#21017;&#26080;&#38656;&#20877;&#27425;&#35835;&#21462;*/</span>
	<span style="color: #FF1493;">if</span> (after(tp-&gt;copied_seq, ptr))
		<span style="color: #FF1493;">return</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Do not replay urg ptr.</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         * NOTE: interesting situation not covered by specs.</span>
<span style="color: #8B8878;">         * Misbehaving sender may send urg ptr, pointing to segment,</span>
<span style="color: #8B8878;">         * which we already have in ofo queue. We are not able to fetch</span>
<span style="color: #8B8878;">         * such data and will stay in TCP_URG_NOTYET until will be eaten</span>
<span style="color: #8B8878;">         * by recvmsg(). Seems, we are not obliged to handle such wicked</span>
<span style="color: #8B8878;">         * situations. But it is worth to think about possibility of some</span>
<span style="color: #8B8878;">         * DoSes using some hypothetical application level deadlock.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">if</span> (before(ptr, tp-&gt;rcv_nxt))
		<span style="color: #FF1493;">return</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Do we already have a newer (or duplicate) urgent pointer?</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#22914;&#26524;&#36824;&#26377;&#24102;&#22806;&#25968;&#25454;&#27809;&#26377;&#34987;&#35835;&#21462;&#65292;&#19988;&#24403;&#21069;&#24102;&#22806;&#25968;&#25454;&#26089;&#20110;&#35813;&#23578;&#26410;&#35835;&#21462;&#30340;&#24102;&#22806;&#25968;&#25454;&#65292;</span>
<span style="color: #8B8878;">        &#21017;&#20002;&#24323;&#35813;&#24102;&#22806;&#25968;&#25454;</span><span style="color: #8B8878;">*/</span>
	<span style="color: #FF1493;">if</span> (tp-&gt;urg_data &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>after(ptr, tp-&gt;urg_seq))
		<span style="color: #FF1493;">return</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Tell the world about our new urgent pointer.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21796;&#37266;&#24322;&#27493;&#31561;&#24453;&#35813;&#22871;&#25509;&#21475;&#30340;&#36827;&#31243;&#65292;&#36890;&#30693;&#26377;&#26032;&#30340;&#24102;&#22806;&#25968;&#25454;&#21040;&#36798;</span>
	sk_send_sigurg(sk);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We may be adding urgent data when the last byte read was</span>
<span style="color: #8B8878;">         * urgent. To do this requires some care. We cannot just ignore</span>
<span style="color: #8B8878;">         * tp-&gt;copied_seq since we would read the last urgent byte again</span>
<span style="color: #8B8878;">         * as data, nor can we alter copied_seq until this data arrives</span>
<span style="color: #8B8878;">         * or we break the semantics of SIOCATMARK (and thus sockatmark())</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         * NOTE. Double Dutch. Rendering to plain English: author of comment</span>
<span style="color: #8B8878;">         * above did something sort of  send("A", MSG_OOB); send("B", MSG_OOB);</span>
<span style="color: #8B8878;">         * and expect that both A and B disappear from stream. This is _wrong_.</span>
<span style="color: #8B8878;">         * Though this happens in BSD with high probability, this is occasional.</span>
<span style="color: #8B8878;">         * Any application relying on this is buggy. Note also, that fix "works"</span>
<span style="color: #8B8878;">         * only in this artificial test. Insert some normal data between A and B and we will</span>
<span style="color: #8B8878;">         * decline of BSD again. Verdict: it is better to remove to trap</span>
<span style="color: #8B8878;">         * buggy users.</span>
<span style="color: #8B8878;">         */</span> <span style="color: #CDC673;">/** &#22914;&#26524;&#24403;&#21069;&#25509;&#25910;&#30340;&#24102;&#22806;&#25968;&#25454;&#27573;&#30340;&#24207;&#21495;&#27491;&#26159;&#25509;&#19979;&#26469;&#38656;&#35201;&#22797;&#21046;&#21040;&#36827;&#31243;&#31354;&#38388;&#27573;&#30340;&#24207;&#21495;&#65292;</span>
<span style="color: #CDC673;">         &#24182;&#19988;&#19979;&#19968;&#20010;&#25509;&#25910;&#27573;&#30340;&#24207;&#21495;&#19982;&#38656;&#35201;&#22797;&#21046;&#21040;&#36827;&#31243;&#31354;&#38388;&#30340;&#24207;&#21495;&#19981;&#30456;&#31561;&#30340;&#24773;&#20917;&#19979;&#65292;</span>
<span style="color: #CDC673;">         &#38656;&#35201;&#26816;&#27979;&#25509;&#25910;&#38431;&#21015;&#20013;&#30340;&#31532;&#19968;&#20010;&#27573;&#26159;&#21542;&#26377;&#25928;&#12290;&#22240;&#20026;&#24403;&#21069;&#22788;&#29702;&#30340;&#26159;&#24102;&#22806;&#25968;&#25454;&#65292;&#22240;&#27492;&#38656;&#35201;&#36882;&#22686;copied_seq&#12290;</span>
<span style="color: #CDC673;">         &#25509;&#30528;&#26816;&#27979;&#25509;&#25910;&#38431;&#21015;&#20013;&#31532;&#19968;&#20010;&#27573;&#26159;&#21542;&#24050;&#32463;&#36807;&#26399;&#65292;&#36807;&#26399;&#21017;&#37322;&#25918;*/</span>
	<span style="color: #FF1493;">if</span> (tp-&gt;urg_seq == tp-&gt;copied_seq &amp;&amp; tp-&gt;urg_data &amp;&amp;
	    <span style="color: #CDC673; font-weight: bold;">!</span>sock_flag(sk, SOCK_URGINLINE) &amp;&amp;
	    tp-&gt;copied_seq != tp-&gt;rcv_nxt) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span> = skb_peek(&amp;sk-&gt;sk_receive_queue);
		tp-&gt;copied_seq++;
		<span style="color: #FF1493;">if</span> (skb &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>before(tp-&gt;copied_seq, TCP_SKB_CB(skb)-&gt;end_seq)) {
			__skb_unlink(skb, &amp;sk-&gt;sk_receive_queue);
			__kfree_skb(skb);
		}
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#24102;&#22806;&#25968;&#25454;&#24207;&#21495;&#20197;&#21450;&#26631;&#24535;&#65292;&#20197;&#20415;&#21518;&#32493;&#26681;&#25454;&#26631;&#24535;&#20316;&#30456;&#24212;&#22788;&#29702;</span>
	tp-&gt;urg_data   = TCP_URG_NOTYET;
	tp-&gt;urg_seq    = ptr;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Disable header prediction.</span><span style="color: #8B8878;"> */</span>
	tp-&gt;pred_flags = 0; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#30001;&#20110;&#25910;&#21040;&#24102;&#22806;&#25968;&#25454;&#65292;&#38656;&#35201;&#31105;&#27490;&#19979;&#27425;&#30340;&#39318;&#37096;&#39044;&#27979;</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd960c78" class="outline-3">
<h3 id="orgd960c78"><span class="section-number-3">7.2</span> 读取带外数据</h3>
<div class="outline-text-3" id="text-7-2">
<p>
tcp_rcv_urg()用于从保存在传输控制块中的带外数据读取到用户空间中，当用于通过recv系统调用读取带外数据时被调用。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      Handle reading urgent data. BSD has very simple semantics for</span>
<span style="color: #8B8878;"> *      this, no blocking and very strange errors 8)</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_recv_urg</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24102;&#35835;&#21462;&#24102;&#22806;&#25968;&#25454;&#30340;&#25152;&#22312;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
<span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">timeo</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35835;&#21462;&#24102;&#22806;&#25968;&#25454;&#30340;&#36229;&#26102;&#26102;&#38388;</span>
<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">msghdr</span> *<span style="color: #FF8C00;">msg</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#26469;&#32452;&#32455;&#35835;&#21462;&#25968;&#25454;&#30340;&#28040;&#24687;&#22836;</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>,  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#25143;&#31354;&#38388;&#25552;&#20379;&#30340;&#32531;&#23384;&#38271;&#24230;</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flags</span>,<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35835;&#21462;&#24102;&#22806;&#25968;&#25454;&#30340;&#26631;&#24535;</span>
<span style="color: #5FD7FF;">int</span> *<span style="color: #FF8C00;">addr_len</span>) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26410;&#20351;&#29992;</span>
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">No URG data to read.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;&#26159;&#21542;&#26377;&#24102;&#22806;&#25968;&#25454;&#21487;&#20197;&#35835;&#21462;</span>
	<span style="color: #FF1493;">if</span> (sock_flag(sk, SOCK_URGINLINE) ||  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#34920;&#31034;&#24102;&#22806;&#25968;&#25454;&#25918;&#20837;&#27491;&#24120;&#25968;&#25454;&#27969;&#65292;&#19981;&#33021;&#20351;&#29992;&#24102;&#22806;&#25968;&#25454;&#30340;&#35835;&#21462;&#26041;&#27861;</span>
	    <span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;urg_data || <span style="color: #8B8878;">//</span><span style="color: #8B8878;">urg_data&#26631;&#24535;&#20026;0,&#34920;&#31034;&#27809;&#26377;&#24102;&#22806;&#25968;&#25454;</span>
	    tp-&gt;urg_data == TCP_URG_READ) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#34920;&#31034;&#24102;&#22806;&#25968;&#25454;&#24050;&#32463;&#20840;&#37096;&#35835;&#21462;</span>
		<span style="color: #FF1493;">return</span> -EINVAL; <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Yes this is right !</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">tcp&#27809;&#26377;&#36830;&#25509;&#65292;&#20063;&#26080;&#27861;&#35835;&#21462;&#24102;&#22806;&#25968;&#25454;</span>
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state == TCP_CLOSE &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>sock_flag(sk, SOCK_DONE))
		<span style="color: #FF1493;">return</span> -ENOTCONN;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32039;&#24613;&#25968;&#25454;&#26377;&#25928;</span>
	<span style="color: #FF1493;">if</span> (tp-&gt;urg_data &amp; TCP_URG_VALID) {
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span> = 0;
		<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">c</span> = tp-&gt;urg_data; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">urg_data&#20013;&#23384;&#20648;&#30340;&#24102;&#22806;&#25968;&#25454;</span>

		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>(flags &amp; MSG_PEEK)) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">MSG_PEEK&#34920;&#31034;&#21482;&#26159;&#26597;&#30475;&#25968;&#25454;</span>
			tp-&gt;urg_data = TCP_URG_READ; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#19981;&#21482;&#26597;&#30475;&#25968;&#25454;&#65292;&#21017;&#35774;&#32622;TCP_URG_READ&#26631;&#24535;</span>

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Read urgent data.</span><span style="color: #8B8878;"> *///</span><span style="color: #8B8878;">&#24050;&#32463;&#35835;&#21462;&#20102;&#24102;&#22806;&#25968;&#25454;&#65292;&#36820;&#22238;&#26631;&#24535;&#20013;&#22686;&#21152;MSG_OOB</span>
		msg-&gt;msg_flags |= MSG_OOB;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#25143;&#25552;&#20379;&#30340;&#32531;&#20914;&#21306;&#38271;&#24230;&#22823;&#20110;0,&#21017;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65292;&#35774;&#32622;&#38271;&#24230;&#20026;1</span>
		<span style="color: #FF1493;">if</span> (len &gt; 0) {
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>(flags &amp; MSG_TRUNC))
				err = memcpy_toiovec(msg-&gt;msg_iov, &amp;c, 1);
			len = 1;
		} <span style="color: #FF1493;">else</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#25143;&#25552;&#20379;&#32531;&#20914;&#21306;&#38271;&#24230;&#20026;0, &#21017;&#35774;&#32622;MSG_TRUNC&#26631;&#24535;</span>
			msg-&gt;msg_flags |= MSG_TRUNC;

		<span style="color: #FF1493;">return</span> err ? -EFAULT : len;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36830;&#25509;&#24050;&#32463;&#26029;&#24320;&#25110;&#32773;&#35843;&#29992;&#20102;shutdown,&#21017;&#19981;&#20801;&#35768;&#25509;&#25910;&#25968;&#25454;</span>
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state == TCP_CLOSE || (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN))
		<span style="color: #FF1493;">return</span> 0;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20854;&#20182;&#29366;&#24577;&#27809;&#26377;&#35835;&#21462;&#21040;&#24102;&#22806;&#25968;&#25454;&#65292;&#21017;&#36820;&#22238;EAGAIN</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Fixed the recv(..., MSG_OOB) behaviour.  BSD docs and</span>
<span style="color: #8B8878;">         * the available implementations agree in this case:</span>
<span style="color: #8B8878;">         * this call should never block, independent of the</span>
<span style="color: #8B8878;">         * blocking state of the socket.</span>
<span style="color: #8B8878;">         * Mike <a href="mailto:pall%40rz.uni-karlsruhe.de">&lt;pall@rz.uni-karlsruhe.de&gt;</a></span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">return</span> -EAGAIN;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org829dcf4" class="outline-2">
<h2 id="org829dcf4"><span class="section-number-2">8</span> SACK信息</h2>
<div class="outline-text-2" id="text-8">
<p>
通过TCP通信时，如果发送序列中的某个数据包丢失，TCP则会重传从最后确认的包开始的后续包，这样原先已经正确传输的包也可能发生重复发送，急剧降低TCP性能。为了改善此种情况，发展出SACK（Selective Acknowledgment，选择确认）技术，使TCP只重传丢失的包，不用发送后续所有的包，并且提供相应的机制使接收方能告诉发送方哪些数据丢失，哪些数据重复发送，哪些数据提前收到等。
</p>

<p>
SACK信息通过TCP头的选项部分提供，信息分为两种，一种标识是否支持SACK，在TCP握手时发送;另一种是具体的SACK信息。
</p>
</div>

<div id="outline-container-org0b562e5" class="outline-3">
<h3 id="org0b562e5"><span class="section-number-3">8.1</span> SACK允许选项</h3>
<div class="outline-text-3" id="text-8-1">
<p>
此选项只允许存在于有SYN标志的TCP段中，即TCP握手的前两个包，标识本端是否支持SACK。
</p>


<div class="figure">
<p><img src="ditaa/tcp-input/sack-syn.png" alt="sack-syn.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgc1dfdac" class="outline-3">
<h3 id="orgc1dfdac"><span class="section-number-3">8.2</span> SACK选项</h3>
<div class="outline-text-3" id="text-8-2">
<p>
SACK选项如下：
</p>
<ul class="org-ul">
<li>选项类型：5。</li>
<li>选项长度：可变，但整个TCP选项长度不得超过40B，实际上，最多不会超过4组边界值。</li>
</ul>


<div class="figure">
<p><img src="image/tcp-input/sack-opt.png" alt="sack-opt.png" />
</p>
<p><span class="figure-number">Figure 12: </span>SACK选项</p>
</div>

<p>
该选项参数告诉对方已经结婚搜到并缓存的不连续数据块，注意都是已经接收到的，发送方可以根据此信息检查究竟是哪些块丢失了，从而重传这些数据块。
</p>
<ul class="org-ul">
<li>Left Edge of Block  已经接收到不连续块的第一个数据的序号</li>
<li>Right Edge of Block 已经接收到不连续块的最后一个数据的序号之后的序列号。表示（Left Edge -1）和（Right Edge）处序列号的数据没能接收到。</li>
</ul>
</div>
</div>

<div id="outline-container-orge1f8254" class="outline-3">
<h3 id="orge1f8254"><span class="section-number-3">8.3</span> SACK的产生</h3>
<div class="outline-text-3" id="text-8-3">
<p>
SACK通常是由TCP接收方产生的，如果在TCP握手时，接收到对方SACK允许选项，且本端也支持SACK,结婚搜异常时就可以发送SACK包通知发送方。
</p>

<p>
TCP接收方接收到非期待序号的数据段时，如果该段的序号小于期待的序号，说明是网络复制或重发的包，可以丢弃;如果受到的数据块大于期待的序号，说明中间有包被丢弃或延迟，这是会发送SACK通知发送方出现了网络丢包。
</p>

<p>
为了反映接收方接收缓存和网络传输的情况，SACK中的第一个块必须描述是哪个数据块激发了SACK选项，接收方应该在SACK选项中尽可能多的填写块信息，如果空间有限不能全部写入，则报告最近接收的不连续数据块，让发送方能了解当前网络传输情况的最新信息。
</p>

<p>
RFC2883扩展了SACK，重传包的SACK（D-SACK）,SACK中描述的是接收到的数据段，这些数据段可能是正常的，也可能是重复发送的，SACK字段具有描述重复发送数据段的能力&#x2013;在第一个SACK数据中描述重复接收的不连续数据块序号，其他SACK数据则还是描述其他接收到的不连续数据，因此第一块SACK描述的序号会比后面的SACK描述的序号大？？？？？？？，而在接收到不完整数据段的情况下，SACK范围甚至可能小于当前的ACK值。通过这种方法，发送方可以更仔细的判断出当前网络的传输情况，发现数据段被网络复制、错误重传、ACK丢失引起的重传、重传超时等网络异常状况。
</p>
</div>
</div>

<div id="outline-container-orga2edb70" class="outline-3">
<h3 id="orga2edb70"><span class="section-number-3">8.4</span> 发送方对SACK的响应</h3>
<div class="outline-text-3" id="text-8-4">
<p>
TCP发送方都应该维护一个未确认的重发数据队列，数据在未被确认前不能释放。重发队列中的每个数据块都有一个表示为“SACKed”，标识该数据块是否被SACK过，对于已经被SACK过的块，在重新发送数据时将被跳过。发送方接收到接收方的SACK信息后，根据SACK中数据标识重发队列中相应数据块的“SACKed”标志。如果接收不到接收方数据，超时后，重发队列中多有数据块的SACKed位都会被清除，因为可能接收方已经出现异常。
</p>

<p>
通过SACK选项可以使得TCP发送方只发送丢失的数据而不用发送第一个丢失包之后的所有数据，提高数据的传输效率。
</p>
</div>
</div>

<div id="outline-container-org2dee450" class="outline-3">
<h3 id="org2dee450"><span class="section-number-3">8.5</span> 实现</h3>
<div class="outline-text-3" id="text-8-5">
<p>
在Linux的实现中，用到了传输控制块的以下成员：
</p>
<ul class="org-ul">
<li>struct tcp_sack_block duplicate_sack[1]</li>
<li>struct tcp_sack_block selective_acks[4]
它们存储用于回复对方的SACK信息，duplicate_sack存储D-SACK信息，selective_acks存储SACK信息，在回复SACK时从这两个成员中取出D-SACK和SACK信息，而在处理接收到的乱序段时，向这两个成员中填入相应的信息。</li>

<li>dsack 标识下次发送的段中的SACK选项中是否存在D-SACK（duplicate-SACK）</li>
<li>sack_ok 标识接收方是否支持SACK,0为不支持SACK,1则表示支持SACK。此外由于sack_ok占用4位，因而在正常带有负荷的段中，其第1、2位有其他含义&#x2013;第一位标识是否启用 FACK拥塞避免，第二位标识在SACK选项中是否存在D-SACK,第三位保留。</li>

<li>u8 num_sacks 下一个发送段的SACK选项中的SACK块数，用于计算eff_sacks.</li>
<li>u8 eff_sacks 下一个发送段中SACK选项的SACK数组大小，如果为零则可以认为没有SACK</li>
</ul>
</div>

<div id="outline-container-orgd0d45cb" class="outline-4">
<h4 id="orgd0d45cb"><span class="section-number-4">8.5.1</span> 调整SACK块</h4>
<div class="outline-text-4" id="text-8-5-1">
<p>
接收到乱序段后，会调用tcp_sack_new_ofo_skb()设置selective_acks数组，计算下一个发送段中SACK选项的SACK块数并设置到num_acks中。
</p>

<p>
在接收到乱序段时，如果发现有重复段，则在启用D-SACK的情况下，会调用tcp_dsack_set()设置用于构成SACK选项的duplicate_ack数组。
</p>

<p>
在接收段的慢速路径处理过程中，如果待回复的ACK段中存在SACK选项，则调用tcp_sack_remove()根据接收到的段调整用于构成SACK选项的selective_acks数组。
</p>
</div>
</div>

<div id="outline-container-orgaced734" class="outline-4">
<h4 id="orgaced734"><span class="section-number-4">8.5.2</span> 构建SACK选项</h4>
<div class="outline-text-4" id="text-8-5-2">
<p>
构建SACK选项参见tcp_build_and_update_options()。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org338a863" class="outline-2">
<h2 id="org338a863"><span class="section-number-2">9</span> 确认的发送</h2>
<div class="outline-text-2" id="text-9">
<p>
TCP接收到数据后，需要发送对应的确认，但如果只为了确认段就发送一个段，会增加不必要的网络流量。因此使用了延迟确认。因为ACK不占用TCP段资源，所以可以将ACK与数据一起发送给对端。
</p>

<p>
因此TCP使用两种模式来处理接收到的数据，即快速确认和延迟确认。在整个TCP发送和接收过程中，由于网络拥塞、接收到小包等原因会在快速确认和延迟确认模式之间切换。
</p>

<p>
当TCP进入延迟确认模式，通常接收到两个TCP段产生一个确认或者言之在0.5s之内产生一个确认。
</p>

<p>
尽管代码中有检测是否在快速确认模式的函数，但事实上确定使用快速确认还是延迟确认有些复杂，存在多个条件。以下任何一种情况都会导致快速确认：
</p>
<ul class="org-ul">
<li>在FIN_WAIT_1和FIN_WAIT_2状态下接收到FIN</li>
<li>在SYN_SENT状态下PAWS校验失败或接收到已确认的段，发送DACK</li>
<li>在接收的慢速处理中，PAWS校验失败或收到已确认的段，发送DACK</li>
<li>接收到多个全尺寸的段且接收窗口的右端已经更新</li>
<li>快速确认模式下</li>
<li>乱序TCP段队列中还有待处理的段</li>
<li>连续接收到2个小包，也就是小于536B的段</li>
</ul>
</div>


<div id="outline-container-orgcb60827" class="outline-3">
<h3 id="orgcb60827"><span class="section-number-3">9.1</span> 快速确认模式</h3>
<div class="outline-text-3" id="text-9-1">
<p>
尽管已经进入快速确认模式，但在该确认模式下发送ACK的数量也是有限的，每次发送ACK后都会递减可发送快速确认数（参见tcp_event_ack_sent()），一旦该值减小到0，就会自动进入延时确认模式。
</p>
</div>

<div id="outline-container-orgf2f6377" class="outline-4">
<h4 id="orgf2f6377"><span class="section-number-4">9.1.1</span> 进入快速确认模式</h4>
<div class="outline-text-4" id="text-9-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_enter_quickack_mode</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26681;&#25454;&#24403;&#21069;&#25509;&#25910;&#31383;&#21475;&#21644;&#23545;&#31471;MSS&#35745;&#31639;&#24471;&#21040;&#20801;&#35768;&#21457;&#36865;&#24555;&#36895;&#30830;&#35748;&#27573;&#25968;&#65292;</span>
<span style="color: #8B8878;">        &#20294;&#26368;&#22810;&#19981;&#33021;&#36229;&#36807;16&#20010;&#65292;&#21516;&#26102;&#35774;&#32622;&#24050;&#21551;&#29992;&#24555;&#36895;&#30830;&#35748;&#27169;&#24335;&#26631;&#35782;</span><span style="color: #8B8878;">*/</span>
	tcp_incr_quickack(sk);
	icsk-&gt;icsk_ack.pingpong = 0;
	icsk-&gt;icsk_ack.ato = TCP_ATO_MIN;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgde38da0" class="outline-4">
<h4 id="orgde38da0"><span class="section-number-4">9.1.2</span> 检测当前的模式</h4>
<div class="outline-text-4" id="text-9-1-2">
<p>
tcp_in_quickack_mode()用于检测当前是否处于快速确认模式，检测条件为可发送快速确认数不为0，同时pingpong为0。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Send ACKs quickly, if "quick" count is not exhausted</span>
<span style="color: #8B8878;"> * and the session is not interactive.</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_in_quickack_mode</span>(<span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>)
{
	<span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
	<span style="color: #FF1493;">return</span> icsk-&gt;icsk_ack.quick &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>icsk-&gt;icsk_ack.pingpong;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd97dc91" class="outline-3">
<h3 id="orgd97dc91"><span class="section-number-3">9.2</span> 处理数据接收事件</h3>
<div class="outline-text-3" id="text-9-2">
<p>
tcp_event_data_recv()在接收到数据之后被调用，用于处理接收到数据之后应该触发的一些事件，如设置发送确认状态，估算对端MSS，计算接收方RTT，确定进入快速确认模式还是延迟确认模式，以及更新最近一次受到数据包的时间。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">There is something which you must keep in mind when you analyze the</span>
<span style="color: #8B8878;"> * behavior of the tp-&gt;ato delayed ack timeout interval.  When a</span>
<span style="color: #8B8878;"> * connection starts up, we want to ack as quickly as possible.  The</span>
<span style="color: #8B8878;"> * problem is that "good" TCP's do slow start at the beginning of data</span>
<span style="color: #8B8878;"> * transmission.  The means that until we send the first few ACK's the</span>
<span style="color: #8B8878;"> * sender will sit on his end and only queue most of his data, because</span>
<span style="color: #8B8878;"> * he can only send snd_cwnd unacked packets at any given time.  For</span>
<span style="color: #8B8878;"> * each ACK we send, he increments snd_cwnd and transmits more of his</span>
<span style="color: #8B8878;"> * queue.  -DaveM</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_event_data_recv</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
	<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">now</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#21040;&#26032;&#30340;&#27573;&#65292;&#38656;&#35201;&#35774;&#32622;&#24403;&#21069;&#21457;&#36865;&#30830;&#35748;&#30340;&#29366;&#24577;&#65292;&#34920;&#31034;&#26377;ACK&#38656;&#35201;&#21457;&#36865;</span>
	inet_csk_schedule_ack(sk);
	<span style="color: #CDC673;">/** &#20272;&#31639;&#12289;&#26356;&#26032;&#23545;&#31471;MSS,&#22312;&#27809;&#26377;&#26102;&#38388;&#25139;&#36873;&#39033;&#30340;&#24773;&#20917;&#19979;&#65292;</span>
<span style="color: #CDC673;">        &#38656;&#35201;&#35745;&#31639;&#25509;&#25910;&#26041;RTT*/</span>
	tcp_measure_rcv_mss(sk, skb);
	tcp_rcv_rtt_measure(tp);

	now = tcp_time_stamp;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#27809;&#26377;&#35774;&#32622;&#24310;&#36831;ACK&#30340;&#36229;&#26102;&#26102;&#38388;&#65292;&#21017;&#36827;&#20837;&#24555;&#36895;&#30830;&#35748;&#27169;&#24335;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>icsk-&gt;icsk_ack.ato) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">The _first_ data packet received, initialize</span>
<span style="color: #8B8878;">                 * delayed ACK engine.</span>
<span style="color: #8B8878;">                 */</span>
		tcp_incr_quickack(sk);
		icsk-&gt;icsk_ack.ato = TCP_ATO_MIN;
	} <span style="color: #FF1493;">else</span> {<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26681;&#25454;&#26412;&#27425;&#19982;&#19978;&#27425;&#25509;&#25910;&#21040;&#25968;&#25454;&#30340;&#26102;&#38388;&#38388;&#38548;&#65292;</span>
<span style="color: #8B8878;">        &#37325;&#26032;&#35774;&#32622;&#24310;&#36831;ACK&#30340;&#36229;&#26102;&#26102;&#38388;&#65292;&#25110;&#32773;&#36827;&#20837;&#24555;&#36895;&#30830;&#35748;&#27169;&#24335;</span><span style="color: #8B8878;">*/</span>
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">m</span> = now - icsk-&gt;icsk_ack.lrcvtime;

		<span style="color: #FF1493;">if</span> (m &lt;= TCP_ATO_MIN/2) {
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">The fastest case is the first.</span><span style="color: #8B8878;"> */</span>
			icsk-&gt;icsk_ack.ato = (icsk-&gt;icsk_ack.ato &gt;&gt; 1) + TCP_ATO_MIN / 2;
		} <span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (m &lt; icsk-&gt;icsk_ack.ato) {
			icsk-&gt;icsk_ack.ato = (icsk-&gt;icsk_ack.ato &gt;&gt; 1) + m;
			<span style="color: #FF1493;">if</span> (icsk-&gt;icsk_ack.ato &gt; icsk-&gt;icsk_rto)
				icsk-&gt;icsk_ack.ato = icsk-&gt;icsk_rto;
		} <span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (m &gt; icsk-&gt;icsk_rto) {
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Too long gap. Apparently sender failed to</span>
<span style="color: #8B8878;">                         * restart window, so that we send ACKs quickly.</span>
<span style="color: #8B8878;">                         */</span>
			tcp_incr_quickack(sk);
			sk_stream_mem_reclaim(sk);
		}
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#26368;&#36817;&#19968;&#27425;&#25509;&#25910;&#25968;&#25454;&#25253;&#30340;&#26102;&#38388;</span>
	icsk-&gt;icsk_ack.lrcvtime = now;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22312;&#25903;&#25345;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;&#26102;&#65292;&#30830;&#23450;&#25509;&#25910;&#30340;&#27573;&#26159;&#21542;&#32463;&#21382;&#30340;&#25317;&#22622;</span>
	TCP_ECN_check_ce(tp, skb);
	<span style="color: #8B8878;">//</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;len &gt;= 128) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22686;&#21152;&#24403;&#21069;&#25509;&#25910;&#31383;&#21475;&#22823;&#23567;&#30340;&#38408;&#20540;</span>
		tcp_grow_window(sk, tp, skb);
	<span style="color: #CDC673;">/** &#22914;&#26524;&#24403;&#21069;&#25509;&#25910;&#31383;&#21475;&#22823;&#23567;&#30340;&#38408;&#20540;&#23567;&#20110;&#28369;&#21160;&#31383;&#21475;&#30340;&#26368;&#22823;&#20540;&#65292;</span>
<span style="color: #CDC673;">        &#21516;&#26102;&#20063;&#23567;&#20110;TCP&#21487;&#29992;&#30340;&#25509;&#25910;&#31354;&#38388;&#65292;&#24182;&#19988;TCP&#32531;&#23384;&#31649;&#29702;&#26410;&#22312;&#35686;&#21578;&#29366;&#24577;&#65292;</span>
<span style="color: #CDC673;">        &#21017;&#21487;&#20197;&#22686;&#38271;&#24403;&#21069;&#25509;&#25910;&#31383;&#21475;&#22823;&#23567;&#30340;&#38408;&#20540;&#12290;*/</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd3bf2ee" class="outline-3">
<h3 id="orgd3bf2ee"><span class="section-number-3">9.3</span> 发送确认紧急程度和状态</h3>
<div class="outline-text-3" id="text-9-3">
<p>
传输控制块中的icsk_ack的成员pending，用来标识当前需要发送确认的紧急程度和状态，可取值为ICSK_ACK_SCHED、ICSK_ACK_PUSHED、ICSK_ACK_PUSHED2和ICSK_ACK_TIMER。变迁关系如下：
</p>


<div class="figure">
<p><img src="image/tcp-input/tcp-ack-status.png" alt="tcp-ack-status.png" />
</p>
<p><span class="figure-number">Figure 13: </span>发送确认紧急程度和状态关系</p>
</div>
</div>

<div id="outline-container-org3ed5b80" class="outline-4">
<h4 id="org3ed5b80"><span class="section-number-4">9.3.1</span> ICSK_ACK_SCHED</h4>
<div class="outline-text-4" id="text-9-3-1">
<p>
接收方并不是随意发送ACK确认的，特别是没有负载的ACK段，当然这与某些选项有关，如TCP_QUICKACK。接收到新段后，才能给对方发送ACK段，因此需要进行标识。详情参见 tcp_event_data_recv()和tcp_data_queue()等函数。
</p>

<p>
有时候尽管设置了需要发送ACK的标志，但在某些条件下，也可能需要延迟发送ACK，而不能立即发送，因为ICSK_ACK_SCHED状态只是发送确认的必要条件。
</p>
</div>
</div>

<div id="outline-container-org28a950c" class="outline-4">
<h4 id="org28a950c"><span class="section-number-4">9.3.2</span> ICSK_ACK_PUSHED和ICSK_ACK_PUSHED2状态</h4>
<div class="outline-text-4" id="text-9-3-2">
<p>
由于接收方无法明确获得发送方的MSS，因此只能通过接收到的发送方发送段的大小来估算发送方的MSS。而tcp_measure_rcv_mss()则用来更新发送方的MSS。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Adapt the MSS value used to make delayed ack decision to the</span>
<span style="color: #8B8878;"> * real world.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_measure_rcv_mss</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,
				<span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
	<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">lss</span> = icsk-&gt;icsk_ack.last_seg_size;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>;

	icsk-&gt;icsk_ack.last_seg_size = 0;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">skb-&gt;len may jitter because of SACKs, even if peer</span>
<span style="color: #8B8878;">         * sends good full-sized frames.</span>
<span style="color: #8B8878;">         */</span>
	len = skb_shinfo(skb)-&gt;gso_size ?: skb-&gt;len;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#25910;&#21040;&#30340;&#27573;&#22823;&#20110;&#24403;&#21069;&#21457;&#36865;&#26041;MSS,&#21017;&#20316;&#20026;&#24403;&#21069;&#21457;&#36865;&#26041;MSS&#26356;&#26032;&#21040;rcv_mss&#23383;&#27573;&#20013;&#12290;</span>
	<span style="color: #FF1493;">if</span> (len &gt;= icsk-&gt;icsk_ack.rcv_mss) {
		icsk-&gt;icsk_ack.rcv_mss = len;
	} <span style="color: #FF1493;">else</span> {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23567;&#20110;&#24403;&#21069;&#21457;&#36865;&#26041;&#30340;MSS</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Otherwise, we make more careful check taking into account,</span>
<span style="color: #8B8878;">                 * that SACKs block is variable.</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 * "len" is invariant segment length, including TCP header.</span>
<span style="color: #8B8878;">                 */</span>
		len += skb-&gt;data - skb-&gt;h.raw;
		<span style="color: #FF1493;">if</span> (len &gt;= TCP_MIN_RCVMSS + <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) || <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22823;&#20110;536</span>
		    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">If PSH is not set, packet should be</span>
<span style="color: #8B8878;">                     * full sized, provided peer TCP is not badly broken.</span>
<span style="color: #8B8878;">                     * This observation (if it is correct 8)) allows</span>
<span style="color: #8B8878;">                     * to handle super-low mtu links fairly.</span>
<span style="color: #8B8878;">                     */</span>
		    <span style="color: #CDC673;">/**&#25110;&#32773;&#22823;&#20110;TCP&#26368;&#23567;&#21487;&#25509;&#25910;&#27573;88&#65292;&#19988;&#19981;&#23384;&#22312;PSH&#26631;&#35782;&#65292;&#27492;&#26102;&#22914;&#26524;&#19982;&#19978;&#27425;&#25509;&#25910;&#30340;&#27573;&#38271;&#24230;&#30456;&#21516;&#65292;</span>
<span style="color: #CDC673;">                    &#21017;&#20316;&#20026;&#24403;&#21069;&#21457;&#36865;&#26041;MSS&#26356;&#26032;&#21040;rcv_mss&#23383;&#27573;&#20013;*/</span>
		    (len &gt;= TCP_MIN_MSS + <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) &amp;&amp;
		     <span style="color: #CDC673; font-weight: bold;">!</span>(tcp_flag_word(skb-&gt;h.th)&amp;TCP_REMNANT))) {  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24182;&#19988;&#19981;&#23384;&#22312;PSH&#26631;&#35782;</span>
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Subtract also invariant (if peer is RFC compliant),</span>
<span style="color: #8B8878;">                         * tcp header plus fixed timestamp option length.</span>
<span style="color: #8B8878;">                         * Resulting "len" is MSS free of SACK jitter.</span>
<span style="color: #8B8878;">                         */</span>
			len -= tcp_sk(sk)-&gt;tcp_header_len;
			icsk-&gt;icsk_ack.last_seg_size = len;
			<span style="color: #FF1493;">if</span> (len == lss) {
				icsk-&gt;icsk_ack.rcv_mss = len;
				<span style="color: #FF1493;">return</span>;
			}
		}
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20854;&#20182;&#24773;&#20917;&#20316;&#20026;&#25509;&#25910;&#21040;&#21040;&#23567;&#21253;&#22788;&#29702;&#65292;&#22914;&#26524;&#26159;&#31532;&#19968;&#27425;&#25509;&#25910;&#21040;&#65292;</span>
<span style="color: #8B8878;">                &#21017;&#35774;&#32622;&#21457;&#36865;&#30830;&#35748;&#32039;&#24613;&#31243;&#24230;&#20026;ICSK_ACK_PUSHED&#12290;</span>
<span style="color: #8B8878;">                &#22312;&#21457;&#36865;&#30830;&#35748;&#32039;&#24613;&#31243;&#24230;&#20026;ICSK_ACK_PUSHED&#26102;&#65292;&#20877;&#27425;&#25509;&#25910;&#21040;&#23567;&#21253;&#65292;&#21017;&#35774;&#32622;&#20026;ICSK_ACK_PUSHED2</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (icsk-&gt;icsk_ack.pending &amp; ICSK_ACK_PUSHED)
			icsk-&gt;icsk_ack.pending |= ICSK_ACK_PUSHED2;
		icsk-&gt;icsk_ack.pending |= ICSK_ACK_PUSHED;
	}
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org27a6f03" class="outline-4">
<h4 id="org27a6f03"><span class="section-number-4">9.3.3</span> 清除发送确认紧急程度和状态标志</h4>
<div class="outline-text-4" id="text-9-3-3">
<p>
在构建TCP段时，如果存在TCPCB_FLAG_ACK标志，则说明此次发送的段带有ACK确认序号，因此需要清除”发送确认紧急程度和状态“，以免在此后再发送不必要的ACK段，影响性能，参见tcp_retransmit_skb()和tcp_event_ack_sent()。
</p>
</div>
</div>
</div>


<div id="outline-container-orgd6e1437" class="outline-3">
<h3 id="orgd6e1437"><span class="section-number-3">9.4</span> 延迟或快速确认</h3>
<div class="outline-text-3" id="text-9-4">
<p>
在ESTABLISHED状态下接收到段后，如果执行慢速路径，则处理完后会调用tcp_data_snd_check()检查是否有数据需要发送。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_ack_snd_check</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>)
{
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>inet_csk_ack_scheduled(sk)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#26597;&#26159;&#21542;&#26377;ACK&#38656;&#35201;&#21457;&#36865;</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We sent a data segment already.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">return</span>;
	}
	<span style="color: #CDC673;">/** &#35813;&#20989;&#25968;&#22312;&#28385;&#36275;&#19968;&#19979;&#26465;&#20214;&#26102;&#65292;&#21450;&#26102;&#21457;&#36865;ACK,&#21542;&#21017;&#24310;&#36831;&#21457;&#36865;ACK&#65306;</span>
<span style="color: #CDC673;">        + &#25509;&#25910;&#31383;&#21475;&#20013;&#26377;&#22810;&#20010;&#20840;&#23610;&#23544;&#27573;&#36824;&#26410;&#30830;&#35748;</span>
<span style="color: #CDC673;">        + &#24403;&#21069;&#22788;&#20110;&#24555;&#36895;&#30830;&#35748;&#27169;&#24335;&#19979;</span>
<span style="color: #CDC673;">        + &#22312;&#21551;&#29992;&#21028;&#26029;&#20081;&#24207;&#38431;&#21015;&#30340;&#24773;&#20917;&#19979;&#65292;&#20081;&#24207;&#38431;&#21015;&#20013;&#23384;&#22312;&#27573;*/</span>
	__tcp_ack_snd_check(sk, 1);
}

<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * Check if sending an ack is needed.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">__tcp_ack_snd_check</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ofo_possible</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);

	    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">More than one full frame received...</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (((tp-&gt;rcv_nxt - tp-&gt;rcv_wup) &gt; inet_csk(sk)-&gt;icsk_ack.rcv_mss
	     <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">... and right edge of window advances far enough.</span>
<span style="color: #8B8878;">              * (tcp_recvmsg() will send ACK otherwise). Or...</span>
<span style="color: #8B8878;">              */</span>
	     &amp;&amp; __tcp_select_window(sk) &gt;= tp-&gt;rcv_wnd) ||
	    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We ACK each frame or...</span><span style="color: #8B8878;"> */</span>
	    tcp_in_quickack_mode(sk) ||
	    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We have out of order data.</span><span style="color: #8B8878;"> */</span>
	    (ofo_possible &amp;&amp;
	     skb_peek(&amp;tp-&gt;out_of_order_queue))) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Then ack it now</span><span style="color: #8B8878;"> */</span>
		tcp_send_ack(sk);
	} <span style="color: #FF1493;">else</span> {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Else, send delayed ack.</span><span style="color: #8B8878;"> */</span>
		tcp_send_delayed_ack(sk);
	}
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org16f8a64" class="outline-2">
<h2 id="org16f8a64"><span class="section-number-2">10</span> recvmsg系统调用在TCP的实现</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-org547f832" class="outline-3">
<h3 id="org547f832"><span class="section-number-3">10.1</span> 套接口层实现</h3>
<div class="outline-text-3" id="text-10-1">
<p>
recvmsg系统调用通过传输层接口sk_prot直接调用到TCP中的传输接口层实现 tcp_recvmsg()。
</p>
</div>
</div>

<div id="outline-container-org33f09d4" class="outline-3">
<h3 id="org33f09d4"><span class="section-number-3">10.2</span> 传输接口层的实现</h3>
<div class="outline-text-3" id="text-10-2">
<p>
tcp_recvmsg()实现把数据从接收队列复制到用户空间中。流程图如下：
</p>


<div class="figure">
<p><img src="image/tcp-input/tcp-recvmsg.png" alt="tcp-recvmsg.png" />
</p>
<p><span class="figure-number">Figure 14: </span>tcp_recvmsg()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      This routine copies from a sock struct into the user buffer.</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> *      Technical note: in 2.3 we work on _locked_ socket, so that</span>
<span style="color: #8B8878;"> *      tricks with *seq access order and skb-&gt;users are not required.</span>
<span style="color: #8B8878;"> *      Probably, code can be easily improved even more.</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_recvmsg</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">kiocb</span> *<span style="color: #FF8C00;">iocb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">msghdr</span> *<span style="color: #FF8C00;">msg</span>,
		<span style="color: #5FD7FF;">size_t</span> <span style="color: #FF8C00;">len</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nonblock</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flags</span>, <span style="color: #5FD7FF;">int</span> *<span style="color: #FF8C00;">addr_len</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">copied</span> = 0;
	<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">peek_seq</span>;
	<span style="color: #5FD7FF;">u32</span> *<span style="color: #FF8C00;">seq</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">used</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">target</span>;             <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Read at least this many bytes</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">timeo</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">task_struct</span> *<span style="color: #FF8C00;">user_recv</span> = <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">copied_early</span> = 0;

	lock_sock(sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23545;&#20256;&#36755;&#23618;&#19978;&#38145;&#65292;&#36991;&#20813;&#35835;&#21462;&#36807;&#31243;&#20013;&#36719;&#20013;&#26029;&#25805;&#20316;&#20256;&#36755;&#23618;</span>

	TCP_CHECK_TIMER(sk);

	err = -ENOTCONN;
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state == TCP_LISTEN) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35813;&#29366;&#24577;&#19981;&#20801;&#35768;&#35835;&#21462;&#25968;&#25454;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#38459;&#22622;&#35835;&#21462;&#30340;&#36229;&#26102;&#65292;&#38750;&#38459;&#22622;&#21017;&#20026;0</span>
	timeo = sock_rcvtimeo(sk, nonblock);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Urgent data needs to be handled specially.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (flags &amp; MSG_OOB) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35835;&#21462;&#24102;&#22806;&#25968;&#25454;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">recv_urg</span>;

	<span style="color: #CDC673;">/** &#20877;&#25226;&#25968;&#25454;&#20174;&#25509;&#25910;&#32531;&#23384;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#36807;&#31243;&#20013;&#65292;&#20250;&#26356;&#26032;&#24403;&#21069;&#24050;&#22797;&#21046;&#20301;&#32622;&#65292;</span>
<span style="color: #CDC673;">        &#20197;&#21450;&#27573;&#24207;&#21495;&#12290;&#22914;&#26524;&#25509;&#25910;&#25968;&#25454;&#65292;&#21017;&#20250;&#26356;&#26032;copied_seq&#65292;&#22914;&#26524;&#21482;&#26159;&#26597;&#30475;&#25968;&#25454;&#65292;</span>
<span style="color: #CDC673;">        &#24182;&#19981;&#20174;&#31995;&#32479;&#32531;&#20914;&#21306;&#31227;&#36208;&#25968;&#25454;&#65292;&#21017;&#19981;&#33021;&#26356;&#26032;copied_seq&#12290;&#22240;&#27492;&#22312;&#25968;&#25454;&#22797;&#21046;&#21040;</span>
<span style="color: #CDC673;">        &#29992;&#25143;&#31354;&#38388;&#36807;&#31243;&#20013;&#65292;&#21306;&#21035;&#25509;&#25910;&#25968;&#25454;&#36824;&#26159;&#26597;&#30475;&#25968;&#25454;&#26159;&#26681;&#25454;&#26159;&#21542;&#26356;&#26032;copied_seq&#65292;</span>
<span style="color: #CDC673;">        &#25152;&#20197;&#36825;&#37324;&#26159;&#26681;&#25454;&#25509;&#25910;&#25968;&#25454;&#36824;&#26159;&#26597;&#30475;&#25968;&#25454;&#26469;&#33719;&#21462;&#35201;&#26356;&#26032;&#26631;&#35760;&#30340;&#22320;&#22336;&#65292;&#21518;&#38754;&#30340;&#22797;&#21046;</span>
<span style="color: #CDC673;">        &#25805;&#20316;&#23601;&#21487;&#20197;&#23436;&#20840;&#19981;&#20851;&#24515;&#26159;&#25509;&#25910;&#36824;&#26159;&#26597;&#30475;&#12290;*/</span>
	seq = &amp;tp-&gt;copied_seq;
	<span style="color: #FF1493;">if</span> (flags &amp; MSG_PEEK) {
		peek_seq = tp-&gt;copied_seq;
		seq = &amp;peek_seq;
	}
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26681;&#25454;&#26159;&#21542;&#35774;&#32622;MSG_WAITALL&#26631;&#24535;&#30830;&#35748;&#26412;&#27425;&#35843;&#29992;&#38656;&#35201;&#25509;&#25910;&#30340;&#25968;&#25454;&#38271;&#24230;&#12290;</span>
<span style="color: #8B8878;">        &#22914;&#26524;&#35774;&#32622;&#35813;&#26631;&#24535;&#65292;&#21017;&#35835;&#21462;&#25968;&#25454;&#38271;&#24230;&#20026;&#29992;&#25143;&#35843;&#29992;&#26102;&#30340;&#21442;&#25968;len&#12290;</span><span style="color: #8B8878;">*/</span>
	target = sock_rcvlowat(sk, flags &amp; MSG_WAITALL, len);

<span style="color: #FF1493;">#ifdef</span> CONFIG_NET_DMA
	tp-&gt;ucopy.dma_chan = <span style="color: #AF87FF;">NULL</span>;
	preempt_disable();
	<span style="color: #FF1493;">if</span> ((len &gt; sysctl_tcp_dma_copybreak) &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>(flags &amp; MSG_PEEK) &amp;&amp;
	    <span style="color: #CDC673; font-weight: bold;">!</span>sysctl_tcp_low_latency &amp;&amp; __get_cpu_var(softnet_data).net_dma) {
		preempt_enable_no_resched();
		tp-&gt;ucopy.pinned_list = dma_pin_iovec_pages(msg-&gt;msg_iov, len);
	} <span style="color: #FF1493;">else</span>
		preempt_enable_no_resched();
<span style="color: #FF1493;">#endif</span>

	<span style="color: #FF1493;">do</span> {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;
		<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">offset</span>;
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36890;&#36807;urg_data&#21644;urg_seq&#26469;&#26816;&#27979;&#24403;&#21069;&#26159;&#21542;&#35835;&#21462;&#21040;&#24102;&#22806;&#25968;&#25454;&#12290;</span>
<span style="color: #8B8878;">                &#22914;&#26524;&#22312;&#35835;&#21040;&#24102;&#22806;&#25968;&#25454;&#20043;&#21069;&#24050;&#32463;&#35835;&#21462;&#20102;&#37096;&#20998;&#25968;&#25454;&#65292;&#21017;&#32456;&#27490;&#26412;&#27425;&#27491;&#24120;&#25968;&#25454;&#30340;&#25509;&#25910;&#12290;</span>
<span style="color: #8B8878;">                &#21542;&#21017;&#22914;&#26524;&#29992;&#25143;&#36827;&#31243;&#26377;&#20449;&#21495;&#24453;&#22788;&#29702;&#65292;&#20063;&#32456;&#27490;&#35835;&#21462;&#12290;</span><span style="color: #8B8878;">*/</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Are we at urgent data? Stop if we have read anything or have SIGURG pending.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (tp-&gt;urg_data &amp;&amp; tp-&gt;urg_seq == *seq) {
			<span style="color: #FF1493;">if</span> (copied)
				<span style="color: #FF1493;">break</span>;
			<span style="color: #FF1493;">if</span> (signal_pending(current)) {
				copied = timeo ? sock_intr_errno(timeo) : -EAGAIN;
				<span style="color: #FF1493;">break</span>;
			}
		}

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Next get a buffer.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#19979;&#19968;&#20010;&#24453;&#35835;&#21462;&#30340;&#27573;</span>
		skb = skb_peek(&amp;sk-&gt;sk_receive_queue);
		<span style="color: #FF1493;">do</span> {
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#38431;&#21015;&#20026;&#31354;&#65292;&#21017;&#21435;&#22788;&#29702;prequeue&#25110;&#21518;&#22791;&#38431;&#21015;</span>
				<span style="color: #FF1493;">break</span>;

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Now that we have two receive queues this</span>
<span style="color: #8B8878;">                         * shouldn't happen.</span>
<span style="color: #8B8878;">                         *//* </span><span style="color: #8B8878;">&#25509;&#25910;&#38431;&#21015;&#20013;&#27573;&#24207;&#21495;&#27604;&#36739;&#22823;&#65292;&#35828;&#26126;&#20063;&#33719;&#21462;&#19981;&#21040;&#19979;&#19968;&#20010;&#24453;&#35835;&#21462;&#30340;&#27573;</span>
<span style="color: #8B8878;">                        &#21435;&#22788;&#29702;prequeue&#25110;&#21518;&#22791;&#38431;&#21015;&#65292;&#23454;&#38469;&#35813;&#24773;&#20917;&#19981;&#20250;&#21457;&#29983;</span><span style="color: #8B8878;">*/</span>
			<span style="color: #FF1493;">if</span> (before(*seq, TCP_SKB_CB(skb)-&gt;seq)) {
				printk(KERN_INFO <span style="color: #CDC673;">"recvmsg bug: copied %X "</span>
				       <span style="color: #CDC673;">"seq %X\n"</span>, *seq, TCP_SKB_CB(skb)-&gt;seq);
				<span style="color: #FF1493;">break</span>;
			}
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#27492;&#22788;&#24050;&#32463;&#33719;&#21462;&#21040;&#24453;&#35835;&#21462;&#30340;&#27573;&#65292;&#35745;&#31639;&#35813;&#27573;&#24320;&#22987;&#35835;&#21462;&#25968;&#25454;&#30340;&#20559;&#31227;&#20301;&#32622;&#65292;</span>
<span style="color: #8B8878;">                        &#35813;&#20559;&#31227;&#20540;&#24517;&#39035;&#22312;&#35813;&#27573;&#30340;&#25968;&#25454;&#38271;&#24230;&#33539;&#22260;&#20869;&#25165;&#26377;&#25928;</span><span style="color: #8B8878;">*/</span>
			offset = *seq - TCP_SKB_CB(skb)-&gt;seq;
			<span style="color: #FF1493;">if</span> (skb-&gt;h.th-&gt;syn) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">syn&#20250;&#21344;&#29992;&#19968;&#20010;&#24207;&#21495;&#65292;&#22240;&#27492;offset&#20943;1</span>
				offset--;
			<span style="color: #FF1493;">if</span> (offset &lt; skb-&gt;len) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20559;&#31227;&#22312;&#27573;&#38271;&#24230;&#33539;&#22260;&#20869;&#65292;&#21017;&#26377;&#25928;</span>
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">found_ok_skb</span>;
			<span style="color: #FF1493;">if</span> (skb-&gt;h.th-&gt;fin) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">fin&#26631;&#24535;</span>
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">found_fin_ok</span>;
			BUG_TRAP(flags &amp; MSG_PEEK);
			skb = skb-&gt;next;
		} <span style="color: #FF1493;">while</span> (skb != (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *)&amp;sk-&gt;sk_receive_queue);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Well, if we have backlog, try to process it now yet.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#21482;&#26377;&#22312;&#35835;&#21462;&#23436;&#25968;&#25454;&#21518;&#65292;&#25165;&#33021;&#22788;&#29702;&#21518;&#22791;&#38431;&#21015;&#12290;</span><span style="color: #8B8878;">*/</span>

		<span style="color: #FF1493;">if</span> (copied &gt;= target &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>sk-&gt;sk_backlog.tail)
			<span style="color: #FF1493;">break</span>;
		<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#30001;&#20110;&#26159;&#22240;&#20026;&#29992;&#25143;&#36827;&#31243;&#38145;&#23450;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#25165;&#20250;&#23558;TCP&#27573;&#32531;&#23384;&#21040;&#21518;&#22791;&#38431;&#21015;&#20013;&#65292;</span>
<span style="color: #8B8878;">                &#22240;&#27492;&#19968;&#26086;&#29992;&#25143;&#36827;&#31243;&#37322;&#25918;&#20256;&#36755;&#25511;&#21046;&#22359;&#23601;&#24212;&#35813;&#31435;&#21363;&#22788;&#29702;&#21518;&#22791;&#38431;&#21015;&#12290;&#22788;&#29702;&#21518;&#22791;&#38431;&#21015;</span>
<span style="color: #8B8878;">                &#22312;release_sock()&#20013;&#23454;&#29616;&#65292;&#19968;&#30830;&#20445;&#22312;&#20219;&#20309;&#26102;&#20505;&#35299;&#38145;&#20256;&#36755;&#25511;&#21046;&#22359;&#26102;&#33021;&#31435;&#21363;&#22788;&#29702;&#21518;&#22791;&#38431;&#21015;&#12290;</span><span style="color: #8B8878;">*/</span>

		<span style="color: #CDC673;">/** &#25509;&#25910;&#38431;&#21015;&#20013;&#21487;&#35835;&#30340;&#27573;&#24050;&#32463;&#35835;&#23436;&#65292;&#22312;&#22788;&#29702;prequeue&#25110;&#21518;&#22791;&#38431;&#21015;&#20043;&#21069;&#38656;&#35201;&#26816;&#27979;</span>
<span style="color: #CDC673;">                &#26159;&#21542;&#26377;&#23548;&#33268;&#36820;&#22238;&#30340;&#20107;&#20214;&#12289;&#29366;&#24577;&#31561;&#12290;&#22914;&#26524;&#26377;&#39044;&#26399;&#30340;&#20107;&#20214;&#21457;&#29983;&#65292;&#21017;&#32467;&#26463;&#36825;&#27425;&#35835;&#21462;&#12290;</span>
<span style="color: #CDC673;">                &#36820;&#22238;&#21069;&#39034;&#20415;&#26816;&#27979;&#21518;&#22791;&#38431;&#21015;&#26159;&#21542;&#23384;&#22312;&#25968;&#25454;&#65292;&#22914;&#26524;&#26377;&#21017;&#22788;&#29702;*/</span>
		<span style="color: #FF1493;">if</span> (copied) {
			<span style="color: #FF1493;">if</span> (sk-&gt;sk_err ||  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#29983;&#38169;&#35823;</span>
			    sk-&gt;sk_state == TCP_CLOSE || <span style="color: #8B8878;">//</span><span style="color: #8B8878;">CLOSE&#29366;&#24577;</span>
			    (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN) || <span style="color: #8B8878;">//</span><span style="color: #8B8878;">shutdown&#29366;&#24577;&#65292;&#19981;&#20801;&#35768;&#25509;&#25910;&#25968;&#25454;</span>
			    <span style="color: #CDC673; font-weight: bold;">!</span>timeo || <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;&#38459;&#22622;</span>
			    signal_pending(current) || <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26377;&#20449;&#21495;</span>
			    (flags &amp; MSG_PEEK))  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21482;&#26159;&#26597;&#30475;&#25968;&#25454;</span>
				<span style="color: #FF1493;">break</span>;
		} <span style="color: #FF1493;">else</span> {
			<span style="color: #FF1493;">if</span> (sock_flag(sk, SOCK_DONE))  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">TCP&#20250;&#35805;&#26159;&#21542;&#21363;&#23558;&#32467;&#26463;</span>
				<span style="color: #FF1493;">break</span>;

			<span style="color: #FF1493;">if</span> (sk-&gt;sk_err) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26377;&#38169;&#35823;&#65292;&#21017;&#36820;&#22238;&#38169;&#35823;</span>
				copied = sock_error(sk);
				<span style="color: #FF1493;">break</span>;
			}

			<span style="color: #FF1493;">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24050;&#32463;shutdown</span>
				<span style="color: #FF1493;">break</span>;

			<span style="color: #FF1493;">if</span> (sk-&gt;sk_state == TCP_CLOSE) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">TCP&#29366;&#24577;&#20026;CLOSE</span>
				<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sock_flag(sk, SOCK_DONE)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20294;&#26159;&#22871;&#25509;&#21475;&#29366;&#24577;&#19981;&#26159;SOCK_DONE</span>
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27492;&#26102;&#21487;&#33021;&#26159;&#36827;&#31243;&#35835;&#21462;&#19968;&#20010;&#27809;&#26377;&#24314;&#31435;&#36215;&#36830;&#25509;&#30340;&#22871;&#25509;&#21475;</span>
					<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">This occurs when user tries to read</span>
<span style="color: #8B8878;">                                         * from never connected socket.</span>
<span style="color: #8B8878;">                                         */</span>
					copied = -ENOTCONN;
					<span style="color: #FF1493;">break</span>;
				}
				<span style="color: #FF1493;">break</span>;
			}

			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>timeo) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;&#38459;&#22622;&#65292;&#19988;&#27809;&#26377;&#35835;&#21462;&#21040;&#25968;&#25454;</span>
				copied = -EAGAIN;
				<span style="color: #FF1493;">break</span>;
			}

			<span style="color: #FF1493;">if</span> (signal_pending(current)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25910;&#21040;&#20449;&#21495;</span>
				copied = sock_intr_errno(timeo);
				<span style="color: #FF1493;">break</span>;
			}
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;&#26159;&#21542;&#26377;&#30830;&#35748;&#38656;&#35201;&#31435;&#21363;&#21457;&#36865;</span>
		tcp_cleanup_rbuf(sk, copied);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20026;&#21551;&#29992;tcp_low_latency&#26102;&#65292;&#26816;&#27979;&#26159;&#21542;&#38656;&#35201;&#22788;&#29702;prequeue&#38431;&#21015;</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sysctl_tcp_low_latency &amp;&amp; tp-&gt;ucopy.task == user_recv) {
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Install new reader</span><span style="color: #8B8878;"> */</span>
			<span style="color: #CDC673;">/** &#22914;&#26524;&#26159;&#26412;&#27425;&#35835;&#21462;&#20013;&#39318;&#27425;&#26816;&#27979;&#22788;&#29702;prequeue&#38431;&#21015;&#65292;</span>
<span style="color: #CDC673;">                        &#21017;&#38656;&#35201;&#35774;&#32622;&#27491;&#22312;&#35835;&#21462;&#30340;&#36827;&#31243;&#25551;&#36848;&#31526;&#12289;&#32531;&#23384;&#22320;&#22336;&#20449;&#24687;&#12290;&#36825;&#26679;&#24403;&#35835;&#21462;&#36827;&#31243;&#36827;&#20837;&#30561;&#30496;&#21518;&#65292;</span>
<span style="color: #CDC673;">                        ESTABLISHED&#29366;&#24577;&#30340;&#25509;&#25910;&#22788;&#29702;&#23601;&#26377;&#26426;&#20250;&#30452;&#25509;&#25226;&#25968;&#25454;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;*/</span>
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>user_recv &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>(flags &amp; (MSG_TRUNC | MSG_PEEK))) {
				user_recv = current;
				tp-&gt;ucopy.task = user_recv;
				tp-&gt;ucopy.iov = msg-&gt;msg_iov;
			}
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#24403;&#21069;&#21487;&#20197;&#20351;&#29992;&#30340;&#29992;&#25143;&#32531;&#23384;&#22823;&#23567;</span>
			tp-&gt;ucopy.len = len;

			BUG_TRAP(tp-&gt;copied_seq == tp-&gt;rcv_nxt ||
				 (flags &amp; (MSG_PEEK | MSG_TRUNC)));

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Ugly... If prequeue is not empty, we have to</span>
<span style="color: #8B8878;">                         * process it before releasing socket, otherwise</span>
<span style="color: #8B8878;">                         * order will be broken at second iteration.</span>
<span style="color: #8B8878;">                         * More elegant solution is required!!!</span>
<span style="color: #8B8878;">                         *</span>
<span style="color: #8B8878;">                         * Look: we have the following (pseudo)queues:</span>
<span style="color: #8B8878;">                         *</span>
<span style="color: #8B8878;">                         * 1. packets in flight</span>
<span style="color: #8B8878;">                         * 2. backlog</span>
<span style="color: #8B8878;">                         * 3. prequeue</span>
<span style="color: #8B8878;">                         * 4. receive_queue</span>
<span style="color: #8B8878;">                         *</span>
<span style="color: #8B8878;">                         * Each queue can be processed only if the next ones</span>
<span style="color: #8B8878;">                         * are empty. At this point we have empty receive_queue.</span>
<span style="color: #8B8878;">                         * But prequeue _can_ be not empty after 2nd iteration,</span>
<span style="color: #8B8878;">                         * when we jumped to start of loop because backlog</span>
<span style="color: #8B8878;">                         * processing added something to receive_queue.</span>
<span style="color: #8B8878;">                         * We cannot release_sock(), because backlog contains</span>
<span style="color: #8B8878;">                         * packets arrived _after_ prequeued ones.</span>
<span style="color: #8B8878;">                         *</span>
<span style="color: #8B8878;">                         * Shortly, algorithm is clear --- to process all</span>
<span style="color: #8B8878;">                         * the queues in order. We could make it more directly,</span>
<span style="color: #8B8878;">                         * requeueing packets from backlog to prequeue, if</span>
<span style="color: #8B8878;">                         * is not empty. It is more elegant, but eats cycles,</span>
<span style="color: #8B8878;">                         * unfortunately.</span>
<span style="color: #8B8878;">                         *///</span><span style="color: #8B8878;">prequeue&#38431;&#21015;&#19981;&#20026;&#31354;&#65292;&#21017;&#36339;&#36716;&#22788;&#29702;</span>
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb_queue_empty(&amp;tp-&gt;ucopy.prequeue))
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">do_prequeue</span>;

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">__ Set realtime policy in scheduler __</span><span style="color: #8B8878;"> */</span>
		}
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#35835;&#21462;&#23436;&#25968;&#25454;&#65292;&#21017;&#36890;&#36807;release_sock&#35299;&#38145;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#20027;&#35201;&#29992;&#26469;&#22788;&#29702;&#21518;&#22791;&#38431;&#21015;&#65292;</span>
<span style="color: #8B8878;">                &#23436;&#25104;&#21518;&#20877;&#35843;&#29992;lock_sock&#38145;&#23450;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#38145;&#23450;&#26102;&#21487;&#33021;&#30561;&#30496;</span><span style="color: #8B8878;">*/</span>
		<span style="color: #FF1493;">if</span> (copied &gt;= target) {
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Do not sleep, just process backlog.</span><span style="color: #8B8878;"> */</span>
			release_sock(sk);
			lock_sock(sk);
		} <span style="color: #FF1493;">else</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#26159;&#38459;&#22622;&#35835;&#21462;&#65292;&#19988;&#36824;&#27809;&#26377;&#35835;&#21462;&#23436;&#65292;&#21017;&#30561;&#30496;&#31561;&#24453;&#25509;&#25910;&#25968;&#25454;</span>
			sk_wait_data(sk, &amp;timeo);

<span style="color: #FF1493;">#ifdef</span> CONFIG_NET_DMA
		tp-&gt;ucopy.wakeup = 0;
<span style="color: #FF1493;">#endif</span>

		<span style="color: #FF1493;">if</span> (user_recv) {
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">chunk</span>;

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">__ Restore normal policy in scheduler __</span><span style="color: #8B8878;"> */</span>
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#21097;&#20313;&#30340;&#29992;&#25143;&#31354;&#38388;&#38271;&#24230;&#21644;&#19968;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#30340;&#25968;&#25454;&#38271;&#24230;</span>
			<span style="color: #FF1493;">if</span> ((chunk = len - tp-&gt;ucopy.len) != 0) {
				NET_ADD_STATS_USER(LINUX_MIB_TCPDIRECTCOPYFROMBACKLOG, chunk);
				len -= chunk;
				copied += chunk;
			}
			<span style="color: #CDC673;">/** &#22914;&#26524;&#25509;&#25910;&#21040;&#25509;&#25910;&#38431;&#21015;&#20013;&#30340;&#25968;&#25454;&#24050;&#32463;&#20840;&#37096;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65292;&#20294;&#26159;prequeue&#19981;&#20026;&#31354;&#65292;</span>
<span style="color: #CDC673;">                        &#21017;&#32487;&#32493;&#22788;&#29702;prequeue&#38431;&#21015;&#65292;&#24182;&#26356;&#26032;&#21097;&#20313;&#29992;&#25143;&#31354;&#38388;&#38271;&#24230;&#21644;&#24050;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#30340;&#38271;&#24230;*/</span>
			<span style="color: #FF1493;">if</span> (tp-&gt;rcv_nxt == tp-&gt;copied_seq &amp;&amp;
			    <span style="color: #CDC673; font-weight: bold;">!</span>skb_queue_empty(&amp;tp-&gt;ucopy.prequeue)) {
<span style="color: #AF87FF;">do_prequeue</span>:
				tcp_prequeue_process(sk);

				<span style="color: #FF1493;">if</span> ((chunk = len - tp-&gt;ucopy.len) != 0) {
					NET_ADD_STATS_USER(LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE, chunk);
					len -= chunk;
					copied += chunk;
				}
			}
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;prequeue&#38431;&#21015;&#21518;&#65292;&#22914;&#26524;&#26377;&#26356;&#26032;copied_seq,&#19988;&#21482;&#26159;&#26597;&#30475;&#25968;&#25454;&#65292;&#21017;&#38656;&#26356;&#26032;peek_seq</span>
		<span style="color: #FF1493;">if</span> ((flags &amp; MSG_PEEK) &amp;&amp; peek_seq != tp-&gt;copied_seq) {
			<span style="color: #FF1493;">if</span> (net_ratelimit())
				printk(KERN_DEBUG <span style="color: #CDC673;">"TCP(%s:%d): Application bug, race in MSG_PEEK.\n"</span>,
				       current-&gt;comm, current-&gt;pid);
			peek_seq = tp-&gt;copied_seq;
		}
		<span style="color: #FF1493;">continue</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32487;&#32493;&#19979;&#19968;&#20010;&#27573;</span>

	<span style="color: #AF87FF;">found_ok_skb</span>:
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Ok so how much can we use?</span><span style="color: #8B8878;"> */</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#21487;&#35835;&#27573;&#30340;&#25968;&#25454;&#38271;&#24230;&#65292;&#20043;&#21069;&#24050;&#32463;&#33719;&#21462;&#21040;&#26412;&#27425;&#35835;&#21462;&#25968;&#25454;&#22312;&#35813;&#27573;&#30340;&#20559;&#31227;offset</span>
		used = skb-&gt;len - offset;
		<span style="color: #FF1493;">if</span> (len &lt; used)
			used = len;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Do we have urgent data here?</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (tp-&gt;urg_data) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24102;&#22806;&#25968;&#25454;&#65292;&#33719;&#21462;&#24102;&#22806;&#25968;&#25454;&#22312;&#35813;&#27573;&#30340;&#20559;&#31227;</span>
			<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">urg_offset</span> = tp-&gt;urg_seq - *seq;
			<span style="color: #FF1493;">if</span> (urg_offset &lt; used) {
				<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>urg_offset) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24102;&#22806;&#25968;&#25454;&#20559;&#31227;&#20026;0&#65292;&#21017;&#24403;&#21069;&#23601;&#26159;&#24102;&#22806;&#25968;&#25454;</span>
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#19981;&#20801;&#35768;&#23558;&#24102;&#22806;&#25968;&#25454;&#25918;&#20837;&#27491;&#24120;&#25968;&#25454;&#27969;</span>
					<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sock_flag(sk, SOCK_URGINLINE)) {
						++*seq;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#25972;&#24050;&#35835;&#21462;seq</span>
						offset++; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#25972;&#27491;&#24120;&#25968;&#25454;&#20559;&#31227;</span>
						used--;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#25972;&#21487;&#35835;&#25968;&#25454;&#38271;&#24230;</span>
						<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>used)  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#27809;&#26377;&#21487;&#35835;&#25968;&#25454;&#65292;&#21017;&#36339;&#36716;</span>
							<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">skip_copy</span>;
					}
				} <span style="color: #FF1493;">else</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24102;&#22806;&#25968;&#25454;&#20559;&#31227;&#19981;&#20026;0</span>
					used = urg_offset;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35835;&#21462;&#21040;&#24102;&#22806;&#25968;&#25454;&#20301;&#32622;</span>
			}
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#35835;&#21462;&#25968;&#25454;&#30340;&#24773;&#20917;</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>(flags &amp; MSG_TRUNC)) {
<span style="color: #FF1493;">#ifdef</span> CONFIG_NET_DMA
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;ucopy.dma_chan &amp;&amp; tp-&gt;ucopy.pinned_list)
				tp-&gt;ucopy.dma_chan = get_softnet_dma();

			<span style="color: #FF1493;">if</span> (tp-&gt;ucopy.dma_chan) {
				tp-&gt;ucopy.dma_cookie = dma_skb_copy_datagram_iovec(
					tp-&gt;ucopy.dma_chan, skb, offset,
					msg-&gt;msg_iov, used,
					tp-&gt;ucopy.pinned_list);

				<span style="color: #FF1493;">if</span> (tp-&gt;ucopy.dma_cookie &lt; 0) {

					printk(KERN_ALERT <span style="color: #CDC673;">"dma_cookie &lt; 0\n"</span>);

					<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Exception. Bailout!</span><span style="color: #8B8878;"> */</span>
					<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>copied)
						copied = -EFAULT;
					<span style="color: #FF1493;">break</span>;
				}
				<span style="color: #FF1493;">if</span> ((offset + used) == skb-&gt;len)
					copied_early = 1;

			} <span style="color: #FF1493;">else</span>
<span style="color: #FF1493;">#endif</span>
			{ <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#25968;&#25454;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;</span>
				err = skb_copy_datagram_iovec(skb, offset,
						msg-&gt;msg_iov, used);
				<span style="color: #FF1493;">if</span> (err) {
					<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Exception. Bailout!</span><span style="color: #8B8878;"> */</span>
					<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>copied)
						copied = -EFAULT;
					<span style="color: #FF1493;">break</span>;
				}
			}
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#25972;&#21442;&#25968;&#65292;&#22914;&#26524;&#26159;&#25130;&#26029;&#65292;&#21017;&#22312;&#35843;&#25972;&#21442;&#25968;&#21518;&#65292;&#22810;&#20313;&#25968;&#25454;&#34987;&#20002;&#24323;</span>
		*seq += used; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24050;&#35835;&#21462;&#25968;&#25454;&#24207;&#21495;</span>
		copied += used;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24050;&#32463;&#35835;&#21462;&#25968;&#25454;&#38271;&#24230;</span>
		len -= used; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21097;&#20313;&#29992;&#25143;&#31354;&#38388;&#32531;&#23384;&#21487;&#29992;&#38271;&#24230;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#25972;&#21512;&#29702;&#30340;TCP&#25509;&#25910;&#32531;&#20914;&#21306;&#22823;&#23567;</span>
		tcp_rcv_space_adjust(sk);

<span style="color: #AF87FF;">skip_copy</span>:
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#22788;&#29702;&#23436;&#24102;&#22806;&#25968;&#25454;&#65292;&#21017;&#23558;urg_data&#28165;&#38500;</span>
		<span style="color: #FF1493;">if</span> (tp-&gt;urg_data &amp;&amp; after(tp-&gt;copied_seq, tp-&gt;urg_seq)) {
			tp-&gt;urg_data = 0;
			tcp_fast_path_check(sk, tp);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#39318;&#37096;&#39044;&#27979;&#26631;&#24535;&#65292;&#19979;&#20010;&#25509;&#25910;&#30340;&#27573;&#25191;&#34892;&#39044;&#27979;</span>
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#35813;&#27573;&#36824;&#26377;&#25968;&#25454;&#26410;&#35835;&#65288;&#22914;&#24102;&#22806;&#25968;&#25454;&#65289;&#65292;&#21017;&#32487;&#32493;&#22788;&#29702;&#35813;&#27573;</span>
		<span style="color: #FF1493;">if</span> (used + offset &lt; skb-&gt;len)
			<span style="color: #FF1493;">continue</span>;

		<span style="color: #FF1493;">if</span> (skb-&gt;h.th-&gt;fin)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">found_fin_ok</span>;
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>(flags &amp; MSG_PEEK)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24050;&#32463;&#35835;&#23436;&#35813;&#27573;&#30340;&#25968;&#25454;&#65292;&#19988;&#19981;&#26159;&#26597;&#30475;&#25968;&#25454;&#65292;&#21017;&#21487;&#20197;&#21024;&#38500;&#35813;SKB</span>
			sk_eat_skb(sk, skb, copied_early);
			copied_early = 0;
		}
		<span style="color: #FF1493;">continue</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#21518;&#32493;&#27573;</span>

	<span style="color: #AF87FF;">found_fin_ok</span>:
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Process the FIN.</span><span style="color: #8B8878;"> */</span>
		++*seq;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">FIN&#21344;&#29992;&#19968;&#20010;&#24207;&#21495;</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>(flags &amp; MSG_PEEK)) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24050;&#32463;&#35835;&#23436;&#35813;&#27573;&#30340;&#25968;&#25454;&#65292;&#19988;&#19981;&#26159;&#26597;&#30475;&#25968;&#25454;&#65292;&#21017;&#21487;&#20197;&#21024;&#38500;&#35813;SKB</span>
			sk_eat_skb(sk, skb, copied_early);
			copied_early = 0;
		}
		<span style="color: #FF1493;">break</span>;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#21040;FIN&#21518;&#26080;&#38656;&#20877;&#22788;&#29702;&#21518;&#32493;&#27573;</span>
	} <span style="color: #FF1493;">while</span> (len &gt; 0);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26410;&#21551;&#29992;tcp_low_latency</span>
	<span style="color: #FF1493;">if</span> (user_recv) {
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb_queue_empty(&amp;tp-&gt;ucopy.prequeue)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">prequeue&#38431;&#21015;&#19981;&#20026;&#31354;&#65292;&#21017;&#22788;&#29702;</span>
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">chunk</span>;

			tp-&gt;ucopy.len = copied &gt; 0 ? len : 0;

			tcp_prequeue_process(sk);
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;prequeue&#36807;&#31243;&#20013;&#65292;&#26377;&#37096;&#20998;&#25968;&#25454;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#65292;&#21017;&#35843;&#25972;&#29992;&#25143;&#31354;&#38388;&#32531;&#23384;&#21644;&#24050;&#35835;&#21462;&#24207;&#21495;</span>
			<span style="color: #FF1493;">if</span> (copied &gt; 0 &amp;&amp; (chunk = len - tp-&gt;ucopy.len) != 0) {
				NET_ADD_STATS_USER(LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE, chunk);
				len -= chunk;
				copied += chunk;
			}
		}
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#28165;&#38500;task&#21644;len,&#34920;&#31034;&#29992;&#25143;&#24403;&#21069;&#27809;&#26377;&#35835;&#21462;&#25968;&#25454;&#12290;</span>
<span style="color: #8B8878;">                &#36825;&#26679;&#22312;&#22788;&#29702;prequeue&#38431;&#21015;&#26102;&#23601;&#19981;&#20250;&#23558;&#25968;&#25454;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#12290;</span>
<span style="color: #8B8878;">                &#22240;&#20026;&#21482;&#26377;&#22312;&#27809;&#26377;&#21551;&#29992;tcp_low_latency&#26102;&#29992;&#25143;&#36827;&#31243;&#20027;&#21160;&#35835;&#21462;&#26102;&#65292;</span>
<span style="color: #8B8878;">                &#25165;&#26377;&#26426;&#20250;&#23558;&#25968;&#25454;&#30452;&#25509;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;</span><span style="color: #8B8878;">*/</span>
		tp-&gt;ucopy.task = <span style="color: #AF87FF;">NULL</span>;
		tp-&gt;ucopy.len = 0;
	}

<span style="color: #FF1493;">#ifdef</span> CONFIG_NET_DMA
	<span style="color: #FF1493;">if</span> (tp-&gt;ucopy.dma_chan) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;
		<span style="color: #5FD7FF;">dma_cookie_t</span> <span style="color: #FF8C00;">done</span>, <span style="color: #FF8C00;">used</span>;

		dma_async_memcpy_issue_pending(tp-&gt;ucopy.dma_chan);

		<span style="color: #FF1493;">while</span> (dma_async_memcpy_complete(tp-&gt;ucopy.dma_chan,
						 tp-&gt;ucopy.dma_cookie, &amp;done,
						 &amp;used) == DMA_IN_PROGRESS) {
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">do partial cleanup of sk_async_wait_queue</span><span style="color: #8B8878;"> */</span>
			<span style="color: #FF1493;">while</span> ((skb = skb_peek(&amp;sk-&gt;sk_async_wait_queue)) &amp;&amp;
			       (dma_async_is_complete(skb-&gt;dma_cookie, done,
						      used) == DMA_SUCCESS)) {
				__skb_dequeue(&amp;sk-&gt;sk_async_wait_queue);
				kfree_skb(skb);
			}
		}

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Safe to free early-copied skbs now</span><span style="color: #8B8878;"> */</span>
		__skb_queue_purge(&amp;sk-&gt;sk_async_wait_queue);
		dma_chan_put(tp-&gt;ucopy.dma_chan);
		tp-&gt;ucopy.dma_chan = <span style="color: #AF87FF;">NULL</span>;
	}
	<span style="color: #FF1493;">if</span> (tp-&gt;ucopy.pinned_list) {
		dma_unpin_iovec_pages(tp-&gt;ucopy.pinned_list);
		tp-&gt;ucopy.pinned_list = <span style="color: #AF87FF;">NULL</span>;
	}
<span style="color: #FF1493;">#endif</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">According to UNIX98, msg_name/msg_namelen are ignored</span>
<span style="color: #8B8878;">         * on connected socket. I was just happy when found this 8) --ANK</span>
<span style="color: #8B8878;">         */</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Clean up data we have read: This will do ACK frames.</span><span style="color: #8B8878;"> */</span>
	tcp_cleanup_rbuf(sk, copied);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23436;&#25104;&#35835;&#21462;&#21518;&#65292;&#20877;&#27425;&#26816;&#27979;&#26159;&#21542;&#26377;&#24517;&#35201;&#31435;&#21363;&#21457;&#36865;ACK</span>

	TCP_CHECK_TIMER(sk);
	release_sock(sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35299;&#38145;sk</span>
	<span style="color: #FF1493;">return</span> copied;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36820;&#22238;&#35835;&#21462;&#23383;&#33410;&#25968;</span>

<span style="color: #AF87FF;">out</span>:
	TCP_CHECK_TIMER(sk);
	release_sock(sk);
	<span style="color: #FF1493;">return</span> err;

<span style="color: #AF87FF;">recv_urg</span>:<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#24102;&#22806;&#25968;&#25454;</span>
	err = tcp_recv_urg(sk, timeo, msg, len, flags, addr_len);
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgb640551" class="outline-2">
<h2 id="orgb640551"><span class="section-number-2">11</span> sk_backlog_rcv接口</h2>
<div class="outline-text-2" id="text-11">
<p>
sk_backlog_rcv接口用于接收预备队列和后备队列的TCP段，tcp中backlog_rcv为tcp_v4_do_rcv()。如果预备队列中还存在TCP段，则调用tcp_prequeue_process()进行与处理，这时backlog_rcv()被回调。
</p>

<p>
如果后备队列还存在TCP段，则调用release_sock()进行处理，这是backlog_rcv函数被回调，参见tcp_v4_do_rcv()。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2022-05-03 Tue 21:23</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
