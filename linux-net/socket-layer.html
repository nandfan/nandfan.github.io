<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>套接口层</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">套接口层</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org154facc">1. socket结构</a></li>
<li><a href="#org74af86b">2. proto_ops结构</a></li>
<li><a href="#orgcf6d884">3. 套接口文件系统</a>
<ul>
<li><a href="#orgf3c7c51">3.1. 套接口文件系统类型</a></li>
<li><a href="#org4aa03ee">3.2. 套接口文件系统超级块操作接口</a></li>
<li><a href="#org18f4f87">3.3. 套接口文件的inode</a></li>
<li><a href="#org95fe8de">3.4. sock_alloc_inode()</a></li>
<li><a href="#orga16f094">3.5. sock_destroy_inode()</a></li>
</ul>
</li>
<li><a href="#org98881d3">4. 套接口文件</a>
<ul>
<li><a href="#orgdf68181">4.1. 套接口文件与套接口的绑定</a>
<ul>
<li><a href="#org834932c">4.1.1. sock_map_fd()</a></li>
<li><a href="#org9dd3ce8">4.1.2. sock_attach_fd()</a></li>
</ul>
</li>
<li><a href="#org3650093">4.2. 根据文件描述符获取套接口</a>
<ul>
<li><a href="#org7dea643">4.2.1. sockfd_lookup_light()</a></li>
<li><a href="#org520ec3b">4.2.2. sock_from_file()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga198d41">5. 进程、文件描述符和套接口</a></li>
<li><a href="#org75d87de">6. 套接口层的系统初始化</a></li>
<li><a href="#orgfc382ff">7. 套接口系统调用</a>
<ul>
<li><a href="#orge3e174a">7.1. 套接口系统调用入口</a></li>
<li><a href="#org2c02078">7.2. socket系统调用</a>
<ul>
<li><a href="#orge3c4a86">7.2.1. sys_socket()</a></li>
<li><a href="#org9b325e0">7.2.2. sock_create()</a></li>
<li><a href="#orgdc81267">7.2.3. inet_create()</a></li>
</ul>
</li>
<li><a href="#org44e2920">7.3. bind系统调用</a>
<ul>
<li><a href="#orgf7bd053">7.3.1. sys_bind()</a></li>
<li><a href="#org4d93e8a">7.3.2. 套接口层的实现 inet_bind()</a></li>
</ul>
</li>
<li><a href="#org7b536a3">7.4. listen系统调用</a></li>
<li><a href="#org2ca6ce9">7.5. accept系统调用</a></li>
<li><a href="#org92fb45f">7.6. connect系统调用</a></li>
<li><a href="#org7bd4837">7.7. shutdown系统调用</a>
<ul>
<li><a href="#org4b0c923">7.7.1. sys_shutdown()</a></li>
<li><a href="#org80c7851">7.7.2. 套接口层的实现</a></li>
</ul>
</li>
<li><a href="#orgd6a3946">7.8. close系统调用</a>
<ul>
<li><a href="#orgbdc327b">7.8.1. 关闭套接口</a></li>
<li><a href="#org59175e3">7.8.2. 套接口层的实现</a></li>
</ul>
</li>
<li><a href="#org595b9d8">7.9. select系统调用实现</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
套接口层位于应用程序和协议栈之间，对应用程序屏蔽了协议相关的实现细节，将应用程序发送的与协议无关的请求映射到与协议相关的实现，由此为应用程序提供了一个网络和进程间的通信接口。
</p>

<p>
通常应用程序中调用库函数，库函数通过系统调用进入套接口层。Linux的套接口层实现提供了一组专门的套接口系统调用，分别在对应的库函数名之前增加“sys_”前缀。 Linux也允许标准I/O系统调用来读写套接字文件。 在创建套接口时，分别与文件和文件描述符进行绑定，此后的操作都通过文件描述符进行。
</p>

<p>
每个传输层协议都对应一个 proto_ops 结构，套接口中包含一个指向该结构的指针，由此实现套接口层和传输层的函数映射。
</p>



<div id="org222c4a7" class="figure">
<p><img src="image/socket-layer/sock-proto.png" alt="sock-proto.png" />
</p>
<p><span class="figure-number">Figure 1: </span>套接口层将一般的请求转换为指定的协议操作</p>
</div>


<div id="outline-container-org154facc" class="outline-2">
<h2 id="org154facc"><span class="section-number-2">1.</span> socket结构</h2>
<div class="outline-text-2" id="text-1">
<p>
套接口代表一条通信链路的一端，存储了该端点所有与通信相关的信息，包括：使用的协议、套接口状态、源和目的地址、到达的连接队列、数据缓存和可选标志等。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> {
        <span style="color: #66D9EF;">socket_state</span>            <span style="color: #FD971F;">state</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26631;&#35782;&#22871;&#25509;&#21475;&#25152;&#22788;&#30340;&#29366;&#24577;&#65292;&#26576;&#20123;&#29366;&#24577;&#21482;&#23545;TCP&#22871;&#25509;&#21475;&#26377;&#24847;&#20041;&#12290;</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>           <span style="color: #FD971F;">flags</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26631;&#24535;&#65292;&#35265;&#19979;&#34920;</span>
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">proto_ops</span> *<span style="color: #FD971F;">ops</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#21521;&#22871;&#25509;&#21475;&#31995;&#32479;&#31995;&#32479;&#35843;&#29992;&#20013;&#36873;&#25321;&#23545;&#24212;&#31867;&#22411;&#30340;&#22871;&#25509;&#21475;&#23618;&#25509;&#21475;&#65292;&#29992;&#26469;&#23558;&#22871;&#25509;&#21475;&#26144;&#23556;&#21040;&#30456;&#24212;&#30340;&#20256;&#36755;&#23618;&#21327;&#35758;&#23454;&#29616;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">fasync_struct</span>    *<span style="color: #FD971F;">fasync_list</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23384;&#20648;&#24322;&#27493;&#36890;&#30693;&#38431;&#21015;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span>             *<span style="color: #FD971F;">file</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#21521;&#19982;&#35813;&#22871;&#25509;&#21475;&#30456;&#20851;&#32852;&#30340;file&#32467;&#26500;&#25351;&#38024;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span>             *<span style="color: #FD971F;">sk</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#21521;&#19982;&#35813;&#22871;&#25509;&#21475;&#20851;&#32852;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        <span style="color: #66D9EF;">wait_queue_head_t</span>       <span style="color: #FD971F;">wait</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31561;&#24453;&#35813;&#22871;&#25509;&#21475;&#30340;&#36827;&#31243;&#38431;&#21015;</span>
        <span style="color: #66D9EF;">short</span>                   <span style="color: #FD971F;">type</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#30340;&#31867;&#22411;</span>
};
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> socket_state的类型</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">socket_state</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SS_FREE</td>
<td class="org-left">该套接口尚未分配，未使用</td>
</tr>

<tr>
<td class="org-left">SS_UNCONNECTED</td>
<td class="org-left">该套接口尚未连接</td>
</tr>

<tr>
<td class="org-left">SS_CONNECTING</td>
<td class="org-left">正在连接过程中</td>
</tr>

<tr>
<td class="org-left">SS_CONNECTED</td>
<td class="org-left">已经连接一个套接口</td>
</tr>

<tr>
<td class="org-left">SS_DISCONNECTING</td>
<td class="org-left">正在断开连接过程中</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> flags的取值</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">flags</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SOCK_ASYNC_NOSPACE</td>
<td class="org-left">标识该套接口的发送队列已满</td>
</tr>

<tr>
<td class="org-left">SOCK_ASYNC_WAITDATA</td>
<td class="org-left">标识应用通过recv接收数据时，是否在等待数据的接收</td>
</tr>

<tr>
<td class="org-left">SOCK_NOSPACE</td>
<td class="org-left">标识非异步的情况下，该套接口的发送队列是否已满</td>
</tr>

<tr>
<td class="org-left">SOCK_PASSCRED</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SOCK_PASSSEC</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> 三种proto_ops结构的实例</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">套接口类型</th>
<th scope="col" class="org-left">对应的 proto_ops 结构实例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">TCP</td>
<td class="org-left">inet_stream_ops</td>
</tr>

<tr>
<td class="org-left">UDP</td>
<td class="org-left">inet_dgram_ops</td>
</tr>

<tr>
<td class="org-left">RAW</td>
<td class="org-left">inet_sockraw_ops</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 4:</span> 套接口的类型</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SOCK_STREAM</td>
<td class="org-left">基于连接的套接口</td>
</tr>

<tr>
<td class="org-left">SOCK_DGRAM</td>
<td class="org-left">基于数据报的套接口</td>
</tr>

<tr>
<td class="org-left">SOCK_RAW</td>
<td class="org-left">原始套接口</td>
</tr>

<tr>
<td class="org-left">SOCK_RDM</td>
<td class="org-left">可靠传送报文套接口</td>
</tr>

<tr>
<td class="org-left">SOCK_SEQPACKET</td>
<td class="org-left">顺序分组套接口</td>
</tr>

<tr>
<td class="org-left">SOCK_DCCP</td>
<td class="org-left">数据包拥塞控制协议套接口</td>
</tr>

<tr>
<td class="org-left">SOCK_PACKET</td>
<td class="org-left">混杂模式套接口</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org74af86b" class="outline-2">
<h2 id="org74af86b"><span class="section-number-2">2.</span> proto_ops结构</h2>
<div class="outline-text-2" id="text-2">
<p>
proto_ops结构包含了一组与套接口系统调用相对应的传输层函数指针，可以把proto_ops结构看作是一张套接口系统调用到传输层函数的跳转表，其中有部分操作会继续通过 proto 结构跳转表，进入具体的传输层或网络层的处理。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">proto_ops</span> {
        <span style="color: #66D9EF;">int</span>             <span style="color: #FD971F;">family</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">module</span>   *<span style="color: #FD971F;">owner</span>;
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">release</span>)   (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">bind</span>)      (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>,
                                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *<span style="color: #FD971F;">myaddr</span>,
                                      <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">sockaddr_len</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">connect</span>)   (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>,
                                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *<span style="color: #FD971F;">vaddr</span>,
                                      <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">sockaddr_len</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">socketpair</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock1</span>,
                                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock2</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">accept</span>)    (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>,
                                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">newsock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">getname</span>)   (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>,
                                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *<span style="color: #FD971F;">addr</span>,
                                      <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">sockaddr_len</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">peer</span>);
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>    (*<span style="color: #A6E22E;">poll</span>)      (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">file</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>,
                                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">poll_table_struct</span> *<span style="color: #FD971F;">wait</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">ioctl</span>)     (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cmd</span>,
                                      <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">arg</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">compat_ioctl</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cmd</span>,
                                      <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">arg</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">listen</span>)    (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">shutdown</span>)  (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">setsockopt</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">level</span>,
                                      <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">optname</span>, <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *optval, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">optlen</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">getsockopt</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">level</span>,
                                      <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">optname</span>, <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *optval, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *optlen);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">compat_setsockopt</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">level</span>,
                                      <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">optname</span>, <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *optval, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">optlen</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">compat_getsockopt</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">level</span>,
                                      <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">optname</span>, <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *optval, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *optlen);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">sendmsg</span>)   (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *<span style="color: #FD971F;">iocb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>,
                                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">m</span>, <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">total_len</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">recvmsg</span>)   (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *<span style="color: #FD971F;">iocb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>,
                                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">m</span>, <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">total_len</span>,
                                      <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>);
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">mmap</span>)      (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">file</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>,
                                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> * <span style="color: #FD971F;">vma</span>);
        <span style="color: #66D9EF;">ssize_t</span>         (*<span style="color: #A6E22E;">sendpage</span>)  (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> *<span style="color: #FD971F;">page</span>,
                                      <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">offset</span>, <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">size</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>);
};
</pre>
</div>

<p>
proto_ops 结构的作用是，完成从与协议无关的套接口层到协议相关的传输层转接，proto 结构将传输层映射到网络层，因此，每个传输层协议都需要定义一个特定的 proto_ops 结构 和 proto 结构的实例。
</p>

<p>
IPv4协议族中，每个传输层协议对应一个 inet_protosw 结构，inet_protosw结构中包含了 proto_ops 结构和 proto 结构。  协议族中所有的 inet_protosw 结构的实例都定义在 <code>inetsw_array[]</code> 静态数组中。 网络子系统初始化时，根据每个结构的type成员（socket类型）将其注册到全局的 <code>inetsw[]</code> 数组。
</p>


<div id="org9b7da5e" class="figure">
<p><img src="image/socket-layer/inetsw-inetswarr.png" alt="inetsw-inetswarr.png" />
</p>
<p><span class="figure-number">Figure 2: </span>inetsw[]和inetsw_array[]</p>
</div>

<p>
当需要创建套接口时，搜索 inetsw[] 数组，查找匹配的 inet_protosw 结构，并将inet_protosw结构的 proto_ops 成员存储在socket的ops中，proto成员则存储在sock结构的sk_prot中。
</p>
</div>
</div>

<div id="outline-container-orgcf6d884" class="outline-2">
<h2 id="orgcf6d884"><span class="section-number-2">3.</span> 套接口文件系统</h2>
<div class="outline-text-2" id="text-3">
<p>
每种文件都有各自的文件类型，套接口关联的文件类型为套接口文件。
</p>
</div>

<div id="outline-container-orgf3c7c51" class="outline-3">
<h3 id="orgf3c7c51"><span class="section-number-3">3.1.</span> 套接口文件系统类型</h3>
<div class="outline-text-3" id="text-3-1">
<p>
为了使套接口与文件描述符关联，并且支持特殊套接口层的i结点的分配和释放，为此定义了 sockfs文件系统类型 sock_fs_type，通过sockfs文件系统的get_sb接口和超级块操作集合中的 alloc_inode和 destroy_inode，可以分配和释放与套接口文件相关的i结点。
</p>

<p>
<i>通过/proc/filesystems 文件，可以查看系统支持的文件系统。</i>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_system_type</span> <span style="color: #FD971F;">sock_fs_type</span> = {
        .name =         <span style="color: #E6DB74;">"sockfs"</span>,
        .get_sb =       sockfs_get_sb,
        .kill_sb =      kill_anon_super,
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org4aa03ee" class="outline-3">
<h3 id="org4aa03ee"><span class="section-number-3">3.2.</span> 套接口文件系统超级块操作接口</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#25991;&#20214;&#31995;&#32479;&#30340;&#25805;&#20316;&#25509;&#21475;&#23450;&#20041;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_operations</span> <span style="color: #FD971F;">sockfs_ops</span> = {
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#25991;&#20214;&#31995;&#32479;&#30340;i&#32467;&#28857;&#20998;&#37197;&#20989;&#25968;</span>
        .alloc_inode     = sock_alloc_inode,
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#25991;&#20214;&#31995;&#32479;&#30340;i&#32467;&#28857;&#37322;&#25918;&#20989;&#25968;</span>
        .destroy_inode   = sock_destroy_inode,
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#22871;&#25509;&#21475;&#25991;&#20214;&#31995;&#32479;&#30340;&#29366;&#24577;&#20449;&#24687;</span>
        .statfs          = simple_statfs,
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org18f4f87" class="outline-3">
<h3 id="org18f4f87"><span class="section-number-3">3.3.</span> 套接口文件的inode</h3>
<div class="outline-text-3" id="text-3-3">
<p>
套接口文件系统的i结点和套接口是一一对应的。系统定义了 socket_alloc 结构，其中将 i结点和socket结构体组合，因此在分配i结点的同时，也分配了socket结构。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket_alloc</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> <span style="color: #FD971F;">socket</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> <span style="color: #FD971F;">vfs_inode</span>;
};
</pre>
</div>

<p>
通过上述结构，我们可以通过套接口定位到i结点，也可以通过i结点定位套接口。
</p>
</div>
</div>

<div id="outline-container-org95fe8de" class="outline-3">
<h3 id="org95fe8de"><span class="section-number-3">3.4.</span> sock_alloc_inode()</h3>
<div class="outline-text-3" id="text-3-4">
<p>
套接口文件系统有自身的i结点分配和释放函数。在通过文件系统模块分配或释放时，会根据文件系统调用对应的i结点分配和释放函数。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #A6E22E;">sock_alloc_inode</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #FD971F;">sb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket_alloc</span> *<span style="color: #FD971F;">ei</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#32531;&#23384;&#20013;&#20998;&#37197; socket_alloc &#32467;&#26500;</span>
        ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>ei)
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#22871;&#25509;&#21475;&#30340;&#31561;&#24453;&#38431;&#21015;</span>
        init_waitqueue_head(&amp;ei-&gt;socket.wait);

        ei-&gt;socket.fasync_list = <span style="color: #AE81FF;">NULL</span>;
        ei-&gt;socket.state = SS_UNCONNECTED;
        ei-&gt;socket.flags = 0;
        ei-&gt;socket.ops = <span style="color: #AE81FF;">NULL</span>;
        ei-&gt;socket.sk = <span style="color: #AE81FF;">NULL</span>;
        ei-&gt;socket.file = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #F92672;">return</span> &amp;ei-&gt;vfs_inode;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga16f094" class="outline-3">
<h3 id="orga16f094"><span class="section-number-3">3.5.</span> sock_destroy_inode()</h3>
<div class="outline-text-3" id="text-3-5">
<p>
该函数是套接口文件系统的i结点释放接口。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">sock_destroy_inode</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #FD971F;">inode</span>)
{
        kmem_cache_free(sock_inode_cachep,
                        container_of(inode, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket_alloc</span>, vfs_inode));
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org98881d3" class="outline-2">
<h2 id="org98881d3"><span class="section-number-2">4.</span> 套接口文件</h2>
<div class="outline-text-2" id="text-4">
<p>
套接口有一套独立的系统调用，包括建立套接口、连接和IO操作等，由于在建立套接口后返回的是文件描述符，因此也可以通过标准的文件I/O操作来读写。 在创建套接口文件时，将其file结构的 f_op 成员指向 socket_file_ops。
</p>

<div class="org-src-container">
<pre class="src src-c">
<span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Socket files have a set of 'special' operations as well as the generic file ones. These don't appear</span>
<span style="color: #75715E;"> *      in the operation structures but are done directly via the socketcall() multiplexor.</span>
<span style="color: #75715E;"> */</span>

<span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_operations</span> <span style="color: #FD971F;">socket_file_ops</span> = {
        .owner =        THIS_MODULE,
        .llseek =       no_llseek,
        .aio_read =     sock_aio_read,
        .aio_write =    sock_aio_write,
        .poll =         sock_poll,
        .unlocked_ioctl = sock_ioctl,
        .compat_ioctl = compat_sock_ioctl,
        .mmap =         sock_mmap,
        .open =         sock_no_open,   <span style="color: #75715E;">/* </span><span style="color: #75715E;">special open code to disallow open via /proc</span><span style="color: #75715E;"> */</span>
        .release =      sock_close,
        .fasync =       sock_fasync,
        .sendpage =     sock_sendpage,
        .splice_write = generic_splice_sendpage,
};
</pre>
</div>
</div>

<div id="outline-container-orgdf68181" class="outline-3">
<h3 id="orgdf68181"><span class="section-number-3">4.1.</span> 套接口文件与套接口的绑定</h3>
<div class="outline-text-3" id="text-4-1">
<p>
应用层通过文件描述符来访问套接口，因此在通过socket系统调用创建套接口时，会通过调用 sock_map_fd() 函数将套接口和文件描述符绑定。
</p>
</div>

<div id="outline-container-org834932c" class="outline-4">
<h4 id="org834932c"><span class="section-number-4">4.1.1.</span> sock_map_fd()</h4>
<div class="outline-text-4" id="text-4-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">sock_map_fd</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">newfile</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;&#19968;&#20010;&#25991;&#20214;&#25551;&#36848;&#31526;&#21644; file&#32467;&#26500;&#30340;&#23454;&#20363;</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fd</span> = sock_alloc_fd(&amp;newfile);

        <span style="color: #F92672;">if</span> (likely(fd &gt;= 0)) {
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20851;&#32852;socket&#21644;file&#23454;&#20363;</span>
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span> = sock_attach_fd(sock, newfile);
                <span style="color: #F92672;">if</span> (unlikely(err &lt; 0)) {
                        put_filp(newfile);
                        put_unused_fd(fd);
                        <span style="color: #F92672;">return</span> err;
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28155;&#21152;&#21040;&#24403;&#21069;&#36827;&#31243;&#30340;&#24050;&#25171;&#24320;&#25991;&#20214;&#21015;&#34920;</span>
                fd_install(fd, newfile);
        }
        <span style="color: #F92672;">return</span> fd;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9dd3ce8" class="outline-4">
<h4 id="org9dd3ce8"><span class="section-number-4">4.1.2.</span> sock_attach_fd()</h4>
<div class="outline-text-4" id="text-4-1-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">sock_attach_fd</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">file</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">qstr</span> <span style="color: #FD971F;">this</span>;
        <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">name</span>[32];

        this.len = sprintf(name, <span style="color: #E6DB74;">"[%lu]"</span>, SOCK_INODE(sock)-&gt;i_ino);
        this.name = name;
        this.hash = 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20026;&#22871;&#25509;&#21475;&#25991;&#20214;&#20998;&#37197;&#30446;&#24405;&#39033;</span>
        file-&gt;f_path.dentry = d_alloc(sock_mnt-&gt;mnt_sb-&gt;s_root, &amp;this);
        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>file-&gt;f_path.dentry))
                <span style="color: #F92672;">return</span> -ENOMEM;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#23450;&#30446;&#24405;&#25805;&#20316;</span>
        file-&gt;f_path.dentry-&gt;d_op = &amp;sockfs_dentry_operations;
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * We dont want to push this dentry into global dentry hash table.</span>
<span style="color: #75715E;">         * We pretend dentry is already hashed, by unsetting DCACHE_UNHASHED</span>
<span style="color: #75715E;">         * This permits a working /proc/$pid/fd/XXX on sockets</span>
<span style="color: #75715E;">         */</span>
        file-&gt;f_path.dentry-&gt;d_flags &amp;= ~DCACHE_UNHASHED;
        d_instantiate(file-&gt;f_path.dentry, SOCK_INODE(sock));
        file-&gt;f_path.mnt = mntget(sock_mnt);
        file-&gt;f_mapping = file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mapping;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#22871;&#25509;&#21475;&#21644;&#25991;&#20214;&#32465;&#23450;&#12290;</span>
        sock-&gt;file = file;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#22871;&#25509;&#21475;&#30340;&#25991;&#20214;&#25805;&#20316;&#38598;&#21512;&#34920;</span>
        file-&gt;f_op = SOCK_INODE(sock)-&gt;i_fop = &amp;socket_file_ops;
        file-&gt;f_mode = FMODE_READ | FMODE_WRITE;
        file-&gt;f_flags = O_RDWR;
        file-&gt;f_pos = 0;
        file-&gt;private_data = sock; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#26469;&#36890;&#36807;private_data&#35775;&#38382;&#22871;&#25509;&#21475;</span>

        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3650093" class="outline-3">
<h3 id="org3650093"><span class="section-number-3">4.2.</span> 根据文件描述符获取套接口</h3>
<div class="outline-text-3" id="text-4-2">
<p>
套接口被创建后，通过其文件描述符来进行操作，sockfd_lookup_light()函数用来通过文件描述符的套接口。
</p>
</div>

<div id="outline-container-org7dea643" class="outline-4">
<h4 id="org7dea643"><span class="section-number-4">4.2.1.</span> sockfd_lookup_light()</h4>
<div class="outline-text-4" id="text-4-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #A6E22E;">sockfd_lookup_light</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fd</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">err</span>,
<span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">fput_needed</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25805;&#20316;&#25104;&#21151;&#26102;&#65292;&#36820;&#22238;&#26159;&#21542;&#23545;&#35813;&#25991;&#20214;&#36827;&#34892;&#20943;&#23569;&#24341;&#29992;&#35745;&#25968;&#30340;&#25805;&#20316;</span>
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">file</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>;

        *err = -EBADF;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#23545;&#24212;&#30340;file&#23454;&#20363;&#65292;&#24182;&#19988;&#33719;&#21462;&#26159;&#21542;&#38656;&#35201;&#20943;&#23569;&#23545;&#25991;&#20214;&#24341;&#29992;&#35745;&#25968;&#30340;&#26631;&#24535;</span>
        file = fget_light(fd, fput_needed);
        <span style="color: #F92672;">if</span> (file) {
                sock = sock_from_file(file, err);
                <span style="color: #F92672;">if</span> (sock)
                        <span style="color: #F92672;">return</span> sock;
                fput_light(file, *fput_needed);
        }
        <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org520ec3b" class="outline-4">
<h4 id="org520ec3b"><span class="section-number-4">4.2.2.</span> sock_from_file()</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
根据文件描述符获取套接口。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #A6E22E;">sock_from_file</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">file</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">err</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #FD971F;">inode</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21028;&#26029;&#26159;&#21542;&#20026;&#22871;&#25509;&#21475;&#25991;&#20214;</span>
        <span style="color: #F92672;">if</span> (file-&gt;f_op == &amp;socket_file_ops)
                <span style="color: #F92672;">return</span> file-&gt;private_data;      <span style="color: #75715E;">/* </span><span style="color: #75715E;">set in sock_map_fd</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;i&#32467;&#28857;</span>
        inode = file-&gt;f_path.dentry-&gt;d_inode;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>S_ISSOCK(inode-&gt;i_mode)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#26159;&#22871;&#25509;&#21475;&#31867;&#22411;</span>
                *err = -ENOTSOCK;
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#36807;i&#32467;&#28857;&#33719;&#21462;&#22871;&#25509;&#21475;&#25351;&#38024;</span>
        sock = SOCKET_I(inode);
        <span style="color: #F92672;">if</span> (sock-&gt;file != file) { <span style="color: #75715E;">//</span><span style="color: #75715E;">file&#23454;&#20363;&#19981;&#21516;&#65292;&#21017;&#20570;&#26657;&#27491;</span>
                printk(KERN_ERR <span style="color: #E6DB74;">"socki_lookup: socket file changed!\n"</span>);
                sock-&gt;file = file;
        }
        <span style="color: #F92672;">return</span> sock;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orga198d41" class="outline-2">
<h2 id="orga198d41"><span class="section-number-2">5.</span> 进程、文件描述符和套接口</h2>
<div class="outline-text-2" id="text-5">
<p>
在 task_struct 结构中，files成员指向 file_struct 结构，该结构主要功能是管理 fd_array 指针数组指向的描述符，每个file实例表示一个打开的文件。
</p>


<div id="org318b853" class="figure">
<p><img src="image/socket-layer/p-f-s.png" alt="p-f-s.png" />
</p>
<p><span class="figure-number">Figure 3: </span>进程、文件和套接口的关系</p>
</div>

<p>
上图中仅显示了一个file结构。 通过 <code>current-&gt;files-&gt;fd_array[fd]</code> 就可以访问当前进程的某个文件描述符。 file结构中，f_op指向 file_operations结构（套接口文件指向的是 socket_file_ops）。
</p>

<p>
private_data指向相关I/O对象专用数据，对于套接口而言，指向的是相关的socket结构。 socket结构中的ops指向创建套接口时选中的协议的 proto_ops 结构。 传输控制块 tcp_sock 结构中的 skc_prot 则指向创建套接口时选中的对应协议的 proto 结构。
</p>
</div>
</div>


<div id="outline-container-org75d87de" class="outline-2">
<h2 id="org75d87de"><span class="section-number-2">6.</span> 套接口层的系统初始化</h2>
<div class="outline-text-2" id="text-6">
<p>
sock_init() 在系统启动时，在初始化列表中被调用，通过 core_initcall 宏加入到内核的初始化列表。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">__init</span> sock_init(<span style="color: #66D9EF;">void</span>)
{
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Initialize sock SLAB cache.</span>
<span style="color: #75715E;">         */</span>

        sk_init();

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Initialize skbuff SLAB cache</span>
<span style="color: #75715E;">         */</span>
        skb_init();

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Initialize the protocols module.</span>
<span style="color: #75715E;">         */</span>

        init_inodecache();
        register_filesystem(&amp;sock_fs_type);
        sock_mnt = kern_mount(&amp;sock_fs_type);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">The real protocol initialization is performed in later initcalls.</span>
<span style="color: #75715E;">         */</span>

<span style="color: #F92672;">#ifdef</span> CONFIG_NETFILTER
        netfilter_init();
<span style="color: #F92672;">#endif</span>

        <span style="color: #F92672;">return</span> 0;
}

<span style="color: #A6E22E;">core_initcall</span>(sock_init);       <span style="color: #75715E;">/* </span><span style="color: #75715E;">early initcall</span><span style="color: #75715E;"> */</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfc382ff" class="outline-2">
<h2 id="orgfc382ff"><span class="section-number-2">7.</span> 套接口系统调用</h2>
<div class="outline-text-2" id="text-7">
<p>
下图展示了套接口层、传输层、网络层之间的调用关系以及之间的接口，一sendmsg调用为例：
<img src="image/socket-layer/sk-trans-inet.png" alt="sk-trans-inet.png" />
</p>
</div>

<div id="outline-container-orge3e174a" class="outline-3">
<h3 id="orge3e174a"><span class="section-number-3">7.1.</span> 套接口系统调用入口</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Linux内核中，每个系统调用都被编号，当进程进行一个系统调用时，通过中断指令 “INT 0X80” (X86)，从用户空间进入系统空间，并将系统调用号作为参数传递。Linux系统中，所有系统调用都会进入系统的同一个地址system_call，在通过系统调用号，调用对应的函数。
</p>

<ul class="org-ul">
<li>socket系统调用的总入口为 sys_socketcall()</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;">call &#26159;&#20855;&#20307;&#30340;&#25805;&#20316;&#30721;</span>
<span style="color: #75715E;">args&#26159;&#25351;&#21521;&#25968;&#32452;&#30340;&#25351;&#38024;</span>
<span style="color: #75715E;">*/</span>
asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">sys_socketcall</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">call</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #66D9EF;">__user</span> *<span style="color: #FD971F;">args</span>);

<span style="color: #75715E;">//</span><span style="color: #75715E;">&#25805;&#20316;&#30721;&#23450;&#20041;</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_SOCKET</span>      1               <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_socket(2)</span><span style="color: #75715E;">                */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_BIND</span>        2               <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_bind(2)</span><span style="color: #75715E;">                  */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_CONNECT</span>     3               <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_connect(2)</span><span style="color: #75715E;">               */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_LISTEN</span>      4               <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_listen(2)</span><span style="color: #75715E;">                */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_ACCEPT</span>      5               <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_accept(2)</span><span style="color: #75715E;">                */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_GETSOCKNAME</span> 6               <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_getsockname(2)</span><span style="color: #75715E;">           */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_GETPEERNAME</span> 7               <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_getpeername(2)</span><span style="color: #75715E;">           */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_SOCKETPAIR</span>  8               <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_socketpair(2)</span><span style="color: #75715E;">            */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_SEND</span>        9               <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_send(2)</span><span style="color: #75715E;">                  */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_RECV</span>        10              <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_recv(2)</span><span style="color: #75715E;">                  */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_SENDTO</span>      11              <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_sendto(2)</span><span style="color: #75715E;">                */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_RECVFROM</span>    12              <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_recvfrom(2)</span><span style="color: #75715E;">              */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_SHUTDOWN</span>    13              <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_shutdown(2)</span><span style="color: #75715E;">              */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_SETSOCKOPT</span>  14              <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_setsockopt(2)</span><span style="color: #75715E;">            */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_GETSOCKOPT</span>  15              <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_getsockopt(2)</span><span style="color: #75715E;">            */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_SENDMSG</span>     16              <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_sendmsg(2)</span><span style="color: #75715E;">               */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYS_RECVMSG</span>     17              <span style="color: #75715E;">/* </span><span style="color: #75715E;">sys_recvmsg(2)</span><span style="color: #75715E;">               */</span>
</pre>
</div>

<ul class="org-ul">
<li>sys_socketcall()</li>
</ul>
<div class="org-src-container">
<pre class="src src-c">
<span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      System call vectors.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> *      Argument checking cleaned up. Saved 20% in size.</span>
<span style="color: #75715E;"> *  This function doesn't need to set the kernel lock because</span>
<span style="color: #75715E;"> *  it is set by the callees.</span>
<span style="color: #75715E;"> */</span>

asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">sys_socketcall</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">call</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #66D9EF;">__user</span> *<span style="color: #FD971F;">args</span>)
{
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">a</span>[6];
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">a0</span>, <span style="color: #FD971F;">a1</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;

        <span style="color: #F92672;">if</span> (call &lt; 1 || call &gt; SYS_RECVMSG)
                <span style="color: #F92672;">return</span> -EINVAL;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">copy_from_user should be SMP safe.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (copy_from_user(a, args, nargs[call]))
                <span style="color: #F92672;">return</span> -EFAULT;

        err = audit_socketcall(nargs[call] / <span style="color: #F92672;">sizeof</span>(<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>), a);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">return</span> err;

        a0 = a[0];
        a1 = a[1];

        <span style="color: #F92672;">switch</span> (call) {
        <span style="color: #F92672;">case</span> SYS_SOCKET: <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21019;&#24314;&#22871;&#25509;&#21475;</span>
                err = sys_socket(a0, a1, a[2]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_BIND:
                err = sys_bind(a0, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> <span style="color: #66D9EF;">__user</span> *)a1, a[2]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_CONNECT:
                err = sys_connect(a0, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> <span style="color: #66D9EF;">__user</span> *)a1, a[2]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_LISTEN:
                err = sys_listen(a0, a1);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_ACCEPT:
                err =
                    sys_accept(a0, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> <span style="color: #66D9EF;">__user</span> *)a1,
                               (<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *)a[2]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_GETSOCKNAME:
                err =
                    sys_getsockname(a0, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> <span style="color: #66D9EF;">__user</span> *)a1,
                                    (<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *)a[2]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_GETPEERNAME:
                err =
                    sys_getpeername(a0, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> <span style="color: #66D9EF;">__user</span> *)a1,
                                    (<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *)a[2]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_SOCKETPAIR:
                err = sys_socketpair(a0, a1, a[2], (<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *)a[3]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_SEND:
                err = sys_send(a0, (<span style="color: #66D9EF;">void</span> <span style="color: #FD971F;">__user</span> *)a1, a[2], a[3]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_SENDTO:
                err = sys_sendto(a0, (<span style="color: #66D9EF;">void</span> <span style="color: #FD971F;">__user</span> *)a1, a[2], a[3],
                                 (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> <span style="color: #66D9EF;">__user</span> *)a[4], a[5]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_RECV:
                err = sys_recv(a0, (<span style="color: #66D9EF;">void</span> <span style="color: #FD971F;">__user</span> *)a1, a[2], a[3]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_RECVFROM:
                err = sys_recvfrom(a0, (<span style="color: #66D9EF;">void</span> <span style="color: #FD971F;">__user</span> *)a1, a[2], a[3],
                                   (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> <span style="color: #66D9EF;">__user</span> *)a[4],
                                   (<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *)a[5]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_SHUTDOWN:
                err = sys_shutdown(a0, a1);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_SETSOCKOPT:
                err = sys_setsockopt(a0, a1, a[2], (<span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *)a[3], a[4]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_GETSOCKOPT:
                err =
                    sys_getsockopt(a0, a1, a[2], (<span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *)a[3],
                                   (<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *)a[4]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_SENDMSG:
                err = sys_sendmsg(a0, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> <span style="color: #66D9EF;">__user</span> *)a1, a[2]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SYS_RECVMSG:
                err = sys_recvmsg(a0, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> <span style="color: #66D9EF;">__user</span> *)a1, a[2]);
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">default</span>:
                err = -EINVAL;
                <span style="color: #F92672;">break</span>;
        }
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>

<p>
<img src="image/socket-layer/net-sockcall.png" alt="net-sockcall.png" />
\[\]\[\]\[\]\[\]\[\]\[\]\[\]\[\]\[\]$$$
</p>
</div>
</div>

<div id="outline-container-org2c02078" class="outline-3">
<h3 id="org2c02078"><span class="section-number-3">7.2.</span> socket系统调用</h3>
<div class="outline-text-3" id="text-7-2">
</div>
<div id="outline-container-orge3c4a86" class="outline-4">
<h4 id="orge3c4a86"><span class="section-number-4">7.2.1.</span> sys_socket()</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
sys_socket()把套接口的创建和与此套接口关联的文件描述符的分配做了封装。
</p>


<div id="org696aaa3" class="figure">
<p><img src="image/socket-layer/sys-socket-func.png" alt="sys-socket-func.png" />
</p>
<p><span class="figure-number">Figure 4: </span>socket系统调用中主要函数的调用关系</p>
</div>

<div class="org-src-container">
<pre class="src src-c">asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">sys_socket</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">family</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">type</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">protocol</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">retval</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21019;&#24314;&#24182;&#21021;&#22987;&#21270;&#22871;&#25509;&#21475;</span>
        retval = sock_create(family, type, protocol, &amp;sock);
        <span style="color: #F92672;">if</span> (retval &lt; 0)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21019;&#24314;&#25991;&#20214;&#25551;&#36848;&#31526;&#65292;&#24182;&#36827;&#34892;&#32465;&#23450;</span>
        retval = sock_map_fd(sock);
        <span style="color: #F92672;">if</span> (retval &lt; 0)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_release</span>;
<span style="color: #AE81FF;">out</span>:
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">It may be already another descriptor 8) Not kernel problem.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">return</span> retval;

<span style="color: #AE81FF;">out_release</span>:
        sock_release(sock);
        <span style="color: #F92672;">return</span> retval;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9b325e0" class="outline-4">
<h4 id="org9b325e0"><span class="section-number-4">7.2.2.</span> sock_create()</h4>
<div class="outline-text-4" id="text-7-2-2">
<p>
实际调用__sock_create()函数。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">__sock_create</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">family</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21327;&#35758;&#26063;</span>
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">type</span>,   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#31867;&#22411;</span>
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">protocol</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;&#23618;&#21327;&#35758;</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> **<span style="color: #FD971F;">res</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#21442;&#25968;</span>
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">kern</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26631;&#35782;&#26159;&#30001;&#24212;&#29992;&#31243;&#24207;&#36824;&#26159;&#20869;&#26680;&#21019;&#24314;</span>
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>;
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_proto_family</span> *<span style="color: #FD971F;">pf</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26816;&#26597;&#21442;&#25968;&#30340;&#21512;&#27861;&#24615;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (family &lt; 0 || family &gt;= NPROTO)
                <span style="color: #F92672;">return</span> -EAFNOSUPPORT;
        <span style="color: #F92672;">if</span> (type &lt; 0 || type &gt;= SOCK_MAX)
                <span style="color: #F92672;">return</span> -EINVAL;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20860;&#23481;&#24615;&#12290;</span>
<span style="color: #75715E;">           SOCK_PACKET&#24050;&#32463;&#31227;&#38500;&#65292;&#32780;&#26159;&#20351;&#29992;PF_PACKET&#26367;&#20195;</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (family == PF_INET &amp;&amp; type == SOCK_PACKET) {
                <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">warned</span>;
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>warned) {
                        warned = 1;
                        printk(KERN_INFO <span style="color: #E6DB74;">"%s uses obsolete (PF_INET,SOCK_PACKET)\n"</span>,
                               current-&gt;comm);
                }
                family = PF_PACKET;
        }

        err = security_socket_create(family, type, protocol, kern);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">return</span> err;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Allocate the socket and allow the family to set things up. if</span>
<span style="color: #75715E;">         *      the protocol is 0, the family is instructed to select an appropriate</span>
<span style="color: #75715E;">         *      default.</span>
<span style="color: #75715E;">         */</span>
        sock = sock_alloc(); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;&#22871;&#25509;&#21475;&#20197;&#21450;&#20851;&#32852;&#30340;i&#32467;&#28857;&#65292;&#24182;&#21021;&#22987;&#21270;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sock) {
                <span style="color: #F92672;">if</span> (net_ratelimit())
                        printk(KERN_WARNING <span style="color: #E6DB74;">"socket: no more sockets\n"</span>);
                <span style="color: #F92672;">return</span> -ENFILE; <span style="color: #75715E;">/* </span><span style="color: #75715E;">Not exactly a match, but its the</span>
<span style="color: #75715E;">                                   closest posix thing</span><span style="color: #75715E;"> */</span>
        }

        sock-&gt;type = type;

<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span>(CONFIG_KMOD)
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Attempt to load a protocol module if the find failed.</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user</span>
<span style="color: #75715E;">         * requested real, full-featured networking support upon configuration.</span>
<span style="color: #75715E;">         * Otherwise module support will break!</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (net_families[family] == <span style="color: #AE81FF;">NULL</span>)
                request_module(<span style="color: #E6DB74;">"net-pf-%d"</span>, family); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21160;&#24577;&#21152;&#36733;&#27169;&#22359;</span>
<span style="color: #F92672;">#endif</span>

        rcu_read_lock();
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#23545;&#24212;&#21327;&#35758;&#26063;&#30340; net_proto_family&#32467;&#26500;</span>
        pf = rcu_dereference(net_families[family]);
        err = -EAFNOSUPPORT;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>pf)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_release</span>;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * We will call the -&gt;create function, that possibly is in a loadable</span>
<span style="color: #75715E;">         * module, so we have to bump that loadable module refcnt first.</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#22914;&#26524;&#21327;&#35758;&#26063;&#30340;net_proto_family&#26159;&#20197;&#20869;&#26680;&#27169;&#22359;&#30340;&#21152;&#36733;&#65292;&#21017;&#22686;&#21152;&#24341;&#29992;&#65292;&#38450;&#27490;&#21368;&#36733;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>try_module_get(pf-&gt;owner))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_release</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Now protected by module ref count</span><span style="color: #75715E;"> */</span>
        rcu_read_unlock();
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#21327;&#35758;&#26063;&#30340;create&#20989;&#25968;&#65292;&#23545;&#22871;&#25509;&#21475;&#36827;&#34892;&#21021;&#22987;&#21270;&#65292;&#21516;&#26102;&#36824;&#21019;&#24314;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        err = pf-&gt;create(sock, protocol);
        <span style="color: #F92672;">if</span> (err &lt; 0)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_module_put</span>;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * Now to bump the refcnt of the [loadable] module that owns this</span>
<span style="color: #75715E;">         * socket at sock_release time we decrement its refcnt.</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#22914;&#26524;&#22871;&#25509;&#21475;&#23545;&#24212;&#30340;proto_ops&#32467;&#26500;&#23454;&#20363;&#26159;&#21160;&#24577;&#21152;&#36733;&#30340;&#20869;&#26680;&#27169;&#22359;&#65292;&#21017;&#22686;&#21152;&#24341;&#29992;&#65292;&#38450;&#27490;&#21368;&#36733;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>try_module_get(sock-&gt;ops-&gt;owner))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_module_busy</span>;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * Now that we're done with the -&gt;create function, the [loadable]</span>
<span style="color: #75715E;">         * module can have its refcnt decremented</span>
<span style="color: #75715E;">         */</span>
        module_put(pf-&gt;owner);
        err = security_socket_post_create(sock, family, type, protocol, kern);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_release</span>;
        *res = sock;

        <span style="color: #F92672;">return</span> 0;

<span style="color: #AE81FF;">out_module_busy</span>:
        err = -EAFNOSUPPORT;
<span style="color: #AE81FF;">out_module_put</span>:
        sock-&gt;ops = <span style="color: #AE81FF;">NULL</span>;
        module_put(pf-&gt;owner);
<span style="color: #AE81FF;">out_sock_release</span>:
        sock_release(sock);
        <span style="color: #F92672;">return</span> err;

<span style="color: #AE81FF;">out_release</span>:
        rcu_read_unlock();
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_sock_release</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdc81267" class="outline-4">
<h4 id="orgdc81267"><span class="section-number-4">7.2.3.</span> inet_create()</h4>
<div class="outline-text-4" id="text-7-2-3">
<p>
该函数用于创建与套接口对应的传输控制块，并建立关联。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Create an inet socket.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_create</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">protocol</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">p</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_protosw</span> *<span style="color: #FD971F;">answer</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">proto</span> *<span style="color: #FD971F;">answer_prot</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">answer_flags</span>;
        <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">answer_no_check</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">try_loading_module</span> = 0;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;

        sock-&gt;state = SS_UNCONNECTED;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Look for the requested type/protocol pair.</span><span style="color: #75715E;"> */</span>
        answer = <span style="color: #AE81FF;">NULL</span>;
<span style="color: #AE81FF;">lookup_protocol</span>:
        err = -ESOCKTNOSUPPORT;
        rcu_read_lock();
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36941;&#21382; inetsw &#25955;&#21015;&#34920;&#65292;&#33719;&#21462;&#23545;&#24212;&#30340; inet_protosw &#32467;&#26500;&#23454;&#20363;</span>
        list_for_each_rcu(p, &amp;inetsw[sock-&gt;type]) {
                answer = list_entry(p, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_protosw</span>, list);
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Check the non-wild match.</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (protocol == answer-&gt;protocol) {
                        <span style="color: #F92672;">if</span> (protocol != IPPROTO_IP)
                                <span style="color: #F92672;">break</span>;
                } <span style="color: #F92672;">else</span> {
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Check for the two wild cases.</span><span style="color: #75715E;"> */</span>
                        <span style="color: #F92672;">if</span> (IPPROTO_IP == protocol) {
                                protocol = answer-&gt;protocol;
                                <span style="color: #F92672;">break</span>;
                        }
                        <span style="color: #F92672;">if</span> (IPPROTO_IP == answer-&gt;protocol)
                                <span style="color: #F92672;">break</span>;
                }
                err = -EPROTONOSUPPORT;
                answer = <span style="color: #AE81FF;">NULL</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#33719;&#21462;&#22833;&#36133;&#65292;&#21017;&#23581;&#35797;&#36890;&#36807;&#21160;&#24577;&#21152;&#36733;&#20869;&#26680;&#27169;&#22359;&#26469;&#33719;&#21462;</span>
        <span style="color: #F92672;">if</span> (unlikely(answer == <span style="color: #AE81FF;">NULL</span>)) {
                <span style="color: #F92672;">if</span> (try_loading_module &lt; 2) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26368;&#22810;&#23581;&#35797;&#20004;&#27425;</span>
                        rcu_read_unlock();
                        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                         * Be more specific, e.g. net-pf-2-proto-132-type-1</span>
<span style="color: #75715E;">                         * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM)</span>
<span style="color: #75715E;">                         */</span>
                        <span style="color: #F92672;">if</span> (++try_loading_module == 1)
                                request_module(<span style="color: #E6DB74;">"net-pf-%d-proto-%d-type-%d"</span>,
                                               PF_INET, protocol, sock-&gt;type);
                        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                         * Fall back to generic, e.g. net-pf-2-proto-132</span>
<span style="color: #75715E;">                         * (net-pf-PF_INET-proto-IPPROTO_SCTP)</span>
<span style="color: #75715E;">                         */</span>
                        <span style="color: #F92672;">else</span>
                                request_module(<span style="color: #E6DB74;">"net-pf-%d-proto-%d"</span>,
                                               PF_INET, protocol);
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">lookup_protocol</span>;
                } <span style="color: #F92672;">else</span>
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_rcu_unlock</span>;
        }

        err = -EPERM;
        <span style="color: #F92672;">if</span> (answer-&gt;capability &gt; 0 &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>capable(answer-&gt;capability))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_rcu_unlock</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#22871;&#25509;&#21475;&#30340;&#22871;&#25509;&#21475;&#23618;&#21644;&#20256;&#36755;&#23618;&#20043;&#38388;&#30340;&#25509;&#21475; ops</span>
        sock-&gt;ops = answer-&gt;ops;
        answer_prot = answer-&gt;prot;
        answer_no_check = answer-&gt;no_check;
        answer_flags = answer-&gt;flags;
        rcu_read_unlock();

        BUG_TRAP(answer_prot-&gt;slab != <span style="color: #AE81FF;">NULL</span>);

        err = -ENOBUFS;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        sk = sk_alloc(PF_INET, GFP_KERNEL, answer_prot, 1);
        <span style="color: #F92672;">if</span> (sk == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        err = 0;
        sk-&gt;sk_no_check = answer_no_check; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;&#25511;&#21046;&#22359;&#26159;&#21542;&#38656;&#35201;&#26657;&#39564;&#21644;</span>
        <span style="color: #F92672;">if</span> (INET_PROTOSW_REUSE &amp; answer_flags) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#21487;&#20197;&#37325;&#29992;&#22320;&#22336;&#21644;&#31471;&#21475;</span>
                sk-&gt;sk_reuse = 1;

        inet = inet_sk(sk);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26631;&#35782;&#26159;&#21542;&#26159;&#38754;&#21521;&#36830;&#25509;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        inet-&gt;is_icsk = (INET_PROTOSW_ICSK &amp; answer_flags) != 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#21407;&#22987;&#22871;&#25509;&#21475;&#65292;&#21017;&#35774;&#32622;&#31471;&#21475;&#20026; &#21327;&#35758;&#21495;&#12290;</span>
        <span style="color: #F92672;">if</span> (SOCK_RAW == sock-&gt;type) {
                inet-&gt;num = protocol;
                <span style="color: #F92672;">if</span> (IPPROTO_RAW == protocol)
                        inet-&gt;hdrincl = 1; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;RAW&#21327;&#35758;&#65292;&#38656;&#35201;&#33258;&#24049;&#26500;&#24314;IP&#39318;&#37096;</span>
        }

        <span style="color: #F92672;">if</span> (ipv4_config.no_pmtu_disc)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21028;&#26029;&#20256;&#36755;&#25511;&#21046;&#22359;&#26159;&#21542;&#25903;&#25345;PMTU</span>
                inet-&gt;pmtudisc = IP_PMTUDISC_DONT;
        <span style="color: #F92672;">else</span>
                inet-&gt;pmtudisc = IP_PMTUDISC_WANT;

        inet-&gt;id = 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23545;&#20256;&#36755;&#25511;&#21046;&#22359;&#36827;&#34892;&#21021;&#22987;&#21270;</span>
        sock_init_data(sock, sk);

        sk-&gt;sk_destruct    = inet_sock_destruct;
        sk-&gt;sk_family      = PF_INET;
        sk-&gt;sk_protocol    = protocol;
        sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21518;&#22791;&#38431;&#21015;&#25509;&#25910;&#20989;&#25968;</span>

        inet-&gt;uc_ttl    = -1;
        inet-&gt;mc_loop   = 1;
        inet-&gt;mc_ttl    = 1;
        inet-&gt;mc_index  = 0;
        inet-&gt;mc_list   = <span style="color: #AE81FF;">NULL</span>;

        sk_refcnt_debug_inc(sk);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;num&#35774;&#32622;&#20102;&#26412;&#22320;&#31471;&#21475;&#21495;&#65292;&#21017;&#38656;&#35201;&#35774;&#32622;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;sport&#20026;&#32593;&#32476;&#23383;&#33410;&#24207;&#30340;&#26412;&#22320;&#31471;&#21475;</span>
        <span style="color: #F92672;">if</span> (inet-&gt;num) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">It assumes that any protocol which allows</span>
<span style="color: #75715E;">                 * the user to assign a number at socket</span>
<span style="color: #75715E;">                 * creation time automatically</span>
<span style="color: #75715E;">                 * shares.</span>
<span style="color: #75715E;">                 */</span>
                inet-&gt;sport = htons(inet-&gt;num);
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#23558;&#20256;&#36755;&#25511;&#21046;&#22359;&#21152;&#20837;&#21040;&#31649;&#29702;&#30340;&#25955;&#21015;&#34920;</span><span style="color: #75715E;"> */</span>
                sk-&gt;sk_prot-&gt;hash(sk);
        }

        <span style="color: #F92672;">if</span> (sk-&gt;sk_prot-&gt;init) {
                err = sk-&gt;sk_prot-&gt;init(sk);
                <span style="color: #F92672;">if</span> (err)
                        sk_common_release(sk);
        }
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> err;
<span style="color: #AE81FF;">out_rcu_unlock</span>:
        rcu_read_unlock();
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org44e2920" class="outline-3">
<h3 id="org44e2920"><span class="section-number-3">7.3.</span> bind系统调用</h3>
<div class="outline-text-3" id="text-7-3">
</div>
<div id="outline-container-orgf7bd053" class="outline-4">
<h4 id="orgf7bd053"><span class="section-number-4">7.3.1.</span> sys_bind()</h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
bind()系统调用用于将本地的地址和传输层端口，与套接口关联起来。
</p>


<div id="org26dc77b" class="figure">
<p><img src="image/socket-layer/bind.png" alt="bind.png" />
</p>
<p><span class="figure-number">Figure 5: </span>bind()调用过程</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Bind a name to a socket. Nothing much to do here since it's</span>
<span style="color: #75715E;"> *      the protocol's responsibility to handle the local address.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> *      We move the socket address to kernel space before we call</span>
<span style="color: #75715E;"> *      the protocol layer (having also checked the address is ok).</span>
<span style="color: #75715E;"> */</span>

asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">sys_bind</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fd</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> <span style="color: #66D9EF;">__user</span> *<span style="color: #FD971F;">umyaddr</span><span style="color: #75715E;">/*</span><span style="color: #75715E;">&#32465;&#23450;&#30340;&#22320;&#22336;</span><span style="color: #75715E;">*/</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">addrlen</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>;
        <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">address</span>[MAX_SOCK_ADDR];
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>, <span style="color: #FD971F;">fput_needed</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#25991;&#20214;&#25551;&#36848;&#31526;&#65292;&#33719;&#21462;&#22871;&#25509;&#21475;&#25351;&#38024;&#65292; fput_needed&#26159;&#36820;&#22238;&#20540;&#65292;&#34920;&#31034;&#26159;&#21542;&#38656;&#35201;&#20943;&#23569;&#25991;&#20214;&#24341;&#29992;&#35745;&#25968;</span>
        sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);
        <span style="color: #F92672;">if</span>(sock) {
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#29992;&#25143;&#31354;&#38388;&#30340;&#25968;&#25454;&#21040;&#20869;&#26680;&#31354;&#38388;</span>
                err = move_addr_to_kernel(umyaddr, addrlen, address);
                <span style="color: #F92672;">if</span> (err &gt;= 0) {
                        err = security_socket_bind(sock,
                                                   (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *)address,
                                                   addrlen);
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>err) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#21327;&#35758;&#26063;&#30340;bind&#25509;&#21475;&#65292;IPv4&#20013;&#26159; inet_bind()</span>
                                err = sock-&gt;ops-&gt;bind(sock,
                                                      (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *)
                                                      address, addrlen);
                }
                fput_light(sock-&gt;file, fput_needed); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;fput_light&#25805;&#20316;&#25991;&#20214;&#24341;&#29992;&#35745;&#25968;&#12290;</span>
        }
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4d93e8a" class="outline-4">
<h4 id="org4d93e8a"><span class="section-number-4">7.3.2.</span> 套接口层的实现 inet_bind()</h4>
<div class="outline-text-4" id="text-7-3-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_bind</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *<span style="color: #FD971F;">uaddr</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">addr_len</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> *<span style="color: #FD971F;">addr</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> *)uaddr;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span> = sock-&gt;sk;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> <span style="color: #FD971F;">snum</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">chk_addr_ret</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#23545;&#24212;&#30340;&#20256;&#36755;&#23618;&#26159;&#21542;&#23454;&#29616;&#20102;&#33258;&#36523;&#30340;bind&#20989;&#25968;&#65288;&#20363;&#22914;SOCK_RAW&#65289;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_prot-&gt;bind) {
                err = sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        }
        err = -EINVAL;
        <span style="color: #F92672;">if</span> (addr_len &lt; <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span>))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#22320;&#22336;&#31867;&#22411;</span>
        chk_addr_ret = inet_addr_type(addr-&gt;sin_addr.s_addr);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Not specified by any standard per-se, however it breaks too</span>
<span style="color: #75715E;">         * many applications when removed.  It is unfortunate since</span>
<span style="color: #75715E;">         * allowing applications to make a non-local bind solves</span>
<span style="color: #75715E;">         * several problems with systems using dynamic addressing.</span>
<span style="color: #75715E;">         * (ie. your servers still start up even if your ISDN link</span>
<span style="color: #75715E;">         *  is temporarily down)</span>
<span style="color: #75715E;">         */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;&#26159;&#21542;&#21487;&#20197;&#36827;&#34892;&#22320;&#22336;&#21644;&#31471;&#21475;&#30340;&#32465;&#23450;</span>
        err = -EADDRNOTAVAIL;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sysctl_ip_nonlocal_bind &amp;&amp;
            <span style="color: #E6DB74; font-weight: bold;">!</span>inet-&gt;freebind &amp;&amp;
            addr-&gt;sin_addr.s_addr != INADDR_ANY &amp;&amp;
            chk_addr_ret != RTN_LOCAL &amp;&amp;
            chk_addr_ret != RTN_MULTICAST &amp;&amp;
            chk_addr_ret != RTN_BROADCAST)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        snum = ntohs(addr-&gt;sin_port);
        err = -EACCES;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;&#32465;&#23450;&#30340;&#31471;&#21475;&#65292;&#21028;&#26029;&#36827;&#31243;&#26159;&#21542;&#20801;&#35768;&#32465;&#23450;&#23567;&#20110;1024&#30340;&#31471;&#21475;</span>
        <span style="color: #F92672;">if</span> (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>capable(CAP_NET_BIND_SERVICE))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        <span style="color: #75715E;">/*      </span><span style="color: #75715E;">We keep a pair of addresses. rcv_saddr is the one</span>
<span style="color: #75715E;">         *      used by hash lookups, and saddr is used for transmit.</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         *      In the BSD API these are the same except where it</span>
<span style="color: #75715E;">         *      would be illegal to use them (multicast/broadcast) in</span>
<span style="color: #75715E;">         *      which case the sending device address is used.</span>
<span style="color: #75715E;">         */</span>
        lock_sock(sk);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Check these errors (active socket, double bind).</span><span style="color: #75715E;"> */</span>
        err = -EINVAL;
        <span style="color: #F92672;">if</span> (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;num)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_release_sock</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#22320;&#22336;&#35774;&#32622;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;</span>
        inet-&gt;rcv_saddr = inet-&gt;saddr = addr-&gt;sin_addr.s_addr;
        <span style="color: #F92672;">if</span> (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
                inet-&gt;saddr = 0;  <span style="color: #75715E;">/* </span><span style="color: #75715E;">Use device</span><span style="color: #75715E;"> */</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35843;&#29992;&#20256;&#36755;&#23618;&#25509;&#21475;&#30340;get_port()&#65292;&#36827;&#34892;&#20855;&#20307;&#20256;&#36755;&#23618;&#30340;&#22320;&#22336;&#32465;&#23450;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) {
                inet-&gt;saddr = inet-&gt;rcv_saddr = 0;
                err = -EADDRINUSE;
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_release_sock</span>;
        }

        <span style="color: #F92672;">if</span> (inet-&gt;rcv_saddr)
                sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26631;&#35782;&#32465;&#23450;&#20102;&#26412;&#22320;&#22320;&#22336;</span>
        <span style="color: #F92672;">if</span> (snum)
                sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26631;&#35782;&#32465;&#23450;&#20102;&#26412;&#22320;&#31471;&#21475;</span>
        inet-&gt;sport = htons(inet-&gt;num);
        inet-&gt;daddr = 0;
        inet-&gt;dport = 0;
        sk_dst_reset(sk);
        err = 0;
<span style="color: #AE81FF;">out_release_sock</span>:
        release_sock(sk);
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7b536a3" class="outline-3">
<h3 id="org7b536a3"><span class="section-number-3">7.4.</span> listen系统调用</h3>
<div class="outline-text-3" id="text-7-4">
<p>
listen系统调用用于通知进程准备好接收套接口上的连接请求，同时指定该套接口上可以排队的连接数。如果超过限制，则拒绝连接请求。
</p>

<div class="org-src-container">
<pre class="src src-c">asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">sys_listen</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fd</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">backlog</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>, <span style="color: #FD971F;">fput_needed</span>;

        sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);
        <span style="color: #F92672;">if</span> (sock) {
                <span style="color: #F92672;">if</span> ((<span style="color: #66D9EF;">unsigned</span>)backlog &gt; sysctl_somaxconn) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;&#38480;&#21046;&#26159;&#21542;&#21512;&#27861;</span>
                        backlog = sysctl_somaxconn;

                err = security_socket_listen(sock, backlog);
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>err)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#23545;&#24212;&#20256;&#36755;&#23618;&#30340;listen&#25805;&#20316;</span>
                        err = sock-&gt;ops-&gt;listen(sock, backlog);
                fput_light(sock-&gt;file, fput_needed);
        }
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2ca6ce9" class="outline-3">
<h3 id="org2ca6ce9"><span class="section-number-3">7.5.</span> accept系统调用</h3>
<div class="outline-text-3" id="text-7-5">
<p>
调用listen之后，可以通过accept等待连接请求。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      For accept, we attempt to create a new socket, set up the link</span>
<span style="color: #75715E;"> *      with the client, wake up the client, then return the new</span>
<span style="color: #75715E;"> *      connected fd. We collect the address of the connector in kernel</span>
<span style="color: #75715E;"> *      space and move it to user at the very end. This is unclean because</span>
<span style="color: #75715E;"> *      we open the socket then return an error.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> *      1003.1g adds the ability to recvmsg() to query connection pending</span>
<span style="color: #75715E;"> *      status to recvmsg. We need to add that support in a way thats</span>
<span style="color: #75715E;"> *      clean when we restucture accept also.</span>
<span style="color: #75715E;"> */</span>

asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">sys_accept</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fd</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> <span style="color: #66D9EF;">__user</span> *<span style="color: #FD971F;">upeer_sockaddr</span>,
                           <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *upeer_addrlen)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, *<span style="color: #FD971F;">newsock</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">newfile</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>, <span style="color: #FD971F;">len</span>, <span style="color: #FD971F;">newfd</span>, <span style="color: #FD971F;">fput_needed</span>;
        <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">address</span>[MAX_SOCK_ADDR];

        sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sock)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        err = -ENFILE;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(newsock = sock_alloc()))<span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;&#26032;&#30340;&#22871;&#25509;&#21475;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_put</span>;

        newsock-&gt;type = sock-&gt;type; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#31867;&#22411;</span>
        newsock-&gt;ops = sock-&gt;ops; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#30340;&#31995;&#32479;&#35843;&#29992;&#36339;&#36716;&#34920;</span>
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * We don't need try_module_get here, as the listening socket (sock)</span>
<span style="color: #75715E;">         * has the protocol module (sock-&gt;ops-&gt;owner) held.</span>
<span style="color: #75715E;">         */</span>
        __module_get(newsock-&gt;ops-&gt;owner);
        newfd = sock_alloc_fd(&amp;newfile);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
        <span style="color: #F92672;">if</span> (unlikely(newfd &lt; 0)) {
                err = newfd;
                sock_release(newsock);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_put</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21644;&#22871;&#25509;&#21475;&#32465;&#23450;&#12290;</span>
        err = sock_attach_fd(newsock, newfile);
        <span style="color: #F92672;">if</span> (err &lt; 0)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_fd</span>;

        err = security_socket_accept(sock, newsock);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_fd</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#23545;&#24212;&#20256;&#36755;&#21327;&#35758;&#30340;accept&#25805;&#20316;&#12290;</span>
        err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags);
        <span style="color: #F92672;">if</span> (err &lt; 0)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_fd</span>;

        <span style="color: #F92672;">if</span> (upeer_sockaddr) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#38656;&#35201;&#33719;&#21462;&#23458;&#25143;&#31471;&#30340;&#22320;&#22336;</span>
                <span style="color: #F92672;">if</span> (newsock-&gt;ops-&gt;getname(newsock, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *)address,
                                          &amp;len, 2) &lt; 0) {
                        err = -ECONNABORTED;
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_fd</span>;
                }
                err = move_addr_to_user(address, len, upeer_sockaddr,
                                        upeer_addrlen);
                <span style="color: #F92672;">if</span> (err &lt; 0)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_fd</span>;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">File flags are not inherited via accept() unlike another OSes.</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#25991;&#20214;&#25551;&#36848;&#31526;&#28155;&#21152;&#21040;&#36827;&#31243;&#30340;&#24050;&#25171;&#24320;&#25991;&#20214;&#21015;&#34920;&#20013;&#12290;</span>
        fd_install(newfd, newfile);
        err = newfd;

        security_socket_post_accept(sock, newsock);

<span style="color: #AE81FF;">out_put</span>:
        fput_light(sock-&gt;file, fput_needed);
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> err;
<span style="color: #AE81FF;">out_fd</span>:
        fput(newfile);
        put_unused_fd(newfd);
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_put</span>;
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org92fb45f" class="outline-3">
<h3 id="org92fb45f"><span class="section-number-3">7.6.</span> connect系统调用</h3>
<div class="outline-text-3" id="text-7-6">
<p>
对于面向连接的协议（TCP），connect() 会与指定的外部地址建立连接。
</p>

<p>
对于无连接协议（UDP或ICMP），connect记录外部地址，以便发送数据报时使用。
</p>


<div id="org4294551" class="figure">
<p><img src="image/socket-layer/connect.png" alt="connect.png" />
</p>
<p><span class="figure-number">Figure 6: </span>conect()调用过程</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Attempt to connect to a socket with the server address.  The address</span>
<span style="color: #75715E;"> *      is in user space so we verify it is OK and move it to kernel space.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> *      For 1003.1g we need to add clean support for a bind to AF_UNSPEC to</span>
<span style="color: #75715E;"> *      break bindings</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> *      NOTE: 1003.1g draft 6.3 is broken with respect to AX.25/NetROM and</span>
<span style="color: #75715E;"> *      other SEQPACKET protocols that take time to connect() as it doesn't</span>
<span style="color: #75715E;"> *      include the -EINPROGRESS status for such sockets.</span>
<span style="color: #75715E;"> */</span>

asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">sys_connect</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fd</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> <span style="color: #66D9EF;">__user</span> *<span style="color: #FD971F;">uservaddr</span>,
                            <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">addrlen</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>;
        <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">address</span>[MAX_SOCK_ADDR];
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>, <span style="color: #FD971F;">fput_needed</span>;

        sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sock)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        err = move_addr_to_kernel(uservaddr, addrlen, address);
        <span style="color: #F92672;">if</span> (err &lt; 0)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_put</span>;

        err =
            security_socket_connect(sock, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *)address, addrlen);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_put</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#20256;&#36755;&#23618;&#30340;connect&#65292;tcp&#20026; inet_stream_connect()</span>
        err = sock-&gt;ops-&gt;connect(sock, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *)address, addrlen,
                                 sock-&gt;file-&gt;f_flags);
<span style="color: #AE81FF;">out_put</span>:
        fput_light(sock-&gt;file, fput_needed);
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org7bd4837" class="outline-3">
<h3 id="org7bd4837"><span class="section-number-3">7.7.</span> shutdown系统调用</h3>
<div class="outline-text-3" id="text-7-7">
</div>
<div id="outline-container-org4b0c923" class="outline-4">
<h4 id="org4b0c923"><span class="section-number-4">7.7.1.</span> sys_shutdown()</h4>
<div class="outline-text-4" id="text-7-7-1">
<p>
shutdown 用于关闭连接的读通道、写通道或者读写通道，如果关闭读通道，则丢弃还未读取的数据和之后到达的数据。对于写通道，会调用对应的协议处理，例如TCP会发送所有剩余的数据，并在发送完成后发送FIN。
</p>

<p>
为了删除和释放文件描述符，还需要调用close()。
</p>


<div id="org21c0bda" class="figure">
<p><img src="image/socket-layer/shutdown.png" alt="shutdown.png" />
</p>
<p><span class="figure-number">Figure 7: </span>shutdown()系统调用过程</p>
</div>

<div class="org-src-container">
<pre class="src src-c">asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E;">sys_shutdown</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fd</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">how</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>, <span style="color: #FD971F;">fput_needed</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>;

        sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);
        <span style="color: #F92672;">if</span> (sock != <span style="color: #AE81FF;">NULL</span>) {
                err = security_socket_shutdown(sock, how);
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>err)
                        err = sock-&gt;ops-&gt;shutdown(sock, how);
                fput_light(sock-&gt;file, fput_needed);
        }
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org80c7851" class="outline-4">
<h4 id="org80c7851"><span class="section-number-4">7.7.2.</span> 套接口层的实现</h4>
<div class="outline-text-4" id="text-7-7-2">
<p>
inet_shutdown()
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_shutdown</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">how</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span> = sock-&gt;sk;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span> = 0;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">This should really check to make sure</span>
<span style="color: #75715E;">         * the socket is a TCP socket. (WHY AC...)</span>
<span style="color: #75715E;">         */</span>
        how++; <span style="color: #75715E;">/* </span><span style="color: #75715E;">maps 0-&gt;1 has the advantage of making bit 1 rcvs and</span>
<span style="color: #75715E;">                       1-&gt;2 bit 2 snds.</span>
<span style="color: #75715E;">                       2-&gt;3</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> ((how &amp; ~SHUTDOWN_MASK) || <span style="color: #E6DB74; font-weight: bold;">!</span>how)     <span style="color: #75715E;">/* </span><span style="color: #75715E;">MAXINT-&gt;0</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">return</span> -EINVAL;

        lock_sock(sk);
        <span style="color: #F92672;">if</span> (sock-&gt;state == SS_CONNECTING) {
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#29366;&#24577;&#37325;&#26032;&#35774;&#32622;&#22871;&#25509;&#21475;&#29366;&#24577;&#65292;&#20351;&#24471;&#22871;&#25509;&#21475;&#22312;&#23436;&#25104;&#20851;&#38381;&#21069;&#21482;&#26377;&#20004;&#31181;&#29366;&#24577;</span>
                <span style="color: #F92672;">if</span> ((1 &lt;&lt; sk-&gt;sk_state) &amp;
                    (TCPF_SYN_SENT | TCPF_SYN_RECV | TCPF_CLOSE))
                        sock-&gt;state = SS_DISCONNECTING;
                <span style="color: #F92672;">else</span>
                        sock-&gt;state = SS_CONNECTED;
        }

        <span style="color: #F92672;">switch</span> (sk-&gt;sk_state) {
        <span style="color: #F92672;">case</span> TCP_CLOSE:
                err = -ENOTCONN;
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Hack to wake up other listeners, who can poll for</span>
<span style="color: #75715E;">                   POLLHUP, even on eg. unconnected UDP sockets -- RR</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">default</span>:
                sk-&gt;sk_shutdown |= how;
                <span style="color: #F92672;">if</span> (sk-&gt;sk_prot-&gt;shutdown)
                        sk-&gt;sk_prot-&gt;shutdown(sk, how); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#20256;&#36755;&#23618;&#30340;shutdown()&#25805;&#20316;</span>
                <span style="color: #F92672;">break</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Remaining two branches are temporary solution for missing</span>
<span style="color: #75715E;">         * close() in multithreaded environment. It is _not_ a good idea,</span>
<span style="color: #75715E;">         * but we have no choice until close() is repaired at VFS level.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">case</span> TCP_LISTEN:
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(how &amp; RCV_SHUTDOWN)) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#20851;&#38381;&#30340;&#25509;&#25910;&#26041;&#21521;&#65292;&#21017;&#21644;TCP_SYN_SENT&#29366;&#24577;&#22788;&#29702;&#30456;&#21516;</span>
                        <span style="color: #F92672;">break</span>;
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Fall through</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">case</span> TCP_SYN_SENT: <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#20110;&#24314;&#31435;&#36830;&#25509;&#36807;&#31243;&#20013;</span>
                err = sk-&gt;sk_prot-&gt;disconnect(sk, O_NONBLOCK);
                sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;
                <span style="color: #F92672;">break</span>;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Wake up anyone sleeping in poll.</span><span style="color: #75715E;"> */</span>
        sk-&gt;sk_state_change(sk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21796;&#37266;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#31561;&#24453;&#38431;&#21015;&#19978;&#30340;&#36827;&#31243;&#12290;</span>
        release_sock(sk);
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd6a3946" class="outline-3">
<h3 id="orgd6a3946"><span class="section-number-3">7.8.</span> close系统调用</h3>
<div class="outline-text-3" id="text-7-8">

<div id="orgc7b3fa7" class="figure">
<p><img src="image/socket-layer/close.png" alt="close.png" />
</p>
<p><span class="figure-number">Figure 8: </span>close系统调用</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">sock_close</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #FD971F;">inode</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">filp</span>)
{
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      It was possible the inode is NULL we were</span>
<span style="color: #75715E;">         *      closing an unfinished socket.</span>
<span style="color: #75715E;">         */</span>

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>inode) {
                printk(KERN_DEBUG <span style="color: #E6DB74;">"sock_close: NULL inode\n"</span>);
                <span style="color: #F92672;">return</span> 0;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#19982;&#25991;&#20214;&#25551;&#36848;&#31526;&#20851;&#32852;&#30340;&#22871;&#25509;&#21475;&#30340;&#24322;&#27493;&#36890;&#30693;&#38431;&#21015;&#20013;&#21024;&#38500;&#23545;&#24212;&#30340;&#32467;&#28857;</span>
        sock_fasync(-1, filp, 0);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20851;&#38381;&#22871;&#25509;&#21475;&#12290;</span>
        sock_release(SOCKET_I(inode));
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>

<div id="outline-container-orgbdc327b" class="outline-4">
<h4 id="orgbdc327b"><span class="section-number-4">7.8.1.</span> 关闭套接口</h4>
<div class="outline-text-4" id="text-7-8-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> *      sock_release    -       close a socket</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@sock</span><span style="color: #E6DB74;">: socket to close</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> *      The socket is released from the protocol stack if it has a release</span>
<span style="color: #E6DB74;"> *      callback, and the inode is then released if the socket is bound to</span>
<span style="color: #E6DB74;"> *      an inode not a file.</span>
<span style="color: #E6DB74;"> */</span>

<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">sock_release</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>)
{
        <span style="color: #F92672;">if</span> (sock-&gt;ops) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#23618;&#30340;proto_ops&#25805;&#20316;&#25509;&#21475;</span>
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">module</span> *<span style="color: #FD971F;">owner</span> = sock-&gt;ops-&gt;owner;
                sock-&gt;ops-&gt;release(sock);  <span style="color: #75715E;">//</span><span style="color: #75715E;">IPv4&#20013;&#20026; inet_release(),&#20854;&#20013;&#35843;&#29992;&#20855;&#20307;&#20256;&#36755;&#23618;&#30340;close&#25805;&#20316;&#12290;</span>
                sock-&gt;ops = <span style="color: #AE81FF;">NULL</span>;
                module_put(owner);
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20043;&#21069;&#24050;&#32463;&#22788;&#29702;&#20102;&#24322;&#27493;&#36890;&#30693;&#38431;&#21015;&#65292;&#22914;&#26524;&#19981;&#20026;&#31354;&#65292;&#21017;&#25171;&#21360;&#20449;&#24687;</span>
        <span style="color: #F92672;">if</span> (sock-&gt;fasync_list)
                printk(KERN_ERR <span style="color: #E6DB74;">"sock_release: fasync list not empty!\n"</span>);

        get_cpu_var(sockets_in_use)--;
        put_cpu_var(sockets_in_use);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sock-&gt;file) {
                iput(SOCK_INODE(sock));
                <span style="color: #F92672;">return</span>;
        }
        sock-&gt;file = <span style="color: #AE81FF;">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org59175e3" class="outline-4">
<h4 id="org59175e3"><span class="section-number-4">7.8.2.</span> 套接口层的实现</h4>
<div class="outline-text-4" id="text-7-8-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      The peer socket should always be NULL (or else). When we call this</span>
<span style="color: #75715E;"> *      function we are destroying the object and from then on nobody</span>
<span style="color: #75715E;"> *      should refer to it.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_release</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span> = sock-&gt;sk;

        <span style="color: #F92672;">if</span> (sk) {
                <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">timeout</span>;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#31163;&#24320;&#21152;&#20837;&#30340;&#22810;&#25773;&#32452;</span><span style="color: #75715E;"> */</span>
                ip_mc_drop_socket(sk);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">If linger is set, we don't return until the close</span>
<span style="color: #75715E;">                 * is complete.  Otherwise we return immediately. The</span>
<span style="color: #75715E;">                 * actually closing is done the same either way.</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 * If the close is due to the process exiting, we never</span>
<span style="color: #75715E;">                 * linger..</span>
<span style="color: #75715E;">                 */</span>
                timeout = 0;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">SOCK_LINGER&#34920;&#31034;&#22914;&#26524;&#26377;&#25968;&#25454;&#24102;&#21457;&#36865;&#65292;&#21017;&#24310;&#36831;&#20851;&#38381;</span>
                <span style="color: #F92672;">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp;
                    <span style="color: #E6DB74; font-weight: bold;">!</span>(current-&gt;flags &amp; PF_EXITING))  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36827;&#31243;&#19981;&#22788;&#20110;&#36864;&#20986;&#36807;&#31243;&#20013;</span>
                        timeout = sk-&gt;sk_lingertime; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#24310;&#36831;&#20851;&#38381;&#30340;&#26102;&#38388;</span>
                sock-&gt;sk = <span style="color: #AE81FF;">NULL</span>;
                sk-&gt;sk_prot-&gt;close(sk, timeout);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#20256;&#36755;&#23618;&#30340;close&#25509;&#21475;</span>
        }
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org595b9d8" class="outline-3">
<h3 id="org595b9d8"><span class="section-number-3">7.9.</span> select系统调用实现</h3>
<div class="outline-text-3" id="text-7-9">
<p>
select用来实现非阻塞 I/O。
</p>


<div id="orge93d0e6" class="figure">
<p><img src="image/socket-layer/select.png" alt="select.png" />
</p>
<p><span class="figure-number">Figure 9: </span>select系统调用</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:55</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
