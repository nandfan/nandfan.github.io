<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TCP连接的建立</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">TCP连接的建立</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0413405">1. 服务端建立连接过程</a></li>
<li><a href="#org22214cf">2. 连接相关的数据结构</a>
<ul>
<li><a href="#org5d43e62">2.1. request_sock_queue结构</a></li>
<li><a href="#org65f6c77">2.2. listen_sock结构</a></li>
<li><a href="#org54b71b9">2.3. tcp_request_sock结构</a>
<ul>
<li><a href="#org0cf6e6b">2.3.1. inet_request_sock</a></li>
<li><a href="#org69d6cd7">2.3.2. request_sock结构</a></li>
</ul>
</li>
<li><a href="#org1be1d7a">2.4. request_sock_ops结构</a></li>
</ul>
</li>
<li><a href="#org92261ca">3. bind系统调用</a>
<ul>
<li><a href="#org39d4690">3.1. bind端口散列表</a></li>
<li><a href="#orgb0a43f0">3.2. 传输层接口实现</a></li>
</ul>
</li>
<li><a href="#org83c8fe1">4. listen系统调用</a>
<ul>
<li><a href="#orgfce26cf">4.1. inet_listen()</a></li>
<li><a href="#org783d2e3">4.2. inet_csk_listen_start监听操作</a></li>
<li><a href="#orge7d36d9">4.3. 分配连接请求块散列表：reqsk_queue_alloc()</a></li>
</ul>
</li>
<li><a href="#orga4b6d4a">5. accept系统调用</a>
<ul>
<li><a href="#org5849e20">5.1. inet_accept()</a></li>
<li><a href="#org9f443d3">5.2. 传输层的接口实现：inet_csk_accept()</a>
<ul>
<li><a href="#orgb09f5ed">5.2.1. 等待新建的连接：inet_csk_wait_for_connect</a></li>
<li><a href="#orgc4a9d53">5.2.2. 获取已建立的连接：reqsk_queue_get_child</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd00b8c1">6. 被动打开</a>
<ul>
<li><a href="#orgb83bd4c">6.1. SYN cookies</a></li>
<li><a href="#org0e70d22">6.2. 第一次握手：接收SYN段</a>
<ul>
<li><a href="#org2d15283">6.2.1. LISTEN状态处理TCP段</a></li>
<li><a href="#org372fcde">6.2.2. LISTEN状态处理SYN段</a></li>
<li><a href="#org5a07f04">6.2.3. 连接请求处理：tcp_v4_conn_request</a></li>
<li><a href="#orge7899c8">6.2.4. 从SKB的控制块中获取IP选项：tcp_v4_save_options()</a></li>
<li><a href="#org411ec02">6.2.5. 将连接请求块保存到父传输控制块的散列表中</a></li>
<li><a href="#org6fbefd5">6.2.6. 更新该传输控制块上已请求连接块的数量</a></li>
<li><a href="#org82fefe1">6.2.7. 函数调用关系</a></li>
</ul>
</li>
<li><a href="#org0c32109">6.3. 第二次握手：发送SYN+ACK段</a>
<ul>
<li><a href="#org6af15cf">6.3.1. 构造并发送SYN+ACK段</a></li>
<li><a href="#org3b05753">6.3.2. 获取路由入口</a></li>
<li><a href="#orgd08d6b8">6.3.3. 构造SYN+ACK段</a></li>
</ul>
</li>
<li><a href="#orgf8c4867">6.4. 第三次握手：接收ACK段</a>
<ul>
<li><a href="#org21ca89f">6.4.1. LISTEN状态处理TCP段</a></li>
<li><a href="#org03886b3">6.4.2. 处理第三次握手的ACK段</a></li>
<li><a href="#org510329e">6.4.3. 在SYN_RECV状态下处理TCP段</a></li>
<li><a href="#orgd86a24b">6.4.4. 为新连接创建传输控制块</a></li>
<li><a href="#org9227082">6.4.5. 为子连接创建传输控制块</a></li>
<li><a href="#orgf66d995">6.4.6. 发送ACK段</a></li>
<li><a href="#org6e91e73">6.4.7. 发送RST段</a></li>
<li><a href="#org13174a9">6.4.8. 子传输控制块开始处理TCP段</a></li>
<li><a href="#org7d564e4">6.4.9. 子传输控制块SYN_RECV状态的ACK段的处理</a></li>
<li><a href="#org5482c9b">6.4.10. 函数调用关系</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0acf08c">7. connect系统调用</a>
<ul>
<li><a href="#orgbc03891">7.1. 套接口层实现：inet_stream_connect()</a></li>
<li><a href="#orgc193198">7.2. 传输层的实现： tcp_v4_connect()</a></li>
</ul>
</li>
<li><a href="#org8bf8ece">8. 主动打开</a>
<ul>
<li><a href="#org70a7d75">8.1. 第一次握手：发送SYN段</a>
<ul>
<li><a href="#orga154638">8.1.1. 初始化客户端传输控制块并发送SYN段</a></li>
<li><a href="#org0851a58">8.1.2. 动态绑定端口： inet_hash_connect()</a></li>
<li><a href="#org68d093f">8.1.3. 构造SYN段并发送：tcp_connect()</a></li>
</ul>
</li>
<li><a href="#orgfa055d2">8.2. 第二次握手： 接收SYN+ACK段</a>
<ul>
<li><a href="#org2a92955">8.2.1. SYN_SENT状态的处理</a></li>
<li><a href="#orgb6d7951">8.2.2. 处理SYN+ACK段</a></li>
</ul>
</li>
<li><a href="#org4366c34">8.3. 第三次握手：发送ACK段</a></li>
</ul>
</li>
<li><a href="#org9ea0a88">9. 同时打开</a>
<ul>
<li><a href="#org6b00fbe">9.1. SYN_SENT状态接收到SYN段</a></li>
<li><a href="#orgbd132c7">9.2. SYN_RECV状态接收SYN+ACK段</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0413405" class="outline-2">
<h2 id="org0413405"><span class="section-number-2">1.</span> 服务端建立连接过程</h2>
<div class="outline-text-2" id="text-1">
<p>
建立TCP连接的过程：
</p>
<ul class="org-ul">
<li>client发送SYN段，表示希望连接的服务器端口以及初始序号。</li>
<li>server发送一个包含server段初始序号以及对client SYN段确认的 SYN+ACK段作为应答，SYN占用一个序号，因此确认序号设置为client初始序号加1。</li>
<li>client发送确认序号为server初始序号加1的ACK段，对server的SYN段进行确认。</li>
</ul>

<p>
在TCP传输控制块 inet_connection_sock 结构中有个 request_sock_queue 结构类型的成员 <b>icsk_accept_queue</b> ，用来保存正在建立连接和已建立连接但未被accept的传输控制块。在request_sock_queue结构的rskq_accept_head 和 rskq_accept_tail 构成的链表中保存了已经我那成连接的连接请求块；在listen_sock结构实例的syn_table散列表中，保存着两个连接状态中的连接请求块，请求块之间使用dl_next形成链表。
</p>


<div id="org9f03226" class="figure">
<p><img src="image/tcp-connect/req-sock.png" alt="req-sock.png" />
</p>
<p><span class="figure-number">Figure 1: </span>请求连接数据结构间的关系</p>
</div>

<p>
虽然每个TCP传输控制块都有请求连接控制块 icsk_accept_queue，但最初创建时不完整，request_sock_queue结构的listen_opt指针为NULL，即还没有为保存SYN_RECV状态的请求连接控制块分配空间，如下图：
</p>


<div id="org6324492" class="figure">
<p><img src="image/tcp-connect/no-complete-reqsock.png" alt="no-complete-reqsock.png" />
</p>
<p><span class="figure-number">Figure 2: </span>不完整的连接请求队列结构</p>
</div>

<p>
在调用listen系统调用时，使TCP进入LISTEN状态，同时还未保存SYN_RECV状态的请求连接控制块分配空间，其中syn_table散列表的大小油listen系统调用的参数backlog控制，分配后的结构如下图：
</p>


<div id="org33157d5" class="figure">
<p><img src="image/tcp-connect/req-sock.png" alt="req-sock.png" />
</p>
<p><span class="figure-number">Figure 3: </span>初始化后的连接请求队列结构</p>
</div>


<p>
listen调用后，套接口就可以接受新的连接了。当有客户端发送SYN段请求连接时，如果SYN合法，会为该连接请求创建连接请求块，并保存相应的信息（双方初始序号、启用的TCP选项等），这些信息由tcp_request_sock结构的描述。
</p>


<div id="org1d2fd92" class="figure">
<p><img src="image/tcp-connect/2-connecting-sock.png" alt="2-connecting-sock.png" />
</p>
<p><span class="figure-number">Figure 4: </span>接收了2个未完成连接的连接请求</p>
</div>


<p>
当服务端接收连接请求后，会建立相应的连接请求块，同时给对方发送SYN+ACK段作为回应。服务端再次收到客户端的ACK确认时，才会真正的为连接创建一个TCP传输控制块，并将其挂载到连接请求块的sk成员上，同时将该连接请求块移动到 rskq_accept_head 队列中，等待服务端accept调用，如下图：
</p>


<div id="org1b63a0e" class="figure">
<p><img src="image/tcp-connect/2-sock-1connect.png" alt="2-sock-1connect.png" />
</p>
<p><span class="figure-number">Figure 5: </span>接收了2个连接请求（一个完成连接，等待accept）</p>
</div>

<p>
调用accept系统调用时，从rskq_accept_head队列中取出请求传输控制块，与套接口相关联后释放该连接请求块，如下图，如果队列为空，则根据是否阻塞来决定是直接返回还是等待超时。
</p>


<div id="org4b9dc9b" class="figure">
<p><img src="image/tcp-connect/2sock-1accept.png" alt="2sock-1accept.png" />
</p>
<p><span class="figure-number">Figure 6: </span>接收了2个连接请求（完成的连接被取走）</p>
</div>
</div>
</div>


<div id="outline-container-org22214cf" class="outline-2">
<h2 id="org22214cf"><span class="section-number-2">2.</span> 连接相关的数据结构</h2>
<div class="outline-text-2" id="text-2">
<p>
TCP连接的建立需要经过三次握手，服务端需要保存待建立连接的相关信息并控制连接，request_sock_queue等结构就是用来存储这些信息。
</p>
</div>

<div id="outline-container-org5d43e62" class="outline-3">
<h3 id="org5d43e62"><span class="section-number-3">2.1.</span> request_sock_queue结构</h3>
<div class="outline-text-3" id="text-2-1">
<p>
TCP传输控制块中，request_sock_queue 结构定义了用于存放连接请求块的容器，包括处于SYN_RECV状态以及已连接但还没被accept的传输控制块，inet_connection_sock结构中用成员 icsk_accept_queue 定义了该容器。
</p>




<div class="org-src-container">
<pre class="src src-c">
<span style="color: #E6DB74;">/** struct request_sock_queue - queue of request_socks</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@rskq_accept_head</span><span style="color: #E6DB74;"> - FIFO head of established children</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@rskq_accept_tail</span><span style="color: #E6DB74;"> - FIFO tail of established children</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@rskq_defer_accept</span><span style="color: #E6DB74;"> - User waits for some data after </span><span style="color: #AE81FF;">accept()</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@syn_wait_lock</span><span style="color: #E6DB74;"> - serializer</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">%syn_wait_lock</span><span style="color: #E6DB74;"> is necessary only to avoid proc interface having to grab the main</span>
<span style="color: #E6DB74;"> * lock sock while browsing the listening hash (otherwise it's deadlock prone).</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This lock is acquired in read mode only from </span><span style="color: #AE81FF;">listening_get_next()</span><span style="color: #E6DB74;"> seq_file</span>
<span style="color: #E6DB74;"> * op and it's acquired in write mode _only_ from code that is actively</span>
<span style="color: #E6DB74;"> * changing rskq_accept_head. All readers that are holding the master sock lock</span>
<span style="color: #E6DB74;"> * don't need to grab this lock in read mode too as rskq_accept_head. writes</span>
<span style="color: #E6DB74;"> * are always protected from the main sock lock.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock_queue</span> {
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#21035;&#25351;&#21521;&#24050;&#23436;&#25104;&#36830;&#25509;&#38142;&#34920;&#30340;&#39318;&#37096;&#21644;&#23614;&#37096;&#65292;listen_opt&#20013;&#30340;&#36830;&#25509;&#35831;&#27714;&#22359;&#36830;&#25509;&#21518;&#20250;&#31227;&#21160;&#21040;&#27492;&#38142;&#34920;&#65292;&#31561;&#24453;accept</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span>     *<span style="color: #FD971F;">rskq_accept_head</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span>     *<span style="color: #FD971F;">rskq_accept_tail</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35775;&#38382;listen_opt&#20197;&#21450;listen_sock&#32467;&#26500;&#25104;&#21592;&#30340;&#21516;&#27493;&#25511;&#21046;&#35835;&#20889;&#38145;</span>
        <span style="color: #66D9EF;">rwlock_t</span>                <span style="color: #FD971F;">syn_wait_lock</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20445;&#23384;&#30456;&#20851;&#22871;&#25509;&#21475;TCP&#23618;&#30340;TCP_DEFER_ACCEPT&#36873;&#39033;&#30340;&#20540;&#12290;</span>
        <span style="color: #66D9EF;">u8</span>                      <span style="color: #FD971F;">rskq_defer_accept</span>;
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#25351;&#21521;listen_sock&#32467;&#26500;&#30340;&#23454;&#20363;&#65292;&#22312;&#20390;&#21548;&#26102;&#24314;&#31435;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">listen_sock</span>      *<span style="color: #FD971F;">listen_opt</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org65f6c77" class="outline-3">
<h3 id="org65f6c77"><span class="section-number-3">2.2.</span> listen_sock结构</h3>
<div class="outline-text-3" id="text-2-2">
<p>
listen_sock结构用来存储连接请求块，该结构的实例在listen系统调用后才会被创建，request_sock_queue结构的listen_opt成员指向该实例。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">listen_sock</span> {
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23454;&#38469;&#20998;&#37197;&#29992;&#26469;&#20445;&#23384;SYN&#35831;&#27714;&#36830;&#25509;&#30340;request_sock&#32467;&#26500;&#25968;&#32452;&#30340;&#38271;&#24230;&#65292;&#20854;&#20540;&#20026;nr_table_entries&#20197;2&#20026;&#24213;&#30340;&#23545;&#25968;</span>
        <span style="color: #66D9EF;">u8</span>                      <span style="color: #FD971F;">max_qlen_log</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#24403;&#21069;&#36830;&#25509;&#35831;&#27714;&#22359;&#30340;&#25968;&#30446;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">int</span>                     <span style="color: #FD971F;">qlen</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;&#26410;&#37325;&#20256;&#36807;SYN+ACK&#27573;&#30340;&#35831;&#27714;&#22359;&#25968;&#30446;&#12290;</span>
        <span style="color: #66D9EF;">int</span>                     <span style="color: #FD971F;">qlen_young</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#29992;&#26469;&#35760;&#24405;&#36830;&#25509;&#24314;&#31435;&#23450;&#26102;&#22120;&#22788;&#29702;&#20989;&#25968;&#19979;&#27425;&#34987;&#28608;&#27963;&#26102;&#24464;&#22788;&#29702;&#30340;&#36830;&#25509;&#35831;&#27714;&#22359;&#25955;&#21015;&#34920;&#20837;&#21475;&#65292; &#22312;&#26412;&#27425;&#22788;&#29702;</span>
<span style="color: #75715E;">        &#32467;&#26463;&#26102;&#23558;&#24403;&#21069;&#30340;&#20837;&#21475;&#20445;&#23384;&#21040;&#35813;&#23383;&#27573;&#65292;&#19979;&#27425;&#20174;&#35813;&#20301;&#32622;&#22788;&#29702;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">int</span>                     <span style="color: #FD971F;">clock_hand</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#26469;&#35745;&#31639;SYN&#35831;&#27714;&#22359;&#25955;&#21015;&#34920;&#38190;&#20540;&#30340;&#38543;&#26426;&#25968;&#65292;&#35813;&#20540;&#22312;reqsk_queue_alloc()&#20013;&#38543;&#26426;&#29983;&#25104;</span>
        <span style="color: #66D9EF;">u32</span>                     <span style="color: #FD971F;">hash_rnd</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23454;&#38469;&#20998;&#37197;&#29992;&#26469;&#20445;&#23384;syn&#35831;&#27714;&#36830;&#25509;&#30340;request_sock&#32467;&#26500;&#25968;&#32452;&#30340;&#38271;&#24230;</span>
        <span style="color: #66D9EF;">u32</span>                     <span style="color: #FD971F;">nr_table_entries</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">request_sock&#32467;&#26500;&#25955;&#21015;&#34920;&#65292;&#35843;&#29992;listen&#26102;&#29983;&#25104;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span>     *<span style="color: #FD971F;">syn_table</span>[0];
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org54b71b9" class="outline-3">
<h3 id="org54b71b9"><span class="section-number-3">2.3.</span> tcp_request_sock结构</h3>
<div class="outline-text-3" id="text-2-3">
<p>
tcp_request_sock结构作为TCP连接请求块，用来保存双方的初始序号、双方的端口及IP地址、TCP选项，如是否支持窗口扩大因子、是否支持SACK等，并控制连接建立。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_request_sock</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_request_sock</span>        <span style="color: #FD971F;">req</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23458;&#25143;&#31471;&#30340;&#21021;&#22987;&#24207;&#21495;&#65292;&#25509;&#25910;&#21040;&#23458;&#25143;&#31471;&#36830;&#25509;&#35831;&#27714;SYN&#27573;&#30340;&#24207;&#21495;</span>
        <span style="color: #66D9EF;">u32</span>                             <span style="color: #FD971F;">rcv_isn</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26381;&#21153;&#31471;&#30340;&#21021;&#22987;&#24207;&#21495;&#65292;&#26381;&#21153;&#31471;&#21457;&#36865;SYN+ACK&#27573;&#30340;&#24207;&#21495;</span>
        <span style="color: #66D9EF;">u32</span>                             <span style="color: #FD971F;">snt_isn</span>;
};
</pre>
</div>
</div>

<div id="outline-container-org0cf6e6b" class="outline-4">
<h4 id="org0cf6e6b"><span class="section-number-4">2.3.1.</span> inet_request_sock</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
用来构成tcp_request_sock结构开头的部分，主要描述双方的地址、支持的TCP选项等。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_request_sock</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span>     <span style="color: #FD971F;">req</span>;
        <span style="color: #66D9EF;">u16</span>                     <span style="color: #FD971F;">inet6_rsk_offset</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">2 bytes hole, try to pack</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">__be32</span>                  <span style="color: #FD971F;">loc_addr</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26412;&#22320;IP&#22320;&#22336;</span>
        <span style="color: #66D9EF;">__be32</span>                  <span style="color: #FD971F;">rmt_addr</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#23545;&#31471;IP&#22320;&#22336;</span>
        <span style="color: #66D9EF;">__be16</span>                  <span style="color: #FD971F;">rmt_port</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23545;&#31471;&#31471;&#21475;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#65292;&#23558;TCP&#39318;&#37096;&#25351;&#23450;&#30340;&#28369;&#21160;&#31383;&#21475;&#22823;&#23567;&#24038;&#31227;snd_wscale&#21518;&#25165;&#26159;&#30495;&#27491;&#30340;&#31383;&#21475;&#22823;&#23567;&#12290;</span>
        <span style="color: #66D9EF;">u16</span>                     <span style="color: #FD971F;">snd_wscale</span> : 4,
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25509;&#25910;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;</span>
                                <span style="color: #FD971F;">rcv_wscale</span> : 4,
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#23384;&#22312;TCP&#26102;&#38388;&#25139;&#36873;&#39033;</span>
                                <span style="color: #FD971F;">tstamp_ok</span>  : 1,
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#25903;&#25345;SACK&#65292;&#25903;&#25345;&#21017;&#21487;&#20197;&#20986;&#29616;&#22312;SYN&#27573;&#20013;&#12290;</span>
                                <span style="color: #FD971F;">sack_ok</span>    : 1,
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#25903;&#25345;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#65292;&#25903;&#25345;&#21017;&#21487;&#20197;&#20986;&#29616;&#22312;SYN&#27573;&#20013;&#12290;</span>
                                <span style="color: #FD971F;">wscale_ok</span>  : 1,
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#21551;&#29992;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;</span>
                                <span style="color: #FD971F;">ecn_ok</span>     : 1,
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26631;&#35782;&#24050;&#32463;&#25509;&#25910;&#21040;&#31532;&#19977;&#27425;&#25569;&#25163;&#30340;ACK&#27573;&#65292;&#20294;&#26159;&#30001;&#20110;&#26381;&#21153;&#22120;&#30340;&#21407;&#22240;&#23548;&#33268;&#27809;&#33021;&#24314;&#31435;&#36830;&#25509;&#65292;&#21487;&#20197;&#26681;&#25454;&#35813;&#26631;&#24535;&#20877;&#27425;&#21457;&#36865;SYN+ACK,&#24314;&#31435;&#36830;&#25509;&#12290;</span>
                                <span style="color: #FD971F;">acked</span>      : 1;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#21521;IP&#36873;&#39033;&#25968;&#25454;&#32467;&#26500;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span>       *<span style="color: #FD971F;">opt</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org69d6cd7" class="outline-4">
<h4 id="org69d6cd7"><span class="section-number-4">2.3.2.</span> request_sock结构</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
该结构用来构成 inet_request_sock结构的起始部分，主要描述对端MSS、本段接收窗口大小及控制连接操作的信息。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">struct request_sock - mini sock to represent a connection request</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> {
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;request_sock &#32467;&#26500;&#23454;&#20363;&#36830;&#25509;&#38142;&#34920;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span>             *<span style="color: #FD971F;">dl_next</span>; <span style="color: #75715E;">/* </span><span style="color: #75715E;">Must be first member!</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23458;&#25143;&#31471;&#36830;&#25509;&#35831;&#27714;&#36890;&#21578;&#30340;MSS&#12290;&#27809;&#26377;&#36890;&#21578;&#21017;&#20351;&#29992;&#21021;&#22987;&#20540;&#65288;RFC&#24314;&#35758;536&#65289;</span>
        <span style="color: #66D9EF;">u16</span>                             <span style="color: #FD971F;">mss</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;SYN+ACK&#27573;&#30340;&#27425;&#25968;&#12290;&#24403;&#36798;&#21040;&#38480;&#21046;&#26102;&#65292;&#21462;&#28040;&#36830;&#25509;&#25805;&#20316;</span>
        <span style="color: #66D9EF;">u8</span>                              <span style="color: #FD971F;">retrans</span>;
        <span style="color: #66D9EF;">u8</span>                              <span style="color: #FD971F;">__pad</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">The following two fields can be easily recomputed I think -AK</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26412;&#31471;&#26368;&#22823;&#36890;&#21578;&#31383;&#21475;&#65292;&#22312;&#29983;&#25104;SYN+ACK&#26102;&#35745;&#31639;&#35813;&#20540;</span>
        <span style="color: #66D9EF;">u32</span>                             <span style="color: #FD971F;">window_clamp</span>; <span style="color: #75715E;">/* </span><span style="color: #75715E;">window clamp at creation time</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36830;&#25509;&#24314;&#31435;&#26102;&#26412;&#31471;&#25509;&#25910;&#31383;&#21475;&#30340;&#22823;&#23567;&#65292;&#22312;&#29983;&#25104;SYN+ACK&#26102;&#35745;&#31639;&#35813;&#20540;</span>
        <span style="color: #66D9EF;">u32</span>                             <span style="color: #FD971F;">rcv_wnd</span>;          <span style="color: #75715E;">/* </span><span style="color: #75715E;">rcv_wnd offered first time</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19979;&#19968;&#20010;&#23558;&#35201;&#21457;&#36865;ACK&#20013;&#30340;&#26102;&#38388;&#25139;&#20540;&#12290;&#24403;&#19968;&#20010;&#21253;&#21547;&#26368;&#21518;&#21457;&#36865;ACK&#30830;&#35748;&#24207;&#21495;&#30340;&#27573;&#21040;&#36798;&#26102;&#65292;&#35813;&#27573;&#20013;&#30340;&#26102;&#38388;&#25139;&#34987;&#20445;&#23384;&#22312;ts_recent&#20013;&#12290;</span>
        <span style="color: #66D9EF;">u32</span>                             <span style="color: #FD971F;">ts_recent</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26381;&#21153;&#31471;&#25509;&#25910;&#21040;&#36830;&#25509;&#35831;&#27714;&#65292;&#24182;&#21457;&#36865;SYN+ACK&#27573;&#20316;&#20026;&#24212;&#31572;&#21518;&#65292;&#31561;&#24453;&#23458;&#25143;&#31471;&#30830;&#35748;&#30340;&#36229;&#26102;&#26102;&#38388;&#65292;&#36229;&#26102;&#21518;&#21457;&#36865;SYN+ACK&#65292;&#30452;&#21040;&#27425;&#25968;&#36798;&#21040;&#19978;&#38480;</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>                   <span style="color: #FD971F;">expires</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;&#36830;&#25509;&#35831;&#27714;&#30340;&#20989;&#25968;&#25351;&#38024;&#34920;&#65292;tcp&#20013;&#25351;&#21521;tcp_request_sock_ops</span>
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock_ops</span>   *<span style="color: #FD971F;">rsk_ops</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#21521;&#23545;&#24212;&#29366;&#24577;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#36830;&#25509;&#24314;&#31435;&#21069;&#26080;&#25928;&#65292;&#25569;&#25163;&#25104;&#21151;&#21518;&#20250;&#24314;&#31435;&#23545;&#24212;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#12290;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span>                     *<span style="color: #FD971F;">sk</span>;
        <span style="color: #66D9EF;">u32</span>                             <span style="color: #FD971F;">secid</span>;
        <span style="color: #66D9EF;">u32</span>                             <span style="color: #FD971F;">peer_secid</span>;
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1be1d7a" class="outline-3">
<h3 id="org1be1d7a"><span class="section-number-3">2.4.</span> request_sock_ops结构</h3>
<div class="outline-text-3" id="text-2-4">
<p>
request_sock_ops结构用来描述处理连接请求的函数指针表，包括用于发送SYN+ACK段、ACK段、RST段的函数。 该结构作为request_sock的成员，可以方便的通过连接请求块索引这些接口。TCP中指向tcp_request_sock_ops。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock_ops</span> {
        <span style="color: #66D9EF;">int</span>             <span style="color: #FD971F;">family</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#25152;&#23646;&#21327;&#35758;&#26063;</span>
        <span style="color: #66D9EF;">int</span>             <span style="color: #FD971F;">obj_size</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">tcp_request_sock&#32467;&#26500;&#30340;&#38271;&#24230;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kmem_cache</span>       *<span style="color: #FD971F;">slab</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36830;&#25509;&#35831;&#27714;&#22359;&#30340;&#39640;&#36895;&#32531;&#23384;slab</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;SYN+ACK&#27573;&#30340;&#20989;&#25968;&#25351;&#38024;&#65288;tcp_v4_send_synack()&#65289;</span>
        <span style="color: #66D9EF;">int</span>             (*<span style="color: #A6E22E;">rtx_syn_ack</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
                                   <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span>,
                                   <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dst_entry</span> *<span style="color: #FD971F;">dst</span>);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;ACK&#27573;&#30340;&#20989;&#25968;&#25351;&#38024;&#65288;tcp_v4_reqsk_send_ack()&#65289;</span>
        <span style="color: #66D9EF;">void</span>    (*<span style="color: #A6E22E;">send_ack</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>,
                                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span>);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;RST&#27573;&#30340;&#20989;&#25968;&#25351;&#38024;&#65288;tcp_v4_send_reset()&#65289;</span>
        <span style="color: #66D9EF;">void</span>    (*<span style="color: #A6E22E;">send_reset</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
                                  <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26512;&#26500;&#20989;&#25968;&#65292;&#37322;&#25918;&#36830;&#25509;&#35831;&#27714;&#22359;&#26102;&#35843;&#29992;&#65288;tcp_v4_reqsk_destructor()&#65289;</span>
        <span style="color: #66D9EF;">void</span>    (*<span style="color: #A6E22E;">destructor</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span>);
};
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org92261ca" class="outline-2">
<h2 id="org92261ca"><span class="section-number-2">3.</span> bind系统调用</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org39d4690" class="outline-3">
<h3 id="org39d4690"><span class="section-number-3">3.1.</span> bind端口散列表</h3>
<div class="outline-text-3" id="text-3-1">
<p>
tcp中使用 inet_bind_hashbucket 散列表来管理已绑定端口。该散列表在TCP初始化时，根据ehash散列表的大小ehash_size调整创建，bind端口实例通过node成员连接在散列表中。
</p>



<div id="org0d76180" class="figure">
<p><img src="image/tcp-connect/bind-st.png" alt="bind-st.png" />
</p>
<p><span class="figure-number">Figure 7: </span>已经bind端口的结构</p>
</div>

<ul class="org-ul">
<li>inet_bind_bucket_create()，用来在bind_bucket_cachep高速缓存中分配bind端口实例，设置后将其添加到inet_bind_hashbucket散列表。</li>

<li>inet_bind_bucket_destory()，将指定的bind端口实例从inet_bind_hashbucket散列表中删除并释放。</li>
</ul>
</div>
</div>

<div id="outline-container-orgb0a43f0" class="outline-3">
<h3 id="orgb0a43f0"><span class="section-number-3">3.2.</span> 传输层接口实现</h3>
<div class="outline-text-3" id="text-3-2">
<p>
bind系统调用通过套接口层的inet_bind()函数跳转到tcp的接口函数 tcp_v4_get_port(), 最终调用 inet_csk_get_port()。
</p>

<p>
如果绑定的本地端口为0，则自动分配一个可用端口。
</p>

<p>
如果指定了端口号，则从已绑定的端口信息中查找，找到则该端口已被使用，如果不能复用，则bind失败；没有找到，则创建新的bind信息块，添加到散列表。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Obtain a reference to a local port for the given sock,</span>
<span style="color: #75715E;"> * if snum is zero it means select any available local port.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_csk_get_port</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_hashinfo</span> *<span style="color: #FD971F;">hashinfo</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">tcp&#25955;&#21015;&#34920;&#31649;&#29702;&#32467;&#26500;&#23454;&#20363; tcp_hashinfo</span>
                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> <span style="color: #FD971F;">snum</span>,<span style="color: #75715E;">//</span><span style="color: #75715E;">&#35201;&#32465;&#23450;&#30340;&#31471;&#21475;&#21495;</span>
                      <span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">bind_conflict</span>)(<span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
                                           <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_bind_bucket</span> *<span style="color: #FD971F;">tb</span>))
<span style="color: #75715E;">/* </span><span style="color: #75715E;">bind_conflict &#20989;&#25968;&#25351;&#38024;&#65292;&#29992;&#26469;&#22312;&#25351;&#23450;&#31471;&#21475;&#20449;&#24687;&#22359;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#38142;&#34920;&#19978;&#26597;&#25214;&#26159;&#21542;&#23384;&#22312;&#19982;&#24453;&#32465;&#23450;&#20256;&#36755;&#25511;&#21046;&#22359;&#20914;&#31361;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#12290;tcp&#20013;&#20351;&#29992; inet_csk_bind_conflict()&#12290;</span>

<span style="color: #75715E;">&#20914;&#31361;&#38656;&#35201;&#28385;&#36275;&#19977;&#20010;&#26465;&#20214;&#65306;</span>
<span style="color: #75715E;">    1. &#20256;&#36755;&#25511;&#21046;&#22359;&#38142;&#34920;&#19978;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#19982;&#24453;&#32465;&#23450;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#25968;&#25454;&#21253;&#36755;&#20986;&#35774;&#22791;&#30340;&#32034;&#24341;&#21495;&#30456;&#31561;&#65292;&#25110;&#20854;&#20013;&#20219;&#20309;&#19968;&#20010;&#20026;0&#12290;</span>
<span style="color: #75715E;">    2. &#20004;&#32773;&#20043;&#38388;&#20219;&#20309;&#19968;&#20010;&#37117;&#27809;&#26377;&#31471;&#21475;&#22797;&#29992;&#65292;&#25110;&#32773;&#38142;&#34920;&#19978;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#19981;&#22788;&#20110;TCP_LISTEN&#29366;&#24577;&#12290;</span>
<span style="color: #75715E;">    3. &#20004;&#32773;&#30340;&#28304;&#22320;&#22336;&#30456;&#31561;&#65292;&#25110;&#32773;&#20219;&#20309;&#19968;&#20010;&#28304;&#22320;&#22336;&#20026;0&#12290;</span>
<span style="color: #75715E;">*/</span>
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_bind_hashbucket</span> *<span style="color: #FD971F;">head</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_node</span> *<span style="color: #FD971F;">node</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_bind_bucket</span> *<span style="color: #FD971F;">tb</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ret</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31105;&#27490;&#19979;&#21322;&#37096;&#65292;&#20445;&#35777;&#36827;&#31243;&#21644;&#19979;&#21322;&#37096;&#20043;&#38388;&#21516;&#27493;&#12290;&#22240;&#20026;&#21518;&#32493;&#25805;&#20316;&#20013;&#26377;&#20123;&#25968;&#25454;&#21487;&#33021;&#34987;&#36827;&#31243;&#21644;&#19979;&#21322;&#37096;&#21516;&#26102;&#35775;&#38382;&#12290;</span>
        local_bh_disable();
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>snum) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31471;&#21475;&#20026;0&#65292;&#34920;&#31034;&#27809;&#26377;&#25351;&#23450;&#31471;&#21475;&#65292;&#36827;&#34892;&#20998;&#37197;</span>
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">low</span> = sysctl_local_port_range[0];   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33258;&#21160;&#20998;&#37197;&#31471;&#21475;&#30340;&#21306;&#38388;</span>
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">high</span> = sysctl_local_port_range[1];
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">remaining</span> = (high - low) + 1;   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;&#31471;&#21475;&#30340;&#37325;&#35797;&#27425;&#25968;</span>
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">rover</span> = net_random() % (high - low) + low;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29983;&#25104;&#21306;&#38388;&#20869;&#30340;&#38543;&#26426;&#31471;&#21475;&#21495;</span>

                <span style="color: #F92672;">do</span> {
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20808;&#26681;&#25454;&#31471;&#21475;&#33719;&#21462;hash&#20540;&#23545;&#24212;&#30340;&#31471;&#21475;&#38142;&#34920;</span>
                        head = &amp;hashinfo-&gt;bhash[inet_bhashfn(rover, hashinfo-&gt;bhash_size)];
                        spin_lock(&amp;head-&gt;lock);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21152;&#38145;&#20934;&#22791;&#36941;&#21382;</span>
                        inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain)
                                <span style="color: #F92672;">if</span> (tb-&gt;port == rover) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31471;&#21475;&#24050;&#34987;&#20351;&#29992;</span>
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">next</span>;
                        <span style="color: #F92672;">break</span>;
                <span style="color: #AE81FF;">next</span>:
                        spin_unlock(&amp;head-&gt;lock);
                        <span style="color: #F92672;">if</span> (++rover &gt; high)  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31471;&#21475;&#21152;1&#26159;&#21542;&#36229;&#36807;&#21306;&#38388;</span>
                                rover = low;
                } <span style="color: #F92672;">while</span> (--remaining &gt; 0);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#37325;&#35797;&#27425;&#25968;&#36882;&#20943;</span>

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Exhausted local port range during search?  It is not</span>
<span style="color: #75715E;">                 * possible for us to be holding one of the bind hash</span>
<span style="color: #75715E;">                 * locks if this test triggers, because if 'remaining'</span>
<span style="color: #75715E;">                 * drops to zero, we broke out of the do/while loop at</span>
<span style="color: #75715E;">                 * the top level, not from the 'break;' statement.</span>
<span style="color: #75715E;">                 */</span>
                ret = 1;
                <span style="color: #F92672;">if</span> (remaining &lt;= 0)  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#37325;&#35797;&#27425;&#25968;&#29992;&#23436;&#65292;&#21017;&#33719;&#21462;&#31471;&#21475;&#22833;&#36133;</span>
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">fail</span>;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">OK, here is the one we will use.  HEAD is</span>
<span style="color: #75715E;">                 * non-NULL and we hold it's mutex.</span>
<span style="color: #75715E;">                 */</span>
                snum = rover;
        } <span style="color: #F92672;">else</span> { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#23450;&#20102;&#31471;&#21475;&#21495;</span>
                head = &amp;hashinfo-&gt;bhash[inet_bhashfn(snum, hashinfo-&gt;bhash_size)];
                spin_lock(&amp;head-&gt;lock);
                inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain)
                        <span style="color: #F92672;">if</span> (tb-&gt;port == snum) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31471;&#21475;&#24050;&#32463;&#34987;&#20351;&#29992;</span>
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">tb_found</span>;
        }
        tb = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">tb_not_found</span>;
<span style="color: #AE81FF;">tb_found</span>:
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>hlist_empty(&amp;tb-&gt;owners)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#26377;&#23545;&#24212;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#65288;&#26159;&#21542;&#26377;&#36827;&#31243;&#22312;&#20351;&#29992;&#65289;</span>
                <span style="color: #F92672;">if</span> (sk-&gt;sk_reuse &gt; 1) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21487;&#20197;&#24378;&#21046;&#22797;&#29992;&#31471;&#21475;</span>
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">success</span>;
                <span style="color: #F92672;">if</span> (tb-&gt;fastreuse &gt; 0 &amp;&amp;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21487;&#20197;&#34987;&#22797;&#29992;</span>
                    sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;&#25511;&#21046;&#22359;&#21487;&#22797;&#29992;&#31471;&#21475;&#19988;&#19981;&#22788;&#20110; TCP_LISTEN&#29366;&#24577;</span>
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">success</span>;
                } <span style="color: #F92672;">else</span> {
                        ret = 1;
                        <span style="color: #F92672;">if</span> (bind_conflict(sk, tb)) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;&#22797;&#29992;&#31471;&#21475;&#26159;&#21542;&#20914;&#31361;</span>
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">fail_unlock</span>;
                }
        }
<span style="color: #AE81FF;">tb_not_found</span>:  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31471;&#21475;&#27809;&#26377;&#34987;&#20351;&#29992;&#65292;&#21017;&#21019;&#24314;&#32465;&#23450;&#31471;&#21475;&#20449;&#24687;</span>
        ret = 1;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tb &amp;&amp; (tb = inet_bind_bucket_create(hashinfo-&gt;bind_bucket_cachep, head, snum)) == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">fail_unlock</span>;
        <span style="color: #F92672;">if</span> (hlist_empty(&amp;tb-&gt;owners)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31471;&#21475;&#36824;&#27809;&#26377;&#34987;&#32465;&#23450;</span>
                <span style="color: #F92672;">if</span> (sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;&#25511;&#21046;&#22359;&#20801;&#35768;&#22797;&#29992;&#31471;&#21475;</span>
                        tb-&gt;fastreuse = 1;
                <span style="color: #F92672;">else</span>
                        tb-&gt;fastreuse = 0;
        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (tb-&gt;fastreuse &amp;&amp;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31471;&#21475;&#24050;&#34987;&#32465;&#23450;</span>
                   (<span style="color: #E6DB74; font-weight: bold;">!</span>sk-&gt;sk_reuse || sk-&gt;sk_state == TCP_LISTEN)) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;&#25511;&#21046;&#22359;&#19981;&#20801;&#35768;&#22797;&#29992;&#31471;&#21475;&#65292;&#25110;&#32773;&#22788;&#20110;TCP_LISTEN</span>
                tb-&gt;fastreuse = 0;
<span style="color: #AE81FF;">success</span>:
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>inet_csk(sk)-&gt;icsk_bind_hash)
                inet_bind_hash(sk, tb, snum);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23436;&#25104;&#20256;&#36755;&#25511;&#21046;&#22359;&#21644;&#31471;&#21475;&#30340;&#32465;&#23450;</span>
        BUG_TRAP(inet_csk(sk)-&gt;icsk_bind_hash == tb);
        ret = 0;

<span style="color: #AE81FF;">fail_unlock</span>:
        spin_unlock(&amp;head-&gt;lock);
<span style="color: #AE81FF;">fail</span>:
        local_bh_enable();
        <span style="color: #F92672;">return</span> ret;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org83c8fe1" class="outline-2">
<h2 id="org83c8fe1"><span class="section-number-2">4.</span> listen系统调用</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgfce26cf" class="outline-3">
<h3 id="orgfce26cf"><span class="section-number-3">4.1.</span> inet_listen()</h3>
<div class="outline-text-3" id="text-4-1">
<p>
inet_listen()函数是listen系统调用的套接口层实现。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Move a socket into listening state.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_listen</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">backlog</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span> = sock-&gt;sk;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">old_state</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;

        lock_sock(sk);

        err = -EINVAL;
        <span style="color: #F92672;">if</span> (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        old_state = sk-&gt;sk_state;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>((1 &lt;&lt; old_state) &amp; (TCPF_CLOSE | TCPF_LISTEN)))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Really, if the socket is already in listen state</span>
<span style="color: #75715E;">         * we can only allow the backlog to be adjusted.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (old_state != TCP_LISTEN) {
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36827;&#34892;&#30417;&#21548;&#25805;&#20316;</span>
                err = inet_csk_listen_start(sk, backlog);
                <span style="color: #F92672;">if</span> (err)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        }
        sk-&gt;sk_max_ack_backlog = backlog;
        err = 0;

<span style="color: #AE81FF;">out</span>:
        release_sock(sk);
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org783d2e3" class="outline-3">
<h3 id="org783d2e3"><span class="section-number-3">4.2.</span> inet_csk_listen_start监听操作</h3>
<div class="outline-text-3" id="text-4-2">
<p>
inet_csk_listen_start() 函数使TCP传输控制块进入监听状态。
</p>

<p>
监听过程：
</p>
<ul class="org-ul">
<li>为管理连接请求块的散列表分配存储空间</li>
<li>将TCP传输控制块迁移到LISTEN状态</li>
<li>将传输控制块添加到监听散列表</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_csk_listen_start</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">nr_table_entries</span><span style="color: #75715E;">/*</span><span style="color: #75715E;">&#36830;&#25509;&#38431;&#21015;&#38271;&#24230;&#19978;&#38480;</span><span style="color: #75715E;">*/</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">rc</span> = reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue, nr_table_entries);

        <span style="color: #F92672;">if</span> (rc != 0)
                <span style="color: #F92672;">return</span> rc;

        sk-&gt;sk_max_ack_backlog = 0;
        sk-&gt;sk_ack_backlog = 0;
        inet_csk_delack_init(sk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270; &#24310;&#26102;&#21457;&#36865;ACK&#27573;&#30456;&#20851;&#30340;&#25968;&#25454;&#32467;&#26500;</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">There is race window here: we announce ourselves listening,</span>
<span style="color: #75715E;">         * but this transition is still not validated by get_port().</span>
<span style="color: #75715E;">         * It is OK, because this socket enters to hash table only</span>
<span style="color: #75715E;">         * after validation is complete.</span>
<span style="color: #75715E;">         */</span>
        sk-&gt;sk_state = TCP_LISTEN;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;num)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36827;&#34892;&#32465;&#23450;&#31471;&#21475;&#30340;&#25805;&#20316;</span>
                inet-&gt;sport = htons(inet-&gt;num);
                sk_dst_reset(sk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28165;&#38500;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;</span>
                sk-&gt;sk_prot-&gt;hash(sk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28155;&#21152;&#33267;&#25955;&#21015;&#34920;</span>
                <span style="color: #F92672;">return</span> 0;
        }

        sk-&gt;sk_state = TCP_CLOSE;
        __reqsk_queue_destroy(&amp;icsk-&gt;icsk_accept_queue);
        <span style="color: #F92672;">return</span> -EADDRINUSE;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orge7d36d9" class="outline-3">
<h3 id="orge7d36d9"><span class="section-number-3">4.3.</span> 分配连接请求块散列表：reqsk_queue_alloc()</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">reqsk_queue_alloc</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock_queue</span> *<span style="color: #FD971F;">queue</span>,
                      <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">nr_table_entries</span>)
{
        <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">lopt_size</span> = <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">listen_sock</span>);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">listen_sock</span> *<span style="color: #FD971F;">lopt</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#29992;&#20110;&#20445;&#23384;SYN&#35831;&#27714;&#36830;&#25509;&#30340; request_sock &#32467;&#26500;&#30340;&#25968;&#32452;&#38271;&#24230;</span>
        nr_table_entries = min_t(u32, nr_table_entries, sysctl_max_syn_backlog);
        nr_table_entries = max_t(u32, nr_table_entries, 8);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30830;&#20445; nr_table_entries &#30340;&#20540;&#20026; 2^n</span>
        nr_table_entries = roundup_pow_of_two(nr_table_entries + 1);
        lopt_size += nr_table_entries * <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *);
        <span style="color: #F92672;">if</span> (lopt_size &gt; PAGE_SIZE) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22823;&#20110;&#19968;&#20010;&#39029;&#38754;&#65292;&#21017;&#20351;&#29992; __vmalloc</span>
                lopt = __vmalloc(lopt_size,
                        GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO,
                        PAGE_KERNEL);
        <span style="color: #F92672;">else</span>
                lopt = kzalloc(lopt_size, GFP_KERNEL);
        <span style="color: #F92672;">if</span> (lopt == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">return</span> -ENOMEM;

        <span style="color: #75715E;">//</span><span style="color: #75715E;">nr_table_entries &#30340;&#20540;&#20026; 2^n &#65292;&#35745;&#31639;n&#20540; max_qlen_log</span>
        <span style="color: #F92672;">for</span> (lopt-&gt;max_qlen_log = 3;
             (1 &lt;&lt; lopt-&gt;max_qlen_log) &lt; nr_table_entries;
             lopt-&gt;max_qlen_log++);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;listen_sock&#32467;&#26500;&#30340;&#25104;&#21592;</span>
        get_random_bytes(&amp;lopt-&gt;hash_rnd, <span style="color: #F92672;">sizeof</span>(lopt-&gt;hash_rnd));
        rwlock_init(&amp;queue-&gt;syn_wait_lock);
        queue-&gt;rskq_accept_head = <span style="color: #AE81FF;">NULL</span>;
        lopt-&gt;nr_table_entries = nr_table_entries;

        write_lock_bh(&amp;queue-&gt;syn_wait_lock);
        queue-&gt;listen_opt = lopt;
        write_unlock_bh(&amp;queue-&gt;syn_wait_lock);

        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orga4b6d4a" class="outline-2">
<h2 id="orga4b6d4a"><span class="section-number-2">5.</span> accept系统调用</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org5849e20" class="outline-3">
<h3 id="org5849e20"><span class="section-number-3">5.1.</span> inet_accept()</h3>
<div class="outline-text-3" id="text-5-1">
<p>
该函数是accept系统调用的套接口层实现。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Accept a pending connection. The TCP layer now gives BSD semantics.</span>
<span style="color: #75715E;"> */</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_accept</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">newsock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk1</span> = sock-&gt;sk; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#22871;&#25509;&#21475;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span> = -EINVAL;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#20256;&#36755;&#23618;&#25509;&#21475;&#30340;&#23454;&#29616;&#20989;&#25968; inet_csk_accept()&#65292;&#26469;&#33719;&#21462;&#24050;&#23436;&#25104;&#36830;&#25509;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk2</span> = sk1-&gt;sk_prot-&gt;accept(sk1, flags, &amp;err);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sk2)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">do_err</span>;

        lock_sock(sk2);

        BUG_TRAP((1 &lt;&lt; sk2-&gt;sk_state) &amp;
                 (TCPF_ESTABLISHED | TCPF_CLOSE_WAIT | TCPF_CLOSE));
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#24050;&#32463;&#36830;&#25509;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#21644;&#22871;&#25509;&#21475;&#36827;&#34892;&#20851;&#32852;&#12290;</span>
        sock_graft(sk2, newsock);

        newsock-&gt;state = SS_CONNECTED;
        err = 0;
        release_sock(sk2);
<span style="color: #AE81FF;">do_err</span>:
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9f443d3" class="outline-3">
<h3 id="org9f443d3"><span class="section-number-3">5.2.</span> 传输层的接口实现：inet_csk_accept()</h3>
<div class="outline-text-3" id="text-5-2">
<p>
该函数获取已经完成连接的传输控制块。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * This will accept the next outstanding connection.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #A6E22E;">inet_csk_accept</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">err</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">newsk</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">error</span>;

        lock_sock(sk);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We need to make sure that this socket is listening,</span>
<span style="color: #75715E;">         * and that it has something pending.</span>
<span style="color: #75715E;">         */</span>
        error = -EINVAL;
        <span style="color: #F92672;">if</span> (sk-&gt;sk_state != TCP_LISTEN) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21482;&#26377;&#30417;&#21548;&#30340;&#22871;&#25509;&#23383;&#25165;&#21487;&#20197;&#36827;&#34892;accept&#25805;&#20316;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_err</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Find already established connection</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38431;&#21015;&#20026;&#31354;&#65292;&#21017;&#27809;&#26377;&#26032;&#36830;&#25509;</span>
                <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">timeo</span> = sock_rcvtimeo(sk, flags &amp; O_NONBLOCK);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">If this is a non blocking socket don't sleep</span><span style="color: #75715E;"> */</span>
                error = -EAGAIN;
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>timeo) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#25351;&#23450;timeout,&#21017;&#30452;&#25509;&#36820;&#22238;</span>
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_err</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22312;&#36229;&#26102;&#26102;&#38388;&#20869;&#31561;&#24453;&#26032;&#36830;&#25509;</span>
                error = inet_csk_wait_for_connect(sk, timeo);
                <span style="color: #F92672;">if</span> (error)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_err</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38431;&#21015;&#20013;&#26377;&#26032;&#36830;&#25509;&#65292;&#21017;&#33719;&#21462;&#26032;&#36830;&#25509;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        newsk = reqsk_queue_get_child(&amp;icsk-&gt;icsk_accept_queue, sk);
        BUG_TRAP(newsk-&gt;sk_state != TCP_SYN_RECV);
<span style="color: #AE81FF;">out</span>:
        release_sock(sk);
        <span style="color: #F92672;">return</span> newsk;
<span style="color: #AE81FF;">out_err</span>:
        newsk = <span style="color: #AE81FF;">NULL</span>;
        *err = error;
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
}
</pre>
</div>
</div>

<div id="outline-container-orgb09f5ed" class="outline-4">
<h4 id="orgb09f5ed"><span class="section-number-4">5.2.1.</span> 等待新建的连接：inet_csk_wait_for_connect</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
该函数用于在超时时间内等待新的连接，直到有新连接，或者超时，或者收到信号等。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * Wait for an incoming connection, avoid race conditions. This must be called</span>
<span style="color: #75715E;"> * with the socket locked.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_csk_wait_for_connect</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">timeo</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        DEFINE_WAIT(wait);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * True wake-one mechanism for incoming connections: only</span>
<span style="color: #75715E;">         * one process gets woken up, not the 'whole herd'.</span>
<span style="color: #75715E;">         * Since we do not 'race &amp; poll' for established sockets</span>
<span style="color: #75715E;">         * anymore, the common case will execute the loop only once.</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         * Subtle issue: "add_wait_queue_exclusive()" will be added</span>
<span style="color: #75715E;">         * after any current non-exclusive waiters, and we know that</span>
<span style="color: #75715E;">         * it will always _stay_ after any new non-exclusive waiters</span>
<span style="color: #75715E;">         * because all non-exclusive waiters are added at the</span>
<span style="color: #75715E;">         * beginning of the wait-queue. As such, it's ok to "drop"</span>
<span style="color: #75715E;">         * our exclusiveness temporarily when we get woken up without</span>
<span style="color: #75715E;">         * having to remove and re-insert us on the wait queue.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">for</span> (;;) {
                prepare_to_wait_exclusive(sk-&gt;sk_sleep, &amp;wait,
                                          TASK_INTERRUPTIBLE);
                release_sock(sk);
                <span style="color: #F92672;">if</span> (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))
                        timeo = schedule_timeout(timeo);
                lock_sock(sk);
                err = 0;
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))
                        <span style="color: #F92672;">break</span>;
                err = -EINVAL;
                <span style="color: #F92672;">if</span> (sk-&gt;sk_state != TCP_LISTEN)
                        <span style="color: #F92672;">break</span>;
                err = sock_intr_errno(timeo);
                <span style="color: #F92672;">if</span> (signal_pending(current))
                        <span style="color: #F92672;">break</span>;
                err = -EAGAIN;
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>timeo)
                        <span style="color: #F92672;">break</span>;
        }
        finish_wait(sk-&gt;sk_sleep, &amp;wait);
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc4a9d53" class="outline-4">
<h4 id="orgc4a9d53"><span class="section-number-4">5.2.2.</span> 获取已建立的连接：reqsk_queue_get_child</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
该函数从已连接队列上取走第一个连接请求块，然后由该连接请求块获得已经创建的子传输请求块，之后释放已完成建立连接的连接请求块，同时更新父传输控制块上已建立连接的数目，最后返回子传输控制块。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #A6E22E;">reqsk_queue_get_child</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock_queue</span> *<span style="color: #FD971F;">queue</span>,
                                                 <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">parent</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span> = reqsk_queue_remove(queue);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">child</span> = req-&gt;sk;

        BUG_TRAP(child != <span style="color: #AE81FF;">NULL</span>);

        sk_acceptq_removed(parent);
        __reqsk_free(req);
        <span style="color: #F92672;">return</span> child;
}
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-orgd00b8c1" class="outline-2">
<h2 id="orgd00b8c1"><span class="section-number-2">6.</span> 被动打开</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgb83bd4c" class="outline-3">
<h3 id="orgb83bd4c"><span class="section-number-3">6.1.</span> SYN cookies</h3>
<div class="outline-text-3" id="text-6-1">
<p>
TCP协议为亲求连接队列开辟了一个较大的内存空间，当SYN请求不断增加致使请求连接数目达到上限时，内核会丢弃SYN连接请求。 SYN cookies技术可以使服务器在半连接队列已满的情况下仍能处理新的SYN请求。
</p>

<p>
当半连接队列满时，SYN cookies并不丢弃SYN请求，而是通过加密技术来标识半连接状态。在TCP实现中，当收到客户端的SYN请求时，服务器需回复SYN+ACK给客户端，之后客户端发送确认。  通常，服务器的初始序列号由服务器按照一定的规律计算得到，或者采用随机数。在SYN cookies中，服务器的初始序号由客户端的IP地址、客户端端口、服务器IP地址和服务器端口、接收到客户端初始序列号以及其他一些安全数值进行hash运算，并进行加密后得到cookie。当服务器遭受SYN攻击导致请求连接队列满时，服务器不会拒绝新的SYN，而是回复初始序列号为cookie的SYN包，如果收到客户端的ACK段，则服务端将ACK序号减1后的值 和上述要素计算的hash值比较，相等则直接完成握手，注意： 此时不必查看此连接是否属于请求连接队列。
</p>

<p>
启用SYN coolies可以通过一下命令：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #75715E;"># </span><span style="color: #75715E;">echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0e70d22" class="outline-3">
<h3 id="org0e70d22"><span class="section-number-3">6.2.</span> 第一次握手：接收SYN段</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-org2d15283" class="outline-4">
<h4 id="org2d15283"><span class="section-number-4">6.2.1.</span> LISTEN状态处理TCP段</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
传输控制块接收处理的段都由 tcp_v4_do_rcv() 函数处理，该函数中，再根据不同状态调用不同函数： ESTABLISHED状态的处理函数为 tcp_rcv_established()，LISTEN状态且已建立半连接的处理函数为 tcp_v4_hnd_req()，其他状态处理函数为 tcp_rcv_state_process()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">The socket must have it's spinlock held when we get</span>
<span style="color: #75715E;"> * here.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * We have a potential double-lock case here, so even when</span>
<span style="color: #75715E;"> * doing backlog processing we use the BH locking scheme.</span>
<span style="color: #75715E;"> * This is because we cannot sleep with the original spinlock</span>
<span style="color: #75715E;"> * held.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_v4_do_rcv</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">rsk</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_state == TCP_LISTEN) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">nsk</span> = tcp_v4_hnd_req(sk, skb);
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>nsk)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;

                <span style="color: #F92672;">if</span> (nsk != sk) {
                        <span style="color: #F92672;">if</span> (tcp_child_process(sk, nsk, skb)) {
                                rsk = nsk;
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">reset</span>;
                        }
                        <span style="color: #F92672;">return</span> 0;
                }
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38500;&#20102; ESTABLISHED&#29366;&#24577;&#21644; LISTEN&#29366;&#24577;&#19988;&#24050;&#32463;&#24314;&#31435;&#21322;&#36830;&#25509; &#29366;&#24577;&#20043;&#22806;&#30340;&#22788;&#29702;&#12290;</span>
        TCP_CHECK_TIMER(sk);
        <span style="color: #F92672;">if</span> (tcp_rcv_state_process(sk, skb, skb-&gt;h.th, skb-&gt;len)) {
                rsk = sk;
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">reset</span>;
        }
        TCP_CHECK_TIMER(sk);
        <span style="color: #F92672;">return</span> 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org372fcde" class="outline-4">
<h4 id="org372fcde"><span class="section-number-4">6.2.2.</span> LISTEN状态处理SYN段</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
服务端处理第一次握手的函数是 tcp_rcv_state_process()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      This function implements the receiving procedure of RFC 793 for</span>
<span style="color: #75715E;"> *      all states except ESTABLISHED and TIME_WAIT.</span>
<span style="color: #75715E;"> *      It's called from both tcp_v4_rcv and tcp_v6_rcv and should be</span>
<span style="color: #75715E;"> *      address independent.</span>
<span style="color: #75715E;"> */</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_rcv_state_process</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span> <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22788;&#29702;&#35813;TCP&#27573;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span><span style="color: #75715E;">*/</span>,
                          <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25509;&#25910;&#21040;&#30340;TCP&#27573;</span>
                          <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span><span style="color: #75715E;">/*</span><span style="color: #75715E;">tcp&#39318;&#37096;</span><span style="color: #75715E;">*/</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">len</span><span style="color: #75715E;">/*</span><span style="color: #75715E;">tcp&#27573;&#38271;&#24230;</span><span style="color: #75715E;">*/</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">queued</span> = 0;

        tp-&gt;rx_opt.saw_tstamp = 0;

        <span style="color: #F92672;">switch</span> (sk-&gt;sk_state) {
        <span style="color: #F92672;">case</span> TCP_CLOSE:
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;

        <span style="color: #F92672;">case</span> TCP_LISTEN:  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36824;&#26410;&#24314;&#31435;&#21322;&#36830;&#25509;&#30340;LISTEN&#29366;&#24577;&#19979;&#65292;&#20043;&#22788;&#29702;SYN&#27573;</span>
                <span style="color: #F92672;">if</span>(th-&gt;ack)
                        <span style="color: #F92672;">return</span> 1;

                <span style="color: #F92672;">if</span>(th-&gt;rst)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;

                <span style="color: #F92672;">if</span>(th-&gt;syn) {
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;SYN&#27573;&#65292;tcp&#20013;&#20026; tcp_v4_conn_request()</span>
                        <span style="color: #F92672;">if</span> (icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; 0)
                                <span style="color: #F92672;">return</span> 1;

                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Now we have several options: In theory there is</span>
<span style="color: #75715E;">                         * nothing else in the frame. KA9Q has an option to</span>
<span style="color: #75715E;">                         * send data with the syn, BSD accepts data with the</span>
<span style="color: #75715E;">                         * syn up to the [to be] advertised window and</span>
<span style="color: #75715E;">                         * Solaris 2.1 gives you a protocol error. For now</span>
<span style="color: #75715E;">                         * we just ignore it, that fits the spec precisely</span>
<span style="color: #75715E;">                         * and avoids incompatibilities. It would be nice in</span>
<span style="color: #75715E;">                         * future to drop through and process the data.</span>
<span style="color: #75715E;">                         *</span>
<span style="color: #75715E;">                         * Now that TTCP is starting to be used we ought to</span>
<span style="color: #75715E;">                         * queue this data.</span>
<span style="color: #75715E;">                         * But, this leaves one open to an easy denial of</span>
<span style="color: #75715E;">                         * service attack, and SYN cookies can't defend</span>
<span style="color: #75715E;">                         * against this problem. So, we drop the data</span>
<span style="color: #75715E;">                         * in the interest of security over speed unless</span>
<span style="color: #75715E;">                         * it's still in use.</span>
<span style="color: #75715E;">                         */</span>
                        kfree_skb(skb);
                        <span style="color: #F92672;">return</span> 0;
                }
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5a07f04" class="outline-4">
<h4 id="org5a07f04"><span class="section-number-4">6.2.3.</span> 连接请求处理：tcp_v4_conn_request</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
tcp_v4_conn_request()是服务端用来处理客户端连接请求的函数。
</p>


<div id="org0f0b712" class="figure">
<p><img src="image/tcp-connect/tcp-v4-conn-request.png" alt="tcp-v4-conn-request.png" />
</p>
<p><span class="figure-number">Figure 8: </span>tcp_v4_conn_request()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_v4_conn_request</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_request_sock</span> *<span style="color: #FD971F;">ireq</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_options_received</span> <span style="color: #FD971F;">tmp_opt</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span>;
        <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">saddr</span> = skb-&gt;nh.iph-&gt;saddr;
        <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span> = skb-&gt;nh.iph-&gt;daddr;
        <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">isn</span> = TCP_SKB_CB(skb)-&gt;when;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dst_entry</span> *<span style="color: #FD971F;">dst</span> = <span style="color: #AE81FF;">NULL</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_SYN_COOKIES
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">want_cookie</span> = 0;
<span style="color: #F92672;">#else</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">want_cookie</span> 0 <span style="color: #75715E;">/* </span><span style="color: #75715E;">Argh, why doesn't gcc optimize this :(</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">#endif</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;SYN&#27573;&#26159;&#21457;&#36865;&#24191;&#25773;&#25110;&#32773;&#32452;&#25773;&#22320;&#22336;&#65292;&#30452;&#25509;&#20002;&#24323;&#65292;&#19981;&#22788;&#29702;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (((<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *)skb-&gt;dst)-&gt;rt_flags &amp;
            (RTCF_BROADCAST | RTCF_MULTICAST))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;SYN&#35831;&#27714;&#36830;&#25509;&#38431;&#21015;&#24050;&#28385;&#65292;&#24182;&#19988; isn&#20026;0&#65292;&#21017;&#38656;&#35201;&#21028;&#26029;&#26159;&#21542;&#21551;&#29992;&#20102;syncookies</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (inet_csk_reqsk_queue_is_full(sk) &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>isn) {
                <span style="color: #F92672;">if</span> (sysctl_tcp_syncookies) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21551;&#29992;&#20102;syncookies</span>
                        want_cookie = 1;
                } <span style="color: #F92672;">else</span>
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#36830;&#25509;&#38431;&#21015;&#38271;&#24230;&#36798;&#21040;&#19978;&#38480;&#65292;&#24182;&#19988;SYN&#35831;&#27714;&#38431;&#21015;&#20013;&#33267;&#23569;&#26377;&#19968;&#20010;&#25569;&#25163;&#36807;&#31243;&#20013;&#27809;&#26377;&#37325;&#20256;&#36807;&#30340;&#27573;&#65292;&#21017;&#20002;&#24323;&#24403;&#21069;&#36830;&#25509;&#35831;&#27714;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (sk_acceptq_is_full(sk) &amp;&amp; inet_csk_reqsk_queue_young(sk) &gt; 1)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;&#36830;&#25509;&#35831;&#27714;&#22359;</span>
        req = reqsk_alloc(&amp;tcp_request_sock_ops);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>req)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG <span style="color: #75715E;">//</span><span style="color: #75715E;">TCP MD5&#31614;&#21517;&#26469;&#20445;&#25252;BGP&#20250;&#35805;</span>
        tcp_rsk(req)-&gt;af_specific = &amp;tcp_request_sock_ipv4_ops;
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28165;&#38500;TCP&#36873;&#39033;&#65292;&#24182;&#21021;&#22987;&#21270;</span>
        tcp_clear_options(&amp;tmp_opt);
        tmp_opt.mss_clamp = 536;
        tmp_opt.user_mss  = tcp_sk(sk)-&gt;rx_opt.user_mss;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35299;&#26512;SYN&#27573;&#30340;TCP&#36873;&#39033;</span>
        tcp_parse_options(skb, &amp;tmp_opt, 0);

        <span style="color: #F92672;">if</span> (want_cookie) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#21551;&#29992;&#20102;syncookies,&#21017;&#28165;&#38500;&#24050;&#35299;&#26512;&#30340;TCP&#36873;&#39033;</span>
                tcp_clear_options(&amp;tmp_opt);
                tmp_opt.saw_tstamp = 0;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23384;&#22312;&#26102;&#38388;&#25139;&#36873;&#39033;&#65292;&#20294;&#26102;&#38388;&#25139;&#30340;&#20540;&#20026;0</span>
        <span style="color: #F92672;">if</span> (tmp_opt.saw_tstamp &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>tmp_opt.rcv_tsval) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Some OSes (unknown ones, but I see them on web server, which</span>
<span style="color: #75715E;">                 * contains information interesting only for windows'</span>
<span style="color: #75715E;">                 * users) do not send their stamp in SYN. It is easy case.</span>
<span style="color: #75715E;">                 * We simply do not advertise TS support.</span>
<span style="color: #75715E;">                 */</span>
                tmp_opt.saw_tstamp = 0;
                tmp_opt.tstamp_ok  = 0;
        }
        tmp_opt.tstamp_ok = tmp_opt.saw_tstamp;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#25910;&#21040;&#30340;SYN&#27573;&#20013;&#30340;&#36873;&#39033;&#21644;&#24207;&#21495;&#26469;&#21021;&#22987;&#21270;&#36830;&#25509;&#35831;&#27714;&#22359;&#20449;&#24687;</span>
        tcp_openreq_init(req, &amp;tmp_opt, skb);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23433;&#20840;&#26816;&#27979;</span>
        <span style="color: #F92672;">if</span> (security_inet_conn_request(sk, skb, req))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop_and_free</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#36830;&#25509;&#35831;&#27714;&#22359;&#65292;&#22320;&#22336;&#65292;IP&#36873;&#39033;&#65288;MSS&#12289;&#31383;&#21475;&#25193;&#22823;&#38134;&#23376;&#12289;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;&#31561;&#65289;</span>
        ireq = inet_rsk(req);
        ireq-&gt;loc_addr = daddr;
        ireq-&gt;rmt_addr = saddr;
        ireq-&gt;opt = tcp_v4_save_options(sk, skb);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>want_cookie)
                TCP_ECN_create_request(req, skb-&gt;h.th);

        <span style="color: #F92672;">if</span> (want_cookie) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21551;&#21160;&#20102;syncookies,&#21017;&#27599;60s&#35686;&#21578;&#19968;&#27425;&#21487;&#33021;&#21463;&#21040;synflood&#25915;&#20987;</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_SYN_COOKIES
                syn_flood_warning(skb);
<span style="color: #F92672;">#endif</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#22235;&#20803;&#32452;&#12289;&#23458;&#25143;&#31471;&#21021;&#22987;&#24207;&#21015;&#21495;&#31561;&#35201;&#32032;&#36827;&#34892;hash&#20803;&#31639;&#24471;&#21040;&#26381;&#21153;&#31471;&#21021;&#22987;&#24207;&#21015;&#21495;</span>
                isn = cookie_v4_init_sequence(sk, skb, &amp;req-&gt;mss);
        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>isn) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span> *<span style="color: #FD971F;">peer</span> = <span style="color: #AE81FF;">NULL</span>;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">VJ's idea. We save last timestamp seen</span>
<span style="color: #75715E;">                 * from the destination in peer table, when entering</span>
<span style="color: #75715E;">                 * state TIME-WAIT, and check against it before</span>
<span style="color: #75715E;">                 * accepting new connection request.</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 * If "isn" is not zero, this request hit alive</span>
<span style="color: #75715E;">                 * timewait bucket, so that all the necessary checks</span>
<span style="color: #75715E;">                 * are made in the function processing timewait state.</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36827;&#20837;TIMEWAIT&#29366;&#24577;&#26102;&#65292;&#20174;&#23545;&#31471;&#20449;&#24687;&#22359;&#20013;&#33719;&#21462;&#26102;&#38388;&#25139;&#65292;&#22312;&#26032;&#30340;&#36830;&#25509;&#35831;&#27714;&#20043;&#21069;&#26816;&#27979;PAWS&#12290;</span>
                <span style="color: #F92672;">if</span> (tmp_opt.saw_tstamp &amp;&amp;
                    tcp_death_row.sysctl_tw_recycle &amp;&amp;
                    (dst = inet_csk_route_req(sk, req)) != <span style="color: #AE81FF;">NULL</span> &amp;&amp;
                    (peer = rt_get_peer((<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *)dst)) != <span style="color: #AE81FF;">NULL</span> &amp;&amp;
                    peer-&gt;v4daddr == saddr) {
                        <span style="color: #F92672;">if</span> (xtime.tv_sec &lt; peer-&gt;tcp_ts_stamp + TCP_PAWS_MSL &amp;&amp;
                            (s32)(peer-&gt;tcp_ts - req-&gt;ts_recent) &gt;
                                                        TCP_PAWS_WINDOW) {
                                NET_INC_STATS_BH(LINUX_MIB_PAWSPASSIVEREJECTED);
                                dst_release(dst);
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop_and_free</span>;
                        }
                }
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26410;&#21551;&#29992;syncookies&#26102;&#65292;&#21463;&#21040;synflood&#65292;&#21017;&#20002;&#24323;</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sysctl_tcp_syncookies &amp;&amp;
                         (sysctl_max_syn_backlog - inet_csk_reqsk_queue_len(sk) &lt;
                          (sysctl_max_syn_backlog &gt;&gt; 2)) &amp;&amp;
                         (<span style="color: #E6DB74; font-weight: bold;">!</span>peer || <span style="color: #E6DB74; font-weight: bold;">!</span>peer-&gt;tcp_ts_stamp) &amp;&amp;
                         (<span style="color: #E6DB74; font-weight: bold;">!</span>dst || <span style="color: #E6DB74; font-weight: bold;">!</span>dst_metric(dst, RTAX_RTT))) {
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Without syncookies last quarter of</span>
<span style="color: #75715E;">                         * backlog is filled with destinations,</span>
<span style="color: #75715E;">                         * proven to be alive.</span>
<span style="color: #75715E;">                         * It means that we continue to communicate</span>
<span style="color: #75715E;">                         * to destinations, already remembered</span>
<span style="color: #75715E;">                         * to the moment of synflood.</span>
<span style="color: #75715E;">                         */</span>
                        LIMIT_NETDEBUG(KERN_DEBUG <span style="color: #E6DB74;">"TCP: drop open "</span>
                                       <span style="color: #E6DB74;">"request from %u.%u.%u.%u/%u\n"</span>,
                                       NIPQUAD(saddr),
                                       ntohs(skb-&gt;h.th-&gt;source));
                        dst_release(dst);
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop_and_free</span>;
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#36807;&#22235;&#20803;&#32452;&#35745;&#31639;&#26381;&#21153;&#31471;&#30340;&#21021;&#22987;&#24207;&#21015;&#21495;</span>
                isn = tcp_v4_init_sequence(skb);
        }
        tcp_rsk(req)-&gt;snt_isn = isn; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#35745;&#31639;&#30340;&#21021;&#22987;&#24207;&#21015;&#21495;&#23384;&#25918;&#21040;&#36830;&#25509;&#35831;&#27714;&#38454;&#27573;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;SYN+ACK</span>
        <span style="color: #F92672;">if</span> (tcp_v4_send_synack(sk, req, dst))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop_and_free</span>;

        <span style="color: #F92672;">if</span> (want_cookie) {
                reqsk_free(req);
        } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#21551;&#29992;syncookies&#26102;&#65292;&#38656;&#35201;&#23558;&#36830;&#25509;&#35831;&#27714;&#22359;&#20445;&#23384;&#21040;&#20854;&#29238;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#30340;&#25955;&#21015;&#34920;&#20013;</span>
                inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);
        }
        <span style="color: #F92672;">return</span> 0;

<span style="color: #AE81FF;">drop_and_free</span>:
        reqsk_free(req);
<span style="color: #AE81FF;">drop</span>:
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge7899c8" class="outline-4">
<h4 id="orge7899c8"><span class="section-number-4">6.2.4.</span> 从SKB的控制块中获取IP选项：tcp_v4_save_options()</h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
tcp_v4_save_options()根据IP选项的长度分配ip_options结构的实例，之后调用ip_option_echo()从SKB的控制块中获取IP选项到该实例中。
</p>
</div>
</div>

<div id="outline-container-org411ec02" class="outline-4">
<h4 id="org411ec02"><span class="section-number-4">6.2.5.</span> 将连接请求块保存到父传输控制块的散列表中</h4>
<div class="outline-text-4" id="text-6-2-5">
<p>
inet_csk_reqsk_queue_hash_add()函数用来将连接请求块保存到父传输控制块的散列表中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">inet_csk_reqsk_queue_hash_add</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span>,
                                   <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">timeout</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">listen_sock</span> *<span style="color: #FD971F;">lopt</span> = icsk-&gt;icsk_accept_queue.listen_opt;
        <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">h</span> = inet_synq_hash(inet_rsk(req)-&gt;rmt_addr, inet_rsk(req)-&gt;rmt_port,
                                     lopt-&gt;hash_rnd, lopt-&gt;nr_table_entries);

        reqsk_queue_hash_req(&amp;icsk-&gt;icsk_accept_queue, h, req, timeout);
        inet_csk_reqsk_queue_added(sk, timeout);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org6fbefd5" class="outline-4">
<h4 id="org6fbefd5"><span class="section-number-4">6.2.6.</span> 更新该传输控制块上已请求连接块的数量</h4>
<div class="outline-text-4" id="text-6-2-6">
<p>
inet_csk_reqsk_queue_added()
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">inet_csk_reqsk_queue_added</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
                                              <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">timeout</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#39318;&#27425;&#25509;&#25910;&#35831;&#27714;&#36830;&#25509;&#65292;&#21017;&#38656;&#35201;&#22797;&#20301;&#24182;&#21551;&#21160;&#20445;&#27963;&#23450;&#26102;&#22120;</span>
        <span style="color: #F92672;">if</span> (reqsk_queue_added(&amp;inet_csk(sk)-&gt;icsk_accept_queue) == 0)
                inet_csk_reset_keepalive_timer(sk, timeout);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org82fefe1" class="outline-4">
<h4 id="org82fefe1"><span class="section-number-4">6.2.7.</span> 函数调用关系</h4>
<div class="outline-text-4" id="text-6-2-7">
<div class="org-src-container">
<pre class="src src-fundamentation">tcp_v4_do_rcv()
        tcp_rcv_state_process
                icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb)  ==&gt; tcp_v4_conn_request()
                        tcp_v4_save_options
                        tcp_v4_send_synack
                                tcp_make_synack
                                ip_build_and_send_pkt
                        inet_csk_reqsk_queue_hash_add
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0c32109" class="outline-3">
<h3 id="org0c32109"><span class="section-number-3">6.3.</span> 第二次握手：发送SYN+ACK段</h3>
<div class="outline-text-3" id="text-6-3">
</div>
<div id="outline-container-org6af15cf" class="outline-4">
<h4 id="org6af15cf"><span class="section-number-4">6.3.1.</span> 构造并发送SYN+ACK段</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
tcp_v4_send_synack()用来为服务端构造回应客户端连接请求SYN段的SYN+ACK段，并将其封装在IP数据包中发送给客户端。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Send a SYN-ACK after having received an ACK.</span>
<span style="color: #75715E;"> *      This still operates on a request_sock only, not on a big</span>
<span style="color: #75715E;"> *      socket.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_v4_send_synack</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span>,
                              <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dst_entry</span> *<span style="color: #FD971F;">dst</span>)
{
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_request_sock</span> *<span style="color: #FD971F;">ireq</span> = inet_rsk(req);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span> = -1;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> * <span style="color: #FD971F;">skb</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26597;&#25214;&#36335;&#30001;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>dst &amp;&amp; (dst = inet_csk_route_req(sk, req)) == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#26597;&#25214;&#30340;&#36335;&#30001;&#12289;&#20256;&#36755;&#25511;&#21046;&#22359;&#12289;&#36830;&#25509;&#35831;&#27714;&#22359;&#30340;&#20449;&#24687;&#26469;&#26500;&#24314;SYN+ACK&#27573;</span>
        skb = tcp_make_synack(sk, dst, req);

        <span style="color: #F92672;">if</span> (skb) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span> = skb-&gt;h.th;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29983;&#25104;tcp&#26657;&#39564;&#30721;</span>
                th-&gt;check = tcp_v4_check(th, skb-&gt;len,
                                         ireq-&gt;loc_addr,
                                         ireq-&gt;rmt_addr,
                                         csum_partial((<span style="color: #66D9EF;">char</span> *)th, skb-&gt;len,
                                                      skb-&gt;csum));
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29983;&#25104;IP&#25968;&#25454;&#25253;&#24182;&#21457;&#36865;</span>
                err = ip_build_and_send_pkt(skb, sk, ireq-&gt;loc_addr,
                                            ireq-&gt;rmt_addr,
                                            ireq-&gt;opt);
                err = net_xmit_eval(err);
        }

<span style="color: #AE81FF;">out</span>:
        dst_release(dst);
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3b05753" class="outline-4">
<h4 id="org3b05753"><span class="section-number-4">6.3.2.</span> 获取路由入口</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
inet_csk_route_req()用来根据连接请求块和服务端传输控制块中的信息（输出网络设备、源目的地址、源目的端口等），为SYN+ACK段查询路由入口。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dst_entry</span>* <span style="color: #A6E22E;">inet_csk_route_req</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
                                     <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span>)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36830;&#25509;&#35831;&#27714;&#22359;</span>
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span>;
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_request_sock</span> *<span style="color: #FD971F;">ireq</span> = inet_rsk(req);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span> *<span style="color: #FD971F;">opt</span> = inet_rsk(req)-&gt;opt;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23450;&#20041;&#24182;&#21021;&#22987;&#21270;&#29992;&#20110;&#36335;&#30001;&#26597;&#35810;&#30340;&#26465;&#20214;&#32452;&#21512;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">flowi</span> <span style="color: #FD971F;">fl</span> = { .oif = sk-&gt;sk_bound_dev_if,
                            .nl_u = { .ip4_u =
                                      { .daddr = ((opt &amp;&amp; opt-&gt;srr) ?
                                                  opt-&gt;faddr :
                                                  ireq-&gt;rmt_addr),
                                        .saddr = ireq-&gt;loc_addr,
                                        .tos = RT_CONN_FLAGS(sk) } },
                            .proto = sk-&gt;sk_protocol,
                            .uli_u = { .ports =
                                       { .sport = inet_sk(sk)-&gt;sport,
                                         .dport = ireq-&gt;rmt_port } } };

        security_req_classify_flow(req, &amp;fl);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#35810;&#36335;&#30001;&#32531;&#23384;&#39033;</span>
        <span style="color: #F92672;">if</span> (ip_route_output_flow(&amp;rt, &amp;fl, sk, 0)) {
                IP_INC_STATS_BH(IPSTATS_MIB_OUTNOROUTES);
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;IP&#39318;&#37096;&#20013;&#21253;&#21547;&#20005;&#26684;&#28304;&#36335;&#30001;&#36873;&#39033;&#65292;&#24182;&#19988;&#36873;&#39033;&#20013;&#33719;&#21462;&#30340;&#19979;&#19968;&#36339;&#21644;&#26597;&#35810;&#30340;&#36335;&#30001;&#19981;&#21305;&#37197;&#65292;&#21017;&#36335;&#30001;&#22833;&#36133;</span>
        <span style="color: #F92672;">if</span> (opt &amp;&amp; opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_dst != rt-&gt;rt_gateway) {
                ip_rt_put(rt);
                IP_INC_STATS_BH(IPSTATS_MIB_OUTNOROUTES);
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
        }
        <span style="color: #F92672;">return</span> &amp;rt-&gt;u.dst;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgd08d6b8" class="outline-4">
<h4 id="orgd08d6b8"><span class="section-number-4">6.3.3.</span> 构造SYN+ACK段</h4>
<div class="outline-text-4" id="text-6-3-3">
<p>
tcp_make_synack()用来构造一个SYN+ACK段，并初始化TCP首部及SKB中的各字段，例如MSS、SACK、窗口扩大因子、时间戳等。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * Prepare a SYN-ACK.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> * <span style="color: #A6E22E;">tcp_make_synack</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dst_entry</span> *<span style="color: #FD971F;">dst</span>,
                                 <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_request_sock</span> *<span style="color: #FD971F;">ireq</span> = inet_rsk(req);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">tcp_header_size</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_md5sig_key</span> *<span style="color: #FD971F;">md5</span>;
        <span style="color: #66D9EF;">__u8</span> *<span style="color: #FD971F;">md5_hash_location</span>;
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20026;SYN+ACK&#20998;&#37197;SKB&#65288;&#24378;&#21046;&#20998;&#37197;&#65289;</span>
        skb = sock_wmalloc(sk, MAX_TCP_HEADER + 15, 1, GFP_ATOMIC);
        <span style="color: #F92672;">if</span> (skb == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20026;MAC&#23618;&#12289;IP&#23618;&#12289;TCP&#39318;&#37096;&#39044;&#30041;&#31354;&#38388;</span><span style="color: #75715E;"> */</span>
        skb_reserve(skb, MAX_TCP_HEADER);

        skb-&gt;dst = dst_clone(dst);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#25509;&#25910;&#30340;SYN&#27573;&#20013;&#30340;&#36873;&#39033;&#35745;&#31639;SYN+ACK&#27573;&#30340;TCP&#39318;&#37096;&#38271;&#24230;</span>
        tcp_header_size = (<span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>) + TCPOLEN_MSS +
                           (ireq-&gt;tstamp_ok ? TCPOLEN_TSTAMP_ALIGNED : 0) +
                           (ireq-&gt;wscale_ok ? TCPOLEN_WSCALE_ALIGNED : 0) +
                           <span style="color: #75715E;">/* </span><span style="color: #75715E;">SACK_PERM is in the place of NOP NOP of TS</span><span style="color: #75715E;"> */</span>
                           ((ireq-&gt;sack_ok &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>ireq-&gt;tstamp_ok) ? TCPOLEN_SACKPERM_ALIGNED : 0));

<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Are we doing MD5 on this segment? If so - make room for it</span><span style="color: #75715E;"> */</span>
        md5 = tcp_rsk(req)-&gt;af_specific-&gt;md5_lookup(sk, req);
        <span style="color: #F92672;">if</span> (md5)
                tcp_header_size += TCPOLEN_MD5SIG_ALIGNED;
<span style="color: #F92672;">#endif</span>
        skb-&gt;h.th = th = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *) skb_push(skb, tcp_header_size);

        memset(th, 0, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>));
        th-&gt;syn = 1;
        th-&gt;ack = 1;
        TCP_ECN_make_synack(req, th);
        th-&gt;source = inet_sk(sk)-&gt;sport;
        th-&gt;dest = ireq-&gt;rmt_port;
        TCP_SKB_CB(skb)-&gt;seq = tcp_rsk(req)-&gt;snt_isn;
        TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + 1;
        TCP_SKB_CB(skb)-&gt;sacked = 0;
        skb_shinfo(skb)-&gt;gso_segs = 1;
        skb_shinfo(skb)-&gt;gso_size = 0;
        skb_shinfo(skb)-&gt;gso_type = 0;
        th-&gt;seq = htonl(TCP_SKB_CB(skb)-&gt;seq);
        th-&gt;ack_seq = htonl(tcp_rsk(req)-&gt;rcv_isn + 1);
        <span style="color: #F92672;">if</span> (req-&gt;rcv_wnd == 0) { <span style="color: #75715E;">/* </span><span style="color: #75715E;">ignored for retransmitted syns</span><span style="color: #75715E;"> */</span>
                <span style="color: #66D9EF;">__u8</span> <span style="color: #FD971F;">rcv_wscale</span>;
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Set this up on the first call only</span><span style="color: #75715E;"> */</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26681;&#25454;&#36335;&#30001;&#39033;&#20013;&#33719;&#21462;&#30340;&#26368;&#22823;&#36890;&#21578;&#31383;&#21475;&#65292;&#21021;&#22987;&#21270;&#35831;&#27714;&#22359;&#20013;&#30340;&#26368;&#22823;&#36890;&#21578;&#31383;&#21475;</span><span style="color: #75715E;"> */</span>
                req-&gt;window_clamp = tp-&gt;window_clamp ? : dst_metric(dst, RTAX_WINDOW);
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35774;&#32622;&#25509;&#25910;&#31383;&#21475;&#12289;&#26368;&#22823;&#36890;&#21578;&#31383;&#21475;&#12289;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#31561;</span><span style="color: #75715E;"> */</span>
                tcp_select_initial_window(tcp_full_space(sk),
                        dst_metric(dst, RTAX_ADVMSS) - (ireq-&gt;tstamp_ok ? TCPOLEN_TSTAMP_ALIGNED : 0),
                        &amp;req-&gt;rcv_wnd,
                        &amp;req-&gt;window_clamp,
                        ireq-&gt;wscale_ok,
                        &amp;rcv_wscale);
                ireq-&gt;rcv_wscale = rcv_wscale;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">RFC1323: The window in SYN &amp; SYN/ACK segments is never scaled.</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;SYN+ACK&#27573;&#30340;&#31383;&#21475;&#22823;&#23567;</span>
        th-&gt;window = htons(req-&gt;rcv_wnd);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;SKB&#30340;TCP&#25511;&#21046;&#22359;&#30340;&#21457;&#36865;&#26102;&#38388;</span>
        TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29983;&#25104;SYN+ACK&#27573;&#30340;&#36873;&#39033;</span>
        tcp_syn_build_options((<span style="color: #66D9EF;">__be32</span> *)(th + 1), dst_metric(dst, RTAX_ADVMSS), ireq-&gt;tstamp_ok,
                              ireq-&gt;sack_ok, ireq-&gt;wscale_ok, ireq-&gt;rcv_wscale,
                              TCP_SKB_CB(skb)-&gt;when,
                              req-&gt;ts_recent,
                              (
<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
                               md5 ? &amp;md5_hash_location :
<span style="color: #F92672;">#endif</span>
                               <span style="color: #AE81FF;">NULL</span>)
                              );

        skb-&gt;csum = 0;
        th-&gt;doff = (tcp_header_size &gt;&gt; 2); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;TCP&#39318;&#37096;&#38271;&#24230;</span>
        TCP_INC_STATS(TCP_MIB_OUTSEGS);

<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Okay, we have all we need - do the md5 hash if needed</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (md5) {
                tp-&gt;af_specific-&gt;calc_md5_hash(md5_hash_location,
                                               md5,
                                               <span style="color: #AE81FF;">NULL</span>, dst, req,
                                               skb-&gt;h.th, sk-&gt;sk_protocol,
                                               skb-&gt;len);
        }
<span style="color: #F92672;">#endif</span>

        <span style="color: #F92672;">return</span> skb;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf8c4867" class="outline-3">
<h3 id="orgf8c4867"><span class="section-number-3">6.4.</span> 第三次握手：接收ACK段</h3>
<div class="outline-text-3" id="text-6-4">
<p>
服务端收到SYN段后，会创建一个连接请求块，同时发送SYN+ACK段给客户端作为回应，然后启动建立连接定时器，等待客户端最后一次握手的ACK段。
</p>
</div>

<div id="outline-container-org21ca89f" class="outline-4">
<h4 id="org21ca89f"><span class="section-number-4">6.4.1.</span> LISTEN状态处理TCP段</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
LISTEN状态下，已建立半连接的连接请求块，接收到第三次握手的ACK段后的处理过程：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_v4_do_rcv</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_state == TCP_LISTEN) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">nsk</span> = tcp_v4_hnd_req(sk, skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;&#19977;&#27425;&#25569;&#25163;&#30340;&#26368;&#21518;&#19968;&#27425;ACK&#27573;</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>nsk)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;

                <span style="color: #F92672;">if</span> (nsk != sk) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#36820;&#22238;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#19981;&#26159;&#20390;&#21548;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#21017;&#35828;&#26126;&#36830;&#25509;&#24314;&#31435;&#25104;&#21151;</span>
                        <span style="color: #F92672;">if</span> (tcp_child_process(sk, nsk, skb)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#22914;&#26524;&#22833;&#36133;&#65292;&#21017;&#21457;&#36865;RST&#27573;&#12290;</span>
                                rsk = nsk;
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">reset</span>;
                        }
                        <span style="color: #F92672;">return</span> 0;
                }
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org03886b3" class="outline-4">
<h4 id="org03886b3"><span class="section-number-4">6.4.2.</span> 处理第三次握手的ACK段</h4>
<div class="outline-text-4" id="text-6-4-2">
<p>
tcp_v4_hnd_req()用来处理三次握手的最后一个ACK段，处理过程如下：
</p>
<ul class="org-ul">
<li>在请求连接散列表中查找对应的连接请求块。</li>
<li>如果找到，则根据TCP段标志，ACK或RST或SYN，作相应的处理，如果是ACK,则完成连接的建立。</li>
<li>如果没有找到，则需要在ehash散列表中查找对应的传输控制块，并作相应的处理。如果还找不到，则由tcp_rcv_state_process()处理。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #A6E22E;">tcp_v4_hnd_req</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span> = skb-&gt;h.th;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span> = skb-&gt;nh.iph;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">nsk</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> **<span style="color: #FD971F;">prev</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26597;&#25214;&#36830;&#25509;&#35831;&#27714;&#22359;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span> = inet_csk_search_req(sk, &amp;prev, th-&gt;source,
                                                       iph-&gt;saddr, iph-&gt;daddr);
        <span style="color: #F92672;">if</span> (req) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25214;&#21040;&#65292;&#21017;&#35828;&#26126;&#21069;&#20004;&#27425;&#25569;&#25163;&#23436;&#25104;&#65292;&#22788;&#29702;&#26368;&#21518;&#19968;&#27425;&#30340;ACK&#27573;</span>
                <span style="color: #F92672;">return</span> tcp_check_req(sk, skb, req, prev);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#19981;&#22312;&#36830;&#25509;&#35831;&#27714;&#25955;&#21015;&#34920;&#20013;&#65292;&#21017;&#21487;&#33021;&#22312;ehash&#25955;&#21015;&#34920;&#65292;&#32487;&#32493;&#26597;&#25214;</span>
        nsk = inet_lookup_established(&amp;tcp_hashinfo, skb-&gt;nh.iph-&gt;saddr,
                                      th-&gt;source, skb-&gt;nh.iph-&gt;daddr,
                                      th-&gt;dest, inet_iif(skb));

        <span style="color: #F92672;">if</span> (nsk) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#25214;&#25104;&#21151;&#65292;&#19988;&#19981;&#22788;&#20110;TIME_WAIT&#29366;&#24577;&#65292;&#21017;&#36820;&#22238;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
                <span style="color: #F92672;">if</span> (nsk-&gt;sk_state != TCP_TIME_WAIT) {
                        bh_lock_sock(nsk);
                        <span style="color: #F92672;">return</span> nsk;
                }
                inet_twsk_put(inet_twsk(nsk));
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
        }

<span style="color: #F92672;">#ifdef</span> CONFIG_SYN_COOKIES
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>th-&gt;rst &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>th-&gt;syn &amp;&amp; th-&gt;ack)  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#21551;&#29992;&#20102;syncookies&#65292;&#21017;&#26816;&#27979;&#26159;&#21542;&#26159;&#36890;&#36807;syncookies&#25569;&#25163;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#23558;&#23458;&#25143;&#31471;&#30340;ACK&#24207;&#21015;&#21495;&#20943;1&#24471;&#21040;cookie&#25351;&#65292;&#24182;&#26681;&#25454;&#35201;&#32032;&#36827;&#34892;hash&#36816;&#31639;&#21518;&#21644;cookie&#20540;&#27604;&#36739;</span><span style="color: #75715E;"> */</span>
                sk = cookie_v4_check(sk, skb, &amp;(IPCB(skb)-&gt;opt));
<span style="color: #F92672;">#endif</span>
        <span style="color: #F92672;">return</span> sk;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org510329e" class="outline-4">
<h4 id="org510329e"><span class="section-number-4">6.4.3.</span> 在SYN_RECV状态下处理TCP段</h4>
<div class="outline-text-4" id="text-6-4-3">
<p>
在SYN_RECV状态下的传输控制块（连接请求块）用 tcp_check_req()来处理接收到的TCP段。处理过程如下：
</p>
<ul class="org-ul">
<li>解析并获取段中的TCP选项。</li>
<li>校验TCP序号。</li>
<li>如果是SYN段，则作为SYN段在处理一次。</li>
<li>检测ACK段确认序号是否有效，无效则立即返回不做处理。</li>
<li>检测ACK段序号是否有效，无效则丢弃。</li>
<li>如果是RST段或者新的SYN段，则向客户端发送RST段进行复位。</li>
<li>校验通过，创建对应的子传输控制块。</li>
<li>将连接请求块插入已完成连接的队列中，等待用户进程的accept()调用。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Process an incoming packet for SYN_RECV sockets represented</span>
<span style="color: #75715E;"> *      as a request_sock.</span>
<span style="color: #75715E;"> */</span>

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #A6E22E;">tcp_check_req</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>,
                           <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span>,
                           <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> **<span style="color: #FD971F;">prev</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span> = skb-&gt;h.th;
        <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">flg</span> = tcp_flag_word(th) &amp; (TCP_FLAG_RST|TCP_FLAG_SYN|TCP_FLAG_ACK);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">paws_reject</span> = 0;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_options_received</span> <span style="color: #FD971F;">tmp_opt</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">child</span>;

        tmp_opt.saw_tstamp = 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;TCP&#39318;&#37096;&#38271;&#24230;&#22823;&#20110;&#19981;&#24102;TCP&#36873;&#39033;&#30340;&#39318;&#37096;&#38271;&#24230;&#65292;&#21017;&#35828;&#26126;&#39318;&#37096;&#20013;&#26377;TCP&#36873;&#39033;</span>
        <span style="color: #F92672;">if</span> (th-&gt;doff &gt; (<span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>)&gt;&gt;2)) {
                <span style="color: #A6E22E;">tcp_parse_options</span>(skb, &amp;tmp_opt, 0); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35299;&#26512;TCP&#36873;&#39033;</span>

                <span style="color: #F92672;">if</span> (tmp_opt.saw_tstamp) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36873;&#39033;&#20013;&#24102;&#26377;&#26102;&#38388;&#25139;&#65292;&#21017;&#35760;&#24405;&#35813;&#26102;&#38388;&#25139;&#21450;&#20854;&#26377;&#25928;&#26102;&#38388;</span>
                        tmp_opt.ts_recent = req-&gt;ts_recent;
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We do not store true stamp, but it is not required,</span>
<span style="color: #75715E;">                         * it can be estimated (approximately)</span>
<span style="color: #75715E;">                         * from another data.</span>
<span style="color: #75715E;">                         */</span>
                        tmp_opt.ts_recent_stamp = xtime.tv_sec - ((TCP_TIMEOUT_INIT/HZ)&lt;&lt;req-&gt;retrans);
                        paws_reject = tcp_paws_check(&amp;tmp_opt, th-&gt;rst); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;TCP&#24207;&#21495;&#26159;&#21542;&#26377;&#25928;</span>
                }
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26816;&#27979;&#26159;&#21542;&#26159;&#23458;&#25143;&#31471;&#37325;&#20256;&#30340;SYN&#27573;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (TCP_SKB_CB(skb)-&gt;seq == tcp_rsk(req)-&gt;rcv_isn &amp;&amp;
            flg == TCP_FLAG_SYN &amp;&amp;
            <span style="color: #E6DB74; font-weight: bold;">!</span>paws_reject) {
                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                 * RFC793 draws (Incorrectly! It was fixed in RFC1122)</span>
<span style="color: #75715E;">                 * this case on figure 6 and figure 8, but formal</span>
<span style="color: #75715E;">                 * protocol description says NOTHING.</span>
<span style="color: #75715E;">                 * To be more exact, it says that we should send ACK,</span>
<span style="color: #75715E;">                 * because this segment (at least, if it has no data)</span>
<span style="color: #75715E;">                 * is out of window.</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 *  CONCLUSION: RFC793 (even with RFC1122) DOES NOT</span>
<span style="color: #75715E;">                 *  describe SYN-RECV state. All the description</span>
<span style="color: #75715E;">                 *  is wrong, we cannot believe to it and should</span>
<span style="color: #75715E;">                 *  rely only on common sense and implementation</span>
<span style="color: #75715E;">                 *  experience.</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 * Enforce "SYN-ACK" according to figure 8, figure 6</span>
<span style="color: #75715E;">                 * of RFC793, fixed by RFC1122.</span>
<span style="color: #75715E;">                 */</span>
                req-&gt;rsk_ops-&gt;rtx_syn_ack(sk, req, <span style="color: #AE81FF;">NULL</span>); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;tcp_v4_send_synack()&#21457;&#36865;SYN+ACK</span>
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Further reproduces section "SEGMENT ARRIVES"</span>
<span style="color: #75715E;">           for state SYN-RECEIVED of RFC793.</span>
<span style="color: #75715E;">           It is broken, however, it does not work only</span>
<span style="color: #75715E;">           when SYNs are crossed.</span>

<span style="color: #75715E;">           You would think that SYN crossing is impossible here, since</span>
<span style="color: #75715E;">           we should have a SYN_SENT socket (from connect()) on our end,</span>
<span style="color: #75715E;">           but this is not true if the crossed SYNs were sent to both</span>
<span style="color: #75715E;">           ends by a malicious third party.  We must defend against this,</span>
<span style="color: #75715E;">           and to do that we first verify the ACK (as per RFC793, page</span>
<span style="color: #75715E;">           36) and reset if it is invalid.  Is this a true full defense?</span>
<span style="color: #75715E;">           To convince ourselves, let us consider a way in which the ACK</span>
<span style="color: #75715E;">           test can still pass in this 'malicious crossed SYNs' case.</span>
<span style="color: #75715E;">           Malicious sender sends identical SYNs (and thus identical sequence</span>
<span style="color: #75715E;">           numbers) to both A and B:</span>

<span style="color: #75715E;">                A: gets SYN, seq=7</span>
<span style="color: #75715E;">                B: gets SYN, seq=7</span>

<span style="color: #75715E;">           By our good fortune, both A and B select the same initial</span>
<span style="color: #75715E;">           send sequence number of seven :-)</span>

<span style="color: #75715E;">                A: sends SYN|ACK, seq=7, ack_seq=8</span>
<span style="color: #75715E;">                B: sends SYN|ACK, seq=7, ack_seq=8</span>

<span style="color: #75715E;">           So we are now A eating this SYN|ACK, ACK test passes.  So</span>
<span style="color: #75715E;">           does sequence test, SYN is truncated, and thus we consider</span>
<span style="color: #75715E;">           it a bare ACK.</span>

<span style="color: #75715E;">           If icsk-&gt;icsk_accept_queue.rskq_defer_accept, we silently drop this</span>
<span style="color: #75715E;">           bare ACK.  Otherwise, we create an established connection.  Both</span>
<span style="color: #75715E;">           ends (listening sockets) accept the new incoming connection and try</span>
<span style="color: #75715E;">           to talk to each other. 8-)</span>

<span style="color: #75715E;">           Note: This case is both harmless, and rare.  Possibility is about the</span>
<span style="color: #75715E;">           same as us discovering intelligent life on another plant tomorrow.</span>

<span style="color: #75715E;">           But generally, we should (RFC lies!) to accept ACK</span>
<span style="color: #75715E;">           from SYNACK both here and in tcp_rcv_state_process().</span>
<span style="color: #75715E;">           tcp_rcv_state_process() does not, hence, we do not too.</span>

<span style="color: #75715E;">           Note that the case is absolutely generic:</span>
<span style="color: #75715E;">           we cannot optimize anything here without</span>
<span style="color: #75715E;">           violating protocol. All the checks must be made</span>
<span style="color: #75715E;">           before attempt to create socket.</span>
<span style="color: #75715E;">         */</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">RFC793 page 36: "If the connection is in any non-synchronized state ...</span>
<span style="color: #75715E;">         *                  and the incoming segment acknowledges something not yet</span>
<span style="color: #75715E;">         *                  sent (the segment carries an unacceptable ACK) ...</span>
<span style="color: #75715E;">         *                  a reset is sent."</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         * Invalid ACK: reset will be sent by listening socket</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#22914;&#26524;&#25509;&#25910;&#30340;ACK&#27573;&#30340;&#30830;&#35748;&#24207;&#21495;&#19982;SYN+ACK&#27573;&#30340;&#24207;&#21495;&#19981;&#21305;&#37197;&#65292;&#21017;&#19981;&#22788;&#29702;&#65292;&#24182;&#36820;&#22238;&#29238;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        <span style="color: #F92672;">if</span> ((flg &amp; TCP_FLAG_ACK) &amp;&amp;
            (TCP_SKB_CB(skb)-&gt;ack_seq != tcp_rsk(req)-&gt;snt_isn + 1))
                <span style="color: #F92672;">return</span> sk;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Also, it would be not so bad idea to check rcv_tsecr, which</span>
<span style="color: #75715E;">         * is essentially ACK extension and too early or too late values</span>
<span style="color: #75715E;">         * should cause reset in unsynchronized states.</span>
<span style="color: #75715E;">         */</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">RFC793: "first check sequence number".</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;ACK&#27573;&#24207;&#21495;&#26080;&#25928;&#25110;&#32773;&#24207;&#21495;&#19981;&#22312;&#25509;&#25910;&#31383;&#21475;&#20869;&#65292;&#21017;&#20002;&#24323;&#25509;&#25910;&#30340;&#27573;&#65292;&#36820;&#22238;NULL</span>
        <span style="color: #F92672;">if</span> (paws_reject || <span style="color: #E6DB74; font-weight: bold;">!</span>tcp_in_window(TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq,
                                          tcp_rsk(req)-&gt;rcv_isn + 1, tcp_rsk(req)-&gt;rcv_isn + 1 + req-&gt;rcv_wnd)) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Out of window: send ACK and drop.</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(flg &amp; TCP_FLAG_RST))  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;RST,&#21017;&#26080;&#38656;&#21457;&#36865;ACK,&#21542;&#21017;&#32473;&#23545;&#27573;&#21457;&#36865;ACK&#27573;&#12290;</span>
                        req-&gt;rsk_ops-&gt;send_ack(skb, req);
                <span style="color: #F92672;">if</span> (paws_reject)
                        NET_INC_STATS_BH(LINUX_MIB_PAWSESTABREJECTED);
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">In sequence, PAWS is OK.</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">ACK&#27573;&#24207;&#21495;&#27491;&#24120;&#65292;&#21017;&#38656;&#35201;&#20445;&#23384;TCP&#27573;&#20013;&#30340;&#26102;&#38388;&#25139;</span>
        <span style="color: #F92672;">if</span> (tmp_opt.saw_tstamp &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>after(TCP_SKB_CB(skb)-&gt;seq, tcp_rsk(req)-&gt;rcv_isn + 1))
                        req-&gt;ts_recent = tmp_opt.rcv_tsval;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;ACK&#27573;&#30340;&#24207;&#21495;&#21644;&#20043;&#21069;&#30340;SYN&#27573;&#30456;&#31561;&#65292;?????????????</span>
                <span style="color: #F92672;">if</span> (TCP_SKB_CB(skb)-&gt;seq == tcp_rsk(req)-&gt;rcv_isn) {
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Truncate SYN, it is out of window starting</span>
<span style="color: #75715E;">                           at tcp_rsk(req)-&gt;rcv_isn + 1.</span><span style="color: #75715E;"> */</span>
                        flg &amp;= ~TCP_FLAG_SYN;
                }

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">RFC793: "second check the RST bit" and</span>
<span style="color: #75715E;">                 *         "fourth, check the SYN bit"</span>
<span style="color: #75715E;">                 *///</span><span style="color: #75715E;">&#22914;&#26524;&#24102;&#26377;RST&#25110;&#32773;SYN,&#21017;&#38656;&#35201;&#22797;&#20301;&#35813;&#26410;&#23436;&#25104;&#30340;&#36830;&#25509;&#12290;</span>
                <span style="color: #F92672;">if</span> (flg &amp; (TCP_FLAG_RST|TCP_FLAG_SYN)) {
                        TCP_INC_STATS_BH(TCP_MIB_ATTEMPTFAILS);
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">embryonic_reset</span>;
                }

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">ACK sequence verified above, just make sure ACK is</span>
<span style="color: #75715E;">                 * set.  If ACK not set, just silently drop the packet.</span>
<span style="color: #75715E;">                 *///</span><span style="color: #75715E;">&#27491;&#24120;&#26469;&#35828;&#65292;&#27573;&#20013;&#24212;&#24403;&#21253;&#21547;ACK</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(flg &amp; TCP_FLAG_ACK))
                        <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#35774;&#32622;&#20102;TCP_DEFER_ACCEPT&#65292;&#21017;&#26080;&#38656;&#25509;&#25910;ACK&#27573;&#65292;&#20004;&#27425;&#25569;&#25163;&#21518;&#30452;&#25509;&#31561;&#24453;&#24102;&#26377;&#36733;&#33655;&#30340;&#25968;&#25454;&#21253;&#65292;</span>
<span style="color: #75715E;">                &#22240;&#27492;&#21487;&#20197;&#30452;&#25509;&#20002;&#24323;ACK&#27573;&#12290;</span><span style="color: #75715E;">*/</span>
                <span style="color: #F92672;">if</span> (inet_csk(sk)-&gt;icsk_accept_queue.rskq_defer_accept &amp;&amp;
                    TCP_SKB_CB(skb)-&gt;end_seq == tcp_rsk(req)-&gt;rcv_isn + 1) {
                        inet_rsk(req)-&gt;acked = 1;
                        <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
                }

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">OK, ACK is valid, create big socket and</span>
<span style="color: #75715E;">                 * feed this segment to it. It will repeat all</span>
<span style="color: #75715E;">                 * the tests. THIS SEGMENT MUST MOVE SOCKET TO</span>
<span style="color: #75715E;">                 * ESTABLISHED STATE. If it will be dropped after</span>
<span style="color: #75715E;">                 * socket is created, wait for troubles.</span>
<span style="color: #75715E;">                 *///</span><span style="color: #75715E;">&#27492;&#26102;&#65292;ACK&#27573;&#26377;&#25928;&#65292;&#35843;&#29992;tcp_v4_syn_recv_sock()&#21019;&#24314;&#23545;&#24212;&#30340;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
                child = inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock(sk, skb,
                                                                 req, <span style="color: #AE81FF;">NULL</span>);
                <span style="color: #F92672;">if</span> (child == <span style="color: #AE81FF;">NULL</span>)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">listen_overflow</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
                <span style="color: #F92672;">else</span> {
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Copy over the MD5 key from the original socket</span><span style="color: #75715E;"> */</span>
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_md5sig_key</span> *<span style="color: #FD971F;">key</span>;
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
                        key = tp-&gt;af_specific-&gt;md5_lookup(sk, child);
                        <span style="color: #F92672;">if</span> (key != <span style="color: #AE81FF;">NULL</span>) {
                                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                                 * We're using one, so create a matching key on the</span>
<span style="color: #75715E;">                                 * newsk structure. If we fail to get memory then we</span>
<span style="color: #75715E;">                                 * end up not copying the key across. Shucks.</span>
<span style="color: #75715E;">                                 */</span>
                                <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">newkey</span> = kmemdup(key-&gt;key, key-&gt;keylen,
                                                       GFP_ATOMIC);
                                <span style="color: #F92672;">if</span> (newkey) {
                                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tcp_alloc_md5sig_pool())
                                                BUG();
                                        tp-&gt;af_specific-&gt;md5_add(child, child,
                                                                 newkey,
                                                                 key-&gt;keylen);
                                }
                        }
                }
<span style="color: #F92672;">#endif</span>

                inet_csk_reqsk_queue_unlink(sk, req, prev);
                inet_csk_reqsk_queue_removed(sk, req);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#21018;&#24314;&#31435;&#36830;&#25509;&#30340;&#36830;&#25509;&#35831;&#27714;&#22359;&#25554;&#20837;&#21040;&#24050;&#23436;&#25104;&#36830;&#25509;&#30340;&#38431;&#21015;&#20013;</span>
                inet_csk_reqsk_queue_add(sk, req, child);
                <span style="color: #F92672;">return</span> child; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36820;&#22238;&#24050;&#32463;&#21019;&#24314;&#30340;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;</span>

        <span style="color: #AE81FF;">listen_overflow</span>:  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#30001;&#20110;&#26381;&#21153;&#22120;&#32321;&#24537;&#25110;&#20854;&#20182;&#21407;&#22240;&#23548;&#33268;&#36830;&#25509;&#24314;&#31435;&#22833;&#36133;</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sysctl_tcp_abort_on_overflow) { <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#24182;&#19988;&#27809;&#26377;&#21551;&#29992;tcp_abort_on_overflow,&#21017;&#35774;&#32622;&#36830;&#25509;&#35831;&#27714;&#22359;&#20013;&#30340;acked&#26631;&#35782;&#65292;</span>
<span style="color: #75715E;">                &#34920;&#31034;&#24050;&#32463;&#25509;&#25910;&#21040;&#19977;&#27425;&#25569;&#25163;&#30340;ACK&#27573;&#65292;&#36830;&#25509;&#23450;&#26102;&#22120;&#21487;&#20197;&#26681;&#25454;&#35813;&#26631;&#24535;&#37325;&#26032;&#32473;&#23458;&#25143;&#31471;&#21457;&#36865;SYN+ACK,&#20877;&#27425;&#23581;&#35797;&#24314;&#31435;&#36830;&#25509;</span><span style="color: #75715E;">*/</span>
                        inet_rsk(req)-&gt;acked = 1;
                        <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
                }

        <span style="color: #AE81FF;">embryonic_reset</span>:
                NET_INC_STATS_BH(LINUX_MIB_EMBRYONICRSTS);
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(flg &amp; TCP_FLAG_RST))
                        req-&gt;rsk_ops-&gt;send_reset(sk, skb);

                inet_csk_reqsk_queue_drop(sk, req, prev);
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd86a24b" class="outline-4">
<h4 id="orgd86a24b"><span class="section-number-4">6.4.4.</span> 为新连接创建传输控制块</h4>
<div class="outline-text-4" id="text-6-4-4">
<p>
完成三次握手后，为新连接创建一个传输控制块，并将其初始化。在创建传输控制块之前，需要检测已经建立连接但没有被accept的子传输控制块是否达到上限，并为子传输控制块获取路由入口。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * The three way handshake has completed - we got a valid synack -</span>
<span style="color: #75715E;"> * now create the new socket.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #A6E22E;">tcp_v4_syn_recv_sock</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>,
                                  <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">request_sock</span> *<span style="color: #FD971F;">req</span>,
                                  <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dst_entry</span> *<span style="color: #FD971F;">dst</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_request_sock</span> *<span style="color: #FD971F;">ireq</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">newinet</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">newtp</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">newsk</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_md5sig_key</span> *<span style="color: #FD971F;">key</span>;
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">accept&#38431;&#21015;&#24050;&#28385;</span>
        <span style="color: #F92672;">if</span> (sk_acceptq_is_full(sk))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">exit_overflow</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>dst &amp;&amp; (dst = inet_csk_route_req(sk, req)) == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">exit</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21019;&#24314;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#24182;&#36827;&#34892;&#37096;&#20998;&#21021;&#22987;&#21270;</span>
        newsk = tcp_create_openreq_child(sk, req, skb);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>newsk)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">exit</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;GSO&#31867;&#22411;</span>
        newsk-&gt;sk_gso_type = SKB_GSO_TCPV4;
        sk_setup_caps(newsk, dst); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30830;&#23450;&#36755;&#20986;&#32593;&#32476;&#25509;&#21475;&#30340;&#29305;&#24615;&#65292;&#24182;&#35774;&#32622;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#25104;&#21592;</span>
        newtp                 = tcp_sk(newsk);
        newinet               = inet_sk(newsk);
        ireq                  = inet_rsk(req);
        newinet-&gt;daddr        = ireq-&gt;rmt_addr;
        newinet-&gt;rcv_saddr    = ireq-&gt;loc_addr;
        newinet-&gt;saddr        = ireq-&gt;loc_addr;
        newinet-&gt;opt          = ireq-&gt;opt;
        ireq-&gt;opt             = <span style="color: #AE81FF;">NULL</span>;
        newinet-&gt;mc_index     = inet_iif(skb);
        newinet-&gt;mc_ttl       = skb-&gt;nh.iph-&gt;ttl;
        inet_csk(newsk)-&gt;icsk_ext_hdr_len = 0;
        <span style="color: #F92672;">if</span> (newinet-&gt;opt)
                inet_csk(newsk)-&gt;icsk_ext_hdr_len = newinet-&gt;opt-&gt;optlen;
        newinet-&gt;id = newtp-&gt;write_seq ^ jiffies;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#36335;&#24452;MTU&#21457;&#29616;&#30340;&#20449;&#24687;&#65288;&#26159;&#21542;&#21551;&#29992;&#36335;&#24452;MTU&#21457;&#29616;&#12289;&#36335;&#24452;MTU&#21457;&#39033;&#25506;&#27979;&#25968;&#25454;&#21253;&#30340;&#22823;&#23567;&#65289;</span>
        tcp_mtup_init(newsk);
        tcp_sync_mss(newsk, dst_mtu(dst));<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#36335;&#30001;&#39033;&#30340;&#36335;&#24452;MTU&#35774;&#32622;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#24403;&#21069;MSS</span>
        newtp-&gt;advmss = dst_metric(dst, RTAX_ADVMSS); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#36335;&#30001;&#39033;&#30340;MSS&#35774;&#32622;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#26368;&#22823;&#27573;&#38271;&#24230;</span>
        tcp_initialize_rcv_mss(newsk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#29992;&#20110;&#24310;&#26102;&#21457;&#36865;ACK&#27573;&#30340;&#25511;&#21046;&#25968;&#25454;&#22359;&#20013;&#30340;rcv_mss</span>

<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Copy over the MD5 key from the original socket</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> ((key = tcp_v4_md5_do_lookup(sk, newinet-&gt;daddr)) != <span style="color: #AE81FF;">NULL</span>) {
                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                 * We're using one, so create a matching key</span>
<span style="color: #75715E;">                 * on the newsk structure. If we fail to get</span>
<span style="color: #75715E;">                 * memory, then we end up not copying the key</span>
<span style="color: #75715E;">                 * across. Shucks.</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">newkey</span> = kmemdup(key-&gt;key, key-&gt;keylen, GFP_ATOMIC);
                <span style="color: #F92672;">if</span> (newkey != <span style="color: #AE81FF;">NULL</span>)
                        tcp_v4_md5_do_add(newsk, inet_sk(sk)-&gt;daddr,
                                          newkey, key-&gt;keylen);
        }
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#21152;&#20837;&#21040;ehash&#25955;&#21015;&#34920;</span>
        __inet_hash(&amp;tcp_hashinfo, newsk, 0);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#34429;&#28982;&#27809;&#26377;&#36827;&#34892;&#26174;&#24335;&#30340;&#31471;&#21475;&#32465;&#23450;&#65288;listen&#31471;&#21475;&#65289;&#65292;&#23454;&#38469;&#24050;&#32463;&#36827;&#34892;&#20102;&#32465;&#23450;&#65292;&#20877;&#27492;&#38656;&#35201;&#36827;&#34892;&#32465;&#23450;&#25805;&#20316;</span>
        __inet_inherit_port(&amp;tcp_hashinfo, sk, newsk);

        <span style="color: #F92672;">return</span> newsk;

<span style="color: #AE81FF;">exit_overflow</span>:
        NET_INC_STATS_BH(LINUX_MIB_LISTENOVERFLOWS);
<span style="color: #AE81FF;">exit</span>:
        NET_INC_STATS_BH(LINUX_MIB_LISTENDROPS);
        dst_release(dst);
        <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org9227082" class="outline-4">
<h4 id="org9227082"><span class="section-number-4">6.4.5.</span> 为子连接创建传输控制块</h4>
<div class="outline-text-4" id="text-6-4-5">
<p>
根据父传输控制块和连接请求块，分配（原子分配）新的子传输控制块。分配后，根据连接请求块和父传输控制块初始化子传输控制块。
</p>
</div>
</div>

<div id="outline-container-orgf66d995" class="outline-4">
<h4 id="orgf66d995"><span class="section-number-4">6.4.6.</span> 发送ACK段</h4>
<div class="outline-text-4" id="text-6-4-6">
<p>
在SYN_RECV状态下，如果接收到的第三次握手段序号无效或者序号不在接收窗口内，且非RST段，则需要项对段发送ACK段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">The code following below sending ACKs in SYN-RECV and TIME-WAIT states</span>
<span style="color: #75715E;">   outside socket context is ugly, certainly. What can I do?</span>
<span style="color: #75715E;"> */</span>

<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">tcp_v4_send_ack</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_timewait_sock</span> *<span style="color: #FD971F;">twsk</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">timewait&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#35813;&#21442;&#25968;&#21482;&#22312;TIME_WAIT&#29366;&#24577;&#19988;&#21551;&#29992;MD5&#25968;&#23383;&#31614;&#21517;&#26102;&#25165;&#20351;&#29992;</span>
                            <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span><span style="color: #75715E;">/*</span><span style="color: #75715E;">&#24453;&#21457;&#36865;&#30340;ACK&#27573;</span><span style="color: #75715E;">*/</span>,
                            <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">seq</span>,<span style="color: #75715E;">//</span><span style="color: #75715E;">&#24453;&#21457;&#36865;ACK&#27573;&#30340;&#24207;&#21495;</span>
                            <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">ack</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24453;&#21457;&#36865;ACK&#27573;&#20013;&#30340;&#30830;&#35748;&#24207;&#21495;</span>
                            <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">win</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#21578;&#23545;&#26041;&#30340;&#26412;&#31471;&#25509;&#25910;&#31383;&#21475;&#22823;&#23567;</span>
                            <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">ts</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#20026;0&#26102;&#65292;&#34920;&#31034;ACK&#27573;&#20013;TCP&#36873;&#39033;&#30340;&#26102;&#38388;&#25139;</span>
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span> = skb-&gt;h.th;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23450;&#20041;ACK&#27573;&#30340;TCP&#39318;&#37096;&#65292;&#21253;&#25324;&#26102;&#38388;&#25139;&#36873;&#39033;</span>
        <span style="color: #F92672;">struct</span> {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> <span style="color: #FD971F;">th</span>;
                <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">opt</span>[(TCPOLEN_TSTAMP_ALIGNED &gt;&gt; 2)
<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
                           + (TCPOLEN_MD5SIG_ALIGNED &gt;&gt; 2)
<span style="color: #F92672;">#endif</span>
                        ];
        } <span style="color: #FD971F;">rep</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_reply_arg</span> <span style="color: #FD971F;">arg</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_md5sig_key</span> *<span style="color: #FD971F;">key</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_md5sig_key</span> <span style="color: #FD971F;">tw_key</span>;
<span style="color: #F92672;">#endif</span>

        memset(&amp;rep.th, 0, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>));
        memset(&amp;arg, 0, <span style="color: #F92672;">sizeof</span>(arg));

        arg.iov[0].iov_base = (<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> *)&amp;rep;
        arg.iov[0].iov_len  = <span style="color: #F92672;">sizeof</span>(rep.th);
        <span style="color: #F92672;">if</span> (ts) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;ACK&#27573;&#30340;&#26102;&#38388;&#25139;&#36873;&#39033;</span>
                rep.opt[0] = htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16) |
                                   (TCPOPT_TIMESTAMP &lt;&lt; 8) |
                                   TCPOLEN_TIMESTAMP);
                rep.opt[1] = htonl(tcp_time_stamp);
                rep.opt[2] = htonl(ts);
                arg.iov[0].iov_len += TCPOLEN_TSTAMP_ALIGNED;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Swap the send and the receive.</span><span style="color: #75715E;"> */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;TCP&#39318;&#37096;&#23383;&#27573;</span>
        rep.th.dest    = th-&gt;source;
        rep.th.source  = th-&gt;dest;
        rep.th.doff    = arg.iov[0].iov_len / 4;
        rep.th.seq     = htonl(seq);
        rep.th.ack_seq = htonl(ack);
        rep.th.ack     = 1;
        rep.th.window  = htons(win);

<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * The SKB holds an imcoming packet, but may not have a valid -&gt;sk</span>
<span style="color: #75715E;">         * pointer. This is especially the case when we're dealing with a</span>
<span style="color: #75715E;">         * TIME_WAIT ack, because the sk structure is long gone, and only</span>
<span style="color: #75715E;">         * the tcp_timewait_sock remains. So the md5 key is stashed in that</span>
<span style="color: #75715E;">         * structure, and we use it in preference.  I believe that (twsk ||</span>
<span style="color: #75715E;">         * skb-&gt;sk) holds true, but we program defensively.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>twsk &amp;&amp; skb-&gt;sk) {
                key = tcp_v4_md5_do_lookup(skb-&gt;sk, skb-&gt;nh.iph-&gt;daddr);
        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (twsk &amp;&amp; twsk-&gt;tw_md5_keylen) {
                tw_key.key = twsk-&gt;tw_md5_key;
                tw_key.keylen = twsk-&gt;tw_md5_keylen;
                key = &amp;tw_key;
        } <span style="color: #F92672;">else</span>
                key = <span style="color: #AE81FF;">NULL</span>;

        <span style="color: #F92672;">if</span> (key) {
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">offset</span> = (ts) ? 3 : 0;

                rep.opt[offset++] = htonl((TCPOPT_NOP &lt;&lt; 24) |
                                          (TCPOPT_NOP &lt;&lt; 16) |
                                          (TCPOPT_MD5SIG &lt;&lt; 8) |
                                          TCPOLEN_MD5SIG);
                arg.iov[0].iov_len += TCPOLEN_MD5SIG_ALIGNED;
                rep.th.doff = arg.iov[0].iov_len/4;

                tcp_v4_do_calc_md5_hash((<span style="color: #66D9EF;">__u8</span> *)&amp;rep.opt[offset],
                                        key,
                                        skb-&gt;nh.iph-&gt;daddr,
                                        skb-&gt;nh.iph-&gt;saddr,
                                        &amp;rep.th, IPPROTO_TCP,
                                        arg.iov[0].iov_len);
        }
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;TCP&#27573;&#30340;&#20266;&#39318;&#37096;&#26816;&#39564;&#21644;&#65292;&#23384;&#25918;&#21040;arg&#65288;ip_reply_arg&#32467;&#26500;&#65289;&#20013;</span>
        arg.csum = csum_tcpudp_nofold(skb-&gt;nh.iph-&gt;daddr,
                                      skb-&gt;nh.iph-&gt;saddr, <span style="color: #75715E;">/* </span><span style="color: #75715E;">XXX</span><span style="color: #75715E;"> */</span>
                                      arg.iov[0].iov_len, IPPROTO_TCP, 0);
        arg.csumoffset = offsetof(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>, check) / 2;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#27492;ACK&#27573;</span>
        ip_send_reply(tcp_socket-&gt;sk, skb, &amp;arg, arg.iov[0].iov_len);

        TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org6e91e73" class="outline-4">
<h4 id="org6e91e73"><span class="section-number-4">6.4.7.</span> 发送RST段</h4>
<div class="outline-text-4" id="text-6-4-7">
<p>
tcp_v4_send_reset 函数用于发送RST段：
</p>
<ul class="org-ul">
<li>首先设置TCP首部个字段</li>
<li>计算TCP校验和</li>
<li>通过网络层函数ip_send_reply()发送RST段</li>
</ul>
</div>
</div>

<div id="outline-container-org13174a9" class="outline-4">
<h4 id="org13174a9"><span class="section-number-4">6.4.8.</span> 子传输控制块开始处理TCP段</h4>
<div class="outline-text-4" id="text-6-4-8">
<p>
新的子传输控制块建立并激活后，则需要处理收到的TCP段，同时需要唤醒等待监听套接口的进程，例如accept系统调用，如果子传输控制块被用户进程锁定，则将该TCP段添加到子传输控制块的后备接收队列中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * Queue segment on the new socket if the new socket is active,</span>
<span style="color: #75715E;"> * otherwise we just shortcircuit this and continue with</span>
<span style="color: #75715E;"> * the new socket.</span>
<span style="color: #75715E;"> */</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_child_process</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">parent</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30417;&#21548;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">child</span>,  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26032;&#21019;&#24314;&#30340;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31532;&#19977;&#27425;&#25569;&#25163;&#30340;ACK&#27573;</span>
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ret</span> = 0;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">state</span> = child-&gt;sk_state;

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sock_owned_by_user(child)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#27809;&#26377;&#27809;&#29992;&#20110;&#36827;&#31243;&#21344;&#29992;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#31532;&#19977;&#27425;&#25569;&#25163;&#30340;ACK&#32487;&#32493;&#21021;&#22987;&#21270;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
                ret = tcp_rcv_state_process(child, skb, skb-&gt;h.th, skb-&gt;len);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Wakeup parent, send SIGIO</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (state == TCP_SYN_RECV &amp;&amp; child-&gt;sk_state != state)
                        parent-&gt;sk_data_ready(parent, 0); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21796;&#37266;&#36827;&#31243;</span>
        } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21542;&#21017;&#28155;&#21152;&#21040;&#21518;&#22791;&#38431;&#21015;</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Alas, it is possible again, because we do lookup</span>
<span style="color: #75715E;">                 * in main socket hash table and lock on listening</span>
<span style="color: #75715E;">                 * socket does not protect us more.</span>
<span style="color: #75715E;">                 */</span>
                sk_add_backlog(child, skb);
        }

        bh_unlock_sock(child);
        sock_put(child);
        <span style="color: #F92672;">return</span> ret;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org7d564e4" class="outline-4">
<h4 id="org7d564e4"><span class="section-number-4">6.4.9.</span> 子传输控制块SYN_RECV状态的ACK段的处理</h4>
<div class="outline-text-4" id="text-6-4-9">
<p>
tcp_rcv_state_process()用来处理ESTABLISHED 和 TIME_WAIT 状态以外的TCP段，以下代码段只显示SYN_RECV状态的处理过程。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      This function implements the receiving procedure of RFC 793 for</span>
<span style="color: #75715E;"> *      all states except ESTABLISHED and TIME_WAIT.</span>
<span style="color: #75715E;"> *      It's called from both tcp_v4_rcv and tcp_v6_rcv and should be</span>
<span style="color: #75715E;"> *      address independent.</span>
<span style="color: #75715E;"> */</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_rcv_state_process</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>,
                          <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35299;&#26512;TCP&#36873;&#39033;&#21516;&#26102;&#26816;&#26597;&#26102;&#38388;&#25139;&#36873;&#39033;&#65292;&#22914;&#26524;&#23384;&#22312;&#26102;&#38388;&#25139;&#19988;PAWS&#26657;&#39564;&#22833;&#36133;&#65292;&#21017;&#20002;&#24323;</span>
        <span style="color: #F92672;">if</span> (tcp_fast_parse_options(skb, th, tp) &amp;&amp; tp-&gt;rx_opt.saw_tstamp &amp;&amp;
            tcp_paws_discard(sk, skb)) {
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>th-&gt;rst) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#19981;&#26159;rst,&#36824;&#38656;&#35201;&#21457;&#36865;DACK&#32473;&#23545;&#27573;&#65292;&#34920;&#31034;&#25509;&#25910;&#30340;TCP&#27573;&#24050;&#32463;&#30830;&#35748;&#36807;</span>
                        NET_INC_STATS_BH(LINUX_MIB_PAWSESTABREJECTED);
                        tcp_send_dupack(sk, skb);
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;
                }
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Reset is accepted even if it did not pass PAWS.</span><span style="color: #75715E;"> */</span>
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">step 1: check sequence number</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">TCP&#24207;&#21495;&#26080;&#25928;&#65292;&#21017;&#20002;&#24323;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) {
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>th-&gt;rst)
                        tcp_send_dupack(sk, skb);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">step 2: check RST bit</span><span style="color: #75715E;"> */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#23384;&#22312;RST,&#21017;&#21521;&#23545;&#31471;&#21457;&#36865;RST</span>
        <span style="color: #F92672;">if</span>(th-&gt;rst) {
                tcp_reset(sk);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#26102;&#38388;&#25139;</span>
        tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)-&gt;seq);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">step 3: check security and precedence [ignored]</span><span style="color: #75715E;"> */</span>

        <span style="color: #75715E;">/*      </span><span style="color: #75715E;">step 4:</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         *      Check for a SYN in window.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23384;&#22312;SYN&#65292;&#21017;&#21521;&#23545;&#31471;&#21457;&#36865;RST&#27573;</span>
        <span style="color: #F92672;">if</span> (th-&gt;syn &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) {
                NET_INC_STATS_BH(LINUX_MIB_TCPABORTONSYN);
                tcp_reset(sk);
                <span style="color: #F92672;">return</span> 1;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">step 5: check the ACK field</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (th-&gt;ack) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;ACK&#26631;&#24535;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36820;&#22238;&#38750;&#38646;&#20540;&#34920;&#31034;&#22788;&#29702;ACK&#27573;&#25104;&#21151;&#65292;&#26159;&#27491;&#24120;&#30340;&#31532;&#19977;&#27425;&#25569;&#25163;&#30340;ACK&#27573;&#12290;</span>
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">acceptable</span> = tcp_ack(sk, skb, FLAG_SLOWPATH);

                <span style="color: #F92672;">switch</span>(sk-&gt;sk_state) {
                <span style="color: #F92672;">case</span> TCP_SYN_RECV:
                        <span style="color: #F92672;">if</span> (acceptable) {
                                tp-&gt;copied_seq = tp-&gt;rcv_nxt;
                                smp_mb();
                                tcp_set_state(sk, TCP_ESTABLISHED);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#20026;ESTABLISHED&#29366;&#24577;</span>
                                sk-&gt;sk_state_change(sk);

                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Note, that this wakeup is only for marginal</span>
<span style="color: #75715E;">                                 * crossed SYN case. Passively open sockets</span>
<span style="color: #75715E;">                                 * are not waked up, because sk-&gt;sk_sleep ==</span>
<span style="color: #75715E;">                                 * NULL and sk-&gt;sk_socket == NULL.</span>
<span style="color: #75715E;">                                 */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#30693;&#36827;&#31243;&#65292;&#35813;&#22871;&#25509;&#21475;&#21487;&#20197;&#21457;&#36865;&#25968;&#25454;&#20102;</span>
                                <span style="color: #F92672;">if</span> (sk-&gt;sk_socket) {
                                        sk_wake_async(sk,0,POLL_OUT);
                                }
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#21508;&#20010;&#23383;&#27573;</span>
                                tp-&gt;snd_una = TCP_SKB_CB(skb)-&gt;ack_seq;
                                tp-&gt;snd_wnd = ntohs(th-&gt;window) &lt;&lt;
                                              tp-&gt;rx_opt.snd_wscale;
                                tcp_init_wl(tp, TCP_SKB_CB(skb)-&gt;ack_seq,
                                            TCP_SKB_CB(skb)-&gt;seq);

                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">tcp_ack considers this ACK as duplicate</span>
<span style="color: #75715E;">                                 * and does not calculate rtt.</span>
<span style="color: #75715E;">                                 * Fix it at least with timestamps.</span>
<span style="color: #75715E;">                                 */</span>
                                <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.saw_tstamp &amp;&amp; tp-&gt;rx_opt.rcv_tsecr &amp;&amp;
                                    <span style="color: #E6DB74; font-weight: bold;">!</span>tp-&gt;srtt)
                                        tcp_ack_saw_tstamp(sk, 0);

                                <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.tstamp_ok)
                                        tp-&gt;advmss -= TCPOLEN_TSTAMP_ALIGNED;

                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Make sure socket is routed, for</span>
<span style="color: #75715E;">                                 * correct metrics.</span>
<span style="color: #75715E;">                                 */</span>  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20026;&#35813;&#22871;&#25509;&#21475;&#24314;&#31435;&#36335;&#30001;</span>
                                icsk-&gt;icsk_af_ops-&gt;rebuild_header(sk);

                                tcp_init_metrics(sk);
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#25317;&#22622;&#25511;&#21046;&#27169;&#22359;</span>
                                tcp_init_congestion_control(sk);

                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Prevent spurious tcp_cwnd_restart() on</span>
<span style="color: #75715E;">                                 * first data packet.</span>
<span style="color: #75715E;">                                 */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#26368;&#36817;&#19968;&#27425;&#21457;&#36865;&#25968;&#25454;&#21253;&#30340;&#26102;&#38388;</span>
                                tp-&gt;lsndtime = tcp_time_stamp;

                                tcp_mtup_init(sk);
                                tcp_initialize_rcv_mss(sk);
                                tcp_init_buffer_space(sk);
                                tcp_fast_path_on(tp);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#26377;&#20851;TCP&#39318;&#37096;&#39044;&#27979;&#30340;&#26631;&#24535;</span>
                        } <span style="color: #F92672;">else</span> {
                                <span style="color: #F92672;">return</span> 1;
                        }
                        <span style="color: #F92672;">break</span>;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        } <span style="color: #F92672;">else</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">step 6: check the URG bit</span><span style="color: #75715E;"> */</span>
        tcp_urg(sk, skb, th);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#26597;&#24102;&#22806;&#26631;&#24535;</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">step 7: process the segment text</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">switch</span> (sk-&gt;sk_state) {
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#25509;&#25910;&#30340;TCP&#27573;&#25490;&#38431;&#65292;&#24314;&#31435;&#36830;&#25509;&#38454;&#27573;&#24212;&#35813;&#19981;&#20250;&#25509;&#25910;&#21040;TCP&#27573;&#12290;</span>
        <span style="color: #F92672;">case</span> TCP_ESTABLISHED:
                tcp_data_queue(sk, skb);
                queued = 1;
                <span style="color: #F92672;">break</span>;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">tcp_data could move socket to TIME-WAIT</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_state != TCP_CLOSE) {   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;CLOSE&#29366;&#24577;&#26102;&#65292;&#26816;&#27979;&#26159;&#21542;&#26377;&#25968;&#25454;&#21644;ACK&#38656;&#35201;&#21457;&#36865;</span>
                tcp_data_snd_check(sk, tp);
                tcp_ack_snd_check(sk);
        }

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>queued) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30830;&#23450;&#26159;&#21542;&#37322;&#25918;&#25509;&#25910;&#30340;TCP&#27573;&#65292;&#22914;&#26524;&#24050;&#32463;&#28155;&#21152;&#21040;&#25509;&#25910;&#38431;&#21015;&#65292;&#21017;&#19981;&#37322;&#25918;&#12290;</span>
<span style="color: #AE81FF;">discard</span>:
                __kfree_skb(skb);
        }
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org5482c9b" class="outline-4">
<h4 id="org5482c9b"><span class="section-number-4">6.4.10.</span> 函数调用关系</h4>
<div class="outline-text-4" id="text-6-4-10">
<p>
第三次握手的ACK段由 tcp_v4_hnd_req() 处理。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">tcp_v4_do_rcv</span>
        <span style="color: #A6E22E;">tcp_v4_hnd_req</span>()
                <span style="color: #A6E22E;">inet_csk_search_req</span>()
                <span style="color: #A6E22E;">tcp_check_req</span>()
                        <span style="color: #A6E22E;">tcp_v4_syn_recv_sock</span>()
                                <span style="color: #A6E22E;">tcp_create_openreq_chile</span>()
        <span style="color: #A6E22E;">tcp_child_process</span>()
                <span style="color: #A6E22E;">tcp_rcv_state_process</span>()
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org0acf08c" class="outline-2">
<h2 id="org0acf08c"><span class="section-number-2">7.</span> connect系统调用</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgbc03891" class="outline-3">
<h3 id="orgbc03891"><span class="section-number-3">7.1.</span> 套接口层实现：inet_stream_connect()</h3>
<div class="outline-text-3" id="text-7-1">
<p>
inet_stream_connect()是connect系统调用的套接口层实现。传输层TCP实现为 tcp_v4_connect()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Connect to a remote host. There is regrettably still a little</span>
<span style="color: #75715E;"> *      TCP 'magic' in here.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_stream_connect</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36827;&#34892;&#36830;&#25509;&#30340;&#22871;&#25509;&#21475;</span>
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *<span style="color: #FD971F;">uaddr</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">addr_len</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30446;&#30340;&#22320;&#22336;&#21450;&#38271;&#24230;</span>
                        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span> = sock-&gt;sk;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;
        <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">timeo</span>;

        lock_sock(sk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25805;&#20316;&#21069;&#21152;&#38145;</span>

        <span style="color: #F92672;">if</span> (uaddr-&gt;sa_family == AF_UNSPEC) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#35774;&#32622;&#22320;&#22336;&#26063;&#65292;&#21017;&#19981;&#33021;&#36827;&#34892;connect&#25805;&#20316;</span>
                err = sk-&gt;sk_prot-&gt;disconnect(sk, flags); <span style="color: #75715E;">//</span><span style="color: #75715E;">tcp_disconnect()</span>
                sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        }

        <span style="color: #F92672;">switch</span> (sock-&gt;state) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#22788;&#20110;&#38750;SS_UNCONNECTED&#29366;&#24577;&#26102;&#65292;&#19981;&#33021;&#36827;&#34892;connect</span>
        <span style="color: #F92672;">default</span>:
                err = -EINVAL;
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">case</span> SS_CONNECTED:
                err = -EISCONN;
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">case</span> SS_CONNECTING:
                err = -EALREADY;
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Fall out of switch with err, set for this state</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> SS_UNCONNECTED:
                err = -EISCONN;
                <span style="color: #F92672;">if</span> (sk-&gt;sk_state != TCP_CLOSE) <span style="color: #75715E;">//</span><span style="color: #75715E;">TCP&#19981;&#22788;&#20110;CLOSE&#29366;&#24577;&#65292;&#21017;&#35828;&#26126;&#24050;&#36830;&#25509;</span>
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

                err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len); <span style="color: #75715E;">//</span><span style="color: #75715E;">tcp_v4_connect() &#21457;&#36865;SYN&#27573;</span>
                <span style="color: #F92672;">if</span> (err &lt; 0)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

                sock-&gt;state = SS_CONNECTING;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Just entered SS_CONNECTING state; the only</span>
<span style="color: #75715E;">                 * difference is that return value in non-blocking</span>
<span style="color: #75715E;">                 * case is EINPROGRESS, rather than EALREADY.</span>
<span style="color: #75715E;">                 */</span>
                err = -EINPROGRESS; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#38750;&#38459;&#22622;&#26041;&#24335;&#36830;&#25509;&#65292;&#21017;&#36820;&#22238;&#35813;&#38169;&#35823;&#30721;&#65292;&#34920;&#31034;&#27491;&#22312;&#36830;&#25509;&#12290;</span>
                <span style="color: #F92672;">break</span>;
        }

        timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#36830;&#25509;&#36229;&#26102;&#26102;&#38388;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19968;&#33324;&#21457;&#36865;&#23436;SYN&#27573;&#21518;&#65292;TCP&#29366;&#24577;&#20250;&#21464;&#20026;TCPF_SYN_SENT&#65292;TCP_SYN_SENT&#21644;TCPF_SYN_RECV&#37117;&#34920;&#31034;&#21322;&#36830;&#25509;&#29366;&#24577;&#12290;</span>
        <span style="color: #F92672;">if</span> ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Error code is set above</span><span style="color: #75715E;"> */</span>
                <span style="color: #75715E;">/*</span><span style="color: #75715E;">TCP_SYN_SENT&#21644;TCPF_SYN_RECV&#37117;&#34920;&#31034;&#21322;&#36830;&#25509;&#29366;&#24577;&#65292;&#22914;&#26524;&#22788;&#20110;&#36825;&#20004;&#31181;&#29366;&#24577;&#65292;&#24182;&#19988;&#26159;&#38459;&#22622;&#26041;&#24335;&#65292;</span>
<span style="color: #75715E;">                &#21017;&#31561;&#24453;&#36830;&#25509;&#23436;&#25104;&#25110;&#36229;&#26102;</span><span style="color: #75715E;">*/</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>timeo || <span style="color: #E6DB74; font-weight: bold;">!</span>inet_wait_for_connect(sk, timeo))
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;&#38459;&#22622;&#65292;&#21017;&#26080;&#38656;&#31561;&#24453;&#36830;&#25509;&#23436;&#25104;</span>
                err = sock_intr_errno(timeo);
                <span style="color: #F92672;">if</span> (signal_pending(current))
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Connection was closed by RST, timeout, ICMP error</span>
<span style="color: #75715E;">         * or another process disconnected us.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_state == TCP_CLOSE) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24314;&#31435;&#22833;&#36133;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">sock_error</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">sk-&gt;sk_err may be not zero now, if RECVERR was ordered by user</span>
<span style="color: #75715E;">         * and error was received after socket entered established state.</span>
<span style="color: #75715E;">         * Hence, it is handled normally after connect() return successfully.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36830;&#25509;&#25104;&#21151;</span>
        sock-&gt;state = SS_CONNECTED;
        err = 0;
<span style="color: #AE81FF;">out</span>:
        release_sock(sk);
        <span style="color: #F92672;">return</span> err;

<span style="color: #AE81FF;">sock_error</span>:
        err = sock_error(sk) ? : -ECONNABORTED;
        sock-&gt;state = SS_UNCONNECTED;
        <span style="color: #F92672;">if</span> (sk-&gt;sk_prot-&gt;disconnect(sk, flags))
                sock-&gt;state = SS_DISCONNECTING;
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc193198" class="outline-3">
<h3 id="orgc193198"><span class="section-number-3">7.2.</span> 传输层的实现： tcp_v4_connect()</h3>
<div class="outline-text-3" id="text-7-2">
<p>
参见下一小节。
</p>
</div>
</div>
</div>


<div id="outline-container-org8bf8ece" class="outline-2">
<h2 id="org8bf8ece"><span class="section-number-2">8.</span> 主动打开</h2>
<div class="outline-text-2" id="text-8">
<p>
在调用connect之后，通过套接口层的校验后，调用传输层的 tcp_v4_connect() 发送SYN段请求连接。
</p>
</div>

<div id="outline-container-org70a7d75" class="outline-3">
<h3 id="org70a7d75"><span class="section-number-3">8.1.</span> 第一次握手：发送SYN段</h3>
<div class="outline-text-3" id="text-8-1">
</div>
<div id="outline-container-orga154638" class="outline-4">
<h4 id="orga154638"><span class="section-number-4">8.1.1.</span> 初始化客户端传输控制块并发送SYN段</h4>
<div class="outline-text-4" id="text-8-1-1">

<div id="org030d0fd" class="figure">
<p><img src="image/tcp-conect/tcp-v4-connect.png" alt="tcp-v4-connect.png" />
</p>
<p><span class="figure-number">Figure 9: </span>tcp_v4_connect函数流程</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">This will initiate an outgoing connection.</span><span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_v4_connect</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *<span style="color: #FD971F;">uaddr</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">addr_len</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> *<span style="color: #FD971F;">usin</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> *)uaddr;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span>;
        <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span>, <span style="color: #FD971F;">nexthop</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">tmp</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;&#30446;&#30340;&#22320;&#22336;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (addr_len &lt; <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span>))
                <span style="color: #F92672;">return</span> -EINVAL;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;&#21327;&#35758;&#26063;</span>
        <span style="color: #F92672;">if</span> (usin-&gt;sin_family != AF_INET)
                <span style="color: #F92672;">return</span> -EAFNOSUPPORT;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#19979;&#19968;&#36339;&#21644;&#30446;&#30340;&#22320;&#22336;&#30340;&#20020;&#26102;&#21464;&#37327;&#37117;&#35774;&#32622;&#20026;connect&#20989;&#25968;&#21442;&#25968;&#20013;&#30340;&#22320;&#22336;</span>
        nexthop = daddr = usin-&gt;sin_addr.s_addr;
        <span style="color: #F92672;">if</span> (inet-&gt;opt &amp;&amp; inet-&gt;opt-&gt;srr) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#20351;&#29992;&#28304;&#22320;&#22336;&#36335;&#30001;&#65292;&#21017;nexthop&#35774;&#32622;&#20026;ip&#36873;&#39033;&#20013;&#30340;faddr</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>daddr)
                        <span style="color: #F92672;">return</span> -EINVAL;
                nexthop = inet-&gt;opt-&gt;faddr;
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26681;&#25454;nexthop&#31561;&#20449;&#24687;&#65292;&#26597;&#25214;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#65292;&#22914;&#26524;&#36335;&#30001;&#21629;&#20013;&#65292;&#21017;&#29983;&#25104;&#23545;&#24212;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;</span>
<span style="color: #75715E;">        &#36825;&#20010;&#32531;&#23384;&#26082;&#21487;&#20197;&#29992;&#20110;&#21457;&#36865;&#24403;&#21069;SYN&#27573;&#65292;&#20063;&#21487;&#20197;&#29992;&#20110;&#21518;&#32493;&#30340;&#25968;&#25454;&#21253;</span><span style="color: #75715E;"> */</span>
        tmp = ip_route_connect(&amp;rt, nexthop, inet-&gt;saddr,
                               RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,
                               IPPROTO_TCP,
                               inet-&gt;sport, usin-&gt;sin_port, sk);
        <span style="color: #F92672;">if</span> (tmp &lt; 0)
                <span style="color: #F92672;">return</span> tmp;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">TCP&#19981;&#33021;&#20351;&#29992;&#32452;&#25773;&#25110;&#22810;&#25773;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;</span>
        <span style="color: #F92672;">if</span> (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) {
                ip_rt_put(rt);
                <span style="color: #F92672;">return</span> -ENETUNREACH;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#27809;&#26377;&#21551;&#29992;&#28304;&#36335;&#30001;&#36873;&#39033;&#65292;&#21017;&#20351;&#29992;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#20013;&#30340;&#30446;&#30340;&#22320;&#22336;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>inet-&gt;opt || <span style="color: #E6DB74; font-weight: bold;">!</span>inet-&gt;opt-&gt;srr)
                daddr = rt-&gt;rt_dst;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#27809;&#26377;&#35774;&#32622;&#28304;&#22320;&#22336;&#65292;&#21017;&#20351;&#29992;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#20013;&#30340;&#28304;&#22320;&#22336;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>inet-&gt;saddr)
                inet-&gt;saddr = rt-&gt;rt_src;
        inet-&gt;rcv_saddr = inet-&gt;saddr;
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#30340;&#26102;&#38388;&#25139;&#21644;&#30446;&#30340;&#22320;&#22336;&#24050;&#32463;&#34987;&#20351;&#29992;&#36807;&#65292;&#21017;&#35828;&#26126;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#20043;&#21069;&#24050;&#32463;&#24314;&#31435;&#36807;&#36830;&#25509;&#24182;&#19988;&#26377;&#36807;&#36890;&#20449;&#65292;</span>
<span style="color: #75715E;">        &#38656;&#35201;&#37325;&#26032;&#21021;&#22987;&#21270;&#30456;&#20851;&#25104;&#21592;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; inet-&gt;daddr != daddr) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Reset inherited state</span><span style="color: #75715E;"> */</span>
                tp-&gt;rx_opt.ts_recent       = 0;
                tp-&gt;rx_opt.ts_recent_stamp = 0;
                tp-&gt;write_seq              = 0;
        }
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#21551;&#29992;&#20102;tcp_tw_recycle&#24182;&#25509;&#25910;&#36807;&#26102;&#38388;&#25139;&#36873;&#39033;&#65292;&#20174;&#23545;&#27573;&#20449;&#24687;&#22359;&#20013;&#33719;&#21462;&#30456;&#24212;&#30340;&#20540;&#26469;&#21021;&#22987;&#21270;</span>
<span style="color: #75715E;">        ts_recent_stamp&#21644;ts_recent</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (tcp_death_row.sysctl_tw_recycle &amp;&amp;
            <span style="color: #E6DB74; font-weight: bold;">!</span>tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; rt-&gt;rt_dst == daddr) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span> *<span style="color: #FD971F;">peer</span> = rt_get_peer(rt);
                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                 * VJ's idea. We save last timestamp seen from</span>
<span style="color: #75715E;">                 * the destination in peer table, when entering state</span>
<span style="color: #75715E;">                 * TIME-WAIT * and initialize rx_opt.ts_recent from it,</span>
<span style="color: #75715E;">                 * when trying new connection.</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #F92672;">if</span> (peer != <span style="color: #AE81FF;">NULL</span> &amp;&amp;
                    peer-&gt;tcp_ts_stamp + TCP_PAWS_MSL &gt;= xtime.tv_sec) {
                        tp-&gt;rx_opt.ts_recent_stamp = peer-&gt;tcp_ts_stamp;
                        tp-&gt;rx_opt.ts_recent = peer-&gt;tcp_ts;
                }
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#30446;&#30340;&#22320;&#22336;&#21450;&#31471;&#21475;</span>
        inet-&gt;dport = usin-&gt;sin_port;
        inet-&gt;daddr = daddr;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;IP&#36873;&#39033;&#37096;&#20998;&#38271;&#24230;</span>
        inet_csk(sk)-&gt;icsk_ext_hdr_len = 0;
        <span style="color: #F92672;">if</span> (inet-&gt;opt)
                inet_csk(sk)-&gt;icsk_ext_hdr_len = inet-&gt;opt-&gt;optlen;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;MSS&#19978;&#38480;</span>
        tp-&gt;rx_opt.mss_clamp = 536;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Socket identity is still unknown (sport may be zero).</span>
<span style="color: #75715E;">         * However we set state to SYN-SENT and not releasing socket</span>
<span style="color: #75715E;">         * lock select source port, enter ourselves into the hash tables and</span>
<span style="color: #75715E;">         * complete initialization after this.</span>
<span style="color: #75715E;">         */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;TCP&#29366;&#24577;&#20026;SYN_SENT</span>
        tcp_set_state(sk, TCP_SYN_SENT);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21160;&#24577;&#30340;&#20998;&#37197;&#24182;&#32465;&#23450;&#26412;&#22320;&#31471;&#21475;&#65292;&#24182;&#28155;&#21152;&#21040;ehash&#25955;&#21015;&#34920;&#12290;&#22914;&#26524;&#22312;&#20998;&#37197;&#31471;&#21475;&#26102;&#65292;&#20998;&#37197;&#30340;&#26159;&#24050;&#20351;&#29992;&#30340;&#31471;&#21475;&#65292;</span>
<span style="color: #75715E;">        &#21017;&#38656;&#35201;&#22312;TIME_WAIT&#29366;&#24577;&#38431;&#21015;&#20013;&#36827;&#34892;&#30456;&#24212;&#30340;&#30830;&#35748;&#65292;&#22240;&#27492;&#35843;&#29992;inet_hash_connect()&#26102;&#65292;&#38656;&#35201;&#20351;&#29992; &#21442;&#25968;&#31649;&#29702;&#22120;tcp_death_row&#21644;timewait&#20256;&#36755;&#25511;&#21046;&#22359;&#20316;&#20026;&#21442;&#25968;</span><span style="color: #75715E;">*/</span>
        err = inet_hash_connect(&amp;tcp_death_row, sk);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">failure</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#28304;&#31471;&#21475;&#25110;&#30446;&#30340;&#31471;&#21475;&#21457;&#29983;&#25913;&#21464;&#65292;&#21017;&#38656;&#35201;&#37325;&#26032;&#26597;&#25214;&#36335;&#30001;&#65292;&#29992;&#26032;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#26356;&#26032;sk&#20013;&#20445;&#23384;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#12290;</span>
        err = ip_route_newports(&amp;rt, IPPROTO_TCP,
                                inet-&gt;sport, inet-&gt;dport, sk);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">failure</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">OK, now commit destination to socket.</span><span style="color: #75715E;">  */</span>
        sk-&gt;sk_gso_type = SKB_GSO_TCPV4; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;GSO&#31867;&#22411;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#36335;&#30001;&#36755;&#20986;&#35774;&#22791;&#29305;&#24615;&#65292;&#35774;&#32622;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#30446;&#30340;&#36335;&#30001;&#32593;&#32476;&#35774;&#22791;&#30340;&#29305;&#24615;&#12290;</span>
        sk_setup_caps(sk, &amp;rt-&gt;u.dst);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#36824;&#27809;&#26377;&#35774;&#32622;&#21021;&#22987;&#24207;&#21495;&#65292;&#21017;&#26681;&#25454;&#22235;&#20803;&#32452;&#35745;&#31639;&#21021;&#22987;&#24207;&#21495;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tp-&gt;write_seq)
                tp-&gt;write_seq = secure_tcp_sequence_number(inet-&gt;saddr,
                                                           inet-&gt;daddr,
                                                           inet-&gt;sport,
                                                           usin-&gt;sin_port);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#24207;&#21495;&#21644;&#24403;&#21069;&#26102;&#38388;&#35745;&#31639;&#29992;&#20110;IP&#39318;&#37096;&#30340;ID&#22495;&#30340;&#20540;&#12290;</span>
        inet-&gt;id = tp-&gt;write_seq ^ jiffies;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26500;&#36896;&#24182;&#21457;&#36865;SYN&#27573;</span>
        err = tcp_connect(sk);
        rt = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">failure</span>;

        <span style="color: #F92672;">return</span> 0;

<span style="color: #AE81FF;">failure</span>:
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * This unhashes the socket and releases the local port,</span>
<span style="color: #75715E;">         * if necessary.</span>
<span style="color: #75715E;">         */</span>
        tcp_set_state(sk, TCP_CLOSE);
        ip_rt_put(rt);
        sk-&gt;sk_route_caps = 0;
        inet-&gt;dport = 0;
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org0851a58" class="outline-4">
<h4 id="org0851a58"><span class="section-number-4">8.1.2.</span> 动态绑定端口： inet_hash_connect()</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
inet_hash_connect()函数主要用于在主动连接过程中动态绑定端口。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * Bind a port for a connect operation and hash it.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_hash_connect</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_timewait_death_row</span> *<span style="color: #FD971F;">death_row</span>,
                      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>)
{       <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#25955;&#21015;&#34920;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_hashinfo</span> *<span style="color: #FD971F;">hinfo</span> = death_row-&gt;hashinfo;
        <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> <span style="color: #FD971F;">snum</span> = inet_sk(sk)-&gt;num; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#31471;&#21475;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_bind_hashbucket</span> *<span style="color: #FD971F;">head</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_bind_bucket</span> *<span style="color: #FD971F;">tb</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ret</span>;

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>snum) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#25351;&#23450;&#31471;&#21475;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#21160;&#24577;&#31471;&#21475;&#33539;&#22260;</span>
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">low</span> = sysctl_local_port_range[0];
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">high</span> = sysctl_local_port_range[1];
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">range</span> = high - low;
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>;
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">port</span>;
                <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">hint</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#28304;&#30446;&#30340;&#22320;&#22336;&#21644;&#30446;&#30340;&#31471;&#21475;&#35745;&#31639;&#33719;&#21462;&#31471;&#21475;&#21021;&#22987;&#20540;</span>
                <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">offset</span> = hint + inet_sk_port_offset(sk);
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_node</span> *<span style="color: #FD971F;">node</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_timewait_sock</span> *<span style="color: #FD971F;">tw</span> = <span style="color: #AE81FF;">NULL</span>;

                local_bh_disable();
                <span style="color: #F92672;">for</span> (i = 1; i &lt;= range; i++) {
                        port = low + (i + offset) % range; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#31471;&#21475;</span>
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#25214;hash&#26631;&#65292;&#26816;&#26597;&#31471;&#21475;&#26159;&#21542;&#34987;&#21344;&#29992;</span>
                        head = &amp;hinfo-&gt;bhash[inet_bhashfn(port, hinfo-&gt;bhash_size)];
                        spin_lock(&amp;head-&gt;lock);

                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Does not bother with rcv_saddr checks,</span>
<span style="color: #75715E;">                         * because the established check is already</span>
<span style="color: #75715E;">                         * unique enough.</span>
<span style="color: #75715E;">                         */</span>
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#20801;&#35768;&#22797;&#29992;&#36890;&#36807;bind&#31995;&#32479;&#35843;&#29992;&#32465;&#23450;&#30340;&#31471;&#21475;&#65292;&#26080;&#35770;&#31471;&#21475;&#26159;&#21542;&#33021;&#34987;&#22797;&#29992;</span>
                        inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain) {
                                <span style="color: #F92672;">if</span> (tb-&gt;port == port) {
                                        BUG_TRAP(<span style="color: #E6DB74; font-weight: bold;">!</span>hlist_empty(&amp;tb-&gt;owners));
                                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21363;&#20351;&#31471;&#21475;&#21487;&#20197;&#22797;&#29992;&#65292;&#20294;&#26159;&#21160;&#24577;&#36873;&#25321;&#31471;&#21475;&#19981;&#33021;&#20351;&#29992;&#36890;&#36807;bind&#21344;&#29992;&#30340;&#31471;&#21475;</span>
                                        <span style="color: #F92672;">if</span> (tb-&gt;fastreuse &gt;= 0)
                                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">next_port</span>;
                                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#26597;&#31471;&#21475;&#26159;&#21542;&#33021;&#34987;&#22797;&#29992;&#65292;&#21160;&#24577;&#32465;&#23450;&#30340;&#31471;&#21475;&#21482;&#33021;&#22797;&#29992;&#22312;TIME_WAIT&#29366;&#24577;&#19979;&#32465;&#23450;&#30340;&#31471;&#21475;&#65288;&#38656;&#35201;&#21551;&#29992;tcp_tw_reuse&#65289;</span>
                                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>__inet_check_established(death_row,
                                                                      sk, port,
                                                                      &amp;tw))
                                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">ok</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21487;&#20197;&#22797;&#29992;</span>
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">next_port</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#19979;&#19968;&#20010;&#31471;&#21475;</span>
                                }
                        }
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31471;&#21475;&#26410;&#20351;&#29992;&#65292;&#21017;&#21487;&#20197;&#20351;&#29992;&#35813;&#31471;&#21475;&#65292;&#20026;&#31471;&#21475;&#21019;&#24314;&#20449;&#24687;&#22359;&#24182;&#28155;&#21152;&#21040;bhash&#25955;&#21015;&#34920;</span>
                        tb = inet_bind_bucket_create(hinfo-&gt;bind_bucket_cachep, head, port);
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tb) {
                                spin_unlock(&amp;head-&gt;lock);
                                <span style="color: #F92672;">break</span>;
                        }
                        tb-&gt;fastreuse = -1;
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">ok</span>;

                <span style="color: #AE81FF;">next_port</span>:
                        spin_unlock(&amp;head-&gt;lock);
                }
                local_bh_enable();
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25214;&#19981;&#21040;&#21487;&#29992;&#31471;&#21475;&#65292;&#36820;&#22238;&#38169;&#35823;</span>
                <span style="color: #F92672;">return</span> -EADDRNOTAVAIL;

<span style="color: #AE81FF;">ok</span>:  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23436;&#25104;&#32465;&#23450;&#36807;&#31243;</span>
                hint += i;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Head lock still held and bh's disabled</span><span style="color: #75715E;"> */</span>
                inet_bind_hash(sk, tb, port);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#20256;&#36755;&#25511;&#21046;&#22359;&#21644;&#32465;&#23450;&#31471;&#21475;&#20449;&#24687;&#20851;&#32852;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#33073;&#31163;ehash&#25955;&#21015;&#34920;&#25110;&#32773;&#27809;&#26377;&#28155;&#21152;&#65292;&#21017;&#28155;&#21152;&#33267;&#25955;&#21015;&#34920;</span>
                <span style="color: #F92672;">if</span> (sk_unhashed(sk)) {
                        inet_sk(sk)-&gt;sport = htons(port);
                        __inet_hash(hinfo, sk, 0);
                }
                spin_unlock(&amp;head-&gt;lock);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#22797;&#29992;&#30340;TIME_WAIT&#29366;&#24577;&#30340;&#31471;&#21475;&#65292;&#21017;&#38656;&#35201;&#21024;&#38500;&#37322;&#25918;TIMEWAIT&#29366;&#24577;&#30340;&#22871;&#25509;&#21475;</span>
                <span style="color: #F92672;">if</span> (tw) {
                        inet_twsk_deschedule(tw, death_row);
                        inet_twsk_put(tw);
                }

                ret = 0;
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#30830;&#35748;&#19982;&#32465;&#23450;&#31471;&#21475;&#20449;&#24687;&#22359;&#32465;&#23450;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#26159;&#21542;&#26159;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;</span>
<span style="color: #75715E;">        &#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#25351;&#21521;&#30340;&#32465;&#23450;&#20449;&#24687;&#22359;&#26159;&#21542;&#26377;&#25928;</span><span style="color: #75715E;">*/</span>
        head = &amp;hinfo-&gt;bhash[inet_bhashfn(snum, hinfo-&gt;bhash_size)];
        tb  = inet_csk(sk)-&gt;icsk_bind_hash;
        spin_lock_bh(&amp;head-&gt;lock);
        <span style="color: #F92672;">if</span> (sk_head(&amp;tb-&gt;owners) == sk &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>sk-&gt;sk_bind_node.next) {
                __inet_hash(hinfo, sk, 0);
                spin_unlock_bh(&amp;head-&gt;lock);
                <span style="color: #F92672;">return</span> 0;
        } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21542;&#21017;&#38656;&#35201;&#36890;&#36807; __inet_check_established()&#26469;&#26816;&#27979;&#35813;&#31471;&#21475;&#33021;&#21542;&#34987;&#20351;&#29992;</span>
                spin_unlock(&amp;head-&gt;lock);
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">No definite answer... Walk to established hash table</span><span style="color: #75715E;"> */</span>
                ret = __inet_check_established(death_row, sk, snum, <span style="color: #AE81FF;">NULL</span>);
<span style="color: #AE81FF;">out</span>:
                local_bh_enable();
                <span style="color: #F92672;">return</span> ret;
        }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org68d093f" class="outline-4">
<h4 id="org68d093f"><span class="section-number-4">8.1.3.</span> 构造SYN段并发送：tcp_connect()</h4>
<div class="outline-text-4" id="text-8-1-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * Build a SYN and send it off.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_connect</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">buff</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#21644;&#36830;&#25509;&#30456;&#20851;&#30340;&#25104;&#21592;&#12290;</span>
        tcp_connect_init(sk);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20026;SYN&#27573;&#20998;&#37197;SKB&#24182;&#35774;&#32622;&#30456;&#20851;&#23383;&#27573;</span>
        buff = alloc_skb_fclone(MAX_TCP_HEADER + 15, sk-&gt;sk_allocation);
        <span style="color: #F92672;">if</span> (unlikely(buff == <span style="color: #AE81FF;">NULL</span>))
                <span style="color: #F92672;">return</span> -ENOBUFS;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Reserve space for headers.</span><span style="color: #75715E;"> */</span>
        skb_reserve(buff, MAX_TCP_HEADER);

        TCP_SKB_CB(buff)-&gt;flags = TCPCB_FLAG_SYN;
        TCP_ECN_send_syn(sk, tp, buff);
        TCP_SKB_CB(buff)-&gt;sacked = 0;
        skb_shinfo(buff)-&gt;gso_segs = 1;
        skb_shinfo(buff)-&gt;gso_size = 0;
        skb_shinfo(buff)-&gt;gso_type = 0;
        buff-&gt;csum = 0;
        tp-&gt;snd_nxt = tp-&gt;write_seq;
        TCP_SKB_CB(buff)-&gt;seq = tp-&gt;write_seq++;
        TCP_SKB_CB(buff)-&gt;end_seq = tp-&gt;write_seq;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Send it off.</span><span style="color: #75715E;"> */</span>
        TCP_SKB_CB(buff)-&gt;when = tcp_time_stamp;
        tp-&gt;retrans_stamp = TCP_SKB_CB(buff)-&gt;when;
        skb_header_release(buff);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;SYN&#27573;&#28155;&#21152;&#21040;&#21457;&#36865;&#38431;&#21015;</span>
        __skb_queue_tail(&amp;sk-&gt;sk_write_queue, buff);
        sk_charge_skb(sk, buff);
        tp-&gt;packets_out += tcp_skb_pcount(buff);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#35813;&#27573;</span>
        tcp_transmit_skb(sk, buff, 1, GFP_KERNEL);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We change tp-&gt;snd_nxt after the tcp_transmit_skb() call</span>
<span style="color: #75715E;">         * in order to make this packet get counted in tcpOutSegs.</span>
<span style="color: #75715E;">         */</span>
        tp-&gt;snd_nxt = tp-&gt;write_seq;
        tp-&gt;pushed_seq = tp-&gt;write_seq;
        TCP_INC_STATS(TCP_MIB_ACTIVEOPENS);

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26368;&#21518;&#21551;&#21160;&#37325;&#20256;&#23450;&#26102;&#22120;&#65292;&#20026;&#37325;&#20256;&#35813;SYN&#27573;&#20570;&#20934;&#22791;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Timer for repeating the SYN until an answer.</span><span style="color: #75715E;"> */</span>
        inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
                                  inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfa055d2" class="outline-3">
<h3 id="orgfa055d2"><span class="section-number-3">8.2.</span> 第二次握手： 接收SYN+ACK段</h3>
<div class="outline-text-3" id="text-8-2">
</div>
<div id="outline-container-org2a92955" class="outline-4">
<h4 id="org2a92955"><span class="section-number-4">8.2.1.</span> SYN_SENT状态的处理</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
tcp_rcv_state_process()用来处理不处于ESTABLISHED和TIME_WAIT状态的TCP段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_rcv_state_process</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>,
                          <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        <span style="color: #F92672;">switch</span> (sk-&gt;sk_state) {
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        <span style="color: #F92672;">case</span> TCP_SYN_SENT: <span style="color: #75715E;">//</span><span style="color: #75715E;">SYN_SENT&#29366;&#24577;&#19979;&#25509;&#25910;&#21040;TCP&#27573;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36820;&#22238;&#20540;&#22823;&#20110;0,&#34920;&#31034;&#38656;&#35201;&#32473;&#23545;&#31471;&#21457;&#36865;RST&#27573;</span>
                queued = tcp_rcv_synsent_state_process(sk, skb, th, len);
                <span style="color: #F92672;">if</span> (queued &gt;= 0)
                        <span style="color: #F92672;">return</span> queued;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Do step6 onward by hand.</span><span style="color: #75715E;"> */</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;&#32039;&#24613;&#25968;&#25454;&#65292;&#26102;&#20505;&#37322;&#25918;&#35813;&#31471;</span>
                tcp_urg(sk, skb, th);
                __kfree_skb(skb);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;&#26159;&#21542;&#26377;&#25968;&#25454;&#38656;&#35201;&#21457;&#36865;</span>
                tcp_data_snd_check(sk, tp);
                <span style="color: #F92672;">return</span> 0;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb6d7951" class="outline-4">
<h4 id="orgb6d7951"><span class="section-number-4">8.2.2.</span> 处理SYN+ACK段</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
SYN_SENT状态下接收的段，除了紧急数据外，其他都由 tcp_rcv_synsent_state_process()处理。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_rcv_synsent_state_process</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>,
                                         <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">saved_clamp</span> = tp-&gt;rx_opt.mss_clamp;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35299;&#26512;TCP&#36873;&#39033;&#65292;&#20445;&#23384;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        tcp_parse_options(skb, &amp;tp-&gt;rx_opt, 0);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;&#23384;&#22312;ACK&#26631;&#24535;&#30340;&#24773;&#20917;</span>
        <span style="color: #F92672;">if</span> (th-&gt;ack) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">rfc793:</span>
<span style="color: #75715E;">                 * "If the state is SYN-SENT then</span>
<span style="color: #75715E;">                 *    first check the ACK bit</span>
<span style="color: #75715E;">                 *      If the ACK bit is set</span>
<span style="color: #75715E;">                 *        If SEG.ACK =&lt; ISS, or SEG.ACK &gt; SND.NXT, send</span>
<span style="color: #75715E;">                 *        a reset (unless the RST bit is set, if so drop</span>
<span style="color: #75715E;">                 *        the segment and return)"</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 *  We do not send data with SYN, so that RFC-correct</span>
<span style="color: #75715E;">                 *  test reduces to:</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #F92672;">if</span> (TCP_SKB_CB(skb)-&gt;ack_seq != tp-&gt;snd_nxt)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">reset_and_undo</span>;

                <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.saw_tstamp &amp;&amp; tp-&gt;rx_opt.rcv_tsecr &amp;&amp;
                    <span style="color: #E6DB74; font-weight: bold;">!</span>between(tp-&gt;rx_opt.rcv_tsecr, tp-&gt;retrans_stamp,
                             tcp_time_stamp)) {
                        NET_INC_STATS_BH(LINUX_MIB_PAWSACTIVEREJECTED);
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">reset_and_undo</span>;
                }

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Now ACK is acceptable.</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 * "If the RST bit is set</span>
<span style="color: #75715E;">                 *    If the ACK was acceptable then signal the user "error:</span>
<span style="color: #75715E;">                 *    connection reset", drop the segment, enter CLOSED state,</span>
<span style="color: #75715E;">                 *    delete TCB, and return."</span>
<span style="color: #75715E;">                 */</span>
                 <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#25509;&#25910;&#30340;&#26159; ACK+RST,&#21017;&#38656;&#35201;&#35843;&#29992;tcp_reset(),&#21516;&#26102;&#36890;&#30693;&#36827;&#31243;&#65292;&#24182;&#20851;&#38381;&#22871;&#25509;&#21475;</span>
                <span style="color: #F92672;">if</span> (th-&gt;rst) {
                        tcp_reset(sk);
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;
                }

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">rfc793:</span>
<span style="color: #75715E;">                 *   "fifth, if neither of the SYN or RST bits is set then</span>
<span style="color: #75715E;">                 *    drop the segment and return."</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 *    See note below!</span>
<span style="color: #75715E;">                 *                                        --ANK(990513)</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>th-&gt;syn) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24517;&#39035;&#23384;&#22312;SYN&#26631;&#24535;&#65292;&#21542;&#21017;&#35748;&#20026;&#35813;&#27573;&#26080;&#25928;</span>
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard_and_undo</span>;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">rfc793:</span>
<span style="color: #75715E;">                 *   "If the SYN bit is on ...</span>
<span style="color: #75715E;">                 *    are acceptable then ...</span>
<span style="color: #75715E;">                 *    (our SYN has been ACKed), change the connection</span>
<span style="color: #75715E;">                 *    state to ESTABLISHED..."</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#39318;&#37096;&#20013;&#33719;&#21462;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;&#29305;&#24615;</span>
                TCP_ECN_rcv_synack(tp, th);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#19982;&#31383;&#21475;&#30456;&#20851;&#30340;&#21464;&#37327;</span>
                tp-&gt;snd_wl1 = TCP_SKB_CB(skb)-&gt;seq;
                tcp_ack(sk, skb, FLAG_SLOWPATH);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Ok.. it's good. Set up sequence numbers and</span>
<span style="color: #75715E;">                 * move to established.</span>
<span style="color: #75715E;">                 */</span>
                tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
                tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + 1;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">RFC1323: The window in SYN &amp; SYN/ACK segments is</span>
<span style="color: #75715E;">                 * never scaled.</span>
<span style="color: #75715E;">                 */</span>
                tp-&gt;snd_wnd = ntohs(th-&gt;window);
                tcp_init_wl(tp, TCP_SKB_CB(skb)-&gt;ack_seq, TCP_SKB_CB(skb)-&gt;seq);

                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tp-&gt;rx_opt.wscale_ok) {
                        tp-&gt;rx_opt.snd_wscale = tp-&gt;rx_opt.rcv_wscale = 0;
                        tp-&gt;window_clamp = min(tp-&gt;window_clamp, 65535U);
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26102;&#38388;&#25139;</span>
                <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.saw_tstamp) {
                        tp-&gt;rx_opt.tstamp_ok       = 1;
                        tp-&gt;tcp_header_len =
                                <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>) + TCPOLEN_TSTAMP_ALIGNED;
                        tp-&gt;advmss          -= TCPOLEN_TSTAMP_ALIGNED;
                        tcp_store_ts_recent(tp);
                } <span style="color: #F92672;">else</span> {
                        tp-&gt;tcp_header_len = <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>);
                }

                <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.sack_ok &amp;&amp; sysctl_tcp_fack)
                        tp-&gt;rx_opt.sack_ok |= 2;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">PMTU MSS &#31561;</span>
                tcp_mtup_init(sk);
                tcp_sync_mss(sk, icsk-&gt;icsk_pmtu_cookie);
                tcp_initialize_rcv_mss(sk);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Remember, tcp_poll() does not lock socket!</span>
<span style="color: #75715E;">                 * Change state from SYN-SENT only after copied_seq</span>
<span style="color: #75715E;">                 * is initialized.</span><span style="color: #75715E;"> */</span>
                tp-&gt;copied_seq = tp-&gt;rcv_nxt;
                smp_mb();
                tcp_set_state(sk, TCP_ESTABLISHED);

                security_inet_conn_established(sk, skb);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Make sure socket is routed, for correct metrics.</span><span style="color: #75715E;">  */</span>
                icsk-&gt;icsk_af_ops-&gt;rebuild_header(sk);

                tcp_init_metrics(sk);

                tcp_init_congestion_control(sk);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Prevent spurious tcp_cwnd_restart() on first data</span>
<span style="color: #75715E;">                 * packet.</span>
<span style="color: #75715E;">                 */</span>
                tp-&gt;lsndtime = tcp_time_stamp;

                tcp_init_buffer_space(sk);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#21551;&#29992;&#36830;&#25509;&#20445;&#27963;&#65292;&#21017;&#21551;&#29992;&#36830;&#25509;&#20445;&#27963;&#23450;&#26102;&#22120;</span>
                <span style="color: #F92672;">if</span> (sock_flag(sk, SOCK_KEEPOPEN))
                        inet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));

                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tp-&gt;rx_opt.snd_wscale) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#39318;&#37096;&#39044;&#27979;&#26631;&#24535;</span>
                        __tcp_fast_path_on(tp, tp-&gt;snd_wnd);
                <span style="color: #F92672;">else</span>
                        tp-&gt;pred_flags = 0;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#19981;&#22788;&#20110;SOCK_DEAD&#29366;&#24577;&#65292;&#21017;&#21796;&#37266;&#35813;&#22871;&#25509;&#21475;&#30340;&#36827;&#31243;</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sock_flag(sk, SOCK_DEAD)) {
                        sk-&gt;sk_state_change(sk);
                        sk_wake_async(sk, 0, POLL_OUT);
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36830;&#25509;&#24314;&#31435;&#23436;&#25104;&#65292;&#26681;&#25454;&#24773;&#20917;&#36827;&#20837;&#24310;&#26102;&#30830;&#35748;&#27169;&#24335;</span>
                <span style="color: #F92672;">if</span> (sk-&gt;sk_write_pending ||
                    icsk-&gt;icsk_accept_queue.rskq_defer_accept ||
                    icsk-&gt;icsk_ack.pingpong) {
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Save one ACK. Data will be ready after</span>
<span style="color: #75715E;">                         * several ticks, if write_pending is set.</span>
<span style="color: #75715E;">                         *</span>
<span style="color: #75715E;">                         * It may be deleted, but with this feature tcpdumps</span>
<span style="color: #75715E;">                         * look so _wonderfully_ clever, that I was not able</span>
<span style="color: #75715E;">                         * to stand against the temptation 8)     --ANK</span>
<span style="color: #75715E;">                         */</span>
                        inet_csk_schedule_ack(sk);
                        icsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;
                        icsk-&gt;icsk_ack.ato       = TCP_ATO_MIN;
                        tcp_incr_quickack(sk);
                        tcp_enter_quickack_mode(sk);
                        inet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,
                                                  TCP_DELACK_MAX, TCP_RTO_MAX);

<span style="color: #AE81FF;">discard</span>:
                        __kfree_skb(skb);
                        <span style="color: #F92672;">return</span> 0;
                } <span style="color: #F92672;">else</span> {
                        tcp_send_ack(sk);
                }
                <span style="color: #F92672;">return</span> -1;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">No ACK in the segment</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (th-&gt;rst) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">rfc793:</span>
<span style="color: #75715E;">                 * "If the RST bit is set</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 *      Otherwise (no ACK) drop the segment and return."</span>
<span style="color: #75715E;">                 */</span>

                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard_and_undo</span>;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">PAWS check.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; tp-&gt;rx_opt.saw_tstamp &amp;&amp; tcp_paws_check(&amp;tp-&gt;rx_opt, 0))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard_and_undo</span>;

        <span style="color: #F92672;">if</span> (th-&gt;syn) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">We see SYN without ACK. It is attempt of</span>
<span style="color: #75715E;">                 * simultaneous connect with crossed SYNs.</span>
<span style="color: #75715E;">                 * Particularly, it can be connect to self.</span>
<span style="color: #75715E;">                 */</span>
                tcp_set_state(sk, TCP_SYN_RECV);

                <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.saw_tstamp) {
                        tp-&gt;rx_opt.tstamp_ok = 1;
                        tcp_store_ts_recent(tp);
                        tp-&gt;tcp_header_len =
                                <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>) + TCPOLEN_TSTAMP_ALIGNED;
                } <span style="color: #F92672;">else</span> {
                        tp-&gt;tcp_header_len = <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>);
                }

                tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
                tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + 1;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">RFC1323: The window in SYN &amp; SYN/ACK segments is</span>
<span style="color: #75715E;">                 * never scaled.</span>
<span style="color: #75715E;">                 */</span>
                tp-&gt;snd_wnd    = ntohs(th-&gt;window);
                tp-&gt;snd_wl1    = TCP_SKB_CB(skb)-&gt;seq;
                tp-&gt;max_window = tp-&gt;snd_wnd;

                TCP_ECN_rcv_syn(tp, th);

                tcp_mtup_init(sk);
                tcp_sync_mss(sk, icsk-&gt;icsk_pmtu_cookie);
                tcp_initialize_rcv_mss(sk);


                tcp_send_synack(sk);
<span style="color: #F92672;">#if</span> 0
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Note, we could accept data and URG from this segment.</span>
<span style="color: #75715E;">                 * There are no obstacles to make this.</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 * However, if we ignore data in ACKless segments sometimes,</span>
<span style="color: #75715E;">                 * we have no reasons to accept it sometimes.</span>
<span style="color: #75715E;">                 * Also, seems the code doing it in step6 of tcp_rcv_state_process</span>
<span style="color: #75715E;">                 * is not flawless. So, discard packet for sanity.</span>
<span style="color: #75715E;">                 * Uncomment this return to process the data.</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #F92672;">return</span> -1;
<span style="color: #F92672;">#else</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;
<span style="color: #F92672;">#endif</span>
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">"fifth, if neither of the SYN or RST bits is set then</span>
<span style="color: #75715E;">         * drop the segment and return."</span>
<span style="color: #75715E;">         */</span>

<span style="color: #AE81FF;">discard_and_undo</span>:
        tcp_clear_options(&amp;tp-&gt;rx_opt);
        tp-&gt;rx_opt.mss_clamp = saved_clamp;
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;

<span style="color: #AE81FF;">reset_and_undo</span>:
        tcp_clear_options(&amp;tp-&gt;rx_opt);
        tp-&gt;rx_opt.mss_clamp = saved_clamp;
        <span style="color: #F92672;">return</span> 1;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4366c34" class="outline-3">
<h3 id="org4366c34"><span class="section-number-3">8.3.</span> 第三次握手：发送ACK段</h3>
<div class="outline-text-3" id="text-8-3">
<p>
tcp_send_ack()用来发送ACK段，同时更新窗口。
</p>
<ul class="org-ul">
<li>发送ACK段时，TCP必须不在CLOSE状态。</li>
<li>为ACK段分配一个SKB，如果分配失败则在启动延时确认定时器后返回。</li>
<li>如果分配SKB成功，则设置SKB中相关的参数，如标志、GSO属性等。</li>
<li>最后设置TCP序号和发送时间，调用tcp_transmit_skb() 发送ACK段。</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org9ea0a88" class="outline-2">
<h2 id="org9ea0a88"><span class="section-number-2">9.</span> 同时打开</h2>
<div class="outline-text-2" id="text-9">
<p>
每一端必须发送一个SYN，并且这两个SYN都传递到对端，这需要两端使用一个对端熟知的端口作为本地端口，此时成为同时打开。
</p>

<p>
出现同时打开的情况时，两端几乎同时发送SYN并进入SYN_SENT状态; 当对端都受到SYN后状态变为SYN_RECV状态，此时发送SYN并对受到的SYN进行确认，当双方都受到对端的SYN和ACK后，状态变为ESTABLISHED。
</p>
</div>

<div id="outline-container-org6b00fbe" class="outline-3">
<h3 id="org6b00fbe"><span class="section-number-3">9.1.</span> SYN_SENT状态接收到SYN段</h3>
<div class="outline-text-3" id="text-9-1">
<p>
SYN_SENT状态下收到的段除了紧急数据之外，其他都由 tcp_rcv_synsent_state_process()处理。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_rcv_synsent_state_process</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>,
                                         <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        <span style="color: #F92672;">if</span> (th-&gt;syn) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;&#25509;&#25910;&#21040;SYN,&#20294;&#26159;&#27809;&#26377;ACK&#30340;&#24773;&#20917;&#65288;&#21516;&#26102;&#25171;&#24320;&#65289;</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">We see SYN without ACK. It is attempt of</span>
<span style="color: #75715E;">                 * simultaneous connect with crossed SYNs.</span>
<span style="color: #75715E;">                 * Particularly, it can be connect to self.</span>
<span style="color: #75715E;">                 */</span>  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#20026;SYN_RECV&#29366;&#24577;</span>
                tcp_set_state(sk, TCP_SYN_RECV);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26102;&#38388;&#25139;</span>
                <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.saw_tstamp) {
                        tp-&gt;rx_opt.tstamp_ok = 1;
                        tcp_store_ts_recent(tp);
                        tp-&gt;tcp_header_len =
                                <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>) + TCPOLEN_TSTAMP_ALIGNED;
                } <span style="color: #F92672;">else</span> {
                        tp-&gt;tcp_header_len = <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>);
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#31383;&#21475;&#30456;&#20851;&#30340;&#25104;&#21592;&#21464;&#37327;</span>
                tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
                tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + 1;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">RFC1323: The window in SYN &amp; SYN/ACK segments is</span>
<span style="color: #75715E;">                 * never scaled.</span>
<span style="color: #75715E;">                 */</span>
                tp-&gt;snd_wnd    = ntohs(th-&gt;window);
                tp-&gt;snd_wl1    = TCP_SKB_CB(skb)-&gt;seq;
                tp-&gt;max_window = tp-&gt;snd_wnd;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#39318;&#37096;&#20013;&#33719;&#21462;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;&#29305;&#24615;</span>
                TCP_ECN_rcv_syn(tp, th);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">PMTU MSS&#31561;&#25104;&#21592;&#30340;&#21021;&#22987;&#21270;</span>
                tcp_mtup_init(sk);
                tcp_sync_mss(sk, icsk-&gt;icsk_pmtu_cookie);
                tcp_initialize_rcv_mss(sk);

                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;SYN+ACK</span>
                tcp_send_synack(sk);
<span style="color: #F92672;">#if</span> 0
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Note, we could accept data and URG from this segment.</span>
<span style="color: #75715E;">                 * There are no obstacles to make this.</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 * However, if we ignore data in ACKless segments sometimes,</span>
<span style="color: #75715E;">                 * we have no reasons to accept it sometimes.</span>
<span style="color: #75715E;">                 * Also, seems the code doing it in step6 of tcp_rcv_state_process</span>
<span style="color: #75715E;">                 * is not flawless. So, discard packet for sanity.</span>
<span style="color: #75715E;">                 * Uncomment this return to process the data.</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #F92672;">return</span> -1;
<span style="color: #F92672;">#else</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;
<span style="color: #F92672;">#endif</span>
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">"fifth, if neither of the SYN or RST bits is set then</span>
<span style="color: #75715E;">         * drop the segment and return."</span>
<span style="color: #75715E;">         */</span>

<span style="color: #AE81FF;">discard_and_undo</span>:
        tcp_clear_options(&amp;tp-&gt;rx_opt);
        tp-&gt;rx_opt.mss_clamp = saved_clamp;
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">discard</span>;

<span style="color: #AE81FF;">reset_and_undo</span>:
        tcp_clear_options(&amp;tp-&gt;rx_opt);
        tp-&gt;rx_opt.mss_clamp = saved_clamp;
        <span style="color: #F92672;">return</span> 1;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd132c7" class="outline-3">
<h3 id="orgbd132c7"><span class="section-number-3">9.2.</span> SYN_RECV状态接收SYN+ACK段</h3>
<div class="outline-text-3" id="text-9-2">
<p>
SYN_RECV状态接收到SYN+ACK参见 tcp_rcv_state_process().
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:55</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
