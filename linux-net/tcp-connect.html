<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2022-04-25 Mon 22:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TCP连接的建立</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="nandfan" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
	     margin-bottom: .2em; }
  .subtitle { text-align: center;
	      font-size: medium;
	      font-weight: bold;
	      margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
	    padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">TCP连接的建立</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1d89f01">1. 服务端建立连接过程</a></li>
<li><a href="#org5a1296b">2. 连接相关的数据结构</a>
<ul>
<li><a href="#orgedee852">2.1. request_sock_queue结构</a></li>
<li><a href="#org0b76edb">2.2. listen_sock结构</a></li>
<li><a href="#orgb9ac1c0">2.3. tcp_request_sock结构</a>
<ul>
<li><a href="#org234ca4c">2.3.1. inet_request_sock</a></li>
<li><a href="#org7ce880f">2.3.2. request_sock结构</a></li>
</ul>
</li>
<li><a href="#org203cd61">2.4. request_sock_ops结构</a></li>
</ul>
</li>
<li><a href="#org6575b7b">3. bind系统调用</a>
<ul>
<li><a href="#org15dbc21">3.1. bind端口散列表</a></li>
<li><a href="#org5f7b9c8">3.2. 传输层接口实现</a></li>
</ul>
</li>
<li><a href="#orgb2feb55">4. listen系统调用</a>
<ul>
<li><a href="#org76dd6ed">4.1. inet_listen()</a></li>
<li><a href="#org97dcb82">4.2. inet_csk_listen_start监听操作</a></li>
<li><a href="#org0cf597d">4.3. 分配连接请求块散列表：reqsk_queue_alloc()</a></li>
</ul>
</li>
<li><a href="#org5462aa4">5. accept系统调用</a>
<ul>
<li><a href="#org76aa5b3">5.1. inet_accept()</a></li>
<li><a href="#org6b2ed99">5.2. 传输层的接口实现：inet_csk_accept()</a>
<ul>
<li><a href="#org5f3d8f8">5.2.1. 等待新建的连接：inet_csk_wait_for_connect</a></li>
<li><a href="#orga9857bd">5.2.2. 获取已建立的连接：reqsk_queue_get_child</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3ee8b28">6. 被动打开</a>
<ul>
<li><a href="#org0ceb93a">6.1. SYN cookies</a></li>
<li><a href="#org612a2eb">6.2. 第一次握手：接收SYN段</a>
<ul>
<li><a href="#org9162f30">6.2.1. LISTEN状态处理TCP段</a></li>
<li><a href="#org41b9ea0">6.2.2. LISTEN状态处理SYN段</a></li>
<li><a href="#orgf9c5e7e">6.2.3. 连接请求处理：tcp_v4_conn_request</a></li>
<li><a href="#org42733dc">6.2.4. 从SKB的控制块中获取IP选项：tcp_v4_save_options()</a></li>
<li><a href="#org728d19d">6.2.5. 将连接请求块保存到父传输控制块的散列表中</a></li>
<li><a href="#orga47b3ce">6.2.6. 更新该传输控制块上已请求连接块的数量</a></li>
<li><a href="#org346d380">6.2.7. 函数调用关系</a></li>
</ul>
</li>
<li><a href="#org6b0a93f">6.3. 第二次握手：发送SYN+ACK段</a>
<ul>
<li><a href="#orgb650d71">6.3.1. 构造并发送SYN+ACK段</a></li>
<li><a href="#org55062cf">6.3.2. 获取路由入口</a></li>
<li><a href="#orgf5edb90">6.3.3. 构造SYN+ACK段</a></li>
</ul>
</li>
<li><a href="#org1764501">6.4. 第三次握手：接收ACK段</a>
<ul>
<li><a href="#org5e32992">6.4.1. LISTEN状态处理TCP段</a></li>
<li><a href="#orgc7688fb">6.4.2. 处理第三次握手的ACK段</a></li>
<li><a href="#org257fc62">6.4.3. 在SYN_RECV状态下处理TCP段</a></li>
<li><a href="#org143660f">6.4.4. 为新连接创建传输控制块</a></li>
<li><a href="#org98296e5">6.4.5. 为子连接创建传输控制块</a></li>
<li><a href="#orgf72b76b">6.4.6. 发送ACK段</a></li>
<li><a href="#org8e9db6f">6.4.7. 发送RST段</a></li>
<li><a href="#org6775931">6.4.8. 子传输控制块开始处理TCP段</a></li>
<li><a href="#orgdaa6d53">6.4.9. 子传输控制块SYN_RECV状态的ACK段的处理</a></li>
<li><a href="#org485c1dd">6.4.10. 函数调用关系</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4a9818c">7. connect系统调用</a>
<ul>
<li><a href="#orgab0a732">7.1. 套接口层实现：inet_stream_connect()</a></li>
<li><a href="#org8d6ecd1">7.2. 传输层的实现： tcp_v4_connect()</a></li>
</ul>
</li>
<li><a href="#org69ba3a7">8. 主动打开</a>
<ul>
<li><a href="#org7b2571b">8.1. 第一次握手：发送SYN段</a>
<ul>
<li><a href="#orgbde8115">8.1.1. 初始化客户端传输控制块并发送SYN段</a></li>
<li><a href="#org76804fa">8.1.2. 动态绑定端口： inet_hash_connect()</a></li>
<li><a href="#orgdb7f8ff">8.1.3. 构造SYN段并发送：tcp_connect()</a></li>
</ul>
</li>
<li><a href="#org3396490">8.2. 第二次握手： 接收SYN+ACK段</a>
<ul>
<li><a href="#orge2b6ce4">8.2.1. SYN_SENT状态的处理</a></li>
<li><a href="#org6f4af6b">8.2.2. 处理SYN+ACK段</a></li>
</ul>
</li>
<li><a href="#org4190c5f">8.3. 第三次握手：发送ACK段</a></li>
</ul>
</li>
<li><a href="#org6824b2f">9. 同时打开</a>
<ul>
<li><a href="#org10864c8">9.1. SYN_SENT状态接收到SYN段</a></li>
<li><a href="#orgc21fcc8">9.2. SYN_RECV状态接收SYN+ACK段</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org1d89f01" class="outline-2">
<h2 id="org1d89f01"><span class="section-number-2">1</span> 服务端建立连接过程</h2>
<div class="outline-text-2" id="text-1">
<p>
建立TCP连接的过程：
</p>
<ul class="org-ul">
<li>client发送SYN段，表示希望连接的服务器端口以及初始序号。</li>
<li>server发送一个包含server段初始序号以及对client SYN段确认的 SYN+ACK段作为应答，SYN占用一个序号，因此确认序号设置为client初始序号加1。</li>
<li>client发送确认序号为server初始序号加1的ACK段，对server的SYN段进行确认。</li>
</ul>

<p>
在TCP传输控制块 inet_connection_sock 结构中有个 request_sock_queue 结构类型的成员 <b>icsk_accept_queue</b> ，用来保存正在建立连接和已建立连接但未被accept的传输控制块。在request_sock_queue结构的rskq_accept_head 和 rskq_accept_tail 构成的链表中保存了已经我那成连接的连接请求块；在listen_sock结构实例的syn_table散列表中，保存着两个连接状态中的连接请求块，请求块之间使用dl_next形成链表。
</p>


<div class="figure">
<p><img src="image/tcp-connect/req-sock.png" alt="req-sock.png" />
</p>
<p><span class="figure-number">Figure 1: </span>请求连接数据结构间的关系</p>
</div>

<p>
虽然每个TCP传输控制块都有请求连接控制块 icsk_accept_queue，但最初创建时不完整，request_sock_queue结构的listen_opt指针为NULL，即还没有为保存SYN_RECV状态的请求连接控制块分配空间，如下图：
</p>


<div class="figure">
<p><img src="image/tcp-connect/no-complete-reqsock.png" alt="no-complete-reqsock.png" />
</p>
<p><span class="figure-number">Figure 2: </span>不完整的连接请求队列结构</p>
</div>

<p>
在调用listen系统调用时，使TCP进入LISTEN状态，同时还未保存SYN_RECV状态的请求连接控制块分配空间，其中syn_table散列表的大小油listen系统调用的参数backlog控制，分配后的结构如下图：
</p>


<div class="figure">
<p><img src="image/tcp-connect/req-sock.png" alt="req-sock.png" />
</p>
<p><span class="figure-number">Figure 3: </span>初始化后的连接请求队列结构</p>
</div>


<p>
listen调用后，套接口就可以接受新的连接了。当有客户端发送SYN段请求连接时，如果SYN合法，会为该连接请求创建连接请求块，并保存相应的信息（双方初始序号、启用的TCP选项等），这些信息由tcp_request_sock结构的描述。
</p>


<div class="figure">
<p><img src="image/tcp-connect/2-connecting-sock.png" alt="2-connecting-sock.png" />
</p>
<p><span class="figure-number">Figure 4: </span>接收了2个未完成连接的连接请求</p>
</div>


<p>
当服务端接收连接请求后，会建立相应的连接请求块，同时给对方发送SYN+ACK段作为回应。服务端再次收到客户端的ACK确认时，才会真正的为连接创建一个TCP传输控制块，并将其挂载到连接请求块的sk成员上，同时将该连接请求块移动到 rskq_accept_head 队列中，等待服务端accept调用，如下图：
</p>


<div class="figure">
<p><img src="image/tcp-connect/2-sock-1connect.png" alt="2-sock-1connect.png" />
</p>
<p><span class="figure-number">Figure 5: </span>接收了2个连接请求（一个完成连接，等待accept）</p>
</div>

<p>
调用accept系统调用时，从rskq_accept_head队列中取出请求传输控制块，与套接口相关联后释放该连接请求块，如下图，如果队列为空，则根据是否阻塞来决定是直接返回还是等待超时。
</p>


<div class="figure">
<p><img src="image/tcp-connect/2sock-1accept.png" alt="2sock-1accept.png" />
</p>
<p><span class="figure-number">Figure 6: </span>接收了2个连接请求（完成的连接被取走）</p>
</div>
</div>
</div>


<div id="outline-container-org5a1296b" class="outline-2">
<h2 id="org5a1296b"><span class="section-number-2">2</span> 连接相关的数据结构</h2>
<div class="outline-text-2" id="text-2">
<p>
TCP连接的建立需要经过三次握手，服务端需要保存待建立连接的相关信息并控制连接，request_sock_queue等结构就是用来存储这些信息。
</p>
</div>

<div id="outline-container-orgedee852" class="outline-3">
<h3 id="orgedee852"><span class="section-number-3">2.1</span> request_sock_queue结构</h3>
<div class="outline-text-3" id="text-2-1">
<p>
TCP传输控制块中，request_sock_queue 结构定义了用于存放连接请求块的容器，包括处于SYN_RECV状态以及已连接但还没被accept的传输控制块，inet_connection_sock结构中用成员 icsk_accept_queue 定义了该容器。
</p>




<div class="org-src-container">
<pre class="src src-c">
<span style="color: #CDC673;">/** struct request_sock_queue - queue of request_socks</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">@rskq_accept_head</span><span style="color: #CDC673;"> - FIFO head of established children</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">@rskq_accept_tail</span><span style="color: #CDC673;"> - FIFO tail of established children</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">@rskq_defer_accept</span><span style="color: #CDC673;"> - User waits for some data after </span><span style="color: #AF87FF;">accept()</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">@syn_wait_lock</span><span style="color: #CDC673;"> - serializer</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">%syn_wait_lock</span><span style="color: #CDC673;"> is necessary only to avoid proc interface having to grab the main</span>
<span style="color: #CDC673;"> * lock sock while browsing the listening hash (otherwise it's deadlock prone).</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> * This lock is acquired in read mode only from </span><span style="color: #AF87FF;">listening_get_next()</span><span style="color: #CDC673;"> seq_file</span>
<span style="color: #CDC673;"> * op and it's acquired in write mode _only_ from code that is actively</span>
<span style="color: #CDC673;"> * changing rskq_accept_head. All readers that are holding the master sock lock</span>
<span style="color: #CDC673;"> * don't need to grab this lock in read mode too as rskq_accept_head. writes</span>
<span style="color: #CDC673;"> * are always protected from the main sock lock.</span>
<span style="color: #CDC673;"> */</span>
<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock_queue</span> {
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20998;&#21035;&#25351;&#21521;&#24050;&#23436;&#25104;&#36830;&#25509;&#38142;&#34920;&#30340;&#39318;&#37096;&#21644;&#23614;&#37096;&#65292;listen_opt&#20013;&#30340;&#36830;&#25509;&#35831;&#27714;&#22359;&#36830;&#25509;&#21518;&#20250;&#31227;&#21160;&#21040;&#27492;&#38142;&#34920;&#65292;&#31561;&#24453;accept</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span>     *<span style="color: #FF8C00;">rskq_accept_head</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span>     *<span style="color: #FF8C00;">rskq_accept_tail</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35775;&#38382;listen_opt&#20197;&#21450;listen_sock&#32467;&#26500;&#25104;&#21592;&#30340;&#21516;&#27493;&#25511;&#21046;&#35835;&#20889;&#38145;</span>
	<span style="color: #5FD7FF;">rwlock_t</span>                <span style="color: #FF8C00;">syn_wait_lock</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20445;&#23384;&#30456;&#20851;&#22871;&#25509;&#21475;TCP&#23618;&#30340;TCP_DEFER_ACCEPT&#36873;&#39033;&#30340;&#20540;&#12290;</span>
	<span style="color: #5FD7FF;">u8</span>                      <span style="color: #FF8C00;">rskq_defer_accept</span>;
	<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#25351;&#21521;listen_sock&#32467;&#26500;&#30340;&#23454;&#20363;&#65292;&#22312;&#20390;&#21548;&#26102;&#24314;&#31435;</span><span style="color: #8B8878;">*/</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">listen_sock</span>      *<span style="color: #FF8C00;">listen_opt</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org0b76edb" class="outline-3">
<h3 id="org0b76edb"><span class="section-number-3">2.2</span> listen_sock结构</h3>
<div class="outline-text-3" id="text-2-2">
<p>
listen_sock结构用来存储连接请求块，该结构的实例在listen系统调用后才会被创建，request_sock_queue结构的listen_opt成员指向该实例。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">listen_sock</span> {
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23454;&#38469;&#20998;&#37197;&#29992;&#26469;&#20445;&#23384;SYN&#35831;&#27714;&#36830;&#25509;&#30340;request_sock&#32467;&#26500;&#25968;&#32452;&#30340;&#38271;&#24230;&#65292;&#20854;&#20540;&#20026;nr_table_entries&#20197;2&#20026;&#24213;&#30340;&#23545;&#25968;</span>
	<span style="color: #5FD7FF;">u8</span>                      <span style="color: #FF8C00;">max_qlen_log</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#24403;&#21069;&#36830;&#25509;&#35831;&#27714;&#22359;&#30340;&#25968;&#30446;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">int</span>                     <span style="color: #FF8C00;">qlen</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24403;&#21069;&#26410;&#37325;&#20256;&#36807;SYN+ACK&#27573;&#30340;&#35831;&#27714;&#22359;&#25968;&#30446;&#12290;</span>
	<span style="color: #5FD7FF;">int</span>                     <span style="color: #FF8C00;">qlen_young</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#29992;&#26469;&#35760;&#24405;&#36830;&#25509;&#24314;&#31435;&#23450;&#26102;&#22120;&#22788;&#29702;&#20989;&#25968;&#19979;&#27425;&#34987;&#28608;&#27963;&#26102;&#24464;&#22788;&#29702;&#30340;&#36830;&#25509;&#35831;&#27714;&#22359;&#25955;&#21015;&#34920;&#20837;&#21475;&#65292; &#22312;&#26412;&#27425;&#22788;&#29702;</span>
<span style="color: #8B8878;">        &#32467;&#26463;&#26102;&#23558;&#24403;&#21069;&#30340;&#20837;&#21475;&#20445;&#23384;&#21040;&#35813;&#23383;&#27573;&#65292;&#19979;&#27425;&#20174;&#35813;&#20301;&#32622;&#22788;&#29702;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">int</span>                     <span style="color: #FF8C00;">clock_hand</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#26469;&#35745;&#31639;SYN&#35831;&#27714;&#22359;&#25955;&#21015;&#34920;&#38190;&#20540;&#30340;&#38543;&#26426;&#25968;&#65292;&#35813;&#20540;&#22312;reqsk_queue_alloc()&#20013;&#38543;&#26426;&#29983;&#25104;</span>
	<span style="color: #5FD7FF;">u32</span>                     <span style="color: #FF8C00;">hash_rnd</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23454;&#38469;&#20998;&#37197;&#29992;&#26469;&#20445;&#23384;syn&#35831;&#27714;&#36830;&#25509;&#30340;request_sock&#32467;&#26500;&#25968;&#32452;&#30340;&#38271;&#24230;</span>
	<span style="color: #5FD7FF;">u32</span>                     <span style="color: #FF8C00;">nr_table_entries</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">request_sock&#32467;&#26500;&#25955;&#21015;&#34920;&#65292;&#35843;&#29992;listen&#26102;&#29983;&#25104;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span>     *<span style="color: #FF8C00;">syn_table</span>[0];
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb9ac1c0" class="outline-3">
<h3 id="orgb9ac1c0"><span class="section-number-3">2.3</span> tcp_request_sock结构</h3>
<div class="outline-text-3" id="text-2-3">
<p>
tcp_request_sock结构作为TCP连接请求块，用来保存双方的初始序号、双方的端口及IP地址、TCP选项，如是否支持窗口扩大因子、是否支持SACK等，并控制连接建立。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_request_sock</span> {
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_request_sock</span>        <span style="color: #FF8C00;">req</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23458;&#25143;&#31471;&#30340;&#21021;&#22987;&#24207;&#21495;&#65292;&#25509;&#25910;&#21040;&#23458;&#25143;&#31471;&#36830;&#25509;&#35831;&#27714;SYN&#27573;&#30340;&#24207;&#21495;</span>
	<span style="color: #5FD7FF;">u32</span>                             <span style="color: #FF8C00;">rcv_isn</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26381;&#21153;&#31471;&#30340;&#21021;&#22987;&#24207;&#21495;&#65292;&#26381;&#21153;&#31471;&#21457;&#36865;SYN+ACK&#27573;&#30340;&#24207;&#21495;</span>
	<span style="color: #5FD7FF;">u32</span>                             <span style="color: #FF8C00;">snt_isn</span>;
};
</pre>
</div>
</div>

<div id="outline-container-org234ca4c" class="outline-4">
<h4 id="org234ca4c"><span class="section-number-4">2.3.1</span> inet_request_sock</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
用来构成tcp_request_sock结构开头的部分，主要描述双方的地址、支持的TCP选项等。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_request_sock</span> {
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span>     <span style="color: #FF8C00;">req</span>;
	<span style="color: #5FD7FF;">u16</span>                     <span style="color: #FF8C00;">inet6_rsk_offset</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">2 bytes hole, try to pack</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">__be32</span>                  <span style="color: #FF8C00;">loc_addr</span>;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26412;&#22320;IP&#22320;&#22336;</span>
	<span style="color: #5FD7FF;">__be32</span>                  <span style="color: #FF8C00;">rmt_addr</span>;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23545;&#31471;IP&#22320;&#22336;</span>
	<span style="color: #5FD7FF;">__be16</span>                  <span style="color: #FF8C00;">rmt_port</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23545;&#31471;&#31471;&#21475;</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#65292;&#23558;TCP&#39318;&#37096;&#25351;&#23450;&#30340;&#28369;&#21160;&#31383;&#21475;&#22823;&#23567;&#24038;&#31227;snd_wscale&#21518;&#25165;&#26159;&#30495;&#27491;&#30340;&#31383;&#21475;&#22823;&#23567;&#12290;</span>
	<span style="color: #5FD7FF;">u16</span>                     <span style="color: #FF8C00;">snd_wscale</span> : 4,
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;</span>
				<span style="color: #FF8C00;">rcv_wscale</span> : 4,
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#23384;&#22312;TCP&#26102;&#38388;&#25139;&#36873;&#39033;</span>
				<span style="color: #FF8C00;">tstamp_ok</span>  : 1,
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#25903;&#25345;SACK&#65292;&#25903;&#25345;&#21017;&#21487;&#20197;&#20986;&#29616;&#22312;SYN&#27573;&#20013;&#12290;</span>
				<span style="color: #FF8C00;">sack_ok</span>    : 1,
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#25903;&#25345;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#65292;&#25903;&#25345;&#21017;&#21487;&#20197;&#20986;&#29616;&#22312;SYN&#27573;&#20013;&#12290;</span>
				<span style="color: #FF8C00;">wscale_ok</span>  : 1,
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#21551;&#29992;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;</span>
				<span style="color: #FF8C00;">ecn_ok</span>     : 1,
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26631;&#35782;&#24050;&#32463;&#25509;&#25910;&#21040;&#31532;&#19977;&#27425;&#25569;&#25163;&#30340;ACK&#27573;&#65292;&#20294;&#26159;&#30001;&#20110;&#26381;&#21153;&#22120;&#30340;&#21407;&#22240;&#23548;&#33268;&#27809;&#33021;&#24314;&#31435;&#36830;&#25509;&#65292;&#21487;&#20197;&#26681;&#25454;&#35813;&#26631;&#24535;&#20877;&#27425;&#21457;&#36865;SYN+ACK,&#24314;&#31435;&#36830;&#25509;&#12290;</span>
				<span style="color: #FF8C00;">acked</span>      : 1;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25351;&#21521;IP&#36873;&#39033;&#25968;&#25454;&#32467;&#26500;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span>       *<span style="color: #FF8C00;">opt</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org7ce880f" class="outline-4">
<h4 id="org7ce880f"><span class="section-number-4">2.3.2</span> request_sock结构</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
该结构用来构成 inet_request_sock结构的起始部分，主要描述对端MSS、本段接收窗口大小及控制连接操作的信息。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">struct request_sock - mini sock to represent a connection request</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> {
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;request_sock &#32467;&#26500;&#23454;&#20363;&#36830;&#25509;&#38142;&#34920;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span>             *<span style="color: #FF8C00;">dl_next</span>; <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Must be first member!</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23458;&#25143;&#31471;&#36830;&#25509;&#35831;&#27714;&#36890;&#21578;&#30340;MSS&#12290;&#27809;&#26377;&#36890;&#21578;&#21017;&#20351;&#29992;&#21021;&#22987;&#20540;&#65288;RFC&#24314;&#35758;536&#65289;</span>
	<span style="color: #5FD7FF;">u16</span>                             <span style="color: #FF8C00;">mss</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;SYN+ACK&#27573;&#30340;&#27425;&#25968;&#12290;&#24403;&#36798;&#21040;&#38480;&#21046;&#26102;&#65292;&#21462;&#28040;&#36830;&#25509;&#25805;&#20316;</span>
	<span style="color: #5FD7FF;">u8</span>                              <span style="color: #FF8C00;">retrans</span>;
	<span style="color: #5FD7FF;">u8</span>                              <span style="color: #FF8C00;">__pad</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">The following two fields can be easily recomputed I think -AK</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26412;&#31471;&#26368;&#22823;&#36890;&#21578;&#31383;&#21475;&#65292;&#22312;&#29983;&#25104;SYN+ACK&#26102;&#35745;&#31639;&#35813;&#20540;</span>
	<span style="color: #5FD7FF;">u32</span>                             <span style="color: #FF8C00;">window_clamp</span>; <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">window clamp at creation time</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36830;&#25509;&#24314;&#31435;&#26102;&#26412;&#31471;&#25509;&#25910;&#31383;&#21475;&#30340;&#22823;&#23567;&#65292;&#22312;&#29983;&#25104;SYN+ACK&#26102;&#35745;&#31639;&#35813;&#20540;</span>
	<span style="color: #5FD7FF;">u32</span>                             <span style="color: #FF8C00;">rcv_wnd</span>;          <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">rcv_wnd offered first time</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19979;&#19968;&#20010;&#23558;&#35201;&#21457;&#36865;ACK&#20013;&#30340;&#26102;&#38388;&#25139;&#20540;&#12290;&#24403;&#19968;&#20010;&#21253;&#21547;&#26368;&#21518;&#21457;&#36865;ACK&#30830;&#35748;&#24207;&#21495;&#30340;&#27573;&#21040;&#36798;&#26102;&#65292;&#35813;&#27573;&#20013;&#30340;&#26102;&#38388;&#25139;&#34987;&#20445;&#23384;&#22312;ts_recent&#20013;&#12290;</span>
	<span style="color: #5FD7FF;">u32</span>                             <span style="color: #FF8C00;">ts_recent</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26381;&#21153;&#31471;&#25509;&#25910;&#21040;&#36830;&#25509;&#35831;&#27714;&#65292;&#24182;&#21457;&#36865;SYN+ACK&#27573;&#20316;&#20026;&#24212;&#31572;&#21518;&#65292;&#31561;&#24453;&#23458;&#25143;&#31471;&#30830;&#35748;&#30340;&#36229;&#26102;&#26102;&#38388;&#65292;&#36229;&#26102;&#21518;&#21457;&#36865;SYN+ACK&#65292;&#30452;&#21040;&#27425;&#25968;&#36798;&#21040;&#19978;&#38480;</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>                   <span style="color: #FF8C00;">expires</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#36830;&#25509;&#35831;&#27714;&#30340;&#20989;&#25968;&#25351;&#38024;&#34920;&#65292;tcp&#20013;&#25351;&#21521;tcp_request_sock_ops</span>
	<span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock_ops</span>   *<span style="color: #FF8C00;">rsk_ops</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25351;&#21521;&#23545;&#24212;&#29366;&#24577;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#36830;&#25509;&#24314;&#31435;&#21069;&#26080;&#25928;&#65292;&#25569;&#25163;&#25104;&#21151;&#21518;&#20250;&#24314;&#31435;&#23545;&#24212;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#12290;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span>                     *<span style="color: #FF8C00;">sk</span>;
	<span style="color: #5FD7FF;">u32</span>                             <span style="color: #FF8C00;">secid</span>;
	<span style="color: #5FD7FF;">u32</span>                             <span style="color: #FF8C00;">peer_secid</span>;
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org203cd61" class="outline-3">
<h3 id="org203cd61"><span class="section-number-3">2.4</span> request_sock_ops结构</h3>
<div class="outline-text-3" id="text-2-4">
<p>
request_sock_ops结构用来描述处理连接请求的函数指针表，包括用于发送SYN+ACK段、ACK段、RST段的函数。 该结构作为request_sock的成员，可以方便的通过连接请求块索引这些接口。TCP中指向tcp_request_sock_ops。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock_ops</span> {
	<span style="color: #5FD7FF;">int</span>             <span style="color: #FF8C00;">family</span>;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25152;&#23646;&#21327;&#35758;&#26063;</span>
	<span style="color: #5FD7FF;">int</span>             <span style="color: #FF8C00;">obj_size</span>;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">tcp_request_sock&#32467;&#26500;&#30340;&#38271;&#24230;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">kmem_cache</span>       *<span style="color: #FF8C00;">slab</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36830;&#25509;&#35831;&#27714;&#22359;&#30340;&#39640;&#36895;&#32531;&#23384;slab</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;SYN+ACK&#27573;&#30340;&#20989;&#25968;&#25351;&#38024;&#65288;tcp_v4_send_synack()&#65289;</span>
	<span style="color: #5FD7FF;">int</span>             (*<span style="color: #87D700;">rtx_syn_ack</span>)(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,
				   <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span>,
				   <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">dst_entry</span> *<span style="color: #FF8C00;">dst</span>);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;ACK&#27573;&#30340;&#20989;&#25968;&#25351;&#38024;&#65288;tcp_v4_reqsk_send_ack()&#65289;</span>
	<span style="color: #5FD7FF;">void</span>    (*<span style="color: #87D700;">send_ack</span>)(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,
				<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span>);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;RST&#27573;&#30340;&#20989;&#25968;&#25351;&#38024;&#65288;tcp_v4_send_reset()&#65289;</span>
	<span style="color: #5FD7FF;">void</span>    (*<span style="color: #87D700;">send_reset</span>)(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,
				  <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26512;&#26500;&#20989;&#25968;&#65292;&#37322;&#25918;&#36830;&#25509;&#35831;&#27714;&#22359;&#26102;&#35843;&#29992;&#65288;tcp_v4_reqsk_destructor()&#65289;</span>
	<span style="color: #5FD7FF;">void</span>    (*<span style="color: #87D700;">destructor</span>)(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span>);
};
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org6575b7b" class="outline-2">
<h2 id="org6575b7b"><span class="section-number-2">3</span> bind系统调用</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org15dbc21" class="outline-3">
<h3 id="org15dbc21"><span class="section-number-3">3.1</span> bind端口散列表</h3>
<div class="outline-text-3" id="text-3-1">
<p>
tcp中使用 inet_bind_hashbucket 散列表来管理已绑定端口。该散列表在TCP初始化时，根据ehash散列表的大小ehash_size调整创建，bind端口实例通过node成员连接在散列表中。
</p>



<div class="figure">
<p><img src="image/tcp-connect/bind-st.png" alt="bind-st.png" />
</p>
<p><span class="figure-number">Figure 7: </span>已经bind端口的结构</p>
</div>

<ul class="org-ul">
<li>inet_bind_bucket_create()，用来在bind_bucket_cachep高速缓存中分配bind端口实例，设置后将其添加到inet_bind_hashbucket散列表。</li>

<li>inet_bind_bucket_destory()，将指定的bind端口实例从inet_bind_hashbucket散列表中删除并释放。</li>
</ul>
</div>
</div>

<div id="outline-container-org5f7b9c8" class="outline-3">
<h3 id="org5f7b9c8"><span class="section-number-3">3.2</span> 传输层接口实现</h3>
<div class="outline-text-3" id="text-3-2">
<p>
bind系统调用通过套接口层的inet_bind()函数跳转到tcp的接口函数 tcp_v4_get_port(), 最终调用 inet_csk_get_port()。
</p>

<p>
如果绑定的本地端口为0，则自动分配一个可用端口。
</p>

<p>
如果指定了端口号，则从已绑定的端口信息中查找，找到则该端口已被使用，如果不能复用，则bind失败；没有找到，则创建新的bind信息块，添加到散列表。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Obtain a reference to a local port for the given sock,</span>
<span style="color: #8B8878;"> * if snum is zero it means select any available local port.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">inet_csk_get_port</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_hashinfo</span> *<span style="color: #FF8C00;">hashinfo</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">tcp&#25955;&#21015;&#34920;&#31649;&#29702;&#32467;&#26500;&#23454;&#20363; tcp_hashinfo</span>
		      <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">short</span> <span style="color: #FF8C00;">snum</span>,<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35201;&#32465;&#23450;&#30340;&#31471;&#21475;&#21495;</span>
		      <span style="color: #5FD7FF;">int</span> (*<span style="color: #87D700;">bind_conflict</span>)(<span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,
					   <span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_bind_bucket</span> *<span style="color: #FF8C00;">tb</span>))
<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">bind_conflict &#20989;&#25968;&#25351;&#38024;&#65292;&#29992;&#26469;&#22312;&#25351;&#23450;&#31471;&#21475;&#20449;&#24687;&#22359;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#38142;&#34920;&#19978;&#26597;&#25214;&#26159;&#21542;&#23384;&#22312;&#19982;&#24453;&#32465;&#23450;&#20256;&#36755;&#25511;&#21046;&#22359;&#20914;&#31361;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#12290;tcp&#20013;&#20351;&#29992; inet_csk_bind_conflict()&#12290;</span>

<span style="color: #8B8878;">&#20914;&#31361;&#38656;&#35201;&#28385;&#36275;&#19977;&#20010;&#26465;&#20214;&#65306;</span>
<span style="color: #8B8878;">    1. &#20256;&#36755;&#25511;&#21046;&#22359;&#38142;&#34920;&#19978;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#19982;&#24453;&#32465;&#23450;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#25968;&#25454;&#21253;&#36755;&#20986;&#35774;&#22791;&#30340;&#32034;&#24341;&#21495;&#30456;&#31561;&#65292;&#25110;&#20854;&#20013;&#20219;&#20309;&#19968;&#20010;&#20026;0&#12290;</span>
<span style="color: #8B8878;">    2. &#20004;&#32773;&#20043;&#38388;&#20219;&#20309;&#19968;&#20010;&#37117;&#27809;&#26377;&#31471;&#21475;&#22797;&#29992;&#65292;&#25110;&#32773;&#38142;&#34920;&#19978;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#19981;&#22788;&#20110;TCP_LISTEN&#29366;&#24577;&#12290;</span>
<span style="color: #8B8878;">    3. &#20004;&#32773;&#30340;&#28304;&#22320;&#22336;&#30456;&#31561;&#65292;&#25110;&#32773;&#20219;&#20309;&#19968;&#20010;&#28304;&#22320;&#22336;&#20026;0&#12290;</span>
<span style="color: #8B8878;">*/</span>
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_bind_hashbucket</span> *<span style="color: #FF8C00;">head</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">hlist_node</span> *<span style="color: #FF8C00;">node</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_bind_bucket</span> *<span style="color: #FF8C00;">tb</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ret</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31105;&#27490;&#19979;&#21322;&#37096;&#65292;&#20445;&#35777;&#36827;&#31243;&#21644;&#19979;&#21322;&#37096;&#20043;&#38388;&#21516;&#27493;&#12290;&#22240;&#20026;&#21518;&#32493;&#25805;&#20316;&#20013;&#26377;&#20123;&#25968;&#25454;&#21487;&#33021;&#34987;&#36827;&#31243;&#21644;&#19979;&#21322;&#37096;&#21516;&#26102;&#35775;&#38382;&#12290;</span>
	local_bh_disable();
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>snum) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31471;&#21475;&#20026;0&#65292;&#34920;&#31034;&#27809;&#26377;&#25351;&#23450;&#31471;&#21475;&#65292;&#36827;&#34892;&#20998;&#37197;</span>
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">low</span> = sysctl_local_port_range[0];   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33258;&#21160;&#20998;&#37197;&#31471;&#21475;&#30340;&#21306;&#38388;</span>
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">high</span> = sysctl_local_port_range[1];
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">remaining</span> = (high - low) + 1;   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20998;&#37197;&#31471;&#21475;&#30340;&#37325;&#35797;&#27425;&#25968;</span>
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">rover</span> = net_random() % (high - low) + low;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29983;&#25104;&#21306;&#38388;&#20869;&#30340;&#38543;&#26426;&#31471;&#21475;&#21495;</span>

		<span style="color: #FF1493;">do</span> {
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20808;&#26681;&#25454;&#31471;&#21475;&#33719;&#21462;hash&#20540;&#23545;&#24212;&#30340;&#31471;&#21475;&#38142;&#34920;</span>
			head = &amp;hashinfo-&gt;bhash[inet_bhashfn(rover, hashinfo-&gt;bhash_size)];
			spin_lock(&amp;head-&gt;lock);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21152;&#38145;&#20934;&#22791;&#36941;&#21382;</span>
			inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain)
				<span style="color: #FF1493;">if</span> (tb-&gt;port == rover) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31471;&#21475;&#24050;&#34987;&#20351;&#29992;</span>
					<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">next</span>;
			<span style="color: #FF1493;">break</span>;
		<span style="color: #AF87FF;">next</span>:
			spin_unlock(&amp;head-&gt;lock);
			<span style="color: #FF1493;">if</span> (++rover &gt; high)  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31471;&#21475;&#21152;1&#26159;&#21542;&#36229;&#36807;&#21306;&#38388;</span>
				rover = low;
		} <span style="color: #FF1493;">while</span> (--remaining &gt; 0);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#37325;&#35797;&#27425;&#25968;&#36882;&#20943;</span>

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Exhausted local port range during search?  It is not</span>
<span style="color: #8B8878;">                 * possible for us to be holding one of the bind hash</span>
<span style="color: #8B8878;">                 * locks if this test triggers, because if 'remaining'</span>
<span style="color: #8B8878;">                 * drops to zero, we broke out of the do/while loop at</span>
<span style="color: #8B8878;">                 * the top level, not from the 'break;' statement.</span>
<span style="color: #8B8878;">                 */</span>
		ret = 1;
		<span style="color: #FF1493;">if</span> (remaining &lt;= 0)  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#37325;&#35797;&#27425;&#25968;&#29992;&#23436;&#65292;&#21017;&#33719;&#21462;&#31471;&#21475;&#22833;&#36133;</span>
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">fail</span>;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">OK, here is the one we will use.  HEAD is</span>
<span style="color: #8B8878;">                 * non-NULL and we hold it's mutex.</span>
<span style="color: #8B8878;">                 */</span>
		snum = rover;
	} <span style="color: #FF1493;">else</span> { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25351;&#23450;&#20102;&#31471;&#21475;&#21495;</span>
		head = &amp;hashinfo-&gt;bhash[inet_bhashfn(snum, hashinfo-&gt;bhash_size)];
		spin_lock(&amp;head-&gt;lock);
		inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain)
			<span style="color: #FF1493;">if</span> (tb-&gt;port == snum) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31471;&#21475;&#24050;&#32463;&#34987;&#20351;&#29992;</span>
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">tb_found</span>;
	}
	tb = <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">tb_not_found</span>;
<span style="color: #AF87FF;">tb_found</span>:
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>hlist_empty(&amp;tb-&gt;owners)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#26377;&#23545;&#24212;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#65288;&#26159;&#21542;&#26377;&#36827;&#31243;&#22312;&#20351;&#29992;&#65289;</span>
		<span style="color: #FF1493;">if</span> (sk-&gt;sk_reuse &gt; 1) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21487;&#20197;&#24378;&#21046;&#22797;&#29992;&#31471;&#21475;</span>
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">success</span>;
		<span style="color: #FF1493;">if</span> (tb-&gt;fastreuse &gt; 0 &amp;&amp;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21487;&#20197;&#34987;&#22797;&#29992;</span>
		    sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36755;&#25511;&#21046;&#22359;&#21487;&#22797;&#29992;&#31471;&#21475;&#19988;&#19981;&#22788;&#20110; TCP_LISTEN&#29366;&#24577;</span>
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">success</span>;
		} <span style="color: #FF1493;">else</span> {
			ret = 1;
			<span style="color: #FF1493;">if</span> (bind_conflict(sk, tb)) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;&#22797;&#29992;&#31471;&#21475;&#26159;&#21542;&#20914;&#31361;</span>
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">fail_unlock</span>;
		}
	}
<span style="color: #AF87FF;">tb_not_found</span>:  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31471;&#21475;&#27809;&#26377;&#34987;&#20351;&#29992;&#65292;&#21017;&#21019;&#24314;&#32465;&#23450;&#31471;&#21475;&#20449;&#24687;</span>
	ret = 1;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tb &amp;&amp; (tb = inet_bind_bucket_create(hashinfo-&gt;bind_bucket_cachep, head, snum)) == <span style="color: #AF87FF;">NULL</span>)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">fail_unlock</span>;
	<span style="color: #FF1493;">if</span> (hlist_empty(&amp;tb-&gt;owners)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31471;&#21475;&#36824;&#27809;&#26377;&#34987;&#32465;&#23450;</span>
		<span style="color: #FF1493;">if</span> (sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36755;&#25511;&#21046;&#22359;&#20801;&#35768;&#22797;&#29992;&#31471;&#21475;</span>
			tb-&gt;fastreuse = 1;
		<span style="color: #FF1493;">else</span>
			tb-&gt;fastreuse = 0;
	} <span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (tb-&gt;fastreuse &amp;&amp;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31471;&#21475;&#24050;&#34987;&#32465;&#23450;</span>
		   (<span style="color: #CDC673; font-weight: bold;">!</span>sk-&gt;sk_reuse || sk-&gt;sk_state == TCP_LISTEN)) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36755;&#25511;&#21046;&#22359;&#19981;&#20801;&#35768;&#22797;&#29992;&#31471;&#21475;&#65292;&#25110;&#32773;&#22788;&#20110;TCP_LISTEN</span>
		tb-&gt;fastreuse = 0;
<span style="color: #AF87FF;">success</span>:
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>inet_csk(sk)-&gt;icsk_bind_hash)
		inet_bind_hash(sk, tb, snum);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23436;&#25104;&#20256;&#36755;&#25511;&#21046;&#22359;&#21644;&#31471;&#21475;&#30340;&#32465;&#23450;</span>
	BUG_TRAP(inet_csk(sk)-&gt;icsk_bind_hash == tb);
	ret = 0;

<span style="color: #AF87FF;">fail_unlock</span>:
	spin_unlock(&amp;head-&gt;lock);
<span style="color: #AF87FF;">fail</span>:
	local_bh_enable();
	<span style="color: #FF1493;">return</span> ret;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgb2feb55" class="outline-2">
<h2 id="orgb2feb55"><span class="section-number-2">4</span> listen系统调用</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org76dd6ed" class="outline-3">
<h3 id="org76dd6ed"><span class="section-number-3">4.1</span> inet_listen()</h3>
<div class="outline-text-3" id="text-4-1">
<p>
inet_listen()函数是listen系统调用的套接口层实现。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      Move a socket into listening state.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">inet_listen</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">socket</span> *<span style="color: #FF8C00;">sock</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">backlog</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span> = sock-&gt;sk;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">old_state</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;

	lock_sock(sk);

	err = -EINVAL;
	<span style="color: #FF1493;">if</span> (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;

	old_state = sk-&gt;sk_state;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>((1 &lt;&lt; old_state) &amp; (TCPF_CLOSE | TCPF_LISTEN)))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Really, if the socket is already in listen state</span>
<span style="color: #8B8878;">         * we can only allow the backlog to be adjusted.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">if</span> (old_state != TCP_LISTEN) {
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36827;&#34892;&#30417;&#21548;&#25805;&#20316;</span>
		err = inet_csk_listen_start(sk, backlog);
		<span style="color: #FF1493;">if</span> (err)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	}
	sk-&gt;sk_max_ack_backlog = backlog;
	err = 0;

<span style="color: #AF87FF;">out</span>:
	release_sock(sk);
	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org97dcb82" class="outline-3">
<h3 id="org97dcb82"><span class="section-number-3">4.2</span> inet_csk_listen_start监听操作</h3>
<div class="outline-text-3" id="text-4-2">
<p>
inet_csk_listen_start() 函数使TCP传输控制块进入监听状态。
</p>

<p>
监听过程：
</p>
<ul class="org-ul">
<li>为管理连接请求块的散列表分配存储空间</li>
<li>将TCP传输控制块迁移到LISTEN状态</li>
<li>将传输控制块添加到监听散列表</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">inet_csk_listen_start</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nr_table_entries</span><span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#36830;&#25509;&#38431;&#21015;&#38271;&#24230;&#19978;&#38480;</span><span style="color: #8B8878;">*/</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">rc</span> = reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue, nr_table_entries);

	<span style="color: #FF1493;">if</span> (rc != 0)
		<span style="color: #FF1493;">return</span> rc;

	sk-&gt;sk_max_ack_backlog = 0;
	sk-&gt;sk_ack_backlog = 0;
	inet_csk_delack_init(sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270; &#24310;&#26102;&#21457;&#36865;ACK&#27573;&#30456;&#20851;&#30340;&#25968;&#25454;&#32467;&#26500;</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">There is race window here: we announce ourselves listening,</span>
<span style="color: #8B8878;">         * but this transition is still not validated by get_port().</span>
<span style="color: #8B8878;">         * It is OK, because this socket enters to hash table only</span>
<span style="color: #8B8878;">         * after validation is complete.</span>
<span style="color: #8B8878;">         */</span>
	sk-&gt;sk_state = TCP_LISTEN;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;num)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36827;&#34892;&#32465;&#23450;&#31471;&#21475;&#30340;&#25805;&#20316;</span>
		inet-&gt;sport = htons(inet-&gt;num);
		sk_dst_reset(sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28165;&#38500;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;</span>
		sk-&gt;sk_prot-&gt;hash(sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28155;&#21152;&#33267;&#25955;&#21015;&#34920;</span>
		<span style="color: #FF1493;">return</span> 0;
	}

	sk-&gt;sk_state = TCP_CLOSE;
	__reqsk_queue_destroy(&amp;icsk-&gt;icsk_accept_queue);
	<span style="color: #FF1493;">return</span> -EADDRINUSE;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org0cf597d" class="outline-3">
<h3 id="org0cf597d"><span class="section-number-3">4.3</span> 分配连接请求块散列表：reqsk_queue_alloc()</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">reqsk_queue_alloc</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock_queue</span> *<span style="color: #FF8C00;">queue</span>,
		      <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">nr_table_entries</span>)
{
	<span style="color: #5FD7FF;">size_t</span> <span style="color: #FF8C00;">lopt_size</span> = <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">listen_sock</span>);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">listen_sock</span> *<span style="color: #FF8C00;">lopt</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;&#29992;&#20110;&#20445;&#23384;SYN&#35831;&#27714;&#36830;&#25509;&#30340; request_sock &#32467;&#26500;&#30340;&#25968;&#32452;&#38271;&#24230;</span>
	nr_table_entries = min_t(u32, nr_table_entries, sysctl_max_syn_backlog);
	nr_table_entries = max_t(u32, nr_table_entries, 8);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#30830;&#20445; nr_table_entries &#30340;&#20540;&#20026; 2^n</span>
	nr_table_entries = roundup_pow_of_two(nr_table_entries + 1);
	lopt_size += nr_table_entries * <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *);
	<span style="color: #FF1493;">if</span> (lopt_size &gt; PAGE_SIZE) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22823;&#20110;&#19968;&#20010;&#39029;&#38754;&#65292;&#21017;&#20351;&#29992; __vmalloc</span>
		lopt = __vmalloc(lopt_size,
			GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO,
			PAGE_KERNEL);
	<span style="color: #FF1493;">else</span>
		lopt = kzalloc(lopt_size, GFP_KERNEL);
	<span style="color: #FF1493;">if</span> (lopt == <span style="color: #AF87FF;">NULL</span>)
		<span style="color: #FF1493;">return</span> -ENOMEM;

	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">nr_table_entries &#30340;&#20540;&#20026; 2^n &#65292;&#35745;&#31639;n&#20540; max_qlen_log</span>
	<span style="color: #FF1493;">for</span> (lopt-&gt;max_qlen_log = 3;
	     (1 &lt;&lt; lopt-&gt;max_qlen_log) &lt; nr_table_entries;
	     lopt-&gt;max_qlen_log++);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;listen_sock&#32467;&#26500;&#30340;&#25104;&#21592;</span>
	get_random_bytes(&amp;lopt-&gt;hash_rnd, <span style="color: #FF1493;">sizeof</span>(lopt-&gt;hash_rnd));
	rwlock_init(&amp;queue-&gt;syn_wait_lock);
	queue-&gt;rskq_accept_head = <span style="color: #AF87FF;">NULL</span>;
	lopt-&gt;nr_table_entries = nr_table_entries;

	write_lock_bh(&amp;queue-&gt;syn_wait_lock);
	queue-&gt;listen_opt = lopt;
	write_unlock_bh(&amp;queue-&gt;syn_wait_lock);

	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org5462aa4" class="outline-2">
<h2 id="org5462aa4"><span class="section-number-2">5</span> accept系统调用</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org76aa5b3" class="outline-3">
<h3 id="org76aa5b3"><span class="section-number-3">5.1</span> inet_accept()</h3>
<div class="outline-text-3" id="text-5-1">
<p>
该函数是accept系统调用的套接口层实现。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      Accept a pending connection. The TCP layer now gives BSD semantics.</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">inet_accept</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">socket</span> *<span style="color: #FF8C00;">sock</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">socket</span> *<span style="color: #FF8C00;">newsock</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flags</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk1</span> = sock-&gt;sk; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#22871;&#25509;&#21475;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span> = -EINVAL;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#29992;&#20256;&#36755;&#23618;&#25509;&#21475;&#30340;&#23454;&#29616;&#20989;&#25968; inet_csk_accept()&#65292;&#26469;&#33719;&#21462;&#24050;&#23436;&#25104;&#36830;&#25509;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk2</span> = sk1-&gt;sk_prot-&gt;accept(sk1, flags, &amp;err);
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sk2)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">do_err</span>;

	lock_sock(sk2);

	BUG_TRAP((1 &lt;&lt; sk2-&gt;sk_state) &amp;
		 (TCPF_ESTABLISHED | TCPF_CLOSE_WAIT | TCPF_CLOSE));
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#24050;&#32463;&#36830;&#25509;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#21644;&#22871;&#25509;&#21475;&#36827;&#34892;&#20851;&#32852;&#12290;</span>
	sock_graft(sk2, newsock);

	newsock-&gt;state = SS_CONNECTED;
	err = 0;
	release_sock(sk2);
<span style="color: #AF87FF;">do_err</span>:
	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org6b2ed99" class="outline-3">
<h3 id="org6b2ed99"><span class="section-number-3">5.2</span> 传输层的接口实现：inet_csk_accept()</h3>
<div class="outline-text-3" id="text-5-2">
<p>
该函数获取已经完成连接的传输控制块。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * This will accept the next outstanding connection.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #87D700;">inet_csk_accept</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flags</span>, <span style="color: #5FD7FF;">int</span> *<span style="color: #FF8C00;">err</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">newsk</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">error</span>;

	lock_sock(sk);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We need to make sure that this socket is listening,</span>
<span style="color: #8B8878;">         * and that it has something pending.</span>
<span style="color: #8B8878;">         */</span>
	error = -EINVAL;
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state != TCP_LISTEN) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21482;&#26377;&#30417;&#21548;&#30340;&#22871;&#25509;&#23383;&#25165;&#21487;&#20197;&#36827;&#34892;accept&#25805;&#20316;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out_err</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Find already established connection</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38431;&#21015;&#20026;&#31354;&#65292;&#21017;&#27809;&#26377;&#26032;&#36830;&#25509;</span>
		<span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">timeo</span> = sock_rcvtimeo(sk, flags &amp; O_NONBLOCK);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">If this is a non blocking socket don't sleep</span><span style="color: #8B8878;"> */</span>
		error = -EAGAIN;
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>timeo) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27809;&#26377;&#25351;&#23450;timeout,&#21017;&#30452;&#25509;&#36820;&#22238;</span>
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out_err</span>;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22312;&#36229;&#26102;&#26102;&#38388;&#20869;&#31561;&#24453;&#26032;&#36830;&#25509;</span>
		error = inet_csk_wait_for_connect(sk, timeo);
		<span style="color: #FF1493;">if</span> (error)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out_err</span>;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38431;&#21015;&#20013;&#26377;&#26032;&#36830;&#25509;&#65292;&#21017;&#33719;&#21462;&#26032;&#36830;&#25509;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
	newsk = reqsk_queue_get_child(&amp;icsk-&gt;icsk_accept_queue, sk);
	BUG_TRAP(newsk-&gt;sk_state != TCP_SYN_RECV);
<span style="color: #AF87FF;">out</span>:
	release_sock(sk);
	<span style="color: #FF1493;">return</span> newsk;
<span style="color: #AF87FF;">out_err</span>:
	newsk = <span style="color: #AF87FF;">NULL</span>;
	*err = error;
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
}
</pre>
</div>
</div>

<div id="outline-container-org5f3d8f8" class="outline-4">
<h4 id="org5f3d8f8"><span class="section-number-4">5.2.1</span> 等待新建的连接：inet_csk_wait_for_connect</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
该函数用于在超时时间内等待新的连接，直到有新连接，或者超时，或者收到信号等。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * Wait for an incoming connection, avoid race conditions. This must be called</span>
<span style="color: #8B8878;"> * with the socket locked.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">inet_csk_wait_for_connect</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">timeo</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
	DEFINE_WAIT(wait);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;

	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         * True wake-one mechanism for incoming connections: only</span>
<span style="color: #8B8878;">         * one process gets woken up, not the 'whole herd'.</span>
<span style="color: #8B8878;">         * Since we do not 'race &amp; poll' for established sockets</span>
<span style="color: #8B8878;">         * anymore, the common case will execute the loop only once.</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         * Subtle issue: "add_wait_queue_exclusive()" will be added</span>
<span style="color: #8B8878;">         * after any current non-exclusive waiters, and we know that</span>
<span style="color: #8B8878;">         * it will always _stay_ after any new non-exclusive waiters</span>
<span style="color: #8B8878;">         * because all non-exclusive waiters are added at the</span>
<span style="color: #8B8878;">         * beginning of the wait-queue. As such, it's ok to "drop"</span>
<span style="color: #8B8878;">         * our exclusiveness temporarily when we get woken up without</span>
<span style="color: #8B8878;">         * having to remove and re-insert us on the wait queue.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">for</span> (;;) {
		prepare_to_wait_exclusive(sk-&gt;sk_sleep, &amp;wait,
					  TASK_INTERRUPTIBLE);
		release_sock(sk);
		<span style="color: #FF1493;">if</span> (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))
			timeo = schedule_timeout(timeo);
		lock_sock(sk);
		err = 0;
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))
			<span style="color: #FF1493;">break</span>;
		err = -EINVAL;
		<span style="color: #FF1493;">if</span> (sk-&gt;sk_state != TCP_LISTEN)
			<span style="color: #FF1493;">break</span>;
		err = sock_intr_errno(timeo);
		<span style="color: #FF1493;">if</span> (signal_pending(current))
			<span style="color: #FF1493;">break</span>;
		err = -EAGAIN;
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>timeo)
			<span style="color: #FF1493;">break</span>;
	}
	finish_wait(sk-&gt;sk_sleep, &amp;wait);
	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga9857bd" class="outline-4">
<h4 id="orga9857bd"><span class="section-number-4">5.2.2</span> 获取已建立的连接：reqsk_queue_get_child</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
该函数从已连接队列上取走第一个连接请求块，然后由该连接请求块获得已经创建的子传输请求块，之后释放已完成建立连接的连接请求块，同时更新父传输控制块上已建立连接的数目，最后返回子传输控制块。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #87D700;">reqsk_queue_get_child</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock_queue</span> *<span style="color: #FF8C00;">queue</span>,
						 <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">parent</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span> = reqsk_queue_remove(queue);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">child</span> = req-&gt;sk;

	<span style="color: #87D700;">BUG_TRAP</span>(child != <span style="color: #AF87FF;">NULL</span>);

	<span style="color: #87D700;">sk_acceptq_removed</span>(parent);
	<span style="color: #87D700;">__reqsk_free</span>(req);
	<span style="color: #FF1493;">return</span> child;
}
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org3ee8b28" class="outline-2">
<h2 id="org3ee8b28"><span class="section-number-2">6</span> 被动打开</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org0ceb93a" class="outline-3">
<h3 id="org0ceb93a"><span class="section-number-3">6.1</span> SYN cookies</h3>
<div class="outline-text-3" id="text-6-1">
<p>
TCP协议为亲求连接队列开辟了一个较大的内存空间，当SYN请求不断增加致使请求连接数目达到上限时，内核会丢弃SYN连接请求。 SYN cookies技术可以使服务器在半连接队列已满的情况下仍能处理新的SYN请求。
</p>

<p>
当半连接队列满时，SYN cookies并不丢弃SYN请求，而是通过加密技术来标识半连接状态。在TCP实现中，当收到客户端的SYN请求时，服务器需回复SYN+ACK给客户端，之后客户端发送确认。  通常，服务器的初始序列号由服务器按照一定的规律计算得到，或者采用随机数。在SYN cookies中，服务器的初始序号由客户端的IP地址、客户端端口、服务器IP地址和服务器端口、接收到客户端初始序列号以及其他一些安全数值进行hash运算，并进行加密后得到cookie。当服务器遭受SYN攻击导致请求连接队列满时，服务器不会拒绝新的SYN，而是回复初始序列号为cookie的SYN包，如果收到客户端的ACK段，则服务端将ACK序号减1后的值 和上述要素计算的hash值比较，相等则直接完成握手，注意： 此时不必查看此连接是否属于请求连接队列。
</p>

<p>
启用SYN coolies可以通过一下命令：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #8B8878;"># </span><span style="color: #8B8878;">echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org612a2eb" class="outline-3">
<h3 id="org612a2eb"><span class="section-number-3">6.2</span> 第一次握手：接收SYN段</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-org9162f30" class="outline-4">
<h4 id="org9162f30"><span class="section-number-4">6.2.1</span> LISTEN状态处理TCP段</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
传输控制块接收处理的段都由 tcp_v4_do_rcv() 函数处理，该函数中，再根据不同状态调用不同函数： ESTABLISHED状态的处理函数为 tcp_rcv_established()，LISTEN状态且已建立半连接的处理函数为 tcp_v4_hnd_req()，其他状态处理函数为 tcp_rcv_state_process()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">The socket must have it's spinlock held when we get</span>
<span style="color: #8B8878;"> * here.</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> * We have a potential double-lock case here, so even when</span>
<span style="color: #8B8878;"> * doing backlog processing we use the BH locking scheme.</span>
<span style="color: #8B8878;"> * This is because we cannot sleep with the original spinlock</span>
<span style="color: #8B8878;"> * held.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_v4_do_rcv</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">rsk</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state == TCP_LISTEN) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">nsk</span> = tcp_v4_hnd_req(sk, skb);
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>nsk)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;

		<span style="color: #FF1493;">if</span> (nsk != sk) {
			<span style="color: #FF1493;">if</span> (tcp_child_process(sk, nsk, skb)) {
				rsk = nsk;
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">reset</span>;
			}
			<span style="color: #FF1493;">return</span> 0;
		}
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38500;&#20102; ESTABLISHED&#29366;&#24577;&#21644; LISTEN&#29366;&#24577;&#19988;&#24050;&#32463;&#24314;&#31435;&#21322;&#36830;&#25509; &#29366;&#24577;&#20043;&#22806;&#30340;&#22788;&#29702;&#12290;</span>
	TCP_CHECK_TIMER(sk);
	<span style="color: #FF1493;">if</span> (tcp_rcv_state_process(sk, skb, skb-&gt;h.th, skb-&gt;len)) {
		rsk = sk;
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">reset</span>;
	}
	TCP_CHECK_TIMER(sk);
	<span style="color: #FF1493;">return</span> 0;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org41b9ea0" class="outline-4">
<h4 id="org41b9ea0"><span class="section-number-4">6.2.2</span> LISTEN状态处理SYN段</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
服务端处理第一次握手的函数是 tcp_rcv_state_process()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      This function implements the receiving procedure of RFC 793 for</span>
<span style="color: #8B8878;"> *      all states except ESTABLISHED and TIME_WAIT.</span>
<span style="color: #8B8878;"> *      It's called from both tcp_v4_rcv and tcp_v6_rcv and should be</span>
<span style="color: #8B8878;"> *      address independent.</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_rcv_state_process</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span> <span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#22788;&#29702;&#35813;TCP&#27573;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span><span style="color: #8B8878;">*/</span>,
			  <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#21040;&#30340;TCP&#27573;</span>
			  <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span><span style="color: #8B8878;">/*</span><span style="color: #8B8878;">tcp&#39318;&#37096;</span><span style="color: #8B8878;">*/</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #FF8C00;">len</span><span style="color: #8B8878;">/*</span><span style="color: #8B8878;">tcp&#27573;&#38271;&#24230;</span><span style="color: #8B8878;">*/</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">queued</span> = 0;

	tp-&gt;rx_opt.saw_tstamp = 0;

	<span style="color: #FF1493;">switch</span> (sk-&gt;sk_state) {
	<span style="color: #FF1493;">case</span> TCP_CLOSE:
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;

	<span style="color: #FF1493;">case</span> TCP_LISTEN:  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36824;&#26410;&#24314;&#31435;&#21322;&#36830;&#25509;&#30340;LISTEN&#29366;&#24577;&#19979;&#65292;&#20043;&#22788;&#29702;SYN&#27573;</span>
		<span style="color: #FF1493;">if</span>(th-&gt;ack)
			<span style="color: #FF1493;">return</span> 1;

		<span style="color: #FF1493;">if</span>(th-&gt;rst)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;

		<span style="color: #FF1493;">if</span>(th-&gt;syn) {
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;SYN&#27573;&#65292;tcp&#20013;&#20026; tcp_v4_conn_request()</span>
			<span style="color: #FF1493;">if</span> (icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; 0)
				<span style="color: #FF1493;">return</span> 1;

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Now we have several options: In theory there is</span>
<span style="color: #8B8878;">                         * nothing else in the frame. KA9Q has an option to</span>
<span style="color: #8B8878;">                         * send data with the syn, BSD accepts data with the</span>
<span style="color: #8B8878;">                         * syn up to the [to be] advertised window and</span>
<span style="color: #8B8878;">                         * Solaris 2.1 gives you a protocol error. For now</span>
<span style="color: #8B8878;">                         * we just ignore it, that fits the spec precisely</span>
<span style="color: #8B8878;">                         * and avoids incompatibilities. It would be nice in</span>
<span style="color: #8B8878;">                         * future to drop through and process the data.</span>
<span style="color: #8B8878;">                         *</span>
<span style="color: #8B8878;">                         * Now that TTCP is starting to be used we ought to</span>
<span style="color: #8B8878;">                         * queue this data.</span>
<span style="color: #8B8878;">                         * But, this leaves one open to an easy denial of</span>
<span style="color: #8B8878;">                         * service attack, and SYN cookies can't defend</span>
<span style="color: #8B8878;">                         * against this problem. So, we drop the data</span>
<span style="color: #8B8878;">                         * in the interest of security over speed unless</span>
<span style="color: #8B8878;">                         * it's still in use.</span>
<span style="color: #8B8878;">                         */</span>
			kfree_skb(skb);
			<span style="color: #FF1493;">return</span> 0;
		}
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf9c5e7e" class="outline-4">
<h4 id="orgf9c5e7e"><span class="section-number-4">6.2.3</span> 连接请求处理：tcp_v4_conn_request</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
tcp_v4_conn_request()是服务端用来处理客户端连接请求的函数。
</p>


<div class="figure">
<p><img src="image/tcp-connect/tcp-v4-conn-request.png" alt="tcp-v4-conn-request.png" />
</p>
<p><span class="figure-number">Figure 8: </span>tcp_v4_conn_request()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_v4_conn_request</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_request_sock</span> *<span style="color: #FF8C00;">ireq</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_options_received</span> <span style="color: #FF8C00;">tmp_opt</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span>;
	<span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">saddr</span> = skb-&gt;nh.iph-&gt;saddr;
	<span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">daddr</span> = skb-&gt;nh.iph-&gt;daddr;
	<span style="color: #5FD7FF;">__u32</span> <span style="color: #FF8C00;">isn</span> = TCP_SKB_CB(skb)-&gt;when;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">dst_entry</span> *<span style="color: #FF8C00;">dst</span> = <span style="color: #AF87FF;">NULL</span>;
<span style="color: #FF1493;">#ifdef</span> CONFIG_SYN_COOKIES
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">want_cookie</span> = 0;
<span style="color: #FF1493;">#else</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">want_cookie</span> 0 <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Argh, why doesn't gcc optimize this :(</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">#endif</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;SYN&#27573;&#26159;&#21457;&#36865;&#24191;&#25773;&#25110;&#32773;&#32452;&#25773;&#22320;&#22336;&#65292;&#30452;&#25509;&#20002;&#24323;&#65292;&#19981;&#22788;&#29702;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (((<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *)skb-&gt;dst)-&gt;rt_flags &amp;
	    (RTCF_BROADCAST | RTCF_MULTICAST))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;SYN&#35831;&#27714;&#36830;&#25509;&#38431;&#21015;&#24050;&#28385;&#65292;&#24182;&#19988; isn&#20026;0&#65292;&#21017;&#38656;&#35201;&#21028;&#26029;&#26159;&#21542;&#21551;&#29992;&#20102;syncookies</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (inet_csk_reqsk_queue_is_full(sk) &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>isn) {
		<span style="color: #FF1493;">if</span> (sysctl_tcp_syncookies) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21551;&#29992;&#20102;syncookies</span>
			want_cookie = 1;
		} <span style="color: #FF1493;">else</span>
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36830;&#25509;&#38431;&#21015;&#38271;&#24230;&#36798;&#21040;&#19978;&#38480;&#65292;&#24182;&#19988;SYN&#35831;&#27714;&#38431;&#21015;&#20013;&#33267;&#23569;&#26377;&#19968;&#20010;&#25569;&#25163;&#36807;&#31243;&#20013;&#27809;&#26377;&#37325;&#20256;&#36807;&#30340;&#27573;&#65292;&#21017;&#20002;&#24323;&#24403;&#21069;&#36830;&#25509;&#35831;&#27714;</span><span style="color: #8B8878;">*/</span>
	<span style="color: #FF1493;">if</span> (sk_acceptq_is_full(sk) &amp;&amp; inet_csk_reqsk_queue_young(sk) &gt; 1)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20998;&#37197;&#36830;&#25509;&#35831;&#27714;&#22359;</span>
	req = reqsk_alloc(&amp;tcp_request_sock_ops);
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>req)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;

<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG <span style="color: #8B8878;">//</span><span style="color: #8B8878;">TCP MD5&#31614;&#21517;&#26469;&#20445;&#25252;BGP&#20250;&#35805;</span>
	tcp_rsk(req)-&gt;af_specific = &amp;tcp_request_sock_ipv4_ops;
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28165;&#38500;TCP&#36873;&#39033;&#65292;&#24182;&#21021;&#22987;&#21270;</span>
	tcp_clear_options(&amp;tmp_opt);
	tmp_opt.mss_clamp = 536;
	tmp_opt.user_mss  = tcp_sk(sk)-&gt;rx_opt.user_mss;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35299;&#26512;SYN&#27573;&#30340;TCP&#36873;&#39033;</span>
	tcp_parse_options(skb, &amp;tmp_opt, 0);

	<span style="color: #FF1493;">if</span> (want_cookie) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#21551;&#29992;&#20102;syncookies,&#21017;&#28165;&#38500;&#24050;&#35299;&#26512;&#30340;TCP&#36873;&#39033;</span>
		tcp_clear_options(&amp;tmp_opt);
		tmp_opt.saw_tstamp = 0;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23384;&#22312;&#26102;&#38388;&#25139;&#36873;&#39033;&#65292;&#20294;&#26102;&#38388;&#25139;&#30340;&#20540;&#20026;0</span>
	<span style="color: #FF1493;">if</span> (tmp_opt.saw_tstamp &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>tmp_opt.rcv_tsval) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Some OSes (unknown ones, but I see them on web server, which</span>
<span style="color: #8B8878;">                 * contains information interesting only for windows'</span>
<span style="color: #8B8878;">                 * users) do not send their stamp in SYN. It is easy case.</span>
<span style="color: #8B8878;">                 * We simply do not advertise TS support.</span>
<span style="color: #8B8878;">                 */</span>
		tmp_opt.saw_tstamp = 0;
		tmp_opt.tstamp_ok  = 0;
	}
	tmp_opt.tstamp_ok = tmp_opt.saw_tstamp;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#25910;&#21040;&#30340;SYN&#27573;&#20013;&#30340;&#36873;&#39033;&#21644;&#24207;&#21495;&#26469;&#21021;&#22987;&#21270;&#36830;&#25509;&#35831;&#27714;&#22359;&#20449;&#24687;</span>
	tcp_openreq_init(req, &amp;tmp_opt, skb);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23433;&#20840;&#26816;&#27979;</span>
	<span style="color: #FF1493;">if</span> (security_inet_conn_request(sk, skb, req))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop_and_free</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#36830;&#25509;&#35831;&#27714;&#22359;&#65292;&#22320;&#22336;&#65292;IP&#36873;&#39033;&#65288;MSS&#12289;&#31383;&#21475;&#25193;&#22823;&#38134;&#23376;&#12289;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;&#31561;&#65289;</span>
	ireq = inet_rsk(req);
	ireq-&gt;loc_addr = daddr;
	ireq-&gt;rmt_addr = saddr;
	ireq-&gt;opt = tcp_v4_save_options(sk, skb);
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>want_cookie)
		TCP_ECN_create_request(req, skb-&gt;h.th);

	<span style="color: #FF1493;">if</span> (want_cookie) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21551;&#21160;&#20102;syncookies,&#21017;&#27599;60s&#35686;&#21578;&#19968;&#27425;&#21487;&#33021;&#21463;&#21040;synflood&#25915;&#20987;</span>
<span style="color: #FF1493;">#ifdef</span> CONFIG_SYN_COOKIES
		syn_flood_warning(skb);
<span style="color: #FF1493;">#endif</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#22235;&#20803;&#32452;&#12289;&#23458;&#25143;&#31471;&#21021;&#22987;&#24207;&#21015;&#21495;&#31561;&#35201;&#32032;&#36827;&#34892;hash&#20803;&#31639;&#24471;&#21040;&#26381;&#21153;&#31471;&#21021;&#22987;&#24207;&#21015;&#21495;</span>
		isn = cookie_v4_init_sequence(sk, skb, &amp;req-&gt;mss);
	} <span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>isn) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span> *<span style="color: #FF8C00;">peer</span> = <span style="color: #AF87FF;">NULL</span>;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">VJ's idea. We save last timestamp seen</span>
<span style="color: #8B8878;">                 * from the destination in peer table, when entering</span>
<span style="color: #8B8878;">                 * state TIME-WAIT, and check against it before</span>
<span style="color: #8B8878;">                 * accepting new connection request.</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 * If "isn" is not zero, this request hit alive</span>
<span style="color: #8B8878;">                 * timewait bucket, so that all the necessary checks</span>
<span style="color: #8B8878;">                 * are made in the function processing timewait state.</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36827;&#20837;TIMEWAIT&#29366;&#24577;&#26102;&#65292;&#20174;&#23545;&#31471;&#20449;&#24687;&#22359;&#20013;&#33719;&#21462;&#26102;&#38388;&#25139;&#65292;&#22312;&#26032;&#30340;&#36830;&#25509;&#35831;&#27714;&#20043;&#21069;&#26816;&#27979;PAWS&#12290;</span>
		<span style="color: #FF1493;">if</span> (tmp_opt.saw_tstamp &amp;&amp;
		    tcp_death_row.sysctl_tw_recycle &amp;&amp;
		    (dst = inet_csk_route_req(sk, req)) != <span style="color: #AF87FF;">NULL</span> &amp;&amp;
		    (peer = rt_get_peer((<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *)dst)) != <span style="color: #AF87FF;">NULL</span> &amp;&amp;
		    peer-&gt;v4daddr == saddr) {
			<span style="color: #FF1493;">if</span> (xtime.tv_sec &lt; peer-&gt;tcp_ts_stamp + TCP_PAWS_MSL &amp;&amp;
			    (s32)(peer-&gt;tcp_ts - req-&gt;ts_recent) &gt;
							TCP_PAWS_WINDOW) {
				NET_INC_STATS_BH(LINUX_MIB_PAWSPASSIVEREJECTED);
				dst_release(dst);
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop_and_free</span>;
			}
		}
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26410;&#21551;&#29992;syncookies&#26102;&#65292;&#21463;&#21040;synflood&#65292;&#21017;&#20002;&#24323;</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sysctl_tcp_syncookies &amp;&amp;
			 (sysctl_max_syn_backlog - inet_csk_reqsk_queue_len(sk) &lt;
			  (sysctl_max_syn_backlog &gt;&gt; 2)) &amp;&amp;
			 (<span style="color: #CDC673; font-weight: bold;">!</span>peer || <span style="color: #CDC673; font-weight: bold;">!</span>peer-&gt;tcp_ts_stamp) &amp;&amp;
			 (<span style="color: #CDC673; font-weight: bold;">!</span>dst || <span style="color: #CDC673; font-weight: bold;">!</span>dst_metric(dst, RTAX_RTT))) {
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Without syncookies last quarter of</span>
<span style="color: #8B8878;">                         * backlog is filled with destinations,</span>
<span style="color: #8B8878;">                         * proven to be alive.</span>
<span style="color: #8B8878;">                         * It means that we continue to communicate</span>
<span style="color: #8B8878;">                         * to destinations, already remembered</span>
<span style="color: #8B8878;">                         * to the moment of synflood.</span>
<span style="color: #8B8878;">                         */</span>
			LIMIT_NETDEBUG(KERN_DEBUG <span style="color: #CDC673;">"TCP: drop open "</span>
				       <span style="color: #CDC673;">"request from %u.%u.%u.%u/%u\n"</span>,
				       NIPQUAD(saddr),
				       ntohs(skb-&gt;h.th-&gt;source));
			dst_release(dst);
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop_and_free</span>;
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36890;&#36807;&#22235;&#20803;&#32452;&#35745;&#31639;&#26381;&#21153;&#31471;&#30340;&#21021;&#22987;&#24207;&#21015;&#21495;</span>
		isn = tcp_v4_init_sequence(skb);
	}
	tcp_rsk(req)-&gt;snt_isn = isn; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#35745;&#31639;&#30340;&#21021;&#22987;&#24207;&#21015;&#21495;&#23384;&#25918;&#21040;&#36830;&#25509;&#35831;&#27714;&#38454;&#27573;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;SYN+ACK</span>
	<span style="color: #FF1493;">if</span> (tcp_v4_send_synack(sk, req, dst))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop_and_free</span>;

	<span style="color: #FF1493;">if</span> (want_cookie) {
		reqsk_free(req);
	} <span style="color: #FF1493;">else</span> {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27809;&#26377;&#21551;&#29992;syncookies&#26102;&#65292;&#38656;&#35201;&#23558;&#36830;&#25509;&#35831;&#27714;&#22359;&#20445;&#23384;&#21040;&#20854;&#29238;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#30340;&#25955;&#21015;&#34920;&#20013;</span>
		inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);
	}
	<span style="color: #FF1493;">return</span> 0;

<span style="color: #AF87FF;">drop_and_free</span>:
	reqsk_free(req);
<span style="color: #AF87FF;">drop</span>:
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org42733dc" class="outline-4">
<h4 id="org42733dc"><span class="section-number-4">6.2.4</span> 从SKB的控制块中获取IP选项：tcp_v4_save_options()</h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
tcp_v4_save_options()根据IP选项的长度分配ip_options结构的实例，之后调用ip_option_echo()从SKB的控制块中获取IP选项到该实例中。
</p>
</div>
</div>

<div id="outline-container-org728d19d" class="outline-4">
<h4 id="org728d19d"><span class="section-number-4">6.2.5</span> 将连接请求块保存到父传输控制块的散列表中</h4>
<div class="outline-text-4" id="text-6-2-5">
<p>
inet_csk_reqsk_queue_hash_add()函数用来将连接请求块保存到父传输控制块的散列表中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">inet_csk_reqsk_queue_hash_add</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span>,
				   <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">timeout</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">listen_sock</span> *<span style="color: #FF8C00;">lopt</span> = icsk-&gt;icsk_accept_queue.listen_opt;
	<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">h</span> = inet_synq_hash(inet_rsk(req)-&gt;rmt_addr, inet_rsk(req)-&gt;rmt_port,
				     lopt-&gt;hash_rnd, lopt-&gt;nr_table_entries);

	reqsk_queue_hash_req(&amp;icsk-&gt;icsk_accept_queue, h, req, timeout);
	inet_csk_reqsk_queue_added(sk, timeout);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga47b3ce" class="outline-4">
<h4 id="orga47b3ce"><span class="section-number-4">6.2.6</span> 更新该传输控制块上已请求连接块的数量</h4>
<div class="outline-text-4" id="text-6-2-6">
<p>
inet_csk_reqsk_queue_added()
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">inet_csk_reqsk_queue_added</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,
					      <span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">timeout</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#26159;&#39318;&#27425;&#25509;&#25910;&#35831;&#27714;&#36830;&#25509;&#65292;&#21017;&#38656;&#35201;&#22797;&#20301;&#24182;&#21551;&#21160;&#20445;&#27963;&#23450;&#26102;&#22120;</span>
	<span style="color: #FF1493;">if</span> (reqsk_queue_added(&amp;inet_csk(sk)-&gt;icsk_accept_queue) == 0)
		inet_csk_reset_keepalive_timer(sk, timeout);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org346d380" class="outline-4">
<h4 id="org346d380"><span class="section-number-4">6.2.7</span> 函数调用关系</h4>
<div class="outline-text-4" id="text-6-2-7">
<div class="org-src-container">
<pre class="src src-fundamentation">tcp_v4_do_rcv()
	tcp_rcv_state_process
		icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb)  ==&gt; tcp_v4_conn_request()
			tcp_v4_save_options
			tcp_v4_send_synack
				tcp_make_synack
				ip_build_and_send_pkt
			inet_csk_reqsk_queue_hash_add
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6b0a93f" class="outline-3">
<h3 id="org6b0a93f"><span class="section-number-3">6.3</span> 第二次握手：发送SYN+ACK段</h3>
<div class="outline-text-3" id="text-6-3">
</div>
<div id="outline-container-orgb650d71" class="outline-4">
<h4 id="orgb650d71"><span class="section-number-4">6.3.1</span> 构造并发送SYN+ACK段</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
tcp_v4_send_synack()用来为服务端构造回应客户端连接请求SYN段的SYN+ACK段，并将其封装在IP数据包中发送给客户端。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      Send a SYN-ACK after having received an ACK.</span>
<span style="color: #8B8878;"> *      This still operates on a request_sock only, not on a big</span>
<span style="color: #8B8878;"> *      socket.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_v4_send_synack</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span>,
			      <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">dst_entry</span> *<span style="color: #FF8C00;">dst</span>)
{
	<span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_request_sock</span> *<span style="color: #FF8C00;">ireq</span> = inet_rsk(req);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span> = -1;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> * <span style="color: #FF8C00;">skb</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26597;&#25214;&#36335;&#30001;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>dst &amp;&amp; (dst = inet_csk_route_req(sk, req)) == <span style="color: #AF87FF;">NULL</span>)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#26597;&#25214;&#30340;&#36335;&#30001;&#12289;&#20256;&#36755;&#25511;&#21046;&#22359;&#12289;&#36830;&#25509;&#35831;&#27714;&#22359;&#30340;&#20449;&#24687;&#26469;&#26500;&#24314;SYN+ACK&#27573;</span>
	skb = tcp_make_synack(sk, dst, req);

	<span style="color: #FF1493;">if</span> (skb) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span> = skb-&gt;h.th;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29983;&#25104;tcp&#26657;&#39564;&#30721;</span>
		th-&gt;check = tcp_v4_check(th, skb-&gt;len,
					 ireq-&gt;loc_addr,
					 ireq-&gt;rmt_addr,
					 csum_partial((<span style="color: #5FD7FF;">char</span> *)th, skb-&gt;len,
						      skb-&gt;csum));
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29983;&#25104;IP&#25968;&#25454;&#25253;&#24182;&#21457;&#36865;</span>
		err = ip_build_and_send_pkt(skb, sk, ireq-&gt;loc_addr,
					    ireq-&gt;rmt_addr,
					    ireq-&gt;opt);
		err = net_xmit_eval(err);
	}

<span style="color: #AF87FF;">out</span>:
	dst_release(dst);
	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org55062cf" class="outline-4">
<h4 id="org55062cf"><span class="section-number-4">6.3.2</span> 获取路由入口</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
inet_csk_route_req()用来根据连接请求块和服务端传输控制块中的信息（输出网络设备、源目的地址、源目的端口等），为SYN+ACK段查询路由入口。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">dst_entry</span>* <span style="color: #87D700;">inet_csk_route_req</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,
				     <span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span>)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36830;&#25509;&#35831;&#27714;&#22359;</span>
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *<span style="color: #FF8C00;">rt</span>;
	<span style="color: #FF1493;">const</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_request_sock</span> *<span style="color: #FF8C00;">ireq</span> = inet_rsk(req);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span> *<span style="color: #FF8C00;">opt</span> = inet_rsk(req)-&gt;opt;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23450;&#20041;&#24182;&#21021;&#22987;&#21270;&#29992;&#20110;&#36335;&#30001;&#26597;&#35810;&#30340;&#26465;&#20214;&#32452;&#21512;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">flowi</span> <span style="color: #FF8C00;">fl</span> = { .oif = sk-&gt;sk_bound_dev_if,
			    .nl_u = { .ip4_u =
				      { .daddr = ((opt &amp;&amp; opt-&gt;srr) ?
						  opt-&gt;faddr :
						  ireq-&gt;rmt_addr),
					.saddr = ireq-&gt;loc_addr,
					.tos = RT_CONN_FLAGS(sk) } },
			    .proto = sk-&gt;sk_protocol,
			    .uli_u = { .ports =
				       { .sport = inet_sk(sk)-&gt;sport,
					 .dport = ireq-&gt;rmt_port } } };

	<span style="color: #87D700;">security_req_classify_flow</span>(req, &amp;fl);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#35810;&#36335;&#30001;&#32531;&#23384;&#39033;</span>
	<span style="color: #FF1493;">if</span> (ip_route_output_flow(&amp;rt, &amp;fl, sk, 0)) {
		IP_INC_STATS_BH(IPSTATS_MIB_OUTNOROUTES);
		<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;IP&#39318;&#37096;&#20013;&#21253;&#21547;&#20005;&#26684;&#28304;&#36335;&#30001;&#36873;&#39033;&#65292;&#24182;&#19988;&#36873;&#39033;&#20013;&#33719;&#21462;&#30340;&#19979;&#19968;&#36339;&#21644;&#26597;&#35810;&#30340;&#36335;&#30001;&#19981;&#21305;&#37197;&#65292;&#21017;&#36335;&#30001;&#22833;&#36133;</span>
	<span style="color: #FF1493;">if</span> (opt &amp;&amp; opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_dst != rt-&gt;rt_gateway) {
		ip_rt_put(rt);
		IP_INC_STATS_BH(IPSTATS_MIB_OUTNOROUTES);
		<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;
	}
	<span style="color: #FF1493;">return</span> &amp;rt-&gt;u.dst;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgf5edb90" class="outline-4">
<h4 id="orgf5edb90"><span class="section-number-4">6.3.3</span> 构造SYN+ACK段</h4>
<div class="outline-text-4" id="text-6-3-3">
<p>
tcp_make_synack()用来构造一个SYN+ACK段，并初始化TCP首部及SKB中的各字段，例如MSS、SACK、窗口扩大因子、时间戳等。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * Prepare a SYN-ACK.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> * <span style="color: #87D700;">tcp_make_synack</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">dst_entry</span> *<span style="color: #FF8C00;">dst</span>,
				 <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_request_sock</span> *<span style="color: #FF8C00;">ireq</span> = inet_rsk(req);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">tcp_header_size</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;
<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_md5sig_key</span> *<span style="color: #FF8C00;">md5</span>;
	<span style="color: #5FD7FF;">__u8</span> *<span style="color: #FF8C00;">md5_hash_location</span>;
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20026;SYN+ACK&#20998;&#37197;SKB&#65288;&#24378;&#21046;&#20998;&#37197;&#65289;</span>
	skb = sock_wmalloc(sk, MAX_TCP_HEADER + 15, 1, GFP_ATOMIC);
	<span style="color: #FF1493;">if</span> (skb == <span style="color: #AF87FF;">NULL</span>)
		<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20026;MAC&#23618;&#12289;IP&#23618;&#12289;TCP&#39318;&#37096;&#39044;&#30041;&#31354;&#38388;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #87D700;">skb_reserve</span>(skb, MAX_TCP_HEADER);

	skb-&gt;dst = dst_clone(dst);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#25509;&#25910;&#30340;SYN&#27573;&#20013;&#30340;&#36873;&#39033;&#35745;&#31639;SYN+ACK&#27573;&#30340;TCP&#39318;&#37096;&#38271;&#24230;</span>
	tcp_header_size = (<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) + TCPOLEN_MSS +
			   (ireq-&gt;tstamp_ok ? TCPOLEN_TSTAMP_ALIGNED : 0) +
			   (ireq-&gt;wscale_ok ? TCPOLEN_WSCALE_ALIGNED : 0) +
			   <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">SACK_PERM is in the place of NOP NOP of TS</span><span style="color: #8B8878;"> */</span>
			   ((ireq-&gt;sack_ok &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>ireq-&gt;tstamp_ok) ? TCPOLEN_SACKPERM_ALIGNED : 0));

<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Are we doing MD5 on this segment? If so - make room for it</span><span style="color: #8B8878;"> */</span>
	md5 = tcp_rsk(req)-&gt;af_specific-&gt;md5_lookup(sk, req);
	<span style="color: #FF1493;">if</span> (md5)
		tcp_header_size += TCPOLEN_MD5SIG_ALIGNED;
<span style="color: #FF1493;">#endif</span>
	skb-&gt;h.th = th = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *) <span style="color: #87D700;">skb_push</span>(skb, tcp_header_size);

	<span style="color: #87D700;">memset</span>(th, 0, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>));
	th-&gt;syn = 1;
	th-&gt;ack = 1;
	<span style="color: #87D700;">TCP_ECN_make_synack</span>(req, th);
	th-&gt;source = inet_sk(sk)-&gt;sport;
	th-&gt;dest = ireq-&gt;rmt_port;
	<span style="color: #87D700;">TCP_SKB_CB</span>(skb)-&gt;seq = tcp_rsk(req)-&gt;snt_isn;
	<span style="color: #87D700;">TCP_SKB_CB</span>(skb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + 1;
	<span style="color: #87D700;">TCP_SKB_CB</span>(skb)-&gt;sacked = 0;
	<span style="color: #87D700;">skb_shinfo</span>(skb)-&gt;gso_segs = 1;
	<span style="color: #87D700;">skb_shinfo</span>(skb)-&gt;gso_size = 0;
	<span style="color: #87D700;">skb_shinfo</span>(skb)-&gt;gso_type = 0;
	th-&gt;seq = htonl(TCP_SKB_CB(skb)-&gt;seq);
	th-&gt;ack_seq = htonl(tcp_rsk(req)-&gt;rcv_isn + 1);
	<span style="color: #FF1493;">if</span> (req-&gt;rcv_wnd == 0) { <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">ignored for retransmitted syns</span><span style="color: #8B8878;"> */</span>
		<span style="color: #5FD7FF;">__u8</span> <span style="color: #FF8C00;">rcv_wscale</span>;
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Set this up on the first call only</span><span style="color: #8B8878;"> */</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26681;&#25454;&#36335;&#30001;&#39033;&#20013;&#33719;&#21462;&#30340;&#26368;&#22823;&#36890;&#21578;&#31383;&#21475;&#65292;&#21021;&#22987;&#21270;&#35831;&#27714;&#22359;&#20013;&#30340;&#26368;&#22823;&#36890;&#21578;&#31383;&#21475;</span><span style="color: #8B8878;"> */</span>
		req-&gt;window_clamp = tp-&gt;window_clamp ? : dst_metric(dst, RTAX_WINDOW);
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#35774;&#32622;&#25509;&#25910;&#31383;&#21475;&#12289;&#26368;&#22823;&#36890;&#21578;&#31383;&#21475;&#12289;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#31561;</span><span style="color: #8B8878;"> */</span>
		tcp_select_initial_window(tcp_full_space(sk),
			dst_metric(dst, RTAX_ADVMSS) - (ireq-&gt;tstamp_ok ? TCPOLEN_TSTAMP_ALIGNED : 0),
			&amp;req-&gt;rcv_wnd,
			&amp;req-&gt;window_clamp,
			ireq-&gt;wscale_ok,
			&amp;rcv_wscale);
		ireq-&gt;rcv_wscale = rcv_wscale;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">RFC1323: The window in SYN &amp; SYN/ACK segments is never scaled.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;SYN+ACK&#27573;&#30340;&#31383;&#21475;&#22823;&#23567;</span>
	th-&gt;window = htons(req-&gt;rcv_wnd);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;SKB&#30340;TCP&#25511;&#21046;&#22359;&#30340;&#21457;&#36865;&#26102;&#38388;</span>
	<span style="color: #87D700;">TCP_SKB_CB</span>(skb)-&gt;when = tcp_time_stamp;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29983;&#25104;SYN+ACK&#27573;&#30340;&#36873;&#39033;</span>
	<span style="color: #87D700;">tcp_syn_build_options</span>((<span style="color: #5FD7FF;">__be32</span> *)(th + 1), dst_metric(dst, RTAX_ADVMSS), ireq-&gt;tstamp_ok,
			      ireq-&gt;sack_ok, ireq-&gt;wscale_ok, ireq-&gt;rcv_wscale,
			      <span style="color: #5FD7FF;">TCP_SKB_CB</span>(<span style="color: #FF8C00;">skb</span>)-&gt;when,
			      req-&gt;ts_recent,
			      (
<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
			       md5 ? &amp;md5_hash_location :
<span style="color: #FF1493;">#endif</span>
			       <span style="color: #AF87FF;">NULL</span>)
			      );

	skb-&gt;csum = 0;
	th-&gt;doff = (tcp_header_size &gt;&gt; 2); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;TCP&#39318;&#37096;&#38271;&#24230;</span>
	<span style="color: #87D700;">TCP_INC_STATS</span>(TCP_MIB_OUTSEGS);

<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Okay, we have all we need - do the md5 hash if needed</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (md5) {
		tp-&gt;af_specific-&gt;calc_md5_hash(md5_hash_location,
					       md5,
					       <span style="color: #AF87FF;">NULL</span>, dst, req,
					       skb-&gt;h.th, sk-&gt;sk_protocol,
					       skb-&gt;len);
	}
<span style="color: #FF1493;">#endif</span>

	<span style="color: #FF1493;">return</span> skb;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1764501" class="outline-3">
<h3 id="org1764501"><span class="section-number-3">6.4</span> 第三次握手：接收ACK段</h3>
<div class="outline-text-3" id="text-6-4">
<p>
服务端收到SYN段后，会创建一个连接请求块，同时发送SYN+ACK段给客户端作为回应，然后启动建立连接定时器，等待客户端最后一次握手的ACK段。
</p>
</div>

<div id="outline-container-org5e32992" class="outline-4">
<h4 id="org5e32992"><span class="section-number-4">6.4.1</span> LISTEN状态处理TCP段</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
LISTEN状态下，已建立半连接的连接请求块，接收到第三次握手的ACK段后的处理过程：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_v4_do_rcv</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state == TCP_LISTEN) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">nsk</span> = tcp_v4_hnd_req(sk, skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#19977;&#27425;&#25569;&#25163;&#30340;&#26368;&#21518;&#19968;&#27425;ACK&#27573;</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>nsk)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;

		<span style="color: #FF1493;">if</span> (nsk != sk) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#36820;&#22238;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#19981;&#26159;&#20390;&#21548;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#21017;&#35828;&#26126;&#36830;&#25509;&#24314;&#31435;&#25104;&#21151;</span>
			<span style="color: #FF1493;">if</span> (tcp_child_process(sk, nsk, skb)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#22914;&#26524;&#22833;&#36133;&#65292;&#21017;&#21457;&#36865;RST&#27573;&#12290;</span>
				rsk = nsk;
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">reset</span>;
			}
			<span style="color: #FF1493;">return</span> 0;
		}
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc7688fb" class="outline-4">
<h4 id="orgc7688fb"><span class="section-number-4">6.4.2</span> 处理第三次握手的ACK段</h4>
<div class="outline-text-4" id="text-6-4-2">
<p>
tcp_v4_hnd_req()用来处理三次握手的最后一个ACK段，处理过程如下：
</p>
<ul class="org-ul">
<li>在请求连接散列表中查找对应的连接请求块。</li>
<li>如果找到，则根据TCP段标志，ACK或RST或SYN，作相应的处理，如果是ACK,则完成连接的建立。</li>
<li>如果没有找到，则需要在ehash散列表中查找对应的传输控制块，并作相应的处理。如果还找不到，则由tcp_rcv_state_process()处理。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #87D700;">tcp_v4_hnd_req</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span> = skb-&gt;h.th;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span> = skb-&gt;nh.iph;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">nsk</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> **<span style="color: #FF8C00;">prev</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26597;&#25214;&#36830;&#25509;&#35831;&#27714;&#22359;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span> = inet_csk_search_req(sk, &amp;prev, th-&gt;source,
						       iph-&gt;saddr, iph-&gt;daddr);
	<span style="color: #FF1493;">if</span> (req) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25214;&#21040;&#65292;&#21017;&#35828;&#26126;&#21069;&#20004;&#27425;&#25569;&#25163;&#23436;&#25104;&#65292;&#22788;&#29702;&#26368;&#21518;&#19968;&#27425;&#30340;ACK&#27573;</span>
		<span style="color: #FF1493;">return</span> tcp_check_req(sk, skb, req, prev);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#19981;&#22312;&#36830;&#25509;&#35831;&#27714;&#25955;&#21015;&#34920;&#20013;&#65292;&#21017;&#21487;&#33021;&#22312;ehash&#25955;&#21015;&#34920;&#65292;&#32487;&#32493;&#26597;&#25214;</span>
	nsk = inet_lookup_established(&amp;tcp_hashinfo, skb-&gt;nh.iph-&gt;saddr,
				      th-&gt;source, skb-&gt;nh.iph-&gt;daddr,
				      th-&gt;dest, inet_iif(skb));

	<span style="color: #FF1493;">if</span> (nsk) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214;&#25104;&#21151;&#65292;&#19988;&#19981;&#22788;&#20110;TIME_WAIT&#29366;&#24577;&#65292;&#21017;&#36820;&#22238;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
		<span style="color: #FF1493;">if</span> (nsk-&gt;sk_state != TCP_TIME_WAIT) {
			bh_lock_sock(nsk);
			<span style="color: #FF1493;">return</span> nsk;
		}
		inet_twsk_put(inet_twsk(nsk));
		<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;
	}

<span style="color: #FF1493;">#ifdef</span> CONFIG_SYN_COOKIES
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>th-&gt;rst &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>th-&gt;syn &amp;&amp; th-&gt;ack)  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#21551;&#29992;&#20102;syncookies&#65292;&#21017;&#26816;&#27979;&#26159;&#21542;&#26159;&#36890;&#36807;syncookies&#25569;&#25163;</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23558;&#23458;&#25143;&#31471;&#30340;ACK&#24207;&#21015;&#21495;&#20943;1&#24471;&#21040;cookie&#25351;&#65292;&#24182;&#26681;&#25454;&#35201;&#32032;&#36827;&#34892;hash&#36816;&#31639;&#21518;&#21644;cookie&#20540;&#27604;&#36739;</span><span style="color: #8B8878;"> */</span>
		sk = cookie_v4_check(sk, skb, &amp;(IPCB(skb)-&gt;opt));
<span style="color: #FF1493;">#endif</span>
	<span style="color: #FF1493;">return</span> sk;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org257fc62" class="outline-4">
<h4 id="org257fc62"><span class="section-number-4">6.4.3</span> 在SYN_RECV状态下处理TCP段</h4>
<div class="outline-text-4" id="text-6-4-3">
<p>
在SYN_RECV状态下的传输控制块（连接请求块）用 tcp_check_req()来处理接收到的TCP段。处理过程如下：
</p>
<ul class="org-ul">
<li>解析并获取段中的TCP选项。</li>
<li>校验TCP序号。</li>
<li>如果是SYN段，则作为SYN段在处理一次。</li>
<li>检测ACK段确认序号是否有效，无效则立即返回不做处理。</li>
<li>检测ACK段序号是否有效，无效则丢弃。</li>
<li>如果是RST段或者新的SYN段，则向客户端发送RST段进行复位。</li>
<li>校验通过，创建对应的子传输控制块。</li>
<li>将连接请求块插入已完成连接的队列中，等待用户进程的accept()调用。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      Process an incoming packet for SYN_RECV sockets represented</span>
<span style="color: #8B8878;"> *      as a request_sock.</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #87D700;">tcp_check_req</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,
			   <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span>,
			   <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> **<span style="color: #FF8C00;">prev</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span> = skb-&gt;h.th;
	<span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">flg</span> = tcp_flag_word(th) &amp; (TCP_FLAG_RST|TCP_FLAG_SYN|TCP_FLAG_ACK);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">paws_reject</span> = 0;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_options_received</span> <span style="color: #FF8C00;">tmp_opt</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">child</span>;

	tmp_opt.saw_tstamp = 0;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;TCP&#39318;&#37096;&#38271;&#24230;&#22823;&#20110;&#19981;&#24102;TCP&#36873;&#39033;&#30340;&#39318;&#37096;&#38271;&#24230;&#65292;&#21017;&#35828;&#26126;&#39318;&#37096;&#20013;&#26377;TCP&#36873;&#39033;</span>
	<span style="color: #FF1493;">if</span> (th-&gt;doff &gt; (<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>)&gt;&gt;2)) {
		tcp_parse_options(skb, &amp;tmp_opt, 0); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35299;&#26512;TCP&#36873;&#39033;</span>

		<span style="color: #FF1493;">if</span> (tmp_opt.saw_tstamp) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36873;&#39033;&#20013;&#24102;&#26377;&#26102;&#38388;&#25139;&#65292;&#21017;&#35760;&#24405;&#35813;&#26102;&#38388;&#25139;&#21450;&#20854;&#26377;&#25928;&#26102;&#38388;</span>
			tmp_opt.ts_recent = req-&gt;ts_recent;
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We do not store true stamp, but it is not required,</span>
<span style="color: #8B8878;">                         * it can be estimated (approximately)</span>
<span style="color: #8B8878;">                         * from another data.</span>
<span style="color: #8B8878;">                         */</span>
			tmp_opt.ts_recent_stamp = xtime.tv_sec - ((TCP_TIMEOUT_INIT/HZ)&lt;&lt;req-&gt;retrans);
			paws_reject = tcp_paws_check(&amp;tmp_opt, th-&gt;rst); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26657;&#39564;TCP&#24207;&#21495;&#26159;&#21542;&#26377;&#25928;</span>
		}
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26816;&#27979;&#26159;&#21542;&#26159;&#23458;&#25143;&#31471;&#37325;&#20256;&#30340;SYN&#27573;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (TCP_SKB_CB(skb)-&gt;seq == tcp_rsk(req)-&gt;rcv_isn &amp;&amp;
	    flg == TCP_FLAG_SYN &amp;&amp;
	    <span style="color: #CDC673; font-weight: bold;">!</span>paws_reject) {
		<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                 * RFC793 draws (Incorrectly! It was fixed in RFC1122)</span>
<span style="color: #8B8878;">                 * this case on figure 6 and figure 8, but formal</span>
<span style="color: #8B8878;">                 * protocol description says NOTHING.</span>
<span style="color: #8B8878;">                 * To be more exact, it says that we should send ACK,</span>
<span style="color: #8B8878;">                 * because this segment (at least, if it has no data)</span>
<span style="color: #8B8878;">                 * is out of window.</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 *  CONCLUSION: RFC793 (even with RFC1122) DOES NOT</span>
<span style="color: #8B8878;">                 *  describe SYN-RECV state. All the description</span>
<span style="color: #8B8878;">                 *  is wrong, we cannot believe to it and should</span>
<span style="color: #8B8878;">                 *  rely only on common sense and implementation</span>
<span style="color: #8B8878;">                 *  experience.</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 * Enforce "SYN-ACK" according to figure 8, figure 6</span>
<span style="color: #8B8878;">                 * of RFC793, fixed by RFC1122.</span>
<span style="color: #8B8878;">                 */</span>
		req-&gt;rsk_ops-&gt;rtx_syn_ack(sk, req, <span style="color: #AF87FF;">NULL</span>); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#29992;tcp_v4_send_synack()&#21457;&#36865;SYN+ACK</span>
		<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Further reproduces section "SEGMENT ARRIVES"</span>
<span style="color: #8B8878;">           for state SYN-RECEIVED of RFC793.</span>
<span style="color: #8B8878;">           It is broken, however, it does not work only</span>
<span style="color: #8B8878;">           when SYNs are crossed.</span>

<span style="color: #8B8878;">           You would think that SYN crossing is impossible here, since</span>
<span style="color: #8B8878;">           we should have a SYN_SENT socket (from connect()) on our end,</span>
<span style="color: #8B8878;">           but this is not true if the crossed SYNs were sent to both</span>
<span style="color: #8B8878;">           ends by a malicious third party.  We must defend against this,</span>
<span style="color: #8B8878;">           and to do that we first verify the ACK (as per RFC793, page</span>
<span style="color: #8B8878;">           36) and reset if it is invalid.  Is this a true full defense?</span>
<span style="color: #8B8878;">           To convince ourselves, let us consider a way in which the ACK</span>
<span style="color: #8B8878;">           test can still pass in this 'malicious crossed SYNs' case.</span>
<span style="color: #8B8878;">           Malicious sender sends identical SYNs (and thus identical sequence</span>
<span style="color: #8B8878;">           numbers) to both A and B:</span>

<span style="color: #8B8878;">                A: gets SYN, seq=7</span>
<span style="color: #8B8878;">                B: gets SYN, seq=7</span>

<span style="color: #8B8878;">           By our good fortune, both A and B select the same initial</span>
<span style="color: #8B8878;">           send sequence number of seven :-)</span>

<span style="color: #8B8878;">                A: sends SYN|ACK, seq=7, ack_seq=8</span>
<span style="color: #8B8878;">                B: sends SYN|ACK, seq=7, ack_seq=8</span>

<span style="color: #8B8878;">           So we are now A eating this SYN|ACK, ACK test passes.  So</span>
<span style="color: #8B8878;">           does sequence test, SYN is truncated, and thus we consider</span>
<span style="color: #8B8878;">           it a bare ACK.</span>

<span style="color: #8B8878;">           If icsk-&gt;icsk_accept_queue.rskq_defer_accept, we silently drop this</span>
<span style="color: #8B8878;">           bare ACK.  Otherwise, we create an established connection.  Both</span>
<span style="color: #8B8878;">           ends (listening sockets) accept the new incoming connection and try</span>
<span style="color: #8B8878;">           to talk to each other. 8-)</span>

<span style="color: #8B8878;">           Note: This case is both harmless, and rare.  Possibility is about the</span>
<span style="color: #8B8878;">           same as us discovering intelligent life on another plant tomorrow.</span>

<span style="color: #8B8878;">           But generally, we should (RFC lies!) to accept ACK</span>
<span style="color: #8B8878;">           from SYNACK both here and in tcp_rcv_state_process().</span>
<span style="color: #8B8878;">           tcp_rcv_state_process() does not, hence, we do not too.</span>

<span style="color: #8B8878;">           Note that the case is absolutely generic:</span>
<span style="color: #8B8878;">           we cannot optimize anything here without</span>
<span style="color: #8B8878;">           violating protocol. All the checks must be made</span>
<span style="color: #8B8878;">           before attempt to create socket.</span>
<span style="color: #8B8878;">         */</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">RFC793 page 36: "If the connection is in any non-synchronized state ...</span>
<span style="color: #8B8878;">         *                  and the incoming segment acknowledges something not yet</span>
<span style="color: #8B8878;">         *                  sent (the segment carries an unacceptable ACK) ...</span>
<span style="color: #8B8878;">         *                  a reset is sent."</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         * Invalid ACK: reset will be sent by listening socket</span>
<span style="color: #8B8878;">         *///</span><span style="color: #8B8878;">&#22914;&#26524;&#25509;&#25910;&#30340;ACK&#27573;&#30340;&#30830;&#35748;&#24207;&#21495;&#19982;SYN+ACK&#27573;&#30340;&#24207;&#21495;&#19981;&#21305;&#37197;&#65292;&#21017;&#19981;&#22788;&#29702;&#65292;&#24182;&#36820;&#22238;&#29238;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
	<span style="color: #FF1493;">if</span> ((flg &amp; TCP_FLAG_ACK) &amp;&amp;
	    (TCP_SKB_CB(skb)-&gt;ack_seq != tcp_rsk(req)-&gt;snt_isn + 1))
		<span style="color: #FF1493;">return</span> sk;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Also, it would be not so bad idea to check rcv_tsecr, which</span>
<span style="color: #8B8878;">         * is essentially ACK extension and too early or too late values</span>
<span style="color: #8B8878;">         * should cause reset in unsynchronized states.</span>
<span style="color: #8B8878;">         */</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">RFC793: "first check sequence number".</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;ACK&#27573;&#24207;&#21495;&#26080;&#25928;&#25110;&#32773;&#24207;&#21495;&#19981;&#22312;&#25509;&#25910;&#31383;&#21475;&#20869;&#65292;&#21017;&#20002;&#24323;&#25509;&#25910;&#30340;&#27573;&#65292;&#36820;&#22238;NULL</span>
	<span style="color: #FF1493;">if</span> (paws_reject || <span style="color: #CDC673; font-weight: bold;">!</span>tcp_in_window(TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq,
					  tcp_rsk(req)-&gt;rcv_isn + 1, tcp_rsk(req)-&gt;rcv_isn + 1 + req-&gt;rcv_wnd)) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Out of window: send ACK and drop.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>(flg &amp; TCP_FLAG_RST))  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#26159;RST,&#21017;&#26080;&#38656;&#21457;&#36865;ACK,&#21542;&#21017;&#32473;&#23545;&#27573;&#21457;&#36865;ACK&#27573;&#12290;</span>
			req-&gt;rsk_ops-&gt;send_ack(skb, req);
		<span style="color: #FF1493;">if</span> (paws_reject)
			NET_INC_STATS_BH(LINUX_MIB_PAWSESTABREJECTED);
		<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">In sequence, PAWS is OK.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">ACK&#27573;&#24207;&#21495;&#27491;&#24120;&#65292;&#21017;&#38656;&#35201;&#20445;&#23384;TCP&#27573;&#20013;&#30340;&#26102;&#38388;&#25139;</span>
	<span style="color: #FF1493;">if</span> (tmp_opt.saw_tstamp &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>after(TCP_SKB_CB(skb)-&gt;seq, tcp_rsk(req)-&gt;rcv_isn + 1))
			req-&gt;ts_recent = tmp_opt.rcv_tsval;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;ACK&#27573;&#30340;&#24207;&#21495;&#21644;&#20043;&#21069;&#30340;SYN&#27573;&#30456;&#31561;&#65292;?????????????</span>
		<span style="color: #FF1493;">if</span> (TCP_SKB_CB(skb)-&gt;seq == tcp_rsk(req)-&gt;rcv_isn) {
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Truncate SYN, it is out of window starting</span>
<span style="color: #8B8878;">                           at tcp_rsk(req)-&gt;rcv_isn + 1.</span><span style="color: #8B8878;"> */</span>
			flg &amp;= ~TCP_FLAG_SYN;
		}

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">RFC793: "second check the RST bit" and</span>
<span style="color: #8B8878;">                 *         "fourth, check the SYN bit"</span>
<span style="color: #8B8878;">                 *///</span><span style="color: #8B8878;">&#22914;&#26524;&#24102;&#26377;RST&#25110;&#32773;SYN,&#21017;&#38656;&#35201;&#22797;&#20301;&#35813;&#26410;&#23436;&#25104;&#30340;&#36830;&#25509;&#12290;</span>
		<span style="color: #FF1493;">if</span> (flg &amp; (TCP_FLAG_RST|TCP_FLAG_SYN)) {
			TCP_INC_STATS_BH(TCP_MIB_ATTEMPTFAILS);
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">embryonic_reset</span>;
		}

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">ACK sequence verified above, just make sure ACK is</span>
<span style="color: #8B8878;">                 * set.  If ACK not set, just silently drop the packet.</span>
<span style="color: #8B8878;">                 *///</span><span style="color: #8B8878;">&#27491;&#24120;&#26469;&#35828;&#65292;&#27573;&#20013;&#24212;&#24403;&#21253;&#21547;ACK</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>(flg &amp; TCP_FLAG_ACK))
			<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#35774;&#32622;&#20102;TCP_DEFER_ACCEPT&#65292;&#21017;&#26080;&#38656;&#25509;&#25910;ACK&#27573;&#65292;&#20004;&#27425;&#25569;&#25163;&#21518;&#30452;&#25509;&#31561;&#24453;&#24102;&#26377;&#36733;&#33655;&#30340;&#25968;&#25454;&#21253;&#65292;</span>
<span style="color: #8B8878;">                &#22240;&#27492;&#21487;&#20197;&#30452;&#25509;&#20002;&#24323;ACK&#27573;&#12290;</span><span style="color: #8B8878;">*/</span>
		<span style="color: #FF1493;">if</span> (inet_csk(sk)-&gt;icsk_accept_queue.rskq_defer_accept &amp;&amp;
		    TCP_SKB_CB(skb)-&gt;end_seq == tcp_rsk(req)-&gt;rcv_isn + 1) {
			inet_rsk(req)-&gt;acked = 1;
			<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;
		}

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">OK, ACK is valid, create big socket and</span>
<span style="color: #8B8878;">                 * feed this segment to it. It will repeat all</span>
<span style="color: #8B8878;">                 * the tests. THIS SEGMENT MUST MOVE SOCKET TO</span>
<span style="color: #8B8878;">                 * ESTABLISHED STATE. If it will be dropped after</span>
<span style="color: #8B8878;">                 * socket is created, wait for troubles.</span>
<span style="color: #8B8878;">                 *///</span><span style="color: #8B8878;">&#27492;&#26102;&#65292;ACK&#27573;&#26377;&#25928;&#65292;&#35843;&#29992;tcp_v4_syn_recv_sock()&#21019;&#24314;&#23545;&#24212;&#30340;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
		child = inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock(sk, skb,
								 req, <span style="color: #AF87FF;">NULL</span>);
		<span style="color: #FF1493;">if</span> (child == <span style="color: #AF87FF;">NULL</span>)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">listen_overflow</span>;
<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
		<span style="color: #FF1493;">else</span> {
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Copy over the MD5 key from the original socket</span><span style="color: #8B8878;"> */</span>
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_md5sig_key</span> *<span style="color: #FF8C00;">key</span>;
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
			key = tp-&gt;af_specific-&gt;md5_lookup(sk, child);
			<span style="color: #FF1493;">if</span> (key != <span style="color: #AF87FF;">NULL</span>) {
				<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                                 * We're using one, so create a matching key on the</span>
<span style="color: #8B8878;">                                 * newsk structure. If we fail to get memory then we</span>
<span style="color: #8B8878;">                                 * end up not copying the key across. Shucks.</span>
<span style="color: #8B8878;">                                 */</span>
				<span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">newkey</span> = kmemdup(key-&gt;key, key-&gt;keylen,
						       GFP_ATOMIC);
				<span style="color: #FF1493;">if</span> (newkey) {
					<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tcp_alloc_md5sig_pool())
						BUG();
					tp-&gt;af_specific-&gt;md5_add(child, child,
								 newkey,
								 key-&gt;keylen);
				}
			}
		}
<span style="color: #FF1493;">#endif</span>

		<span style="color: #87D700;">inet_csk_reqsk_queue_unlink</span>(sk, req, prev);
		<span style="color: #87D700;">inet_csk_reqsk_queue_removed</span>(sk, req);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#21018;&#24314;&#31435;&#36830;&#25509;&#30340;&#36830;&#25509;&#35831;&#27714;&#22359;&#25554;&#20837;&#21040;&#24050;&#23436;&#25104;&#36830;&#25509;&#30340;&#38431;&#21015;&#20013;</span>
		<span style="color: #87D700;">inet_csk_reqsk_queue_add</span>(sk, req, child);
		<span style="color: #FF1493;">return</span> child; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36820;&#22238;&#24050;&#32463;&#21019;&#24314;&#30340;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;</span>

	<span style="color: #AF87FF;">listen_overflow</span>:  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#30001;&#20110;&#26381;&#21153;&#22120;&#32321;&#24537;&#25110;&#20854;&#20182;&#21407;&#22240;&#23548;&#33268;&#36830;&#25509;&#24314;&#31435;&#22833;&#36133;</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sysctl_tcp_abort_on_overflow) { <span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#24182;&#19988;&#27809;&#26377;&#21551;&#29992;tcp_abort_on_overflow,&#21017;&#35774;&#32622;&#36830;&#25509;&#35831;&#27714;&#22359;&#20013;&#30340;acked&#26631;&#35782;&#65292;</span>
<span style="color: #8B8878;">                &#34920;&#31034;&#24050;&#32463;&#25509;&#25910;&#21040;&#19977;&#27425;&#25569;&#25163;&#30340;ACK&#27573;&#65292;&#36830;&#25509;&#23450;&#26102;&#22120;&#21487;&#20197;&#26681;&#25454;&#35813;&#26631;&#24535;&#37325;&#26032;&#32473;&#23458;&#25143;&#31471;&#21457;&#36865;SYN+ACK,&#20877;&#27425;&#23581;&#35797;&#24314;&#31435;&#36830;&#25509;</span><span style="color: #8B8878;">*/</span>
			inet_rsk(req)-&gt;acked = 1;
			<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;
		}

	<span style="color: #AF87FF;">embryonic_reset</span>:
		<span style="color: #87D700;">NET_INC_STATS_BH</span>(LINUX_MIB_EMBRYONICRSTS);
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>(flg &amp; TCP_FLAG_RST))
			req-&gt;rsk_ops-&gt;send_reset(sk, skb);

		<span style="color: #87D700;">inet_csk_reqsk_queue_drop</span>(sk, req, prev);
		<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org143660f" class="outline-4">
<h4 id="org143660f"><span class="section-number-4">6.4.4</span> 为新连接创建传输控制块</h4>
<div class="outline-text-4" id="text-6-4-4">
<p>
完成三次握手后，为新连接创建一个传输控制块，并将其初始化。在创建传输控制块之前，需要检测已经建立连接但没有被accept的子传输控制块是否达到上限，并为子传输控制块获取路由入口。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * The three way handshake has completed - we got a valid synack -</span>
<span style="color: #8B8878;"> * now create the new socket.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #87D700;">tcp_v4_syn_recv_sock</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,
				  <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">request_sock</span> *<span style="color: #FF8C00;">req</span>,
				  <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">dst_entry</span> *<span style="color: #FF8C00;">dst</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_request_sock</span> *<span style="color: #FF8C00;">ireq</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">newinet</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">newtp</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">newsk</span>;
<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_md5sig_key</span> *<span style="color: #FF8C00;">key</span>;
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">accept&#38431;&#21015;&#24050;&#28385;</span>
	<span style="color: #FF1493;">if</span> (sk_acceptq_is_full(sk))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">exit_overflow</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>dst &amp;&amp; (dst = inet_csk_route_req(sk, req)) == <span style="color: #AF87FF;">NULL</span>)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">exit</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21019;&#24314;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#24182;&#36827;&#34892;&#37096;&#20998;&#21021;&#22987;&#21270;</span>
	newsk = tcp_create_openreq_child(sk, req, skb);
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>newsk)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">exit</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;GSO&#31867;&#22411;</span>
	newsk-&gt;sk_gso_type = SKB_GSO_TCPV4;
	<span style="color: #87D700;">sk_setup_caps</span>(newsk, dst); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#30830;&#23450;&#36755;&#20986;&#32593;&#32476;&#25509;&#21475;&#30340;&#29305;&#24615;&#65292;&#24182;&#35774;&#32622;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#25104;&#21592;</span>
	newtp                 = tcp_sk(newsk);
	newinet               = inet_sk(newsk);
	ireq                  = inet_rsk(req);
	newinet-&gt;daddr        = ireq-&gt;rmt_addr;
	newinet-&gt;rcv_saddr    = ireq-&gt;loc_addr;
	newinet-&gt;saddr        = ireq-&gt;loc_addr;
	newinet-&gt;opt          = ireq-&gt;opt;
	ireq-&gt;opt             = <span style="color: #AF87FF;">NULL</span>;
	newinet-&gt;mc_index     = inet_iif(skb);
	newinet-&gt;mc_ttl       = skb-&gt;nh.iph-&gt;ttl;
	<span style="color: #87D700;">inet_csk</span>(newsk)-&gt;icsk_ext_hdr_len = 0;
	<span style="color: #FF1493;">if</span> (newinet-&gt;opt)
		<span style="color: #87D700;">inet_csk</span>(newsk)-&gt;icsk_ext_hdr_len = newinet-&gt;opt-&gt;optlen;
	newinet-&gt;id = newtp-&gt;write_seq ^ jiffies;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#36335;&#24452;MTU&#21457;&#29616;&#30340;&#20449;&#24687;&#65288;&#26159;&#21542;&#21551;&#29992;&#36335;&#24452;MTU&#21457;&#29616;&#12289;&#36335;&#24452;MTU&#21457;&#39033;&#25506;&#27979;&#25968;&#25454;&#21253;&#30340;&#22823;&#23567;&#65289;</span>
	<span style="color: #87D700;">tcp_mtup_init</span>(newsk);
	<span style="color: #87D700;">tcp_sync_mss</span>(newsk, <span style="color: #5FD7FF;">dst_mtu</span>(<span style="color: #FF8C00;">dst</span>));<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#36335;&#30001;&#39033;&#30340;&#36335;&#24452;MTU&#35774;&#32622;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#24403;&#21069;MSS</span>
	newtp-&gt;advmss = dst_metric(dst, RTAX_ADVMSS); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#36335;&#30001;&#39033;&#30340;MSS&#35774;&#32622;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#26368;&#22823;&#27573;&#38271;&#24230;</span>
	<span style="color: #87D700;">tcp_initialize_rcv_mss</span>(newsk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#29992;&#20110;&#24310;&#26102;&#21457;&#36865;ACK&#27573;&#30340;&#25511;&#21046;&#25968;&#25454;&#22359;&#20013;&#30340;rcv_mss</span>

<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Copy over the MD5 key from the original socket</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> ((key = tcp_v4_md5_do_lookup(sk, newinet-&gt;daddr)) != <span style="color: #AF87FF;">NULL</span>) {
		<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                 * We're using one, so create a matching key</span>
<span style="color: #8B8878;">                 * on the newsk structure. If we fail to get</span>
<span style="color: #8B8878;">                 * memory, then we end up not copying the key</span>
<span style="color: #8B8878;">                 * across. Shucks.</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">newkey</span> = kmemdup(key-&gt;key, key-&gt;keylen, GFP_ATOMIC);
		<span style="color: #FF1493;">if</span> (newkey != <span style="color: #AF87FF;">NULL</span>)
			tcp_v4_md5_do_add(newsk, inet_sk(sk)-&gt;daddr,
					  newkey, key-&gt;keylen);
	}
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#21152;&#20837;&#21040;ehash&#25955;&#21015;&#34920;</span>
	__inet_hash(&amp;tcp_hashinfo, newsk, 0);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#34429;&#28982;&#27809;&#26377;&#36827;&#34892;&#26174;&#24335;&#30340;&#31471;&#21475;&#32465;&#23450;&#65288;listen&#31471;&#21475;&#65289;&#65292;&#23454;&#38469;&#24050;&#32463;&#36827;&#34892;&#20102;&#32465;&#23450;&#65292;&#20877;&#27492;&#38656;&#35201;&#36827;&#34892;&#32465;&#23450;&#25805;&#20316;</span>
	__inet_inherit_port(&amp;tcp_hashinfo, sk, newsk);

	<span style="color: #FF1493;">return</span> newsk;

<span style="color: #AF87FF;">exit_overflow</span>:
	<span style="color: #87D700;">NET_INC_STATS_BH</span>(LINUX_MIB_LISTENOVERFLOWS);
<span style="color: #AF87FF;">exit</span>:
	<span style="color: #87D700;">NET_INC_STATS_BH</span>(LINUX_MIB_LISTENDROPS);
	<span style="color: #87D700;">dst_release</span>(dst);
	<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org98296e5" class="outline-4">
<h4 id="org98296e5"><span class="section-number-4">6.4.5</span> 为子连接创建传输控制块</h4>
<div class="outline-text-4" id="text-6-4-5">
<p>
根据父传输控制块和连接请求块，分配（原子分配）新的子传输控制块。分配后，根据连接请求块和父传输控制块初始化子传输控制块。
</p>
</div>
</div>

<div id="outline-container-orgf72b76b" class="outline-4">
<h4 id="orgf72b76b"><span class="section-number-4">6.4.6</span> 发送ACK段</h4>
<div class="outline-text-4" id="text-6-4-6">
<p>
在SYN_RECV状态下，如果接收到的第三次握手段序号无效或者序号不在接收窗口内，且非RST段，则需要项对段发送ACK段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">The code following below sending ACKs in SYN-RECV and TIME-WAIT states</span>
<span style="color: #8B8878;">   outside socket context is ugly, certainly. What can I do?</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">tcp_v4_send_ack</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_timewait_sock</span> *<span style="color: #FF8C00;">twsk</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">timewait&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#35813;&#21442;&#25968;&#21482;&#22312;TIME_WAIT&#29366;&#24577;&#19988;&#21551;&#29992;MD5&#25968;&#23383;&#31614;&#21517;&#26102;&#25165;&#20351;&#29992;</span>
			    <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span><span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#24453;&#21457;&#36865;&#30340;ACK&#27573;</span><span style="color: #8B8878;">*/</span>,
			    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">seq</span>,<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24453;&#21457;&#36865;ACK&#27573;&#30340;&#24207;&#21495;</span>
			    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">ack</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24453;&#21457;&#36865;ACK&#27573;&#20013;&#30340;&#30830;&#35748;&#24207;&#21495;</span>
			    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">win</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36890;&#21578;&#23545;&#26041;&#30340;&#26412;&#31471;&#25509;&#25910;&#31383;&#21475;&#22823;&#23567;</span>
			    <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">ts</span>) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19981;&#20026;0&#26102;&#65292;&#34920;&#31034;ACK&#27573;&#20013;TCP&#36873;&#39033;&#30340;&#26102;&#38388;&#25139;</span>
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span> = skb-&gt;h.th;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23450;&#20041;ACK&#27573;&#30340;TCP&#39318;&#37096;&#65292;&#21253;&#25324;&#26102;&#38388;&#25139;&#36873;&#39033;</span>
	<span style="color: #FF1493;">struct</span> {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> <span style="color: #FF8C00;">th</span>;
		<span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">opt</span>[(TCPOLEN_TSTAMP_ALIGNED &gt;&gt; 2)
<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
			   + (TCPOLEN_MD5SIG_ALIGNED &gt;&gt; 2)
<span style="color: #FF1493;">#endif</span>
			];
	} <span style="color: #FF8C00;">rep</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_reply_arg</span> <span style="color: #FF8C00;">arg</span>;
<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_md5sig_key</span> *<span style="color: #FF8C00;">key</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_md5sig_key</span> <span style="color: #FF8C00;">tw_key</span>;
<span style="color: #FF1493;">#endif</span>

	memset(&amp;rep.th, 0, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>));
	memset(&amp;arg, 0, <span style="color: #FF1493;">sizeof</span>(arg));

	arg.iov[0].iov_base = (<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *)&amp;rep;
	arg.iov[0].iov_len  = <span style="color: #FF1493;">sizeof</span>(rep.th);
	<span style="color: #FF1493;">if</span> (ts) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;ACK&#27573;&#30340;&#26102;&#38388;&#25139;&#36873;&#39033;</span>
		rep.opt[0] = htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16) |
				   (TCPOPT_TIMESTAMP &lt;&lt; 8) |
				   TCPOLEN_TIMESTAMP);
		rep.opt[1] = htonl(tcp_time_stamp);
		rep.opt[2] = htonl(ts);
		arg.iov[0].iov_len += TCPOLEN_TSTAMP_ALIGNED;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Swap the send and the receive.</span><span style="color: #8B8878;"> */</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;TCP&#39318;&#37096;&#23383;&#27573;</span>
	rep.th.dest    = th-&gt;source;
	rep.th.source  = th-&gt;dest;
	rep.th.doff    = arg.iov[0].iov_len / 4;
	rep.th.seq     = htonl(seq);
	rep.th.ack_seq = htonl(ack);
	rep.th.ack     = 1;
	rep.th.window  = htons(win);

<span style="color: #FF1493;">#ifdef</span> CONFIG_TCP_MD5SIG
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         * The SKB holds an imcoming packet, but may not have a valid -&gt;sk</span>
<span style="color: #8B8878;">         * pointer. This is especially the case when we're dealing with a</span>
<span style="color: #8B8878;">         * TIME_WAIT ack, because the sk structure is long gone, and only</span>
<span style="color: #8B8878;">         * the tcp_timewait_sock remains. So the md5 key is stashed in that</span>
<span style="color: #8B8878;">         * structure, and we use it in preference.  I believe that (twsk ||</span>
<span style="color: #8B8878;">         * skb-&gt;sk) holds true, but we program defensively.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>twsk &amp;&amp; skb-&gt;sk) {
		key = tcp_v4_md5_do_lookup(skb-&gt;sk, skb-&gt;nh.iph-&gt;daddr);
	} <span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (twsk &amp;&amp; twsk-&gt;tw_md5_keylen) {
		tw_key.key = twsk-&gt;tw_md5_key;
		tw_key.keylen = twsk-&gt;tw_md5_keylen;
		key = &amp;tw_key;
	} <span style="color: #FF1493;">else</span>
		key = <span style="color: #AF87FF;">NULL</span>;

	<span style="color: #FF1493;">if</span> (key) {
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">offset</span> = (ts) ? 3 : 0;

		rep.opt[offset++] = htonl((TCPOPT_NOP &lt;&lt; 24) |
					  (TCPOPT_NOP &lt;&lt; 16) |
					  (TCPOPT_MD5SIG &lt;&lt; 8) |
					  TCPOLEN_MD5SIG);
		arg.iov[0].iov_len += TCPOLEN_MD5SIG_ALIGNED;
		rep.th.doff = arg.iov[0].iov_len/4;

		tcp_v4_do_calc_md5_hash((<span style="color: #5FD7FF;">__u8</span> *)&amp;rep.opt[offset],
					key,
					skb-&gt;nh.iph-&gt;daddr,
					skb-&gt;nh.iph-&gt;saddr,
					&amp;rep.th, IPPROTO_TCP,
					arg.iov[0].iov_len);
	}
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;TCP&#27573;&#30340;&#20266;&#39318;&#37096;&#26816;&#39564;&#21644;&#65292;&#23384;&#25918;&#21040;arg&#65288;ip_reply_arg&#32467;&#26500;&#65289;&#20013;</span>
	arg.csum = csum_tcpudp_nofold(skb-&gt;nh.iph-&gt;daddr,
				      skb-&gt;nh.iph-&gt;saddr, <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">XXX</span><span style="color: #8B8878;"> */</span>
				      arg.iov[0].iov_len, IPPROTO_TCP, 0);
	arg.csumoffset = offsetof(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>, check) / 2;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;&#27492;ACK&#27573;</span>
	ip_send_reply(tcp_socket-&gt;sk, skb, &amp;arg, arg.iov[0].iov_len);

	TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8e9db6f" class="outline-4">
<h4 id="org8e9db6f"><span class="section-number-4">6.4.7</span> 发送RST段</h4>
<div class="outline-text-4" id="text-6-4-7">
<p>
tcp_v4_send_reset 函数用于发送RST段：
</p>
<ul class="org-ul">
<li>首先设置TCP首部个字段</li>
<li>计算TCP校验和</li>
<li>通过网络层函数ip_send_reply()发送RST段</li>
</ul>
</div>
</div>

<div id="outline-container-org6775931" class="outline-4">
<h4 id="org6775931"><span class="section-number-4">6.4.8</span> 子传输控制块开始处理TCP段</h4>
<div class="outline-text-4" id="text-6-4-8">
<p>
新的子传输控制块建立并激活后，则需要处理收到的TCP段，同时需要唤醒等待监听套接口的进程，例如accept系统调用，如果子传输控制块被用户进程锁定，则将该TCP段添加到子传输控制块的后备接收队列中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * Queue segment on the new socket if the new socket is active,</span>
<span style="color: #8B8878;"> * otherwise we just shortcircuit this and continue with</span>
<span style="color: #8B8878;"> * the new socket.</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_child_process</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">parent</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#30417;&#21548;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
		      <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">child</span>,  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26032;&#21019;&#24314;&#30340;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
		      <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31532;&#19977;&#27425;&#25569;&#25163;&#30340;ACK&#27573;</span>
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ret</span> = 0;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">state</span> = child-&gt;sk_state;

	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sock_owned_by_user(child)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;&#27809;&#26377;&#27809;&#29992;&#20110;&#36827;&#31243;&#21344;&#29992;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#31532;&#19977;&#27425;&#25569;&#25163;&#30340;ACK&#32487;&#32493;&#21021;&#22987;&#21270;&#23376;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
		ret = tcp_rcv_state_process(child, skb, skb-&gt;h.th, skb-&gt;len);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Wakeup parent, send SIGIO</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">if</span> (state == TCP_SYN_RECV &amp;&amp; child-&gt;sk_state != state)
			parent-&gt;sk_data_ready(parent, 0); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21796;&#37266;&#36827;&#31243;</span>
	} <span style="color: #FF1493;">else</span> {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21542;&#21017;&#28155;&#21152;&#21040;&#21518;&#22791;&#38431;&#21015;</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Alas, it is possible again, because we do lookup</span>
<span style="color: #8B8878;">                 * in main socket hash table and lock on listening</span>
<span style="color: #8B8878;">                 * socket does not protect us more.</span>
<span style="color: #8B8878;">                 */</span>
		sk_add_backlog(child, skb);
	}

	bh_unlock_sock(child);
	sock_put(child);
	<span style="color: #FF1493;">return</span> ret;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgdaa6d53" class="outline-4">
<h4 id="orgdaa6d53"><span class="section-number-4">6.4.9</span> 子传输控制块SYN_RECV状态的ACK段的处理</h4>
<div class="outline-text-4" id="text-6-4-9">
<p>
tcp_rcv_state_process()用来处理ESTABLISHED 和 TIME_WAIT 状态以外的TCP段，以下代码段只显示SYN_RECV状态的处理过程。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      This function implements the receiving procedure of RFC 793 for</span>
<span style="color: #8B8878;"> *      all states except ESTABLISHED and TIME_WAIT.</span>
<span style="color: #8B8878;"> *      It's called from both tcp_v4_rcv and tcp_v6_rcv and should be</span>
<span style="color: #8B8878;"> *      address independent.</span>
<span style="color: #8B8878;"> */</span>

<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_rcv_state_process</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,
			  <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35299;&#26512;TCP&#36873;&#39033;&#21516;&#26102;&#26816;&#26597;&#26102;&#38388;&#25139;&#36873;&#39033;&#65292;&#22914;&#26524;&#23384;&#22312;&#26102;&#38388;&#25139;&#19988;PAWS&#26657;&#39564;&#22833;&#36133;&#65292;&#21017;&#20002;&#24323;</span>
	<span style="color: #FF1493;">if</span> (tcp_fast_parse_options(skb, th, tp) &amp;&amp; tp-&gt;rx_opt.saw_tstamp &amp;&amp;
	    tcp_paws_discard(sk, skb)) {
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>th-&gt;rst) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#19981;&#26159;rst,&#36824;&#38656;&#35201;&#21457;&#36865;DACK&#32473;&#23545;&#27573;&#65292;&#34920;&#31034;&#25509;&#25910;&#30340;TCP&#27573;&#24050;&#32463;&#30830;&#35748;&#36807;</span>
			NET_INC_STATS_BH(LINUX_MIB_PAWSESTABREJECTED);
			tcp_send_dupack(sk, skb);
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
		}
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Reset is accepted even if it did not pass PAWS.</span><span style="color: #8B8878;"> */</span>
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">step 1: check sequence number</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">TCP&#24207;&#21495;&#26080;&#25928;&#65292;&#21017;&#20002;&#24323;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) {
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>th-&gt;rst)
			tcp_send_dupack(sk, skb);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">step 2: check RST bit</span><span style="color: #8B8878;"> */</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#23384;&#22312;RST,&#21017;&#21521;&#23545;&#31471;&#21457;&#36865;RST</span>
	<span style="color: #FF1493;">if</span>(th-&gt;rst) {
		tcp_reset(sk);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#26102;&#38388;&#25139;</span>
	tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)-&gt;seq);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">step 3: check security and precedence [ignored]</span><span style="color: #8B8878;"> */</span>

	<span style="color: #8B8878;">/*      </span><span style="color: #8B8878;">step 4:</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         *      Check for a SYN in window.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23384;&#22312;SYN&#65292;&#21017;&#21521;&#23545;&#31471;&#21457;&#36865;RST&#27573;</span>
	<span style="color: #FF1493;">if</span> (th-&gt;syn &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) {
		NET_INC_STATS_BH(LINUX_MIB_TCPABORTONSYN);
		tcp_reset(sk);
		<span style="color: #FF1493;">return</span> 1;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">step 5: check the ACK field</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (th-&gt;ack) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;ACK&#26631;&#24535;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36820;&#22238;&#38750;&#38646;&#20540;&#34920;&#31034;&#22788;&#29702;ACK&#27573;&#25104;&#21151;&#65292;&#26159;&#27491;&#24120;&#30340;&#31532;&#19977;&#27425;&#25569;&#25163;&#30340;ACK&#27573;&#12290;</span>
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">acceptable</span> = tcp_ack(sk, skb, FLAG_SLOWPATH);

		<span style="color: #FF1493;">switch</span>(sk-&gt;sk_state) {
		<span style="color: #FF1493;">case</span> TCP_SYN_RECV:
			<span style="color: #FF1493;">if</span> (acceptable) {
				tp-&gt;copied_seq = tp-&gt;rcv_nxt;
				smp_mb();
				tcp_set_state(sk, TCP_ESTABLISHED);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#20026;ESTABLISHED&#29366;&#24577;</span>
				sk-&gt;sk_state_change(sk);

				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Note, that this wakeup is only for marginal</span>
<span style="color: #8B8878;">                                 * crossed SYN case. Passively open sockets</span>
<span style="color: #8B8878;">                                 * are not waked up, because sk-&gt;sk_sleep ==</span>
<span style="color: #8B8878;">                                 * NULL and sk-&gt;sk_socket == NULL.</span>
<span style="color: #8B8878;">                                 */</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36890;&#30693;&#36827;&#31243;&#65292;&#35813;&#22871;&#25509;&#21475;&#21487;&#20197;&#21457;&#36865;&#25968;&#25454;&#20102;</span>
				<span style="color: #FF1493;">if</span> (sk-&gt;sk_socket) {
					sk_wake_async(sk,0,POLL_OUT);
				}
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#21508;&#20010;&#23383;&#27573;</span>
				tp-&gt;snd_una = TCP_SKB_CB(skb)-&gt;ack_seq;
				tp-&gt;snd_wnd = ntohs(th-&gt;window) &lt;&lt;
					      tp-&gt;rx_opt.snd_wscale;
				tcp_init_wl(tp, TCP_SKB_CB(skb)-&gt;ack_seq,
					    TCP_SKB_CB(skb)-&gt;seq);

				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">tcp_ack considers this ACK as duplicate</span>
<span style="color: #8B8878;">                                 * and does not calculate rtt.</span>
<span style="color: #8B8878;">                                 * Fix it at least with timestamps.</span>
<span style="color: #8B8878;">                                 */</span>
				<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.saw_tstamp &amp;&amp; tp-&gt;rx_opt.rcv_tsecr &amp;&amp;
				    <span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;srtt)
					tcp_ack_saw_tstamp(sk, 0);

				<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.tstamp_ok)
					tp-&gt;advmss -= TCPOLEN_TSTAMP_ALIGNED;

				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Make sure socket is routed, for</span>
<span style="color: #8B8878;">                                 * correct metrics.</span>
<span style="color: #8B8878;">                                 */</span>  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20026;&#35813;&#22871;&#25509;&#21475;&#24314;&#31435;&#36335;&#30001;</span>
				icsk-&gt;icsk_af_ops-&gt;rebuild_header(sk);

				tcp_init_metrics(sk);
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#25317;&#22622;&#25511;&#21046;&#27169;&#22359;</span>
				tcp_init_congestion_control(sk);

				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Prevent spurious tcp_cwnd_restart() on</span>
<span style="color: #8B8878;">                                 * first data packet.</span>
<span style="color: #8B8878;">                                 */</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#26368;&#36817;&#19968;&#27425;&#21457;&#36865;&#25968;&#25454;&#21253;&#30340;&#26102;&#38388;</span>
				tp-&gt;lsndtime = tcp_time_stamp;

				tcp_mtup_init(sk);
				tcp_initialize_rcv_mss(sk);
				tcp_init_buffer_space(sk);
				tcp_fast_path_on(tp);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;&#26377;&#20851;TCP&#39318;&#37096;&#39044;&#27979;&#30340;&#26631;&#24535;</span>
			} <span style="color: #FF1493;">else</span> {
				<span style="color: #FF1493;">return</span> 1;
			}
			<span style="color: #FF1493;">break</span>;
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	} <span style="color: #FF1493;">else</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">step 6: check the URG bit</span><span style="color: #8B8878;"> */</span>
	tcp_urg(sk, skb, th);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#26597;&#24102;&#22806;&#26631;&#24535;</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">step 7: process the segment text</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">switch</span> (sk-&gt;sk_state) {
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#25509;&#25910;&#30340;TCP&#27573;&#25490;&#38431;&#65292;&#24314;&#31435;&#36830;&#25509;&#38454;&#27573;&#24212;&#35813;&#19981;&#20250;&#25509;&#25910;&#21040;TCP&#27573;&#12290;</span>
	<span style="color: #FF1493;">case</span> TCP_ESTABLISHED:
		tcp_data_queue(sk, skb);
		queued = 1;
		<span style="color: #FF1493;">break</span>;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">tcp_data could move socket to TIME-WAIT</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state != TCP_CLOSE) {   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;CLOSE&#29366;&#24577;&#26102;&#65292;&#26816;&#27979;&#26159;&#21542;&#26377;&#25968;&#25454;&#21644;ACK&#38656;&#35201;&#21457;&#36865;</span>
		tcp_data_snd_check(sk, tp);
		tcp_ack_snd_check(sk);
	}

	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>queued) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#30830;&#23450;&#26159;&#21542;&#37322;&#25918;&#25509;&#25910;&#30340;TCP&#27573;&#65292;&#22914;&#26524;&#24050;&#32463;&#28155;&#21152;&#21040;&#25509;&#25910;&#38431;&#21015;&#65292;&#21017;&#19981;&#37322;&#25918;&#12290;</span>
<span style="color: #AF87FF;">discard</span>:
		__kfree_skb(skb);
	}
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org485c1dd" class="outline-4">
<h4 id="org485c1dd"><span class="section-number-4">6.4.10</span> 函数调用关系</h4>
<div class="outline-text-4" id="text-6-4-10">
<p>
第三次握手的ACK段由 tcp_v4_hnd_req() 处理。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">tcp_v4_do_rcv</span>
	<span style="color: #87D700;">tcp_v4_hnd_req</span>()
		<span style="color: #87D700;">inet_csk_search_req</span>()
		<span style="color: #87D700;">tcp_check_req</span>()
			<span style="color: #87D700;">tcp_v4_syn_recv_sock</span>()
				<span style="color: #87D700;">tcp_create_openreq_chile</span>()
	<span style="color: #87D700;">tcp_child_process</span>()
		<span style="color: #87D700;">tcp_rcv_state_process</span>()
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org4a9818c" class="outline-2">
<h2 id="org4a9818c"><span class="section-number-2">7</span> connect系统调用</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgab0a732" class="outline-3">
<h3 id="orgab0a732"><span class="section-number-3">7.1</span> 套接口层实现：inet_stream_connect()</h3>
<div class="outline-text-3" id="text-7-1">
<p>
inet_stream_connect()是connect系统调用的套接口层实现。传输层TCP实现为 tcp_v4_connect()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      Connect to a remote host. There is regrettably still a little</span>
<span style="color: #8B8878;"> *      TCP 'magic' in here.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">inet_stream_connect</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">socket</span> *<span style="color: #FF8C00;">sock</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36827;&#34892;&#36830;&#25509;&#30340;&#22871;&#25509;&#21475;</span>
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sockaddr</span> *<span style="color: #FF8C00;">uaddr</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">addr_len</span>, <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#30446;&#30340;&#22320;&#22336;&#21450;&#38271;&#24230;</span>
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flags</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span> = sock-&gt;sk;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;
	<span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">timeo</span>;

	lock_sock(sk); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25805;&#20316;&#21069;&#21152;&#38145;</span>

	<span style="color: #FF1493;">if</span> (uaddr-&gt;sa_family == AF_UNSPEC) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27809;&#26377;&#35774;&#32622;&#22320;&#22336;&#26063;&#65292;&#21017;&#19981;&#33021;&#36827;&#34892;connect&#25805;&#20316;</span>
		err = sk-&gt;sk_prot-&gt;disconnect(sk, flags); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">tcp_disconnect()</span>
		sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	}

	<span style="color: #FF1493;">switch</span> (sock-&gt;state) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22871;&#25509;&#21475;&#22788;&#20110;&#38750;SS_UNCONNECTED&#29366;&#24577;&#26102;&#65292;&#19981;&#33021;&#36827;&#34892;connect</span>
	<span style="color: #FF1493;">default</span>:
		err = -EINVAL;
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">case</span> SS_CONNECTED:
		err = -EISCONN;
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">case</span> SS_CONNECTING:
		err = -EALREADY;
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Fall out of switch with err, set for this state</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">break</span>;
	<span style="color: #FF1493;">case</span> SS_UNCONNECTED:
		err = -EISCONN;
		<span style="color: #FF1493;">if</span> (sk-&gt;sk_state != TCP_CLOSE) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">TCP&#19981;&#22788;&#20110;CLOSE&#29366;&#24577;&#65292;&#21017;&#35828;&#26126;&#24050;&#36830;&#25509;</span>
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;

		err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">tcp_v4_connect() &#21457;&#36865;SYN&#27573;</span>
		<span style="color: #FF1493;">if</span> (err &lt; 0)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;

		sock-&gt;state = SS_CONNECTING;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Just entered SS_CONNECTING state; the only</span>
<span style="color: #8B8878;">                 * difference is that return value in non-blocking</span>
<span style="color: #8B8878;">                 * case is EINPROGRESS, rather than EALREADY.</span>
<span style="color: #8B8878;">                 */</span>
		err = -EINPROGRESS; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#26159;&#38750;&#38459;&#22622;&#26041;&#24335;&#36830;&#25509;&#65292;&#21017;&#36820;&#22238;&#35813;&#38169;&#35823;&#30721;&#65292;&#34920;&#31034;&#27491;&#22312;&#36830;&#25509;&#12290;</span>
		<span style="color: #FF1493;">break</span>;
	}

	timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#36830;&#25509;&#36229;&#26102;&#26102;&#38388;</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19968;&#33324;&#21457;&#36865;&#23436;SYN&#27573;&#21518;&#65292;TCP&#29366;&#24577;&#20250;&#21464;&#20026;TCPF_SYN_SENT&#65292;TCP_SYN_SENT&#21644;TCPF_SYN_RECV&#37117;&#34920;&#31034;&#21322;&#36830;&#25509;&#29366;&#24577;&#12290;</span>
	<span style="color: #FF1493;">if</span> ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Error code is set above</span><span style="color: #8B8878;"> */</span>
		<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">TCP_SYN_SENT&#21644;TCPF_SYN_RECV&#37117;&#34920;&#31034;&#21322;&#36830;&#25509;&#29366;&#24577;&#65292;&#22914;&#26524;&#22788;&#20110;&#36825;&#20004;&#31181;&#29366;&#24577;&#65292;&#24182;&#19988;&#26159;&#38459;&#22622;&#26041;&#24335;&#65292;</span>
<span style="color: #8B8878;">                &#21017;&#31561;&#24453;&#36830;&#25509;&#23436;&#25104;&#25110;&#36229;&#26102;</span><span style="color: #8B8878;">*/</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>timeo || <span style="color: #CDC673; font-weight: bold;">!</span>inet_wait_for_connect(sk, timeo))
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;&#38459;&#22622;&#65292;&#21017;&#26080;&#38656;&#31561;&#24453;&#36830;&#25509;&#23436;&#25104;</span>
		err = sock_intr_errno(timeo);
		<span style="color: #FF1493;">if</span> (signal_pending(current))
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Connection was closed by RST, timeout, ICMP error</span>
<span style="color: #8B8878;">         * or another process disconnected us.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_state == TCP_CLOSE) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24314;&#31435;&#22833;&#36133;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">sock_error</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">sk-&gt;sk_err may be not zero now, if RECVERR was ordered by user</span>
<span style="color: #8B8878;">         * and error was received after socket entered established state.</span>
<span style="color: #8B8878;">         * Hence, it is handled normally after connect() return successfully.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36830;&#25509;&#25104;&#21151;</span>
	sock-&gt;state = SS_CONNECTED;
	err = 0;
<span style="color: #AF87FF;">out</span>:
	release_sock(sk);
	<span style="color: #FF1493;">return</span> err;

<span style="color: #AF87FF;">sock_error</span>:
	err = sock_error(sk) ? : -ECONNABORTED;
	sock-&gt;state = SS_UNCONNECTED;
	<span style="color: #FF1493;">if</span> (sk-&gt;sk_prot-&gt;disconnect(sk, flags))
		sock-&gt;state = SS_DISCONNECTING;
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8d6ecd1" class="outline-3">
<h3 id="org8d6ecd1"><span class="section-number-3">7.2</span> 传输层的实现： tcp_v4_connect()</h3>
<div class="outline-text-3" id="text-7-2">
<p>
参见下一小节。
</p>
</div>
</div>
</div>


<div id="outline-container-org69ba3a7" class="outline-2">
<h2 id="org69ba3a7"><span class="section-number-2">8</span> 主动打开</h2>
<div class="outline-text-2" id="text-8">
<p>
在调用connect之后，通过套接口层的校验后，调用传输层的 tcp_v4_connect() 发送SYN段请求连接。
</p>
</div>

<div id="outline-container-org7b2571b" class="outline-3">
<h3 id="org7b2571b"><span class="section-number-3">8.1</span> 第一次握手：发送SYN段</h3>
<div class="outline-text-3" id="text-8-1">
</div>
<div id="outline-container-orgbde8115" class="outline-4">
<h4 id="orgbde8115"><span class="section-number-4">8.1.1</span> 初始化客户端传输控制块并发送SYN段</h4>
<div class="outline-text-4" id="text-8-1-1">

<div class="figure">
<p><img src="image/tcp-conect/tcp-v4-connect.png" alt="tcp-v4-connect.png" />
</p>
<p><span class="figure-number">Figure 9: </span>tcp_v4_connect函数流程</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">This will initiate an outgoing connection.</span><span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_v4_connect</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sockaddr</span> *<span style="color: #FF8C00;">uaddr</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">addr_len</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sockaddr_in</span> *<span style="color: #FF8C00;">usin</span> = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sockaddr_in</span> *)uaddr;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *<span style="color: #FF8C00;">rt</span>;
	<span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">daddr</span>, <span style="color: #FF8C00;">nexthop</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">tmp</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26657;&#39564;&#30446;&#30340;&#22320;&#22336;&#38271;&#24230;</span>
	<span style="color: #FF1493;">if</span> (addr_len &lt; <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sockaddr_in</span>))
		<span style="color: #FF1493;">return</span> -EINVAL;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26657;&#39564;&#21327;&#35758;&#26063;</span>
	<span style="color: #FF1493;">if</span> (usin-&gt;sin_family != AF_INET)
		<span style="color: #FF1493;">return</span> -EAFNOSUPPORT;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#19979;&#19968;&#36339;&#21644;&#30446;&#30340;&#22320;&#22336;&#30340;&#20020;&#26102;&#21464;&#37327;&#37117;&#35774;&#32622;&#20026;connect&#20989;&#25968;&#21442;&#25968;&#20013;&#30340;&#22320;&#22336;</span>
	nexthop = daddr = usin-&gt;sin_addr.s_addr;
	<span style="color: #FF1493;">if</span> (inet-&gt;opt &amp;&amp; inet-&gt;opt-&gt;srr) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#20351;&#29992;&#28304;&#22320;&#22336;&#36335;&#30001;&#65292;&#21017;nexthop&#35774;&#32622;&#20026;ip&#36873;&#39033;&#20013;&#30340;faddr</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>daddr)
			<span style="color: #FF1493;">return</span> -EINVAL;
		nexthop = inet-&gt;opt-&gt;faddr;
	}
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26681;&#25454;nexthop&#31561;&#20449;&#24687;&#65292;&#26597;&#25214;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#65292;&#22914;&#26524;&#36335;&#30001;&#21629;&#20013;&#65292;&#21017;&#29983;&#25104;&#23545;&#24212;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;</span>
<span style="color: #8B8878;">        &#36825;&#20010;&#32531;&#23384;&#26082;&#21487;&#20197;&#29992;&#20110;&#21457;&#36865;&#24403;&#21069;SYN&#27573;&#65292;&#20063;&#21487;&#20197;&#29992;&#20110;&#21518;&#32493;&#30340;&#25968;&#25454;&#21253;</span><span style="color: #8B8878;"> */</span>
	tmp = ip_route_connect(&amp;rt, nexthop, inet-&gt;saddr,
			       RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,
			       IPPROTO_TCP,
			       inet-&gt;sport, usin-&gt;sin_port, sk);
	<span style="color: #FF1493;">if</span> (tmp &lt; 0)
		<span style="color: #FF1493;">return</span> tmp;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">TCP&#19981;&#33021;&#20351;&#29992;&#32452;&#25773;&#25110;&#22810;&#25773;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;</span>
	<span style="color: #FF1493;">if</span> (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) {
		ip_rt_put(rt);
		<span style="color: #FF1493;">return</span> -ENETUNREACH;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#27809;&#26377;&#21551;&#29992;&#28304;&#36335;&#30001;&#36873;&#39033;&#65292;&#21017;&#20351;&#29992;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#20013;&#30340;&#30446;&#30340;&#22320;&#22336;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>inet-&gt;opt || <span style="color: #CDC673; font-weight: bold;">!</span>inet-&gt;opt-&gt;srr)
		daddr = rt-&gt;rt_dst;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#27809;&#26377;&#35774;&#32622;&#28304;&#22320;&#22336;&#65292;&#21017;&#20351;&#29992;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#20013;&#30340;&#28304;&#22320;&#22336;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>inet-&gt;saddr)
		inet-&gt;saddr = rt-&gt;rt_src;
	inet-&gt;rcv_saddr = inet-&gt;saddr;
	<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#30340;&#26102;&#38388;&#25139;&#21644;&#30446;&#30340;&#22320;&#22336;&#24050;&#32463;&#34987;&#20351;&#29992;&#36807;&#65292;&#21017;&#35828;&#26126;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#20043;&#21069;&#24050;&#32463;&#24314;&#31435;&#36807;&#36830;&#25509;&#24182;&#19988;&#26377;&#36807;&#36890;&#20449;&#65292;</span>
<span style="color: #8B8878;">        &#38656;&#35201;&#37325;&#26032;&#21021;&#22987;&#21270;&#30456;&#20851;&#25104;&#21592;</span><span style="color: #8B8878;">*/</span>
	<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; inet-&gt;daddr != daddr) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Reset inherited state</span><span style="color: #8B8878;"> */</span>
		tp-&gt;rx_opt.ts_recent       = 0;
		tp-&gt;rx_opt.ts_recent_stamp = 0;
		tp-&gt;write_seq              = 0;
	}
	<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#22914;&#26524;&#21551;&#29992;&#20102;tcp_tw_recycle&#24182;&#25509;&#25910;&#36807;&#26102;&#38388;&#25139;&#36873;&#39033;&#65292;&#20174;&#23545;&#27573;&#20449;&#24687;&#22359;&#20013;&#33719;&#21462;&#30456;&#24212;&#30340;&#20540;&#26469;&#21021;&#22987;&#21270;</span>
<span style="color: #8B8878;">        ts_recent_stamp&#21644;ts_recent</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (tcp_death_row.sysctl_tw_recycle &amp;&amp;
	    <span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; rt-&gt;rt_dst == daddr) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span> *<span style="color: #FF8C00;">peer</span> = rt_get_peer(rt);
		<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                 * VJ's idea. We save last timestamp seen from</span>
<span style="color: #8B8878;">                 * the destination in peer table, when entering state</span>
<span style="color: #8B8878;">                 * TIME-WAIT * and initialize rx_opt.ts_recent from it,</span>
<span style="color: #8B8878;">                 * when trying new connection.</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #FF1493;">if</span> (peer != <span style="color: #AF87FF;">NULL</span> &amp;&amp;
		    peer-&gt;tcp_ts_stamp + TCP_PAWS_MSL &gt;= xtime.tv_sec) {
			tp-&gt;rx_opt.ts_recent_stamp = peer-&gt;tcp_ts_stamp;
			tp-&gt;rx_opt.ts_recent = peer-&gt;tcp_ts;
		}
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#30446;&#30340;&#22320;&#22336;&#21450;&#31471;&#21475;</span>
	inet-&gt;dport = usin-&gt;sin_port;
	inet-&gt;daddr = daddr;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;IP&#36873;&#39033;&#37096;&#20998;&#38271;&#24230;</span>
	inet_csk(sk)-&gt;icsk_ext_hdr_len = 0;
	<span style="color: #FF1493;">if</span> (inet-&gt;opt)
		inet_csk(sk)-&gt;icsk_ext_hdr_len = inet-&gt;opt-&gt;optlen;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;MSS&#19978;&#38480;</span>
	tp-&gt;rx_opt.mss_clamp = 536;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Socket identity is still unknown (sport may be zero).</span>
<span style="color: #8B8878;">         * However we set state to SYN-SENT and not releasing socket</span>
<span style="color: #8B8878;">         * lock select source port, enter ourselves into the hash tables and</span>
<span style="color: #8B8878;">         * complete initialization after this.</span>
<span style="color: #8B8878;">         */</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;TCP&#29366;&#24577;&#20026;SYN_SENT</span>
	tcp_set_state(sk, TCP_SYN_SENT);
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21160;&#24577;&#30340;&#20998;&#37197;&#24182;&#32465;&#23450;&#26412;&#22320;&#31471;&#21475;&#65292;&#24182;&#28155;&#21152;&#21040;ehash&#25955;&#21015;&#34920;&#12290;&#22914;&#26524;&#22312;&#20998;&#37197;&#31471;&#21475;&#26102;&#65292;&#20998;&#37197;&#30340;&#26159;&#24050;&#20351;&#29992;&#30340;&#31471;&#21475;&#65292;</span>
<span style="color: #8B8878;">        &#21017;&#38656;&#35201;&#22312;TIME_WAIT&#29366;&#24577;&#38431;&#21015;&#20013;&#36827;&#34892;&#30456;&#24212;&#30340;&#30830;&#35748;&#65292;&#22240;&#27492;&#35843;&#29992;inet_hash_connect()&#26102;&#65292;&#38656;&#35201;&#20351;&#29992; &#21442;&#25968;&#31649;&#29702;&#22120;tcp_death_row&#21644;timewait&#20256;&#36755;&#25511;&#21046;&#22359;&#20316;&#20026;&#21442;&#25968;</span><span style="color: #8B8878;">*/</span>
	err = inet_hash_connect(&amp;tcp_death_row, sk);
	<span style="color: #FF1493;">if</span> (err)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">failure</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#28304;&#31471;&#21475;&#25110;&#30446;&#30340;&#31471;&#21475;&#21457;&#29983;&#25913;&#21464;&#65292;&#21017;&#38656;&#35201;&#37325;&#26032;&#26597;&#25214;&#36335;&#30001;&#65292;&#29992;&#26032;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#26356;&#26032;sk&#20013;&#20445;&#23384;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#12290;</span>
	err = ip_route_newports(&amp;rt, IPPROTO_TCP,
				inet-&gt;sport, inet-&gt;dport, sk);
	<span style="color: #FF1493;">if</span> (err)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">failure</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">OK, now commit destination to socket.</span><span style="color: #8B8878;">  */</span>
	sk-&gt;sk_gso_type = SKB_GSO_TCPV4; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;GSO&#31867;&#22411;</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#36335;&#30001;&#36755;&#20986;&#35774;&#22791;&#29305;&#24615;&#65292;&#35774;&#32622;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#30446;&#30340;&#36335;&#30001;&#32593;&#32476;&#35774;&#22791;&#30340;&#29305;&#24615;&#12290;</span>
	sk_setup_caps(sk, &amp;rt-&gt;u.dst);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#36824;&#27809;&#26377;&#35774;&#32622;&#21021;&#22987;&#24207;&#21495;&#65292;&#21017;&#26681;&#25454;&#22235;&#20803;&#32452;&#35745;&#31639;&#21021;&#22987;&#24207;&#21495;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;write_seq)
		tp-&gt;write_seq = secure_tcp_sequence_number(inet-&gt;saddr,
							   inet-&gt;daddr,
							   inet-&gt;sport,
							   usin-&gt;sin_port);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#24207;&#21495;&#21644;&#24403;&#21069;&#26102;&#38388;&#35745;&#31639;&#29992;&#20110;IP&#39318;&#37096;&#30340;ID&#22495;&#30340;&#20540;&#12290;</span>
	inet-&gt;id = tp-&gt;write_seq ^ jiffies;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26500;&#36896;&#24182;&#21457;&#36865;SYN&#27573;</span>
	err = tcp_connect(sk);
	rt = <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #FF1493;">if</span> (err)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">failure</span>;

	<span style="color: #FF1493;">return</span> 0;

<span style="color: #AF87FF;">failure</span>:
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         * This unhashes the socket and releases the local port,</span>
<span style="color: #8B8878;">         * if necessary.</span>
<span style="color: #8B8878;">         */</span>
	tcp_set_state(sk, TCP_CLOSE);
	ip_rt_put(rt);
	sk-&gt;sk_route_caps = 0;
	inet-&gt;dport = 0;
	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org76804fa" class="outline-4">
<h4 id="org76804fa"><span class="section-number-4">8.1.2</span> 动态绑定端口： inet_hash_connect()</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
inet_hash_connect()函数主要用于在主动连接过程中动态绑定端口。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * Bind a port for a connect operation and hash it.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">inet_hash_connect</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_timewait_death_row</span> *<span style="color: #FF8C00;">death_row</span>,
		      <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>)
{       <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#25955;&#21015;&#34920;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_hashinfo</span> *<span style="color: #FF8C00;">hinfo</span> = death_row-&gt;hashinfo;
	<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">short</span> <span style="color: #FF8C00;">snum</span> = inet_sk(sk)-&gt;num; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#31471;&#21475;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_bind_hashbucket</span> *<span style="color: #FF8C00;">head</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_bind_bucket</span> *<span style="color: #FF8C00;">tb</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ret</span>;

	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>snum) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27809;&#26377;&#25351;&#23450;&#31471;&#21475;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#21160;&#24577;&#31471;&#21475;&#33539;&#22260;</span>
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">low</span> = sysctl_local_port_range[0];
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">high</span> = sysctl_local_port_range[1];
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">range</span> = high - low;
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>;
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">port</span>;
		<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">hint</span>;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#28304;&#30446;&#30340;&#22320;&#22336;&#21644;&#30446;&#30340;&#31471;&#21475;&#35745;&#31639;&#33719;&#21462;&#31471;&#21475;&#21021;&#22987;&#20540;</span>
		<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">offset</span> = hint + inet_sk_port_offset(sk);
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">hlist_node</span> *<span style="color: #FF8C00;">node</span>;
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_timewait_sock</span> *<span style="color: #FF8C00;">tw</span> = <span style="color: #AF87FF;">NULL</span>;

		local_bh_disable();
		<span style="color: #FF1493;">for</span> (i = 1; i &lt;= range; i++) {
			port = low + (i + offset) % range; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#31471;&#21475;</span>
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214;hash&#26631;&#65292;&#26816;&#26597;&#31471;&#21475;&#26159;&#21542;&#34987;&#21344;&#29992;</span>
			head = &amp;hinfo-&gt;bhash[inet_bhashfn(port, hinfo-&gt;bhash_size)];
			spin_lock(&amp;head-&gt;lock);

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Does not bother with rcv_saddr checks,</span>
<span style="color: #8B8878;">                         * because the established check is already</span>
<span style="color: #8B8878;">                         * unique enough.</span>
<span style="color: #8B8878;">                         */</span>
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19981;&#20801;&#35768;&#22797;&#29992;&#36890;&#36807;bind&#31995;&#32479;&#35843;&#29992;&#32465;&#23450;&#30340;&#31471;&#21475;&#65292;&#26080;&#35770;&#31471;&#21475;&#26159;&#21542;&#33021;&#34987;&#22797;&#29992;</span>
			inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain) {
				<span style="color: #FF1493;">if</span> (tb-&gt;port == port) {
					BUG_TRAP(<span style="color: #CDC673; font-weight: bold;">!</span>hlist_empty(&amp;tb-&gt;owners));
					<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21363;&#20351;&#31471;&#21475;&#21487;&#20197;&#22797;&#29992;&#65292;&#20294;&#26159;&#21160;&#24577;&#36873;&#25321;&#31471;&#21475;&#19981;&#33021;&#20351;&#29992;&#36890;&#36807;bind&#21344;&#29992;&#30340;&#31471;&#21475;</span>
					<span style="color: #FF1493;">if</span> (tb-&gt;fastreuse &gt;= 0)
						<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">next_port</span>;
					<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#26597;&#31471;&#21475;&#26159;&#21542;&#33021;&#34987;&#22797;&#29992;&#65292;&#21160;&#24577;&#32465;&#23450;&#30340;&#31471;&#21475;&#21482;&#33021;&#22797;&#29992;&#22312;TIME_WAIT&#29366;&#24577;&#19979;&#32465;&#23450;&#30340;&#31471;&#21475;&#65288;&#38656;&#35201;&#21551;&#29992;tcp_tw_reuse&#65289;</span>
					<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>__inet_check_established(death_row,
								      sk, port,
								      &amp;tw))
						<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">ok</span>;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21487;&#20197;&#22797;&#29992;</span>
					<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">next_port</span>;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#19979;&#19968;&#20010;&#31471;&#21475;</span>
				}
			}
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31471;&#21475;&#26410;&#20351;&#29992;&#65292;&#21017;&#21487;&#20197;&#20351;&#29992;&#35813;&#31471;&#21475;&#65292;&#20026;&#31471;&#21475;&#21019;&#24314;&#20449;&#24687;&#22359;&#24182;&#28155;&#21152;&#21040;bhash&#25955;&#21015;&#34920;</span>
			tb = inet_bind_bucket_create(hinfo-&gt;bind_bucket_cachep, head, port);
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tb) {
				spin_unlock(&amp;head-&gt;lock);
				<span style="color: #FF1493;">break</span>;
			}
			tb-&gt;fastreuse = -1;
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">ok</span>;

		<span style="color: #AF87FF;">next_port</span>:
			spin_unlock(&amp;head-&gt;lock);
		}
		local_bh_enable();
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25214;&#19981;&#21040;&#21487;&#29992;&#31471;&#21475;&#65292;&#36820;&#22238;&#38169;&#35823;</span>
		<span style="color: #FF1493;">return</span> -EADDRNOTAVAIL;

<span style="color: #AF87FF;">ok</span>:  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23436;&#25104;&#32465;&#23450;&#36807;&#31243;</span>
		hint += i;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Head lock still held and bh's disabled</span><span style="color: #8B8878;"> */</span>
		inet_bind_hash(sk, tb, port);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#20256;&#36755;&#25511;&#21046;&#22359;&#21644;&#32465;&#23450;&#31471;&#21475;&#20449;&#24687;&#20851;&#32852;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#33073;&#31163;ehash&#25955;&#21015;&#34920;&#25110;&#32773;&#27809;&#26377;&#28155;&#21152;&#65292;&#21017;&#28155;&#21152;&#33267;&#25955;&#21015;&#34920;</span>
		<span style="color: #FF1493;">if</span> (sk_unhashed(sk)) {
			inet_sk(sk)-&gt;sport = htons(port);
			__inet_hash(hinfo, sk, 0);
		}
		spin_unlock(&amp;head-&gt;lock);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#26159;&#22797;&#29992;&#30340;TIME_WAIT&#29366;&#24577;&#30340;&#31471;&#21475;&#65292;&#21017;&#38656;&#35201;&#21024;&#38500;&#37322;&#25918;TIMEWAIT&#29366;&#24577;&#30340;&#22871;&#25509;&#21475;</span>
		<span style="color: #FF1493;">if</span> (tw) {
			inet_twsk_deschedule(tw, death_row);
			inet_twsk_put(tw);
		}

		ret = 0;
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	}
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#30830;&#35748;&#19982;&#32465;&#23450;&#31471;&#21475;&#20449;&#24687;&#22359;&#32465;&#23450;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#26159;&#21542;&#26159;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;</span>
<span style="color: #8B8878;">        &#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#25351;&#21521;&#30340;&#32465;&#23450;&#20449;&#24687;&#22359;&#26159;&#21542;&#26377;&#25928;</span><span style="color: #8B8878;">*/</span>
	head = &amp;hinfo-&gt;bhash[inet_bhashfn(snum, hinfo-&gt;bhash_size)];
	tb  = inet_csk(sk)-&gt;icsk_bind_hash;
	spin_lock_bh(&amp;head-&gt;lock);
	<span style="color: #FF1493;">if</span> (sk_head(&amp;tb-&gt;owners) == sk &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>sk-&gt;sk_bind_node.next) {
		__inet_hash(hinfo, sk, 0);
		spin_unlock_bh(&amp;head-&gt;lock);
		<span style="color: #FF1493;">return</span> 0;
	} <span style="color: #FF1493;">else</span> {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21542;&#21017;&#38656;&#35201;&#36890;&#36807; __inet_check_established()&#26469;&#26816;&#27979;&#35813;&#31471;&#21475;&#33021;&#21542;&#34987;&#20351;&#29992;</span>
		spin_unlock(&amp;head-&gt;lock);
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">No definite answer... Walk to established hash table</span><span style="color: #8B8878;"> */</span>
		ret = __inet_check_established(death_row, sk, snum, <span style="color: #AF87FF;">NULL</span>);
<span style="color: #AF87FF;">out</span>:
		local_bh_enable();
		<span style="color: #FF1493;">return</span> ret;
	}
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdb7f8ff" class="outline-4">
<h4 id="orgdb7f8ff"><span class="section-number-4">8.1.3</span> 构造SYN段并发送：tcp_connect()</h4>
<div class="outline-text-4" id="text-8-1-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> * Build a SYN and send it off.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_connect</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">buff</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#21644;&#36830;&#25509;&#30456;&#20851;&#30340;&#25104;&#21592;&#12290;</span>
	tcp_connect_init(sk);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20026;SYN&#27573;&#20998;&#37197;SKB&#24182;&#35774;&#32622;&#30456;&#20851;&#23383;&#27573;</span>
	buff = alloc_skb_fclone(MAX_TCP_HEADER + 15, sk-&gt;sk_allocation);
	<span style="color: #FF1493;">if</span> (unlikely(buff == <span style="color: #AF87FF;">NULL</span>))
		<span style="color: #FF1493;">return</span> -ENOBUFS;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Reserve space for headers.</span><span style="color: #8B8878;"> */</span>
	skb_reserve(buff, MAX_TCP_HEADER);

	TCP_SKB_CB(buff)-&gt;flags = TCPCB_FLAG_SYN;
	TCP_ECN_send_syn(sk, tp, buff);
	TCP_SKB_CB(buff)-&gt;sacked = 0;
	skb_shinfo(buff)-&gt;gso_segs = 1;
	skb_shinfo(buff)-&gt;gso_size = 0;
	skb_shinfo(buff)-&gt;gso_type = 0;
	buff-&gt;csum = 0;
	tp-&gt;snd_nxt = tp-&gt;write_seq;
	TCP_SKB_CB(buff)-&gt;seq = tp-&gt;write_seq++;
	TCP_SKB_CB(buff)-&gt;end_seq = tp-&gt;write_seq;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Send it off.</span><span style="color: #8B8878;"> */</span>
	TCP_SKB_CB(buff)-&gt;when = tcp_time_stamp;
	tp-&gt;retrans_stamp = TCP_SKB_CB(buff)-&gt;when;
	skb_header_release(buff);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;SYN&#27573;&#28155;&#21152;&#21040;&#21457;&#36865;&#38431;&#21015;</span>
	__skb_queue_tail(&amp;sk-&gt;sk_write_queue, buff);
	sk_charge_skb(sk, buff);
	tp-&gt;packets_out += tcp_skb_pcount(buff);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;&#35813;&#27573;</span>
	tcp_transmit_skb(sk, buff, 1, GFP_KERNEL);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We change tp-&gt;snd_nxt after the tcp_transmit_skb() call</span>
<span style="color: #8B8878;">         * in order to make this packet get counted in tcpOutSegs.</span>
<span style="color: #8B8878;">         */</span>
	tp-&gt;snd_nxt = tp-&gt;write_seq;
	tp-&gt;pushed_seq = tp-&gt;write_seq;
	TCP_INC_STATS(TCP_MIB_ACTIVEOPENS);

	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26368;&#21518;&#21551;&#21160;&#37325;&#20256;&#23450;&#26102;&#22120;&#65292;&#20026;&#37325;&#20256;&#35813;SYN&#27573;&#20570;&#20934;&#22791;</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Timer for repeating the SYN until an answer.</span><span style="color: #8B8878;"> */</span>
	inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
				  inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3396490" class="outline-3">
<h3 id="org3396490"><span class="section-number-3">8.2</span> 第二次握手： 接收SYN+ACK段</h3>
<div class="outline-text-3" id="text-8-2">
</div>
<div id="outline-container-orge2b6ce4" class="outline-4">
<h4 id="orge2b6ce4"><span class="section-number-4">8.2.1</span> SYN_SENT状态的处理</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
tcp_rcv_state_process()用来处理不处于ESTABLISHED和TIME_WAIT状态的TCP段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_rcv_state_process</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,
			  <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #FF1493;">switch</span> (sk-&gt;sk_state) {
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #FF1493;">case</span> TCP_SYN_SENT: <span style="color: #8B8878;">//</span><span style="color: #8B8878;">SYN_SENT&#29366;&#24577;&#19979;&#25509;&#25910;&#21040;TCP&#27573;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36820;&#22238;&#20540;&#22823;&#20110;0,&#34920;&#31034;&#38656;&#35201;&#32473;&#23545;&#31471;&#21457;&#36865;RST&#27573;</span>
		queued = tcp_rcv_synsent_state_process(sk, skb, th, len);
		<span style="color: #FF1493;">if</span> (queued &gt;= 0)
			<span style="color: #FF1493;">return</span> queued;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Do step6 onward by hand.</span><span style="color: #8B8878;"> */</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#32039;&#24613;&#25968;&#25454;&#65292;&#26102;&#20505;&#37322;&#25918;&#35813;&#31471;</span>
		tcp_urg(sk, skb, th);
		__kfree_skb(skb);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;&#26159;&#21542;&#26377;&#25968;&#25454;&#38656;&#35201;&#21457;&#36865;</span>
		tcp_data_snd_check(sk, tp);
		<span style="color: #FF1493;">return</span> 0;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org6f4af6b" class="outline-4">
<h4 id="org6f4af6b"><span class="section-number-4">8.2.2</span> 处理SYN+ACK段</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
SYN_SENT状态下接收的段，除了紧急数据外，其他都由 tcp_rcv_synsent_state_process()处理。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_rcv_synsent_state_process</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,
					 <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcp_sock</span> *<span style="color: #FF8C00;">tp</span> = tcp_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_connection_sock</span> *<span style="color: #FF8C00;">icsk</span> = inet_csk(sk);
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">saved_clamp</span> = tp-&gt;rx_opt.mss_clamp;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35299;&#26512;TCP&#36873;&#39033;&#65292;&#20445;&#23384;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
	tcp_parse_options(skb, &amp;tp-&gt;rx_opt, 0);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#23384;&#22312;ACK&#26631;&#24535;&#30340;&#24773;&#20917;</span>
	<span style="color: #FF1493;">if</span> (th-&gt;ack) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">rfc793:</span>
<span style="color: #8B8878;">                 * "If the state is SYN-SENT then</span>
<span style="color: #8B8878;">                 *    first check the ACK bit</span>
<span style="color: #8B8878;">                 *      If the ACK bit is set</span>
<span style="color: #8B8878;">                 *        If SEG.ACK =&lt; ISS, or SEG.ACK &gt; SND.NXT, send</span>
<span style="color: #8B8878;">                 *        a reset (unless the RST bit is set, if so drop</span>
<span style="color: #8B8878;">                 *        the segment and return)"</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 *  We do not send data with SYN, so that RFC-correct</span>
<span style="color: #8B8878;">                 *  test reduces to:</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #FF1493;">if</span> (TCP_SKB_CB(skb)-&gt;ack_seq != tp-&gt;snd_nxt)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">reset_and_undo</span>;

		<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.saw_tstamp &amp;&amp; tp-&gt;rx_opt.rcv_tsecr &amp;&amp;
		    <span style="color: #CDC673; font-weight: bold;">!</span>between(tp-&gt;rx_opt.rcv_tsecr, tp-&gt;retrans_stamp,
			     tcp_time_stamp)) {
			NET_INC_STATS_BH(LINUX_MIB_PAWSACTIVEREJECTED);
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">reset_and_undo</span>;
		}

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Now ACK is acceptable.</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 * "If the RST bit is set</span>
<span style="color: #8B8878;">                 *    If the ACK was acceptable then signal the user "error:</span>
<span style="color: #8B8878;">                 *    connection reset", drop the segment, enter CLOSED state,</span>
<span style="color: #8B8878;">                 *    delete TCB, and return."</span>
<span style="color: #8B8878;">                 */</span>
		 <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#25509;&#25910;&#30340;&#26159; ACK+RST,&#21017;&#38656;&#35201;&#35843;&#29992;tcp_reset(),&#21516;&#26102;&#36890;&#30693;&#36827;&#31243;&#65292;&#24182;&#20851;&#38381;&#22871;&#25509;&#21475;</span>
		<span style="color: #FF1493;">if</span> (th-&gt;rst) {
			tcp_reset(sk);
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
		}

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">rfc793:</span>
<span style="color: #8B8878;">                 *   "fifth, if neither of the SYN or RST bits is set then</span>
<span style="color: #8B8878;">                 *    drop the segment and return."</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 *    See note below!</span>
<span style="color: #8B8878;">                 *                                        --ANK(990513)</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>th-&gt;syn) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24517;&#39035;&#23384;&#22312;SYN&#26631;&#24535;&#65292;&#21542;&#21017;&#35748;&#20026;&#35813;&#27573;&#26080;&#25928;</span>
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_and_undo</span>;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">rfc793:</span>
<span style="color: #8B8878;">                 *   "If the SYN bit is on ...</span>
<span style="color: #8B8878;">                 *    are acceptable then ...</span>
<span style="color: #8B8878;">                 *    (our SYN has been ACKed), change the connection</span>
<span style="color: #8B8878;">                 *    state to ESTABLISHED..."</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20174;&#39318;&#37096;&#20013;&#33719;&#21462;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;&#29305;&#24615;</span>
		TCP_ECN_rcv_synack(tp, th);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#19982;&#31383;&#21475;&#30456;&#20851;&#30340;&#21464;&#37327;</span>
		tp-&gt;snd_wl1 = TCP_SKB_CB(skb)-&gt;seq;
		tcp_ack(sk, skb, FLAG_SLOWPATH);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Ok.. it's good. Set up sequence numbers and</span>
<span style="color: #8B8878;">                 * move to established.</span>
<span style="color: #8B8878;">                 */</span>
		tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
		tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + 1;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">RFC1323: The window in SYN &amp; SYN/ACK segments is</span>
<span style="color: #8B8878;">                 * never scaled.</span>
<span style="color: #8B8878;">                 */</span>
		tp-&gt;snd_wnd = ntohs(th-&gt;window);
		tcp_init_wl(tp, TCP_SKB_CB(skb)-&gt;ack_seq, TCP_SKB_CB(skb)-&gt;seq);

		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;rx_opt.wscale_ok) {
			tp-&gt;rx_opt.snd_wscale = tp-&gt;rx_opt.rcv_wscale = 0;
			tp-&gt;window_clamp = min(tp-&gt;window_clamp, 65535U);
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26102;&#38388;&#25139;</span>
		<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.saw_tstamp) {
			tp-&gt;rx_opt.tstamp_ok       = 1;
			tp-&gt;tcp_header_len =
				<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) + TCPOLEN_TSTAMP_ALIGNED;
			tp-&gt;advmss          -= TCPOLEN_TSTAMP_ALIGNED;
			tcp_store_ts_recent(tp);
		} <span style="color: #FF1493;">else</span> {
			tp-&gt;tcp_header_len = <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>);
		}

		<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.sack_ok &amp;&amp; sysctl_tcp_fack)
			tp-&gt;rx_opt.sack_ok |= 2;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">PMTU MSS &#31561;</span>
		tcp_mtup_init(sk);
		tcp_sync_mss(sk, icsk-&gt;icsk_pmtu_cookie);
		tcp_initialize_rcv_mss(sk);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Remember, tcp_poll() does not lock socket!</span>
<span style="color: #8B8878;">                 * Change state from SYN-SENT only after copied_seq</span>
<span style="color: #8B8878;">                 * is initialized.</span><span style="color: #8B8878;"> */</span>
		tp-&gt;copied_seq = tp-&gt;rcv_nxt;
		smp_mb();
		tcp_set_state(sk, TCP_ESTABLISHED);

		security_inet_conn_established(sk, skb);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Make sure socket is routed, for correct metrics.</span><span style="color: #8B8878;">  */</span>
		icsk-&gt;icsk_af_ops-&gt;rebuild_header(sk);

		tcp_init_metrics(sk);

		tcp_init_congestion_control(sk);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Prevent spurious tcp_cwnd_restart() on first data</span>
<span style="color: #8B8878;">                 * packet.</span>
<span style="color: #8B8878;">                 */</span>
		tp-&gt;lsndtime = tcp_time_stamp;

		tcp_init_buffer_space(sk);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#21551;&#29992;&#36830;&#25509;&#20445;&#27963;&#65292;&#21017;&#21551;&#29992;&#36830;&#25509;&#20445;&#27963;&#23450;&#26102;&#22120;</span>
		<span style="color: #FF1493;">if</span> (sock_flag(sk, SOCK_KEEPOPEN))
			inet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));

		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>tp-&gt;rx_opt.snd_wscale) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#39318;&#37096;&#39044;&#27979;&#26631;&#24535;</span>
			__tcp_fast_path_on(tp, tp-&gt;snd_wnd);
		<span style="color: #FF1493;">else</span>
			tp-&gt;pred_flags = 0;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22871;&#25509;&#21475;&#19981;&#22788;&#20110;SOCK_DEAD&#29366;&#24577;&#65292;&#21017;&#21796;&#37266;&#35813;&#22871;&#25509;&#21475;&#30340;&#36827;&#31243;</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>sock_flag(sk, SOCK_DEAD)) {
			sk-&gt;sk_state_change(sk);
			sk_wake_async(sk, 0, POLL_OUT);
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36830;&#25509;&#24314;&#31435;&#23436;&#25104;&#65292;&#26681;&#25454;&#24773;&#20917;&#36827;&#20837;&#24310;&#26102;&#30830;&#35748;&#27169;&#24335;</span>
		<span style="color: #FF1493;">if</span> (sk-&gt;sk_write_pending ||
		    icsk-&gt;icsk_accept_queue.rskq_defer_accept ||
		    icsk-&gt;icsk_ack.pingpong) {
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Save one ACK. Data will be ready after</span>
<span style="color: #8B8878;">                         * several ticks, if write_pending is set.</span>
<span style="color: #8B8878;">                         *</span>
<span style="color: #8B8878;">                         * It may be deleted, but with this feature tcpdumps</span>
<span style="color: #8B8878;">                         * look so _wonderfully_ clever, that I was not able</span>
<span style="color: #8B8878;">                         * to stand against the temptation 8)     --ANK</span>
<span style="color: #8B8878;">                         */</span>
			inet_csk_schedule_ack(sk);
			icsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;
			icsk-&gt;icsk_ack.ato       = TCP_ATO_MIN;
			tcp_incr_quickack(sk);
			tcp_enter_quickack_mode(sk);
			inet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,
						  TCP_DELACK_MAX, TCP_RTO_MAX);

<span style="color: #AF87FF;">discard</span>:
			__kfree_skb(skb);
			<span style="color: #FF1493;">return</span> 0;
		} <span style="color: #FF1493;">else</span> {
			tcp_send_ack(sk);
		}
		<span style="color: #FF1493;">return</span> -1;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">No ACK in the segment</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (th-&gt;rst) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">rfc793:</span>
<span style="color: #8B8878;">                 * "If the RST bit is set</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 *      Otherwise (no ACK) drop the segment and return."</span>
<span style="color: #8B8878;">                 */</span>

		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_and_undo</span>;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">PAWS check.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; tp-&gt;rx_opt.saw_tstamp &amp;&amp; tcp_paws_check(&amp;tp-&gt;rx_opt, 0))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard_and_undo</span>;

	<span style="color: #FF1493;">if</span> (th-&gt;syn) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We see SYN without ACK. It is attempt of</span>
<span style="color: #8B8878;">                 * simultaneous connect with crossed SYNs.</span>
<span style="color: #8B8878;">                 * Particularly, it can be connect to self.</span>
<span style="color: #8B8878;">                 */</span>
		tcp_set_state(sk, TCP_SYN_RECV);

		<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.saw_tstamp) {
			tp-&gt;rx_opt.tstamp_ok = 1;
			tcp_store_ts_recent(tp);
			tp-&gt;tcp_header_len =
				<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) + TCPOLEN_TSTAMP_ALIGNED;
		} <span style="color: #FF1493;">else</span> {
			tp-&gt;tcp_header_len = <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>);
		}

		tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
		tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + 1;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">RFC1323: The window in SYN &amp; SYN/ACK segments is</span>
<span style="color: #8B8878;">                 * never scaled.</span>
<span style="color: #8B8878;">                 */</span>
		tp-&gt;snd_wnd    = ntohs(th-&gt;window);
		tp-&gt;snd_wl1    = TCP_SKB_CB(skb)-&gt;seq;
		tp-&gt;max_window = tp-&gt;snd_wnd;

		TCP_ECN_rcv_syn(tp, th);

		tcp_mtup_init(sk);
		tcp_sync_mss(sk, icsk-&gt;icsk_pmtu_cookie);
		tcp_initialize_rcv_mss(sk);


		tcp_send_synack(sk);
<span style="color: #FF1493;">#if</span> 0
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Note, we could accept data and URG from this segment.</span>
<span style="color: #8B8878;">                 * There are no obstacles to make this.</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 * However, if we ignore data in ACKless segments sometimes,</span>
<span style="color: #8B8878;">                 * we have no reasons to accept it sometimes.</span>
<span style="color: #8B8878;">                 * Also, seems the code doing it in step6 of tcp_rcv_state_process</span>
<span style="color: #8B8878;">                 * is not flawless. So, discard packet for sanity.</span>
<span style="color: #8B8878;">                 * Uncomment this return to process the data.</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #FF1493;">return</span> -1;
<span style="color: #FF1493;">#else</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
<span style="color: #FF1493;">#endif</span>
	}
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">"fifth, if neither of the SYN or RST bits is set then</span>
<span style="color: #8B8878;">         * drop the segment and return."</span>
<span style="color: #8B8878;">         */</span>

<span style="color: #AF87FF;">discard_and_undo</span>:
	tcp_clear_options(&amp;tp-&gt;rx_opt);
	tp-&gt;rx_opt.mss_clamp = saved_clamp;
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;

<span style="color: #AF87FF;">reset_and_undo</span>:
	tcp_clear_options(&amp;tp-&gt;rx_opt);
	tp-&gt;rx_opt.mss_clamp = saved_clamp;
	<span style="color: #FF1493;">return</span> 1;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4190c5f" class="outline-3">
<h3 id="org4190c5f"><span class="section-number-3">8.3</span> 第三次握手：发送ACK段</h3>
<div class="outline-text-3" id="text-8-3">
<p>
tcp_send_ack()用来发送ACK段，同时更新窗口。
</p>
<ul class="org-ul">
<li>发送ACK段时，TCP必须不在CLOSE状态。</li>
<li>为ACK段分配一个SKB，如果分配失败则在启动延时确认定时器后返回。</li>
<li>如果分配SKB成功，则设置SKB中相关的参数，如标志、GSO属性等。</li>
<li>最后设置TCP序号和发送时间，调用tcp_transmit_skb() 发送ACK段。</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org6824b2f" class="outline-2">
<h2 id="org6824b2f"><span class="section-number-2">9</span> 同时打开</h2>
<div class="outline-text-2" id="text-9">
<p>
每一端必须发送一个SYN，并且这两个SYN都传递到对端，这需要两端使用一个对端熟知的端口作为本地端口，此时成为同时打开。
</p>

<p>
出现同时打开的情况时，两端几乎同时发送SYN并进入SYN_SENT状态; 当对端都受到SYN后状态变为SYN_RECV状态，此时发送SYN并对受到的SYN进行确认，当双方都受到对端的SYN和ACK后，状态变为ESTABLISHED。
</p>
</div>

<div id="outline-container-org10864c8" class="outline-3">
<h3 id="org10864c8"><span class="section-number-3">9.1</span> SYN_SENT状态接收到SYN段</h3>
<div class="outline-text-3" id="text-9-1">
<p>
SYN_SENT状态下收到的段除了紧急数据之外，其他都由 tcp_rcv_synsent_state_process()处理。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">tcp_rcv_synsent_state_process</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,
					 <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span> *<span style="color: #FF8C00;">th</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #FF1493;">if</span> (th-&gt;syn) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#25509;&#25910;&#21040;SYN,&#20294;&#26159;&#27809;&#26377;ACK&#30340;&#24773;&#20917;&#65288;&#21516;&#26102;&#25171;&#24320;&#65289;</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">We see SYN without ACK. It is attempt of</span>
<span style="color: #8B8878;">                 * simultaneous connect with crossed SYNs.</span>
<span style="color: #8B8878;">                 * Particularly, it can be connect to self.</span>
<span style="color: #8B8878;">                 */</span>  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#20026;SYN_RECV&#29366;&#24577;</span>
		tcp_set_state(sk, TCP_SYN_RECV);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26102;&#38388;&#25139;</span>
		<span style="color: #FF1493;">if</span> (tp-&gt;rx_opt.saw_tstamp) {
			tp-&gt;rx_opt.tstamp_ok = 1;
			tcp_store_ts_recent(tp);
			tp-&gt;tcp_header_len =
				<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>) + TCPOLEN_TSTAMP_ALIGNED;
		} <span style="color: #FF1493;">else</span> {
			tp-&gt;tcp_header_len = <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">tcphdr</span>);
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#31383;&#21475;&#30456;&#20851;&#30340;&#25104;&#21592;&#21464;&#37327;</span>
		tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
		tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + 1;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">RFC1323: The window in SYN &amp; SYN/ACK segments is</span>
<span style="color: #8B8878;">                 * never scaled.</span>
<span style="color: #8B8878;">                 */</span>
		tp-&gt;snd_wnd    = ntohs(th-&gt;window);
		tp-&gt;snd_wl1    = TCP_SKB_CB(skb)-&gt;seq;
		tp-&gt;max_window = tp-&gt;snd_wnd;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20174;&#39318;&#37096;&#20013;&#33719;&#21462;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;&#29305;&#24615;</span>
		TCP_ECN_rcv_syn(tp, th);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">PMTU MSS&#31561;&#25104;&#21592;&#30340;&#21021;&#22987;&#21270;</span>
		tcp_mtup_init(sk);
		tcp_sync_mss(sk, icsk-&gt;icsk_pmtu_cookie);
		tcp_initialize_rcv_mss(sk);

		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;SYN+ACK</span>
		tcp_send_synack(sk);
<span style="color: #FF1493;">#if</span> 0
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Note, we could accept data and URG from this segment.</span>
<span style="color: #8B8878;">                 * There are no obstacles to make this.</span>
<span style="color: #8B8878;">                 *</span>
<span style="color: #8B8878;">                 * However, if we ignore data in ACKless segments sometimes,</span>
<span style="color: #8B8878;">                 * we have no reasons to accept it sometimes.</span>
<span style="color: #8B8878;">                 * Also, seems the code doing it in step6 of tcp_rcv_state_process</span>
<span style="color: #8B8878;">                 * is not flawless. So, discard packet for sanity.</span>
<span style="color: #8B8878;">                 * Uncomment this return to process the data.</span>
<span style="color: #8B8878;">                 */</span>
		<span style="color: #FF1493;">return</span> -1;
<span style="color: #FF1493;">#else</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;
<span style="color: #FF1493;">#endif</span>
	}
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">"fifth, if neither of the SYN or RST bits is set then</span>
<span style="color: #8B8878;">         * drop the segment and return."</span>
<span style="color: #8B8878;">         */</span>

<span style="color: #AF87FF;">discard_and_undo</span>:
	tcp_clear_options(&amp;tp-&gt;rx_opt);
	tp-&gt;rx_opt.mss_clamp = saved_clamp;
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">discard</span>;

<span style="color: #AF87FF;">reset_and_undo</span>:
	tcp_clear_options(&amp;tp-&gt;rx_opt);
	tp-&gt;rx_opt.mss_clamp = saved_clamp;
	<span style="color: #FF1493;">return</span> 1;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc21fcc8" class="outline-3">
<h3 id="orgc21fcc8"><span class="section-number-3">9.2</span> SYN_RECV状态接收SYN+ACK段</h3>
<div class="outline-text-3" id="text-9-2">
<p>
SYN_RECV状态接收到SYN+ACK参见 tcp_rcv_state_process().
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2022-04-25 Mon 22:45</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
