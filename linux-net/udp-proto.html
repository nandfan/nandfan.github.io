<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:56 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>UDP：用户数据报</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">UDP：用户数据报</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org76ae31d">1. 引言</a>
<ul>
<li><a href="#org8df965a">1.1. UPD首部</a></li>
<li><a href="#org18b76b8">1.2. UDP的输入与输出</a></li>
</ul>
</li>
<li><a href="#org721493f">2. UDP的inet_protosw结构</a></li>
<li><a href="#org8f9be32">3. UDP的传输控制块</a></li>
<li><a href="#org00a6b61">4. UDP的proto结构和proto_ops结构的实例</a></li>
<li><a href="#org4da9c91">5. UDP的状态</a></li>
<li><a href="#orgac39ec8">6. UDP传输控制块的管理</a></li>
<li><a href="#org9d271db">7. bind系统调用的实现</a></li>
<li><a href="#orgd93d0a7">8. UDP套接口的关闭</a></li>
<li><a href="#orgb9beaf8">9. connect系统调用的实现</a>
<ul>
<li><a href="#org5e38748">9.1. udp_disconnect()</a></li>
<li><a href="#org94c1e15">9.2. ip4_datagram_connect()</a></li>
</ul>
</li>
<li><a href="#orgfe13835">10. select系统调用的实现</a></li>
<li><a href="#orgadb9143">11. UDP的ioctl</a>
<ul>
<li><a href="#org35b5dbc">11.1. UDP的套接口选项</a></li>
</ul>
</li>
<li><a href="#org557a03a">12. UDP校验和</a>
<ul>
<li><a href="#org976517f">12.1. 输入UDP数据报校验和的计算</a>
<ul>
<li><a href="#org1eed72d">12.1.1. udp4_csum_init()</a></li>
<li><a href="#org24b6f2e">12.1.2. udp_lib_checksum_complete()</a></li>
</ul>
</li>
<li><a href="#org1d2565c">12.2. 输出UDP数据报校验和的计算</a>
<ul>
<li><a href="#orgbc2333f">12.2.1. udp4_hwcsum_outgoing()</a></li>
<li><a href="#orgf7ee886">12.2.2. csum_tcpudp_magic()和udp_csum_outgoing()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgddff7f2">13. UDP的输出：sendmsg系统调用</a>
<ul>
<li><a href="#org84e5f2f">13.1. udp_sendmsg()</a></li>
<li><a href="#orge26a5fe">13.2. udp_push_pending_frames()</a></li>
</ul>
</li>
<li><a href="#org5ccf5bd">14. UDP的输入</a>
<ul>
<li><a href="#org70e9736">14.1. UDP接收的入口：udp_rcv()</a></li>
<li><a href="#org3b79ddc">14.2. UDP组播数据报输入：__udp4_lib_mcast_deliver()</a></li>
<li><a href="#org57847ee">14.3. udp_queue_rcv_skb()</a></li>
</ul>
</li>
<li><a href="#org696af26">15. recvmsg系统调用的实现</a></li>
<li><a href="#orgd6930b7">16. UDP的差错处理：udp_err()</a></li>
<li><a href="#org2db9e74">17. 轻量级UDP</a></li>
</ul>
</div>
</div>

<div id="outline-container-org76ae31d" class="outline-2">
<h2 id="org76ae31d"><span class="section-number-2">1.</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
UDP是一个简单的面向数据报的传输层协议：进程的每个输出操作通常都会产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流的协议不同，例如TCP，应用程序产生的数据与真正发送的单个IP数据报不能存在直接的关联。UPD数据报封装成IP数据报的格式。
</p>


<div id="orgaca023a" class="figure">
<p><img src="image/udp-proto/udp-encap.png" alt="udp-encap.png" />
</p>
<p><span class="figure-number">Figure 1: </span>UDP封装</p>
</div>

<p>
UDP不提供可靠性，它把应用程序传给IP层的数据发送出去，但并不保证他们能到达目的地。应用程序必须关心IP数据报的长度，如果它超过网络MTU，则需要对IP数据报进行分片。源端到目的端之间的每一段都有可能进行分片，不只是发送方主机。
</p>
</div>

<div id="outline-container-org8df965a" class="outline-3">
<h3 id="org8df965a"><span class="section-number-3">1.1.</span> UPD首部</h3>
<div class="outline-text-3" id="text-1-1">
<p>
UDP首部各自段如下图：
</p>

<div id="org770da9e" class="figure">
<p><img src="image/udp-proto/udp-header.png" alt="udp-header.png" />
</p>
<p><span class="figure-number">Figure 2: </span>UDP首部</p>
</div>

<p>
端口号用来标识发送和接收进程。UDP长度字段指的是UDP首部和UDP数据的总字节数，该字段的最小值为8，即无UDP数据报。IP数据报长度指的是整个IP数据报的总长度，因此UDP长度是拥IP长度减去IP首部长度。
</p>
</div>
</div>


<div id="outline-container-org18b76b8" class="outline-3">
<h3 id="org18b76b8"><span class="section-number-3">1.2.</span> UDP的输入与输出</h3>
<div class="outline-text-3" id="text-1-2">
<p>
进程输出一个UDP数据报时，通常会在IP层组装成一个对应的IP数据报。但实际上并不一定是如此，可以由UDP_CROK选项来确定发送的UDP数据是否组成一个单独的IP数据报发送。当UDP_CORK选项值为非0时，即一个UDP数据对应一个IP数据报，会有延迟。
</p>

<p>
UDP函数调用关系如下：
</p>

<div id="org32f031f" class="figure">
<p><img src="image/udp-proto/udp-call.png" alt="udp-call.png" />
</p>
<p><span class="figure-number">Figure 3: </span>UDP函数调用关系</p>
</div>

<p>
和TCP一样，sock结构中的sk_receive_queue成员是UDP的接收队列，通常情况下，接收到的UDP数据报会缓存到此，等待用户进程的读取。UDP接收到数据报后，通过校验UDP数据报，根据类型（IPSEC封装、组播、单播）作不同的处理后被添加到接收队列。
</p>


<div id="orgb84e163" class="figure">
<p><img src="image/udp-proto/udp-recv-queue.png" alt="udp-recv-queue.png" />
</p>
<p><span class="figure-number">Figure 4: </span>UDP接收队列</p>
</div>

<p>
UDP传输控制块中的sk_receive_queue是存储已接收待传递到用户空间的UDP数据报的双向链表的表头。
</p>
</div>
</div>
</div>


<div id="outline-container-org721493f" class="outline-2">
<h2 id="org721493f"><span class="section-number-2">2.</span> UDP的inet_protosw结构</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_protosw</span> <span style="color: #FD971F;">inetsw_array</span>[] =
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        {
                .type =       SOCK_DGRAM, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#31867;&#22411;</span>
                .protocol =   IPPROTO_UDP, <span style="color: #75715E;">//</span><span style="color: #75715E;">UDP&#21327;&#35758;&#31867;&#22411;</span>
                .prot =       &amp;udp_prot,  <span style="color: #75715E;">///</span><span style="color: #75715E;">UDP&#20256;&#36755;&#23618;&#25805;&#20316;&#25509;&#21475;</span>
                .ops =        &amp;inet_dgram_ops, <span style="color: #75715E;">//</span><span style="color: #75715E;">UDP&#22871;&#25509;&#21475;&#23618;&#25805;&#20316;&#25509;&#21475;</span>
                .capability = -1,   <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22312;&#21019;&#24314;UDP&#22871;&#25509;&#21475;&#26102;&#38656;&#35201;&#26816;&#39564;&#21019;&#24314;&#35813;&#22871;&#25509;&#21475;&#30340;&#36827;&#31243;&#26159;&#21542;&#26377;&#36825;&#31181;&#33021;&#21147;&#65292;</span>
<span style="color: #75715E;">                capability&#20026; -1&#34920;&#31034;&#26080;&#38656;&#20316;&#26657;&#39564;</span><span style="color: #75715E;"> */</span>
                .no_check =   UDP_CSUM_DEFAULT, <span style="color: #75715E;">/* </span><span style="color: #75715E;">UDP&#30340;&#26657;&#39564;&#21644;&#26159;&#21487;&#36873;&#30340;&#65292;UDP_CSUM_DEFAULT&#26631;&#35782;</span>
<span style="color: #75715E;">                UDP&#38656;&#35201;&#36827;&#34892;&#27491;&#24120;&#30340;&#26657;&#39564;&#21644;&#25805;&#20316;</span><span style="color: #75715E;">*/</span>
                .flags =      INET_PROTOSW_PERMANENT, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#34920;&#31034;&#19981;&#33021;&#20316;&#20026;&#20869;&#26680;&#27169;&#22359;&#36827;&#34892;&#21160;&#24577;&#30340;&#21152;&#36733;&#25110;&#21368;&#36733;&#12290;</span>
       },
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
};
</pre>
</div>
</div>
</div>


<div id="outline-container-org8f9be32" class="outline-2">
<h2 id="org8f9be32"><span class="section-number-2">3.</span> UDP的传输控制块</h2>
<div class="outline-text-2" id="text-3">
<p>
UDP协议的传输控制块用udp_sock结构表示，是对inet_sock结构的扩展。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udp_sock</span> {
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">inet_sock has to be the first member</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> <span style="color: #FD971F;">inet</span>;
        <span style="color: #E6DB74;">/** &#21457;&#36865;&#29366;&#24577;&#65292;&#21482;&#33021;&#26159;0&#25110;&#32773;AF_INET</span>
<span style="color: #E6DB74;">        + 0     &#34920;&#31034;&#25968;&#25454;&#24050;&#32463;&#20174;UDP&#22871;&#25509;&#21475;&#21457;&#36865;&#21040;IP&#23618;&#65292;&#21487;&#20197;&#32487;&#32493;&#35843;&#29992;</span><span style="color: #AE81FF;">sendmsg()</span><span style="color: #E6DB74;">&#21457;&#36865;&#25968;&#25454;</span>
<span style="color: #E6DB74;">        + AF_INET UDP&#27491;&#22312;&#22788;&#29702;&#35843;&#29992;sendmsg&#30340;&#21457;&#36865;&#25968;&#25454;&#65292;&#19981;&#38656;&#35201;&#22788;&#29702;&#30446;&#30340;&#22320;&#22336;&#12289;&#36335;&#30001;&#20449;&#24687;&#65292;</span>
<span style="color: #E6DB74;">          &#30452;&#25509;&#22788;&#29702;UDP&#25968;&#25454;*/</span>
        <span style="color: #66D9EF;">int</span>              <span style="color: #FD971F;">pending</span>;
        <span style="color: #E6DB74;">/** &#23453;&#30707;&#21457;&#36865;UDP&#25968;&#25454;&#26159;&#21542;&#32452;&#25104;&#19968;&#20010;&#21333;&#29420;&#30340;IP&#25968;&#25454;&#25253;&#21457;&#36865;&#65292;&#30001;UDP&#30340;UDP_CORK&#36873;&#39033;&#35774;&#32622;</span>
<span style="color: #E6DB74;">        + 0     &#26377;&#25968;&#25454;&#38656;&#35201;&#21457;&#36865;&#26102;&#65292;&#31435;&#21363;&#21457;&#36865;</span>
<span style="color: #E6DB74;">        + &#38750;0   &#23558;UDP&#25968;&#25454;&#32452;&#25104;&#19968;&#20010;&#21333;&#19968;64KB&#30340;UDP&#25968;&#25454;&#25253;&#21518;&#25165;&#36827;&#34892;&#21457;&#36865;&#65292;&#22240;&#27492;&#20250;&#26377;&#24310;&#36831;*/</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">corkflag</span>;      <span style="color: #75715E;">/* </span><span style="color: #75715E;">Cork is required</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#34920;&#31034;&#26412;&#22871;&#25509;&#21475;&#26159;&#21542;&#36890;&#36807;IPSEC&#23553;&#35013;&#65292;&#30001;UDP&#30340;UDP_ENCAP&#22871;&#25509;&#21475;&#36873;&#39033;&#35774;&#32622;&#65292;&#19968;&#33324;&#22312;IKE&#31243;&#24207;&#25171;&#24320;</span>
<span style="color: #75715E;">        UDP&#31471;&#21475;4500&#26102;&#35774;&#32622;</span><span style="color: #75715E;">*/</span>
        <span style="color: #66D9EF;">__u16</span>            <span style="color: #FD971F;">encap_type</span>;    <span style="color: #75715E;">/* </span><span style="color: #75715E;">Is this an Encapsulation socket?</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20174;UDP&#22871;&#25509;&#21475;&#21457;&#36865;&#25968;&#25454;&#21040;IP&#23618;&#26102;&#65292;&#34920;&#31034;&#24453;&#21457;&#36865;&#25968;&#25454;&#30340;&#38271;&#24230;</span><span style="color: #75715E;">*/</span>
        <span style="color: #66D9EF;">__u16</span>            <span style="color: #FD971F;">len</span>;           <span style="color: #75715E;">/* </span><span style="color: #75715E;">total length of pending frames</span><span style="color: #75715E;"> */</span>
        <span style="color: #E6DB74;">/** &#36731;&#37327;&#32423;UDP&#65292;&#36890;&#36807;UDPLITE_SEND_CSCOV&#21644;UDPLITE_RECV_CSCOV&#36873;&#39033;&#35774;&#32622;&#65292;&#29992;&#20110;&#23454;&#29616;</span>
<span style="color: #E6DB74;">        &#25511;&#21046;&#21457;&#36865;&#21644;&#25509;&#25910;&#26657;&#39564;&#21644;&#30340;&#25191;&#34892;</span>
<span style="color: #E6DB74;">        pcslen/pcrlen&#21462;&#20540;&#65306;</span>
<span style="color: #E6DB74;">        + &#20540;&#20026;0         &#34920;&#31034;&#23545;&#21457;&#36865;/&#25509;&#25910;&#30340;&#25972;&#20010;UDP-Lite&#25968;&#25454;&#21253;&#36827;&#34892;&#26657;&#39564;</span>
<span style="color: #E6DB74;">        + &#20540;&gt;=8         &#34920;&#31034;&#23545;&#21457;&#36865;/&#25509;&#25910;UDP-Lite&#21253;&#30340;&#21069;pcslen/pcrlen&#20010;&#23383;&#33410;&#36827;&#34892;&#26657;&#39564;</span>
<span style="color: #E6DB74;">        + &#20854;&#20182;&#20540;&#38750;&#27861;    */</span>
        <span style="color: #66D9EF;">__u16</span>            <span style="color: #FD971F;">pcslen</span>;
        <span style="color: #66D9EF;">__u16</span>            <span style="color: #FD971F;">pcrlen</span>;
<span style="color: #75715E;">/* </span><span style="color: #75715E;">indicator bits used by pcflag:</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">UDPLITE_BIT</span>      0x1            <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#34920;&#31034;&#35813;&#22871;&#25509;&#21475;&#26159;&#21542;&#20026;&#36731;&#37327;&#32423;UDP</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">UDPLITE_SEND_CC</span>  0x2            <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35774;&#32622;&#20102;&#36873;&#39033;UDPLITE_SEND_CSCOV</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">UDPLITE_RECV_CC</span>  0x4            <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35774;&#32622;&#20102;&#36873;&#39033;UDPLITE_RECV_CSCOV</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#25353;&#20301;&#23384;&#20648;&#65292;&#34920;&#31034;&#26159;&#21542;&#35774;&#32622;&#20102;UDPLITE_SEND_CSCOV&#25110;UDPLITE_RECV_CSCOV&#36873;&#39033;</span><span style="color: #75715E;">*/</span>
        <span style="color: #66D9EF;">__u8</span>             <span style="color: #FD971F;">pcflag</span>;
};
</pre>
</div>
</div>
</div>


<div id="outline-container-org00a6b61" class="outline-2">
<h2 id="org00a6b61"><span class="section-number-2">4.</span> UDP的proto结构和proto_ops结构的实例</h2>
<div class="outline-text-2" id="text-4">
<p>
UDP协议的传输层接口是udp_prot，套接口层接口为inet_dgram_ops。
</p>
</div>
</div>


<div id="outline-container-org4da9c91" class="outline-2">
<h2 id="org4da9c91"><span class="section-number-2">5.</span> UDP的状态</h2>
<div class="outline-text-2" id="text-5">
<p>
UDP的传输是没有状态的，但事实上，UDP和RAW也借用了TCP中的一些值：在一个套接口创建之初，其状态都是TCP_CLOSE，当UDP套接口调用了connect()后，状态改变为TCP_ESTABLISHED，最后，关闭套接口时又置回TCP_CLOSE，RAW也是如此。
</p>
</div>
</div>


<div id="outline-container-orgac39ec8" class="outline-2">
<h2 id="orgac39ec8"><span class="section-number-2">6.</span> UDP传输控制块的管理</h2>
<div class="outline-text-2" id="text-6">
<p>
与TCP不同，UDP并不是在hash接口中将其传输控制块添加到udp_hahs散列表中的，而是在绑定端口后，才将其添加到散列表中，关键字为端口号与散列表大小取模后的值。
</p>

<p>
和TCP一样，成功创建一个UDP传输控制块后，也需要对其进行合理的管理。由于UDP没有状态的迁移，因此管理比TCP容易很多。但并非所有的UDP传输控制块都是在散列表中管理的，只有当套接口绑定了端口后，此时可接收或发送数据，才会添加到散列表中管理。udp_hash散列表，大小为UDP_HTABLE_SIZE。套接口一旦绑定端口添加到散列表后，直到关闭才会从散列表删除。
</p>

<p>
UDP传输层中只使用一个udp_hash散列表来管理UDP传输控制块，如下图：
</p>

<div id="org327f7e8" class="figure">
<p><img src="image/udp-proto/udp-sk-hash.png" alt="udp-sk-hash.png" />
</p>
<p><span class="figure-number">Figure 5: </span>UDP传输控制块的散列表</p>
</div>

<p>
UDP传输控制块在udp_hash散列表中的添加与删除，参见bind系统调用的实现与UDP套接口的关闭。
</p>
</div>
</div>


<div id="outline-container-org9d271db" class="outline-2">
<h2 id="org9d271db"><span class="section-number-2">7.</span> bind系统调用的实现</h2>
<div class="outline-text-2" id="text-7">
<p>
UDP的绑定实际上完成两个功能，根据选取的合适端口号将传输控制块添加到udp_hash散列表中，并将端口号设置到传输控制块中。
</p>

<p>
bind的调用过程比较简单，首先根据套接口的文件描述符获取对应的传输控制块，然后调用套接口层bind接口inet_bind()，最后调用到传输层接口。在inet_bind()中，如果是原始IP则调用bind接口进行绑定，其他的包括TCP和UDP则调用get_port接口进行绑定。
</p>

<p>
在UDP中实现传输接口层get_port接口的函数是udp_v4_get_port()，它只是一个接口函数，而真正实现bing功能的是__udp_lib_get_port()。udp_v4_get_port封装了udp_get_port()，udp_get_port()有封装了__udp_lib_get_port()。相对于udp_v4_get_port()，udp_get_port()多了一个参数scmp，该参数是一个函数指针，在此实际传入的是ipv4_rcv_saddr_equal()，用于比较两个传输控制块的接收地址是否相等。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;">  *              UDP</span>
<span style="color: #E6DB74;">  *   </span><span style="color: #AE81FF;">get_port()</span><span style="color: #E6DB74;"> --&gt; </span><span style="color: #AE81FF;">udp_v4_get_port()</span>
<span style="color: #E6DB74;">  *                  |--&gt;  </span><span style="color: #AE81FF;">udp_get_port()</span>
<span style="color: #E6DB74;">  *                           |--&gt; </span><span style="color: #AE81FF;">__udp_lib_get_port()</span>
<span style="color: #E6DB74;">  *</span>
<span style="color: #E6DB74;">  */</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_v4_get_port</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> <span style="color: #FD971F;">snum</span>)
{
        <span style="color: #F92672;">return</span> udp_get_port(sk, snum, ipv4_rcv_saddr_equal);
}

<span style="color: #E6DB74;">/**</span>
<span style="color: #AE81FF;">ipv4_rcv_saddr_equal()</span><span style="color: #E6DB74;">&#27604;&#36739;&#20004;&#20010;&#20256;&#36755;&#25511;&#21046;&#22359;&#26412;&#22320;&#32465;&#23450;&#22320;&#22336;&#30456;&#31561;&#30340;&#26465;&#20214;&#26159;&#65292;&#20256;&#36755;&#25511;&#21046;&#22359;&#25903;&#25345;IPv4&#65292;</span>
<span style="color: #E6DB74;">&#20004;&#32773;&#30456;&#31561;&#19988;&#37117;&#19981;&#20026;&#31354;&#12290;</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ipv4_rcv_saddr_equal</span>(<span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk1</span>, <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk2</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet1</span> = inet_sk(sk1), *<span style="color: #FD971F;">inet2</span> = inet_sk(sk2);

        <span style="color: #F92672;">return</span>  ( <span style="color: #E6DB74; font-weight: bold;">!</span>ipv6_only_sock(sk2)  &amp;&amp;
                  (<span style="color: #E6DB74; font-weight: bold;">!</span>inet1-&gt;rcv_saddr || <span style="color: #E6DB74; font-weight: bold;">!</span>inet2-&gt;rcv_saddr ||
                   inet1-&gt;rcv_saddr == inet2-&gt;rcv_saddr      ));
}

__inline__ <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_get_port</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> <span style="color: #FD971F;">snum</span>,
                        <span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">scmp</span>)(<span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *, <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *))
{
        <span style="color: #F92672;">return</span>  __udp_lib_get_port(sk, snum, udp_hash, &amp;udp_port_rover, scmp);
}
</pre>
</div>

<p>
__udp_lib_get_port多了两个参数udp_hash和udp_port_rover。前者用于管理UDP传输控制块散列表，后者是个全局变量，用于记录最近一次自动绑定的端口号，下次自动绑定端口时，在从udp_port_rover开始尝试。
</p>

<p>
__udp_lib_get_port()完成真正的绑定操作。如果指定了端口，则绑定过程是很简单的，首先检测端口是否可用，检测通过后进行绑定。如果未指定端口，则自动选择一个合适的端口进行绑定。选择合适的端口是为了使UDP传输控制块在udp_hash散列表中的分布比较均匀，即散列表的每个桶存储的UDP传输控制块差不多。
</p>

<p>
因此选择可用端口号的方法并不是简单的递增查找未使用的端口号，而是尝试着从记录标记开始递增端口号并遍历散列表中的所有链表，得到一个端口号，该端口号可得到散列表桶内控制块最少那个桶的关键字。该端口号并不能保证能够使用，因为还确定其是否已经被绑定，检测该端口是否正在使用。如果没有使用，则查找结束，否则对该端口号递增一个散列表大小，即UDP_HTABLE_SIZE，之后再次检测。如此不断重复，知道得到可用端口号或查找失败为止。如果找到可用端口号则记录之，下次绑定时从此端口号开始尝试查找可用端口号。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> *  __udp_lib_get_port  -  UDP/-Lite port lookup for IPv4 and IPv6</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> *  </span><span style="color: #AE81FF;">@sk</span><span style="color: #E6DB74;">:          socket struct in question</span>
<span style="color: #E6DB74;"> *  </span><span style="color: #AE81FF;">@snum</span><span style="color: #E6DB74;">:        port number to look up</span>
<span style="color: #E6DB74;"> *  </span><span style="color: #AE81FF;">@udptable</span><span style="color: #E6DB74;">:    hash list table, must be of UDP_HTABLE_SIZE</span>
<span style="color: #E6DB74;"> *  </span><span style="color: #AE81FF;">@port_rover</span><span style="color: #E6DB74;">:  pointer to record of last unallocated port</span>
<span style="color: #E6DB74;"> *  </span><span style="color: #AE81FF;">@saddr_comp</span><span style="color: #E6DB74;">:  AF-dependent comparison of bound local IP addresses</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">__udp_lib_get_port</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24453;&#32465;&#23450;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> <span style="color: #FD971F;">snum</span>,    <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32465;&#23450;&#30340;&#31471;&#21475;&#21495;</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span> <span style="color: #FD971F;">udptable</span>[],  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31649;&#29702;UDP&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#25955;&#21015;&#34920;</span>
<span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">port_rover</span>,  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26368;&#36817;&#19968;&#27425;&#33258;&#21160;&#32465;&#23450;&#30340;&#31471;&#21475;&#21495;</span>
<span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">saddr_comp</span>)(<span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk1</span>,  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#27604;&#36739;&#20004;&#20010;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#25509;&#25910;&#22320;&#22336;&#26159;&#21542;&#30456;&#31561;</span>
<span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk2</span> )    )
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_node</span> *<span style="color: #FD971F;">node</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span> *<span style="color: #FD971F;">head</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk2</span>;
        <span style="color: #66D9EF;">int</span>    <span style="color: #FD971F;">error</span> = 1;

        write_lock_bh(&amp;udp_hash_lock);
        <span style="color: #F92672;">if</span> (snum == 0) {
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">best_size_so_far</span>, <span style="color: #FD971F;">best</span>, <span style="color: #FD971F;">result</span>, <span style="color: #FD971F;">i</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;udp_port_rover&#19981;&#22312;&#25351;&#23450;&#33539;&#22260;&#20869;&#26102;&#65292;&#21017;&#34987;&#24378;&#21046;&#25351;&#23450;&#20026;&#25351;&#23450;&#33539;&#22260;&#30340;&#26368;&#23567;&#20540;</span>
                <span style="color: #F92672;">if</span> (*port_rover &gt; sysctl_local_port_range[1] ||
                    *port_rover &lt; sysctl_local_port_range[0])
                        *port_rover = sysctl_local_port_range[0];

                <span style="color: #E6DB74;">/** &#20026;&#20102;&#20351;UDP&#20256;&#36755;&#25511;&#21046;&#22359;&#22312;udp_hash&#25955;&#21015;&#34920;&#20998;&#24067;&#27604;&#36739;&#22343;&#21248;&#65292;&#22240;&#27492;&#36873;&#25321;&#21487;&#29992;&#31471;&#21475;&#21495;&#30340;&#26041;&#27861;</span>
<span style="color: #E6DB74;">                &#24182;&#19981;&#26159;&#31616;&#21333;&#30340;&#36882;&#22686;&#26597;&#25214;&#26410;&#20351;&#29992;&#31471;&#21475;&#21495;&#65292;&#32780;&#26159;&#23581;&#35797;&#30528;&#20174;&#35760;&#24405;&#26631;&#35760;&#24320;&#22987;&#36882;&#22686;&#31471;&#21475;&#21495;&#24182;&#36941;&#21382;&#25955;&#21015;&#34920;</span>
<span style="color: #E6DB74;">                &#20013;&#25152;&#26377;&#30340;&#38142;&#34920;&#65292;&#24471;&#21040;&#19968;&#20010;&#31471;&#21475;&#21495;&#65292;&#21487;&#35745;&#31639;&#24471;&#21040;&#26742;&#20869;&#25511;&#21046;&#22359;&#25968;&#37327;&#26368;&#23569;&#30340;&#37027;&#20010;&#26742;&#30340;&#20851;&#38190;&#23383;&#12290;</span>
<span style="color: #E6DB74;">                &#22914;&#26524;&#19968;&#20010;&#26742;&#20869;&#30340;&#38142;&#34920;&#38271;&#24230;&#20026;0&#65292;&#21017;&#21487;&#20197;&#30830;&#23450;&#35745;&#31639;&#24471;&#21040;&#35813;&#26742;&#20851;&#38190;&#23383;&#30340;&#31471;&#21475;&#24517;&#23450;&#27809;&#26377;&#20351;&#29992;&#65292;</span>
<span style="color: #E6DB74;">                &#22240;&#27492;&#26597;&#25214;&#32467;&#26463;&#65292;&#21542;&#21017;&#38656;&#30830;&#35748;&#26597;&#25214;&#21040;&#30340;&#31471;&#21475;&#21495;&#26159;&#21542;&#27491;&#22312;&#34987;&#20351;&#29992;&#12290;*/</span>
                best_size_so_far = 32767;
                best = result = *port_rover;
                <span style="color: #F92672;">for</span> (i = 0; i &lt; UDP_HTABLE_SIZE; i++, result++) {
                        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">size</span>;

                        head = &amp;udptable[result &amp; (UDP_HTABLE_SIZE - 1)];
                        <span style="color: #F92672;">if</span> (hlist_empty(head)) {
                                <span style="color: #F92672;">if</span> (result &gt; sysctl_local_port_range[1])
                                        result = sysctl_local_port_range[0] +
                                                ((result - sysctl_local_port_range[0]) &amp;
                                                 (UDP_HTABLE_SIZE - 1));
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">gotit</span>;
                        }
                        size = 0;
                        sk_for_each(sk2, node, head) {
                                <span style="color: #F92672;">if</span> (++size &gt;= best_size_so_far)
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">next</span>;
                        }
                        best_size_so_far = size;
                        best = result;
                <span style="color: #AE81FF;">next</span>:
                        ;
                }
                <span style="color: #E6DB74;">/** &#27492;&#26102;&#26597;&#25214;&#21040;&#30340;&#31471;&#21475;&#21495;&#65292;&#24182;&#19981;&#33021;&#20445;&#35777;&#21487;&#20197;&#20351;&#29992;&#65292;&#22240;&#20026;&#24182;&#19981;&#30830;&#23450;&#35813;&#31471;&#21475;&#26159;&#21542;&#24050;&#32463;&#34987;&#32465;&#23450;&#12290;</span>
<span style="color: #E6DB74;">                &#22240;&#27492;&#65292;&#38656;&#35201;&#26816;&#27979;&#35813;&#31471;&#21475;&#26159;&#21542;&#27491;&#22312;&#34987;&#20351;&#29992;&#12290;&#22914;&#26524;&#27809;&#26377;&#20351;&#29992;&#65292;&#21017;&#26597;&#25214;&#32467;&#26463;&#65292;&#21542;&#21017;&#23545;&#35813;&#31471;&#21475;</span>
<span style="color: #E6DB74;">                &#22686;&#21152;&#19968;&#20010;&#25955;&#21015;&#34920;&#22823;&#23567;&#21518;&#20877;&#27425;&#26816;&#27979;&#12290;&#22914;&#27492;&#21453;&#22797;&#65292;&#30693;&#36947;&#33719;&#24471;&#21487;&#29992;&#30340;&#31471;&#21475;&#21495;&#25110;&#30830;&#23450;&#27809;&#26377;&#21487;&#29992;&#30340;</span>
<span style="color: #E6DB74;">                &#31471;&#21475;&#21495;&#20026;&#27490;&#12290;*/</span>
                result = best;
                <span style="color: #F92672;">for</span>(i = 0; i &lt; (1 &lt;&lt; 16) / UDP_HTABLE_SIZE; i++, result += UDP_HTABLE_SIZE) {
                        <span style="color: #F92672;">if</span> (result &gt; sysctl_local_port_range[1])
                                result = sysctl_local_port_range[0]
                                        + ((result - sysctl_local_port_range[0]) &amp;
                                           (UDP_HTABLE_SIZE - 1));
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span> __udp_lib_lport_inuse(result, udptable))
                                <span style="color: #F92672;">break</span>;
                }
                <span style="color: #F92672;">if</span> (i &gt;= (1 &lt;&lt; 16) / UDP_HTABLE_SIZE)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">fail</span>;
                <span style="color: #E6DB74;">/** &#22914;&#26524;&#26597;&#25214;&#21040;&#21487;&#29992;&#30340;&#31471;&#21475;&#21495;&#65292;&#21017;&#20445;&#23384;&#35813;&#31471;&#21475;&#21495;&#65292;&#21516;&#26102;&#26356;&#26032;&#20840;&#23616;&#21464;&#37327;udp_port_rover,</span>
<span style="color: #E6DB74;">                &#19979;&#27425;&#20877;&#33258;&#21160;&#32465;&#23450;&#31471;&#21475;&#26102;&#65292;&#20877;&#20174;udp_port_rover&#30340;&#20540;&#36215;&#24320;&#22987;&#26597;&#25214;&#12290;*/</span>
<span style="color: #AE81FF;">gotit</span>:
                *port_rover = snum = result;
        } <span style="color: #F92672;">else</span> { <span style="color: #E6DB74;">/** &#22914;&#26524;&#25351;&#23450;&#20102;&#31471;&#21475;&#65292;&#21017;&#26681;&#25454;&#31471;&#21475;&#21495;&#24471;&#21040;&#35813;&#25955;&#21015;&#34920;&#30340;&#20837;&#21475;&#65292;&#24182;&#36941;&#21382;&#35813;&#38142;&#34920;&#26816;&#27979;&#35813;&#31471;&#21475;</span>
<span style="color: #E6DB74;">        &#26159;&#21542;&#21487;&#20197;&#20351;&#29992;&#12290;&#19968;&#26086;&#26816;&#27979;&#21040;&#35813;&#25351;&#23450;&#31471;&#21475;&#21495;&#19981;&#33021;&#20351;&#29992;&#65292;&#21017;&#36820;&#22238;&#23545;&#24212;&#30340;&#38169;&#35823;*/</span>
                head = &amp;udptable[snum &amp; (UDP_HTABLE_SIZE - 1)];

                sk_for_each(sk2, node, head)
                        <span style="color: #F92672;">if</span> (inet_sk(sk2)-&gt;num == snum                        &amp;&amp;
                            sk2 != sk                                        &amp;&amp;
                            (<span style="color: #E6DB74; font-weight: bold;">!</span>sk2-&gt;sk_reuse        || <span style="color: #E6DB74; font-weight: bold;">!</span>sk-&gt;sk_reuse)         &amp;&amp;
                            (<span style="color: #E6DB74; font-weight: bold;">!</span>sk2-&gt;sk_bound_dev_if || <span style="color: #E6DB74; font-weight: bold;">!</span>sk-&gt;sk_bound_dev_if
                             || sk2-&gt;sk_bound_dev_if == sk-&gt;sk_bound_dev_if) &amp;&amp;
                            (*saddr_comp)(sk, sk2)                             )
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">fail</span>;
        }
        <span style="color: #E6DB74;">/** &#30830;&#23450;&#31471;&#21475;&#21495;&#21487;&#20351;&#29992;&#21518;&#65292;&#21017;&#23558;&#31471;&#21475;&#21495;&#35774;&#32622;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#65292;&#24182;&#23558;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#28155;&#21152;&#21040;udp_hash</span>
<span style="color: #E6DB74;">        &#25955;&#21015;&#34920;&#20013;*/</span>
        inet_sk(sk)-&gt;num = snum;
        <span style="color: #F92672;">if</span> (sk_unhashed(sk)) {
                head = &amp;udptable[snum &amp; (UDP_HTABLE_SIZE - 1)];
                sk_add_node(sk, head);
                sock_prot_inc_use(sk-&gt;sk_prot);
        }
        error = 0;
<span style="color: #AE81FF;">fail</span>:   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32465;&#23450;&#22833;&#36133;&#65292;&#21017;&#36820;&#22238;&#38169;&#35823;</span>
        write_unlock_bh(&amp;udp_hash_lock);
        <span style="color: #F92672;">return</span> error;
}
</pre>
</div>
</div>
</div>



<div id="outline-container-orgd93d0a7" class="outline-2">
<h2 id="orgd93d0a7"><span class="section-number-2">8.</span> UDP套接口的关闭</h2>
<div class="outline-text-2" id="text-8">
<p>
关闭套接口后，通过文件系统到套接口，最终调用到对应的传输接口层的close接口。通过UDP的proto结构udp_prot，UDP的传输接口层的close接口为udp_lib_close()，通过对传输接口层的unhash接口的调用，将传输控制块从散列表删除。
</p>

<div class="org-src-container">
<pre class="src src-fundamental">udp_lib_close()
        sk_common_release()
                sk-&gt;sk_prot-&gt;destory-----&gt; udp_destory_socket()  (proto)
                        udp_flush_pending_frames()
                        release_sock()
                sk-&gt;sk_prot-&gt;unhash()-----&gt;udp_lib_unhash()    (proto)
                        sk_del_node_init()
</pre>
</div>

<p>
udp_lib_close直接调用了sk_common_release()。
</p>

<p>
sk_common_release()是一个较为通用的函数，在创建套接口后初始化失败、关闭UDP套接口和原始IP套接口时都会调用该函数。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">sk_common_release</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>)
{
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35843;&#29992;&#20256;&#36755;&#25509;&#21475;&#23618;&#30340;destroy&#25509;&#21475;&#65292;&#22312;&#20256;&#36755;&#25511;&#21046;&#22359;&#37322;&#25918;&#21069;&#20316;&#28165;&#29702;&#24037;&#20316;&#12290;&#23454;&#29616;UDP&#20256;&#36755;&#25509;&#21475;&#23618;</span>
<span style="color: #75715E;">        destroy&#25509;&#21475;&#30340;&#20989;&#25968;&#20026;udp_destroy_sock()&#12290;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_prot-&gt;destroy)
                sk-&gt;sk_prot-&gt;destroy(sk);

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * Observation: when sock_common_release is called, processes have</span>
<span style="color: #75715E;">         * no access to socket. But net still has.</span>
<span style="color: #75715E;">         * Step one, detach it from networking:</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         * A. Remove from hash tables.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35843;&#29992;&#20256;&#36755;&#25509;&#21475;&#23618;&#30340;unhash&#25509;&#21475;&#65292;&#23558;&#20256;&#36755;&#25511;&#21046;&#22359;&#20174;&#31649;&#29702;&#25955;&#21015;&#34920;&#21024;&#38500;&#12290;udp_lib_unhash()</span><span style="color: #75715E;">*/</span>
        sk-&gt;sk_prot-&gt;unhash(sk);

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * In this point socket cannot receive new packets, but it is possible</span>
<span style="color: #75715E;">         * that some packets are in flight because some CPU runs receiver and</span>
<span style="color: #75715E;">         * did hash table lookup before we unhashed socket. They will achieve</span>
<span style="color: #75715E;">         * receive queue and will be purged by socket destructor.</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         * Also we still have packets pending on receive queue and probably,</span>
<span style="color: #75715E;">         * our own packets waiting in device queues. sock_destroy will drain</span>
<span style="color: #75715E;">         * receive queue, but transmitted packets will delay socket destruction</span>
<span style="color: #75715E;">         * until the last reference will be released.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28165;&#29702;&#21518;&#35774;&#32622;&#20026;&#23396;&#20799;&#22871;&#25509;&#21475;</span>
        sock_orphan(sk);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#37322;&#25918;&#26377;&#20851;IPSEC&#30340;&#20256;&#36755;&#31574;&#30053;</span>
        xfrm_sk_free_policy(sk);

        sk_refcnt_debug_release(sk);
        sock_put(sk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36882;&#20943;&#24341;&#29992;&#35745;&#25968;&#65292;&#20026;0&#26102;&#65292;&#25165;&#21487;&#20197;&#37322;&#25918;</span>
}
</pre>
</div>

<p>
udp_destroy_sock()调用udp_flush_pending_frames()将未发送的数据发送出去，如果有等待该传输控制块的进程，则将它们唤醒。
</p>

<p>
udp_lib_unhash()调用sk_del_node_init()从udp_hahs散列表中删除传输控制块。
</p>
</div>
</div>


<div id="outline-container-orgb9beaf8" class="outline-2">
<h2 id="orgb9beaf8"><span class="section-number-2">9.</span> connect系统调用的实现</h2>
<div class="outline-text-2" id="text-9">
<p>
UDP虽然不是基于连接的协议，但是也提供了connect系统调用。通过调用connect()，传输控制块记录目的地址和目的端口，并且根据这两者选择目的路由。这样发送数据时就可以通过调用write()或send()，而不需要调用sendto，写到已连接UDP套接口上的任何内容都会自动发送到由connect()指定的地址和端口。
</p>

<p>
同样，在接收数据时，也可以不必调用recvfrom()以获取数据报的发送者，而可用read()，recv()或recvmsg()。因为在一个已连接UDP套接口上接收到的内核为输入操作返回的数据报，只能是那些来自connect()所指定协议地址的数据报。目的地址为该已连接UDP套接口的本地地址，而发送方不是该套接口早先connect()到的地址的数据报，是不会投递到该套接口的。这样就限制了一个已连接UDP套接口只能与一个对端交换数据报。
</p>

<p>
inet_dgram_connect()为connect在UDP套接口层的实现。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_dgram_connect</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> * <span style="color: #FD971F;">uaddr</span>,
                       <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">addr_len</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span> = sock-&gt;sk;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22320;&#22336;&#26063;&#26080;&#25928;&#65292;&#21017;&#35843;&#29992;&#20256;&#36755;&#25509;&#21475;&#23618;&#30340;disconnect&#25509;&#21475;&#65292;&#21363;udp_disconnect()</span>
        <span style="color: #F92672;">if</span> (uaddr-&gt;sa_family == AF_UNSPEC)
                <span style="color: #F92672;">return</span> sk-&gt;sk_prot-&gt;disconnect(sk, flags);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#27809;&#26377;&#35774;&#32622;&#31471;&#21475;&#21495;&#65292;&#21017;&#21160;&#24577;&#36873;&#25321;&#19968;&#20010;&#31354;&#38386;&#30340;&#31471;&#21475;&#32465;&#23450;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>inet_sk(sk)-&gt;num &amp;&amp; inet_autobind(sk))
                <span style="color: #F92672;">return</span> -EAGAIN;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#20256;&#36755;&#25509;&#21475;&#23618;&#30340;connect&#25509;&#21475; ip4_datagram_connect()&#36827;&#34892;&#36830;&#25509;</span>
        <span style="color: #F92672;">return</span> sk-&gt;sk_prot-&gt;connect(sk, (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *)uaddr, addr_len);
}
</pre>
</div>
</div>

<div id="outline-container-org5e38748" class="outline-3">
<h3 id="org5e38748"><span class="section-number-3">9.1.</span> udp_disconnect()</h3>
<div class="outline-text-3" id="text-9-1">
<p>
udp_disconnect()是传输接口层UDP的disconnect接口的实现，复位传输控制块的状态、目的地址、目的端口、本地端口、输出接口以及目的路由缓存。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_disconnect</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      1003.1g - break association.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#20301;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#29366;&#24577;&#12289;&#30446;&#30340;&#22320;&#22336;&#12289;&#30446;&#30340;&#31471;&#21475;&#20197;&#21450;&#36755;&#20986;&#25509;&#21475;</span>
        sk-&gt;sk_state = TCP_CLOSE;
        inet-&gt;daddr = 0;
        inet-&gt;dport = 0;
        sk-&gt;sk_bound_dev_if = 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#24050;&#32465;&#23450;&#26412;&#22320;&#31471;&#21475;&#65292;&#21017;&#22797;&#20301;&#26412;&#22320;&#31471;&#21475;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(sk-&gt;sk_userlocks &amp; SOCK_BINDADDR_LOCK))
                inet_reset_saddr(sk);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#32465;&#23450;&#26412;&#22320;&#31471;&#21475;&#65292;&#21017;&#23558;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#20174;udp_hash&#25955;&#21015;&#34920;&#21024;&#38500;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(sk-&gt;sk_userlocks &amp; SOCK_BINDPORT_LOCK)) {
                sk-&gt;sk_prot-&gt;unhash(sk);
                inet-&gt;sport = 0;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#20301;&#24453;&#26029;&#24320;&#36830;&#25509;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;</span>
        sk_dst_reset(sk);
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org94c1e15" class="outline-3">
<h3 id="org94c1e15"><span class="section-number-3">9.2.</span> ip4_datagram_connect()</h3>
<div class="outline-text-3" id="text-9-2">
<p>
ip4_datagram_connect()是传输接口层UDP的connect接口的实现。首先复位传输控制块的目的路由缓存，再根据目的地址得到输出路由缓存，最后将查询得到的路由缓存中的源地址、目的地址、目的端口以及目的路由缓存更新到传输控制块中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip4_datagram_connect</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr</span> *<span style="color: #FD971F;">uaddr</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">addr_len</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> *<span style="color: #FD971F;">usin</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> *) uaddr;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span>;
        <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">saddr</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">oif</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;usin&#30340;&#38271;&#24230;&#20197;&#21450;&#22320;&#22336;&#26063;</span>
        <span style="color: #F92672;">if</span> (addr_len &lt; <span style="color: #F92672;">sizeof</span>(*usin))
                <span style="color: #F92672;">return</span> -EINVAL;

        <span style="color: #F92672;">if</span> (usin-&gt;sin_family != AF_INET)
                <span style="color: #F92672;">return</span> -EAFNOSUPPORT;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22312;&#36830;&#25509;&#20256;&#36755;&#25511;&#21046;&#22359;&#20043;&#21069;&#21487;&#33021;&#20256;&#36755;&#36807;&#25968;&#25454;&#65292;&#21487;&#33021;&#23384;&#22312;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#65292;</span>
<span style="color: #75715E;">        &#22240;&#27492;&#38656;&#35201;&#22797;&#20301;&#24453;&#36830;&#25509;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;</span><span style="color: #75715E;"> */</span>
        sk_dst_reset(sk);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#30830;&#23450;&#36755;&#20986;&#25509;&#21475;&#21644;&#28304;&#22320;&#22336;</span><span style="color: #75715E;">*/</span>
        oif = sk-&gt;sk_bound_dev_if;
        saddr = inet-&gt;saddr;
        <span style="color: #F92672;">if</span> (MULTICAST(usin-&gt;sin_addr.s_addr)) {
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>oif)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#30446;&#30340;&#22320;&#22336;&#26159;&#32452;&#25773;&#22320;&#22336;&#26102;&#65292;&#22914;&#26524;&#27809;&#26377;&#30830;&#23450;&#36755;&#20986;&#25509;&#21475;&#65292;&#21017;&#37325;&#26032;&#30830;&#23450;</span>
                        oif = inet-&gt;mc_index;
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>saddr)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#30446;&#30340;&#22320;&#22336;&#26159;&#32452;&#25773;&#22320;&#22336;&#26102;&#65292;&#22914;&#26524;&#27809;&#26377;&#30830;&#23450;&#28304;&#22320;&#22336;&#65292;&#21017;&#37325;&#26032;&#30830;&#23450;</span>
                        saddr = inet-&gt;mc_addr;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#35810;&#36755;&#20986;&#36335;&#30001;&#65292;&#26597;&#35810;&#22833;&#36133;&#65292;&#21017;&#36820;&#22238;&#23545;&#24212;&#30340;&#38169;&#35823;</span>
        err = ip_route_connect(&amp;rt, usin-&gt;sin_addr.s_addr, saddr,
                               RT_CONN_FLAGS(sk), oif,
                               sk-&gt;sk_protocol,
                               inet-&gt;sport, usin-&gt;sin_port, sk);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">return</span> err;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36335;&#30001;&#30340;&#30446;&#30340;&#22320;&#22336;&#26159;&#24191;&#25773;&#22320;&#22336;&#65292;&#20294;&#26159;&#22871;&#25509;&#21475;&#19981;&#25903;&#25345;&#24191;&#25773;&#25968;&#25454;&#25253;&#30340;&#36755;&#20986;&#65292;&#21017;&#36820;&#22238;&#38169;&#35823;</span>
        <span style="color: #F92672;">if</span> ((rt-&gt;rt_flags &amp; RTCF_BROADCAST) &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>sock_flag(sk, SOCK_BROADCAST)) {
                ip_rt_put(rt);
                <span style="color: #F92672;">return</span> -EACCES;
        }
        <span style="color: #E6DB74;">/** &#23558;&#36335;&#30001;&#32531;&#23384;&#39033;&#30340;&#28304;&#22320;&#22336;&#12289;&#30446;&#30340;&#22320;&#22336;&#20197;&#21450;&#30446;&#30340;&#31471;&#21475;&#26356;&#26032;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#65292;</span>
<span style="color: #E6DB74;">        &#21516;&#26102;&#26356;&#26032;&#29992;&#20110;&#35774;&#32622;&#21040;IP&#39318;&#37096;&#20013;&#30340;id&#22495;*/</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>inet-&gt;saddr)
                inet-&gt;saddr = rt-&gt;rt_src;       <span style="color: #75715E;">/* </span><span style="color: #75715E;">Update source address</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>inet-&gt;rcv_saddr)
                inet-&gt;rcv_saddr = rt-&gt;rt_src;
        inet-&gt;daddr = rt-&gt;rt_dst;
        inet-&gt;dport = usin-&gt;sin_port;
        sk-&gt;sk_state = TCP_ESTABLISHED;
        inet-&gt;id = jiffies;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#32531;&#23384;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#12290;</span>
        sk_dst_set(sk, &amp;rt-&gt;u.dst);
        <span style="color: #F92672;">return</span>(0);
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgfe13835" class="outline-2">
<h2 id="orgfe13835"><span class="section-number-2">10.</span> select系统调用的实现</h2>
<div class="outline-text-2" id="text-10">
<p>
select是通用文件系统的系统调用，因此在调用过程中很多代码都是在通用文件系统中实现，而套接口文件系统实现了poll接口，只需根据当前传输控制块的状态、接收到的数据等返回相应的标志即可。文件系统提供了一系列的标志，来表示文件当前的状态。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> select()返回的标志</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">select()返回的标志</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">POLLIN/POLLRDNORM</td>
<td class="org-left">文件可以正常读</td>
</tr>

<tr>
<td class="org-left">POLLPRI</td>
<td class="org-left">高优先级数据（带外）可以读取</td>
</tr>

<tr>
<td class="org-left">POLLOUT/POLLWRNORM</td>
<td class="org-left">可以写数据到文件而不被阻塞</td>
</tr>

<tr>
<td class="org-left">POLLERR</td>
<td class="org-left">文件在写过程中发生了错误</td>
</tr>

<tr>
<td class="org-left">POLLHUP</td>
<td class="org-left">无法继续读写文件。对于套接口文件，则因为关闭了读写后，无法继续读写文件</td>
</tr>

<tr>
<td class="org-left">POLLNVAL</td>
<td class="org-left">无效的请求，例如文件没有打开</td>
</tr>

<tr>
<td class="org-left">POLLRDBAND</td>
<td class="org-left">从文件中可以读取带外数据。当前只用在Linux内核网络模块的decnet中</td>
</tr>

<tr>
<td class="org-left">POLLWRBAND</td>
<td class="org-left">可以写带有零优先级的数据到文件中。当前只用在Linux内核网络模块的decnet中</td>
</tr>

<tr>
<td class="org-left">POLLRDHUP</td>
<td class="org-left">基于连接的套接口，对方关闭了连接或者本方进行读的半关闭，从而不允许继续接收数据</td>
</tr>
</tbody>
</table>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> *      udp_poll - wait for a UDP event.</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@file</span><span style="color: #E6DB74;"> - file struct</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@sock</span><span style="color: #E6DB74;"> - socket</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@wait</span><span style="color: #E6DB74;"> - poll table</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> *      This is same as datagram poll, except for the special case of</span>
<span style="color: #E6DB74;"> *      blocking sockets. If application is using a blocking fd</span>
<span style="color: #E6DB74;"> *      and a packet with checksum error is in the queue;</span>
<span style="color: #E6DB74;"> *      then it could get return from select indicating data available</span>
<span style="color: #E6DB74;"> *      but then block when reading it. Add special case code</span>
<span style="color: #E6DB74;"> *      to work around these arguably broken applications.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_poll</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">file</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>, <span style="color: #66D9EF;">poll_table</span> *<span style="color: #FD971F;">wait</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#21508;&#31181;&#20449;&#24687;&#65292;pool&#24471;&#21040;&#24403;&#21069;&#30340;&#26631;&#24535;</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mask</span> = datagram_poll(file, sock, wait);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span> = sock-&gt;sk;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30830;&#23450;&#26159;&#21542;&#20026;&#36731;&#37327;&#32423;UDP</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">is_lite</span> = IS_UDPLITE(sk);

        <span style="color: #E6DB74;">/** &#22914;&#26524;&#25991;&#20214;&#30340;&#35835;&#20889;&#26159;&#22312;&#38459;&#22622;&#27169;&#24335;&#19979;&#65292;&#19988;&#25991;&#20214;&#33021;&#27491;&#24120;&#35835;&#65292;&#21516;&#26102;&#33267;&#23569;&#27809;&#26377;&#36827;&#34892;&#35835;&#21322;&#20851;&#38381;&#65292;</span>
<span style="color: #E6DB74;">        &#22312;&#36825;&#31181;&#24773;&#20917;&#19979;&#65292;&#26816;&#27979;&#24050;&#25509;&#25910;&#21040;&#30340;&#31532;&#19968;&#20010;UDP&#25968;&#25454;&#25253;&#26657;&#39564;&#21644;&#65292;&#22914;&#26524;&#26816;&#27979;&#22833;&#36133;&#21017;&#20002;&#24323;&#65292;&#32487;&#32493;&#26657;&#39564;&#21518;&#38754;</span>
<span style="color: #E6DB74;">        &#30340;UDP&#25968;&#25454;&#25253;&#65292;&#30452;&#33267;&#26657;&#39564;&#36890;&#36807;&#25110;&#25509;&#25910;&#38431;&#21015;&#20013;&#27809;&#26377;&#25968;&#25454;&#25253;&#20026;&#27490;&#12290;&#22914;&#26524;&#26368;&#21518;&#25509;&#25910;&#38431;&#21015;&#20013;&#27809;&#26377;&#25968;&#25454;&#20102;&#65292;</span>
<span style="color: #E6DB74;">        &#21363;&#25509;&#25910;&#38431;&#21015;&#20013;&#27809;&#26377;&#25968;&#25454;&#21253;&#36890;&#36807;&#26657;&#39564;&#21644;&#26816;&#27979;&#65292;&#21017;&#21435;&#38500;POLLIN&#21450;POLLRDNORM&#26631;&#24535;*/</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Check for false positives due to checksum errors</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> ( (mask &amp; POLLRDNORM) &amp;&amp;
             <span style="color: #E6DB74; font-weight: bold;">!</span>(file-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp;
             <span style="color: #E6DB74; font-weight: bold;">!</span>(sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)){
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff_head</span> *<span style="color: #FD971F;">rcvq</span> = &amp;sk-&gt;sk_receive_queue;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;

                spin_lock_bh(&amp;rcvq-&gt;lock);
                <span style="color: #F92672;">while</span> ((skb = skb_peek(rcvq)) != <span style="color: #AE81FF;">NULL</span>) {
                        <span style="color: #F92672;">if</span> (udp_lib_checksum_complete(skb)) {
                                UDP_INC_STATS_BH(UDP_MIB_INERRORS, is_lite);
                                __skb_unlink(skb, rcvq);
                                kfree_skb(skb);
                        } <span style="color: #F92672;">else</span> {
                                skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
                                <span style="color: #F92672;">break</span>;
                        }
                }
                spin_unlock_bh(&amp;rcvq-&gt;lock);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">nothing to see, move along</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (skb == <span style="color: #AE81FF;">NULL</span>)
                        mask &amp;= ~(POLLIN | POLLRDNORM);
        }

        <span style="color: #F92672;">return</span> mask;

}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> *      datagram_poll - generic datagram poll</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@file</span><span style="color: #E6DB74;">: file struct</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@sock</span><span style="color: #E6DB74;">: socket</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@wait</span><span style="color: #E6DB74;">: poll table</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> *      Datagram poll: Again totally generic. This also handles</span>
<span style="color: #E6DB74;"> *      sequenced packet sockets providing the socket receive queue</span>
<span style="color: #E6DB74;"> *      is only ever holding data ready to receive.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> *      Note: when you _don't_ use this routine for this protocol,</span>
<span style="color: #E6DB74;"> *      and you use a different write policy from </span><span style="color: #AE81FF;">sock_writeable()</span>
<span style="color: #E6DB74;"> *      then please supply your own write_space callback.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">datagram_poll</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">file</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">socket</span> *<span style="color: #FD971F;">sock</span>,
                           <span style="color: #66D9EF;">poll_table</span> *<span style="color: #FD971F;">wait</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span> = sock-&gt;sk;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mask</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30001;&#20110;&#36827;&#31243;&#22312;poll&#36807;&#31243;&#20013;&#20250;&#23384;&#22312;&#30561;&#30496;&#65292;&#22240;&#27492;&#25226;&#24403;&#21069;&#36827;&#31243;&#28155;&#21152;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#30561;&#30496;&#38431;&#21015;sk_sleep&#20013;</span>
        poll_wait(file, sk-&gt;sk_sleep, wait);
        mask = 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#26377;&#38169;&#35823;&#21457;&#29983;&#65292;&#21017;&#35774;&#32622;POLLERR&#26631;&#24535;&#12290;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">exceptional events?</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_err || <span style="color: #E6DB74; font-weight: bold;">!</span>skb_queue_empty(&amp;sk-&gt;sk_error_queue))
                mask |= POLLERR;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#22871;&#25509;&#21475;&#25509;&#25910;&#36890;&#36947;&#24050;&#32463;&#20851;&#38381;&#65292;&#19981;&#20801;&#35768;&#32487;&#32493;&#25509;&#25910;&#25968;&#25454;&#65292;&#21017;&#22312;POLLRDHUP&#20301;&#28155;&#21152;&#26631;&#24535;</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)
                mask |= POLLRDHUP;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#25509;&#25910;&#21644;&#21457;&#36865;&#36890;&#36947;&#37117;&#20851;&#38381;&#65292;&#21017;&#35774;&#32622;POLLHUP&#26631;&#24535;</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_shutdown == SHUTDOWN_MASK)
                mask |= POLLHUP;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#25509;&#25910;&#38431;&#21015;&#23384;&#22312;&#25968;&#25454;&#65292;&#21017;&#35774;&#32622;iPOLLIN&#21450;POLLRDNORM&#26631;&#24535;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">readable?</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb_queue_empty(&amp;sk-&gt;sk_receive_queue) ||
            (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN))
                mask |= POLLIN | POLLRDNORM;
        <span style="color: #E6DB74;">/** &#22914;&#26524;&#26159;&#22522;&#20110;&#36830;&#25509;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#21017;&#24403;&#20854;&#29366;&#24577;&#20026;CLOSE&#26102;&#65292;&#28155;&#21152;POLLHUP&#26631;&#24535;&#65307;</span>
<span style="color: #E6DB74;">        &#29366;&#24577;&#20026;SYN_SENT&#26102;&#65292;&#35828;&#26126;&#36830;&#25509;&#23578;&#26410;&#24314;&#31435;&#65292;&#19981;&#33021;&#25509;&#25910;&#25968;&#25454;&#65292;&#22240;&#27492;&#19981;&#29992;&#32771;&#34385;&#20889;&#30340;&#24773;&#20917;&#65292;&#30452;&#25509;&#36820;&#22238;&#26631;&#24535;&#12290;*/</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Connection-based need to check for termination and startup</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (connection_based(sk)) {
                <span style="color: #F92672;">if</span> (sk-&gt;sk_state == TCP_CLOSE)
                        mask |= POLLHUP;
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">connection hasn't started yet?</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (sk-&gt;sk_state == TCP_SYN_SENT)
                        <span style="color: #F92672;">return</span> mask;
        }
        <span style="color: #E6DB74;">/** &#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#36755;&#20986;&#32531;&#23384;&#21306;&#23578;&#26410;&#36798;&#21040;&#19978;&#38480;&#65292;&#21017;&#34920;&#26126;&#21487;&#20889;&#65292;&#35774;&#32622;POLLOUT&#12289;POLLWRNORM&#20197;&#21450;</span>
<span style="color: #E6DB74;">        POLLWRBAND&#26631;&#24535;&#12290;&#21542;&#21017;&#35774;&#32622;&#24322;&#27493;&#30340;&#24773;&#20917;&#19979;&#35813;&#22871;&#25509;&#21475;&#30340;&#21457;&#36865;&#38431;&#21015;&#26159;&#21542;&#24050;&#28385;&#26631;&#24535;&#12290;*/</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">writable?</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (sock_writeable(sk))
                mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
        <span style="color: #F92672;">else</span>
                set_bit(SOCK_ASYNC_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);

        <span style="color: #F92672;">return</span> mask;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgadb9143" class="outline-2">
<h2 id="orgadb9143"><span class="section-number-2">11.</span> UDP的ioctl</h2>
<div class="outline-text-2" id="text-11">
<p>
UDP中的ioctl命令如下：
</p>
<ul class="org-ul">
<li>SIOCOUTQ  返回标识该传输控制块为发送而分配的所有数据区的总大小。</li>
<li>SIOCINQ   获取在接收队列缓存中第一个未读取数据报的长度。</li>
</ul>
</div>

<div id="outline-container-org35b5dbc" class="outline-3">
<h3 id="org35b5dbc"><span class="section-number-3">11.1.</span> UDP的套接口选项</h3>
<div class="outline-text-3" id="text-11-1">
<p>
从udp_prot和inet_dgram_ops的定义，可了解到UDP套接口选项入口为udp_setsockopt()。在该函数中会根据选项分别调用不同的函数处理&#x2013;如果是SOL_UDP或者SOL_UDPLITE级别，则调用udp_lib_setsockopt(),否则通过IP接口调用ip_setsockopt()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_setsockopt</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">level</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">optname</span>,
                   <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *optval, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">optlen</span>)
{
        <span style="color: #F92672;">if</span> (level == SOL_UDP  ||  level == SOL_UDPLITE)
                <span style="color: #F92672;">return</span> udp_lib_setsockopt(sk, level, optname, optval, optlen,
                                          udp_push_pending_frames);
        <span style="color: #F92672;">return</span> ip_setsockopt(sk, level, optname, optval, optlen);
}
</pre>
</div>

<p>
UDP的套接口选项如下：
</p>
<ul class="org-ul">
<li>UDP_CORK  确定发送的UDP数据是否组成一个单一的UDP数据报发送出去。如果值为0,则有数据需要发送时，立即组成一个UDP数据报发送出去；如果值为非0，则每个UDP数据报长度必须达到64KB才将其发送出去，因此会有延迟。</li>

<li>UDP_ENCAP 切丁该套接口IPSEC封装方式，有效的的值为0、UDP_ENCAP_ESPINUDP和UDP_ENCAP_ESPINUDP_NON_IKE。</li>
<li>UDPLITE_SEND_CSCOV和UDPLITE_RECV_CSCOV 用于控制轻量级UDP发送或接收校验和的执行。
<ul class="org-ul">
<li>当其值为0时，表示对发送和接收的整个轻量级UDP数据报进行校验</li>
<li>当其值大于等于8时，表示对发送和接收轻量级UDP数据报指定的前几个字节进行校验</li>
<li>其他值，非法。</li>
</ul></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org557a03a" class="outline-2">
<h2 id="org557a03a"><span class="section-number-2">12.</span> UDP校验和</h2>
<div class="outline-text-2" id="text-12">
<p>
UDP校验和与TCP校验和类似，覆盖UDP首部及UDP数据，但UDP的校验和是可选的。UDP数据报同样包含一个12B长的伪首部，这是为了计算校验和而设置的。UDP数据报中的伪首部格式如下：
</p>


<div id="org11139d7" class="figure">
<p><img src="image/udp-proto/udp-csum.png" alt="udp-csum.png" />
</p>
<p><span class="figure-number">Figure 6: </span>UDP校验和计算过程中使用的各个字段</p>
</div>

<p>
如果发送方没有计算校验和而接收方检测到校验和有差错，则UDP数据报会被悄悄丢弃。不产生任何差错报文。
</p>

<p>
尽管UDP校验和是可选的，但通常总是会做UDP校验。关闭UDP校验和以提高性能在单个局域网中或许是可以接受的，但是在数据报经过路由器时，通过对链路层数据帧进行循环冗余检验（如以太网或者令牌环数据帧）可以检测到大多数的差错，会导致传输失败。无论相信与否，路由器中也存在软件和硬件差错，会修改数据报中的数据。如果关闭端到端的UDP校验和功能，那么这些差错就不能在UDP层被检测出来。此外，一些数据链路层协议（如SLIP）没有任何形式的数据链路层校验和。
</p>

<p>
UDP校验和选项默认是打开的，如果发送段已经计算了校验和，那么接收端必须检验接收到的校验和。
</p>
</div>

<div id="outline-container-org976517f" class="outline-3">
<h3 id="org976517f"><span class="section-number-3">12.1.</span> 输入UDP数据报校验和的计算</h3>
<div class="outline-text-3" id="text-12-1">
</div>
<div id="outline-container-org1eed72d" class="outline-4">
<h4 id="org1eed72d"><span class="section-number-4">12.1.1.</span> udp4_csum_init()</h4>
<div class="outline-text-4" id="text-12-1-1">
<p>
udp4_csum_init()用于UDP数据报接收校验和的初始化，只要是对伪首部进行校验和的计算。当然也有例外，如果校验和有硬件完成，则只对伪首部进行校验检测。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Initialize UDP checksum. If exited with zero value (success),</span>
<span style="color: #75715E;"> * CHECKSUM_UNNECESSARY means, that no more checks are required.</span>
<span style="color: #75715E;"> * Otherwise, csum completion requires chacksumming packet body,</span>
<span style="color: #75715E;"> * including udp header and folding it to skb-&gt;csum.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">udp4_csum_init</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span> *<span style="color: #FD971F;">uh</span>)
{
        <span style="color: #F92672;">if</span> (uh-&gt;check == 0) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;&#21644;&#20026;0,&#34920;&#31034;&#27492;UDP&#25968;&#25454;&#25253;&#19981;&#38656;&#35201;&#26657;&#39564;&#21644;&#26816;&#27979;</span>
                skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (skb-&gt;ip_summed == CHECKSUM_COMPLETE) {<span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26657;&#39564;&#21644;&#24050;&#32463;&#30001;&#30828;&#20214;&#23436;&#25104;&#65292;</span>
<span style="color: #75715E;">        &#21017;&#21482;&#38656;&#35201;&#23545;&#20266;&#39318;&#37096;&#36827;&#34892;&#26657;&#39564;&#12290;&#36890;&#36807;&#21518;&#65292;&#21017;&#19981;&#38656;&#35201;&#20877;&#36827;&#34892;&#26816;&#27979;</span><span style="color: #75715E;">*/</span>
               <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>csum_tcpudp_magic(skb-&gt;nh.iph-&gt;saddr, skb-&gt;nh.iph-&gt;daddr,
                                      skb-&gt;len, IPPROTO_UDP, skb-&gt;csum       ))
                        skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23545;&#20110;&#36719;&#20214;&#23436;&#25104;&#26657;&#39564;&#21644;&#30340;&#25805;&#20316;&#65292;&#39318;&#20808;&#29983;&#25104;&#20266;&#39318;&#37096;&#30340;&#37096;&#20998;&#32047;&#21152;&#21644;</span>
        <span style="color: #F92672;">if</span> (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)
                skb-&gt;csum = csum_tcpudp_nofold(skb-&gt;nh.iph-&gt;saddr,
                                               skb-&gt;nh.iph-&gt;daddr,
                                               skb-&gt;len, IPPROTO_UDP, 0);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Probably, we should checksum udp header (it should be in cache</span>
<span style="color: #75715E;">         * in any case) and data in tiny packets (&lt; rx copybreak).</span>
<span style="color: #75715E;">         */</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">UDP = UDP-Lite with a non-partial checksum coverage</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#34920;&#31034;&#25509;&#25910;&#21040;&#30340;&#19981;&#26159;&#36731;&#37327;&#32423;&#30340;UDP&#25968;&#25454;&#25253;</span>
        UDP_SKB_CB(skb)-&gt;partial_cov = 0;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org24b6f2e" class="outline-4">
<h4 id="org24b6f2e"><span class="section-number-4">12.1.2.</span> udp_lib_checksum_complete()</h4>
<div class="outline-text-4" id="text-12-1-2">
<p>
udp_lib_checksum_complete()和__udp_lib_checksum_complete()都是基于伪首部累加和，完成全包校验和的检测。不同之处在于，前者封装调用了后者，只是对那些没有必要进行校验和检测的数据报不再检测。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Generic checksumming routines for UDP(-Lite) v4 and v6</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">__sum16</span> <span style="color: #A6E22E;">__udp_lib_checksum_complete</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span> UDP_SKB_CB(skb)-&gt;partial_cov)
                <span style="color: #F92672;">return</span> __skb_checksum_complete(skb);
        <span style="color: #F92672;">return</span> csum_fold(skb_checksum(skb, 0, UDP_SKB_CB(skb)-&gt;cscov,
                                      skb-&gt;csum));
}

<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_lib_checksum_complete</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">return</span> skb-&gt;ip_summed != CHECKSUM_UNNECESSARY &amp;&amp;
                __udp_lib_checksum_complete(skb);
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org1d2565c" class="outline-3">
<h3 id="org1d2565c"><span class="section-number-3">12.2.</span> 输出UDP数据报校验和的计算</h3>
<div class="outline-text-3" id="text-12-2">
</div>
<div id="outline-container-orgbc2333f" class="outline-4">
<h4 id="orgbc2333f"><span class="section-number-4">12.2.1.</span> udp4_hwcsum_outgoing()</h4>
<div class="outline-text-4" id="text-12-2-1">
<p>
udp4_hwcsum_outgoing()用于在支持硬件完成校验和的情况下，如果发送队列中的数据报由一个SKB组成，则只执行UDP用户数据部分的校验和，这样其他部分由硬件来完成。而如果发送队列中的数据报由多个SKB组成，则硬件也完成不了校验和，因此干脆直接由软件来执行整个UDP数据报的校验和。
</p>
</div>
</div>

<div id="outline-container-orgf7ee886" class="outline-4">
<h4 id="orgf7ee886"><span class="section-number-4">12.2.2.</span> csum_tcpudp_magic()和udp_csum_outgoing()</h4>
<div class="outline-text-4" id="text-12-2-2">
<p>
csum_tcpudp_magic() 用在硬件不支持完成校验和的情况下，执行UDP用户数据部分的校验和。
</p>

<p>
udp_csum_outgoing() 则基于UDP用户数据的中间累加和，执行伪首部校验和，生成UDP数据报的校验码。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgddff7f2" class="outline-2">
<h2 id="orgddff7f2"><span class="section-number-2">13.</span> UDP的输出：sendmsg系统调用</h2>
<div class="outline-text-2" id="text-13">
<div class="org-src-container">
<pre class="src src-fundamental">sys_send()
        sockfd_lookup_light()
        sock_sendmsg()
                __sock_sendmsg()              proto_ops
                        sock-&gt;ops-&gt;sendmsg() -----------&gt; inet_sendmsg()
                                                        proto
                                sk-&gt;sk_prot-&gt;sendmsg()-------------&gt;udp_sendmsg()
</pre>
</div>
</div>

<div id="outline-container-org84e5f2f" class="outline-3">
<h3 id="org84e5f2f"><span class="section-number-3">13.1.</span> udp_sendmsg()</h3>
<div class="outline-text-3" id="text-13-1">
<p>
udp_sendmsg()实现了UDP数据报的组织和发送。首先获取发送的目的地址和目的端口，然后处理控制信息，接着选路，最后将数据分片并组成UDP数据报发送出去，流程图如下：
</p>


<div id="org1c72f68" class="figure">
<p><img src="image/udp-proto/udp-sendmsg.png" alt="udp-sendmsg.png" />
</p>
<p><span class="figure-number">Figure 7: </span>udp_sendmsg()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_sendmsg</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *<span style="color: #FD971F;">iocb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">msg</span>,
                <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udp_sock</span> *<span style="color: #FD971F;">up</span> = udp_sk(sk);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ulen</span> = len;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ipcm_cookie</span> <span style="color: #FD971F;">ipc</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span> = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">free</span> = 0;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">connected</span> = 0;
        <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span>, <span style="color: #FD971F;">faddr</span>, <span style="color: #FD971F;">saddr</span>;
        <span style="color: #66D9EF;">__be16</span> <span style="color: #FD971F;">dport</span>;
        <span style="color: #66D9EF;">u8</span>  <span style="color: #FD971F;">tos</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>, <span style="color: #FD971F;">is_udplite</span> = up-&gt;pcflag;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#36807;UDP_CORK&#36873;&#39033;&#20540;&#25110;&#32773;&#21457;&#36865;&#26631;&#24535;&#20013;&#30340;MSG_MORE&#26631;&#24535;&#26469;&#30830;&#23450;&#21457;&#36865;&#32773;&#26159;&#21542;&#36824;&#26377;&#26356;&#22810;&#30340;&#25968;&#25454;</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">corkreq</span> = up-&gt;corkflag || msg-&gt;msg_flags&amp;MSG_MORE;
        <span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">getfrag</span>)(<span style="color: #66D9EF;">void</span> *, <span style="color: #66D9EF;">char</span> *, <span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">int</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30001;&#20110;IP&#25968;&#25454;&#25253;&#30340;&#38480;&#21046;&#65292;UDP&#25968;&#25454;&#25253;&#26368;&#38271;&#20026;64KB&#12290;</span>
        <span style="color: #F92672;">if</span> (len &gt; 0xFFFF)
                <span style="color: #F92672;">return</span> -EMSGSIZE;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Check the flags.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">UDP&#19981;&#25903;&#25345;&#21457;&#36865;&#24102;&#22806;&#25968;&#25454;&#65292;&#22240;&#27492;&#22914;&#26524;&#21457;&#36865;&#26631;&#24535;&#20013;&#35774;&#32622;&#20102;MSG_OOB,&#21017;&#36820;&#22238;&#38169;&#35823;</span>
        <span style="color: #F92672;">if</span> (msg-&gt;msg_flags&amp;MSG_OOB)     <span style="color: #75715E;">/* </span><span style="color: #75715E;">Mirror BSD error message compatibility</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">return</span> -EOPNOTSUPP;

        ipc.opt = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;UDP&#27491;&#22312;&#36755;&#20986;&#25968;&#25454;&#30340;&#36807;&#31243;&#20013;&#65292;&#21017;&#36339;&#36716;&#21040;do_append_data&#22788;&#30452;&#25509;&#22788;&#29702;</span>
        <span style="color: #F92672;">if</span> (up-&gt;pending) {
                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                 * There are pending frames.</span>
<span style="color: #75715E;">                 * The socket lock must be held while it's corked.</span>
<span style="color: #75715E;">                 */</span>
                lock_sock(sk);
                <span style="color: #F92672;">if</span> (likely(up-&gt;pending)) {
                        <span style="color: #F92672;">if</span> (unlikely(up-&gt;pending != AF_INET)) {
                                release_sock(sk);
                                <span style="color: #F92672;">return</span> -EINVAL;
                        }
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">do_append_data</span>;
                }
                release_sock(sk);
        }
        ulen += <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32047;&#35745;UDP&#25968;&#25454;&#25253;&#38271;&#24230;</span>

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Get and verify the address.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;msg&#20013;&#24102;&#26377;&#30446;&#30340;&#22320;&#22336;&#30340;&#24773;&#20917;&#65292;&#36890;&#24120;&#26159;&#35843;&#29992;sendto&#21457;&#36865;UDP&#25968;&#25454;</span>
        <span style="color: #F92672;">if</span> (msg-&gt;msg_name) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> * <span style="color: #FD971F;">usin</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span>*)msg-&gt;msg_name;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30446;&#30340;&#22320;&#22336;&#38271;&#24230;&#26657;&#39564;</span>
                <span style="color: #F92672;">if</span> (msg-&gt;msg_namelen &lt; <span style="color: #F92672;">sizeof</span>(*usin))
                        <span style="color: #F92672;">return</span> -EINVAL;
                <span style="color: #F92672;">if</span> (usin-&gt;sin_family != AF_INET) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22320;&#22336;&#26063;&#26657;&#39564;</span>
                        <span style="color: #F92672;">if</span> (usin-&gt;sin_family != AF_UNSPEC)
                                <span style="color: #F92672;">return</span> -EAFNOSUPPORT;
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32531;&#23384;&#30446;&#30340;&#22320;&#22336;&#30446;&#30340;&#31471;&#21475;&#21040;&#20020;&#26102;&#21464;&#37327;</span>
                daddr = usin-&gt;sin_addr.s_addr;
                dport = usin-&gt;sin_port;
                <span style="color: #F92672;">if</span> (dport == 0)
                        <span style="color: #F92672;">return</span> -EINVAL;
        } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22788;&#29702;msg&#20013;&#27809;&#26377;&#30446;&#30340;&#22320;&#22336;&#30340;&#24773;&#20917;&#65292;&#35843;&#29992;&#20102;connect&#21518;&#21457;&#36865;&#25968;&#25454;&#26102;&#19981;&#38656;&#35201;&#24102;&#22320;&#22336;</span><span style="color: #75715E;">*/</span>
                <span style="color: #F92672;">if</span> (sk-&gt;sk_state != TCP_ESTABLISHED) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#26597;&#29366;&#24577;&#26159;&#21542;&#20026;ESTABLISHED</span>
                        <span style="color: #F92672;">return</span> -EDESTADDRREQ;
                daddr = inet-&gt;daddr;
                dport = inet-&gt;dport;
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Open fast path for connected socket.</span>
<span style="color: #75715E;">                   Route will not be used, if at least one option is set.</span>
<span style="color: #75715E;">                 *///</span><span style="color: #75715E;">&#35774;&#32622;connected&#26631;&#24535;&#21518;&#65292;&#21518;&#32493;&#30340;&#26597;&#25214;&#36335;&#30001;&#36807;&#31243;&#21487;&#20197;&#20316;&#24555;&#36895;&#22788;&#29702;</span>
                connected = 1;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;ipc&#30340;&#28304;&#22320;&#22336;&#21644;&#36755;&#20986;&#32593;&#32476;&#35774;&#22791;&#32034;&#24341;</span>
        ipc.addr = inet-&gt;saddr;
        ipc.oif = sk-&gt;sk_bound_dev_if;
        <span style="color: #F92672;">if</span> (msg-&gt;msg_controllen) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#20026;0,&#21017;&#38656;&#35201;&#22788;&#29702;&#25511;&#21046;&#20449;&#24687;</span>
                <span style="color: #E6DB74;">/** &#35843;&#29992;ip_cmsg_send&#22788;&#29702;&#25511;&#21046;&#20449;&#24687;&#12290;&#21253;&#25324;&#22914;&#26524;&#23384;&#22312;IP&#36873;&#39033;&#65288;IP_RETOPTS&#65289;&#21017;&#26657;&#39564;&#65292;</span>
<span style="color: #E6DB74;">                &#22914;&#26524;&#35774;&#23450;&#28304;&#22320;&#22336;&#21644;&#36755;&#20986;&#32593;&#32476;&#35774;&#22791;&#32034;&#24341;&#65288;IP_PKTINFO&#65289;&#21017;&#20174;&#25511;&#21046;&#20449;&#24687;&#20013;&#33719;&#21462;&#12290;*/</span>
                err = ip_cmsg_send(msg, &amp;ipc);
                <span style="color: #F92672;">if</span> (err)
                        <span style="color: #F92672;">return</span> err;
                <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#23384;&#22312;IP&#36873;&#39033;&#65292;&#21017;&#35774;&#32622;free&#26631;&#24535;&#65292;&#34920;&#31034;ipc&#20013;opt&#25351;&#21521;&#30340;IP&#36873;&#39033;&#26159;&#22312;</span>
<span style="color: #75715E;">                ip_cmsg_send&#20013;&#20998;&#37197;&#30340;&#65292;&#22788;&#29702;&#23436;&#21518;&#38656;&#35201;&#37322;&#25918;&#12290;</span><span style="color: #75715E;">*/</span>
                <span style="color: #F92672;">if</span> (ipc.opt)
                        free = 1;
                connected = 0;
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#21457;&#36865;&#30340;&#25968;&#25454;&#20013;&#27809;&#26377;IP&#36873;&#39033;&#25511;&#21046;&#20449;&#24687;&#65292;&#21017;&#20174;inet_sock&#32467;&#26500;&#30340;opt&#20013;&#33719;&#21462;IP&#36873;&#39033;&#20449;&#24687;</span>
<span style="color: #75715E;">        &#65288;&#36890;&#36807;IP_OPTIONS&#22871;&#25509;&#21475;&#36873;&#39033;&#35774;&#32622;&#65289;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>ipc.opt)
                ipc.opt = inet-&gt;opt;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25511;&#21046;&#20449;&#24687;ipc&#20013;&#35201;&#20445;&#23384;&#30446;&#30340;&#22320;&#22336;&#65292;&#25152;&#20197;&#20808;&#23558;&#28304;&#22320;&#22336;&#20445;&#23384;&#22312;saddr</span>
        saddr = ipc.addr;
        ipc.addr = faddr = daddr;
        <span style="color: #E6DB74;">/** &#22914;&#26524;&#23384;&#22312;&#23485;&#26494;&#25110;&#20005;&#26684;&#28304;&#36335;&#30001;&#36873;&#36335;&#30340;IP&#36873;&#39033;&#65292;&#21017;&#19981;&#33021;&#26681;&#25454;&#30446;&#30340;&#22320;&#22336;&#36873;&#36335;&#65292;&#32780;&#24212;&#35813;&#23558;&#36873;&#39033;&#20013;&#30340;</span>
<span style="color: #E6DB74;">        &#19979;&#19968;&#31449;&#22320;&#22336;&#20316;&#20026;&#30446;&#30340;&#22320;&#22336;&#26469;&#36873;&#36335;&#12290;&#22240;&#27492;&#22312;&#27492;&#23558;&#19979;&#19968;&#31449;&#22320;&#22336;&#20445;&#23384;&#22312;&#20020;&#26102;&#21464;&#37327;&#20013;&#65292;&#20197;&#29992;&#20110;&#21518;&#32493;&#30340;&#36873;&#36335;&#65292;</span>
<span style="color: #E6DB74;">        &#12290;&#21516;&#26102;&#30001;&#20110;&#21518;&#32493;&#38656;&#35201;&#37325;&#26032;&#36873;&#36335;&#65292;&#22312;&#27492;&#22797;&#20301;connected&#26631;&#24535;*/</span>
        <span style="color: #F92672;">if</span> (ipc.opt &amp;&amp; ipc.opt-&gt;srr) {
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>daddr)
                        <span style="color: #F92672;">return</span> -EINVAL;
                faddr = ipc.opt-&gt;faddr;
                connected = 0;
        }
        <span style="color: #E6DB74;">/** &#22914;&#26524;&#35774;&#32622;&#20102;SO_DONTROUTE&#36873;&#39033;&#65292;&#25110;&#21457;&#36865;&#26102;&#35774;&#32622;&#20102;MSG_DONTROUTE&#26631;&#24535;&#65292;&#20877;&#25110;&#32773;&#22312;IP&#36873;&#39033;&#20013;</span>
<span style="color: #E6DB74;">        &#23384;&#22312;&#20005;&#26684;&#28304;&#36335;&#30001;&#36873;&#39033;&#65292;&#21017;&#35828;&#26126;&#30446;&#30340;&#22320;&#22336;&#25110;&#19979;&#19968;&#36339;&#24517;&#23450;&#20301;&#20110;&#26412;&#22320;&#23376;&#32593;&#12290;&#22240;&#27492;&#22312;tos&#21464;&#37327;&#20013;&#35774;&#32622;</span>
<span style="color: #E6DB74;">        RTO_ONLINK&#26631;&#24535;&#65292;&#21518;&#32493;&#26597;&#25214;&#36335;&#30001;&#26102;&#34920;&#31034;&#19982;&#30446;&#30340;&#22320;&#30452;&#36830;&#12290;*/</span>
        tos = RT_TOS(inet-&gt;tos);
        <span style="color: #F92672;">if</span> (sock_flag(sk, SOCK_LOCALROUTE) ||
            (msg-&gt;msg_flags &amp; MSG_DONTROUTE) ||
            (ipc.opt &amp;&amp; ipc.opt-&gt;is_strictroute)) {
                tos |= RTO_ONLINK;
                connected = 0;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;&#30446;&#30340;&#22320;&#22336;&#20026;&#32452;&#25773;&#22320;&#22336;&#30340;&#24773;&#20917;</span>
        <span style="color: #F92672;">if</span> (MULTICAST(daddr)) {
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>ipc.oif) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32452;&#25773;&#25253;&#25991;&#65292;&#25511;&#21046;&#20449;&#24687;&#20013;&#27809;&#26377;&#25351;&#23450;&#32452;&#25773;&#36755;&#20986;&#32593;&#32476;&#35774;&#22791;</span>
                        ipc.oif = inet-&gt;mc_index;
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>saddr)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#32452;&#25773;&#25253;&#25991;&#65292;&#25511;&#21046;&#20449;&#24687;&#20013;&#27809;&#26377;&#25351;&#23450;&#32452;&#25773;&#36755;&#28304;&#22320;&#22336;</span>
                        saddr = inet-&gt;mc_addr;
                connected = 0; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30001;&#20110;&#26159;&#32452;&#25773;&#25253;&#25991;&#65292;&#38656;&#35201;&#22312;&#36335;&#30001;&#34920;&#26597;&#25214;&#36335;&#30001;</span>
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#21487;&#20197;&#30452;&#25509;&#20174;&#22871;&#25509;&#21475;&#20013;&#33719;&#21462;&#36335;&#30001;&#32531;&#23384;&#39033;</span>
        <span style="color: #F92672;">if</span> (connected)
                rt = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span>*)sk_dst_check(sk, 0);
        <span style="color: #E6DB74;">/**&#26410;&#36830;&#25509;&#65292;&#25110;&#32773;&#21457;&#36865;&#20102;&#25511;&#21046;&#20449;&#24687;&#65292;&#25110;&#32773;&#26159;&#32452;&#25773;&#25253;&#25991;&#65292;&#25110;&#32773;&#27809;&#26377;&#33719;&#21462;&#21040;&#36335;&#30001;&#65292;</span>
<span style="color: #E6DB74;">        &#37117;&#38656;&#35201;&#26597;&#25214;&#36335;&#30001;&#34920; */</span>
        <span style="color: #F92672;">if</span> (rt == <span style="color: #AE81FF;">NULL</span>) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">flowi</span> <span style="color: #FD971F;">fl</span> = { .oif = ipc.oif,
                                    .nl_u = { .ip4_u =
                                              { .daddr = faddr,
                                                .saddr = saddr,
                                                .tos = tos } },
                                    .proto = sk-&gt;sk_protocol,
                                    .uli_u = { .ports =
                                               { .sport = inet-&gt;sport,
                                                 .dport = dport } } };
                security_sk_classify_flow(sk, &amp;fl);
                err = ip_route_output_flow(&amp;rt, &amp;fl, sk, <span style="color: #E6DB74; font-weight: bold;">!</span>(msg-&gt;msg_flags&amp;MSG_DONTWAIT));
                <span style="color: #F92672;">if</span> (err)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

                err = -EACCES;
                <span style="color: #F92672;">if</span> ((rt-&gt;rt_flags &amp; RTCF_BROADCAST) &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#21040;&#30340;&#36335;&#30001;&#26159;&#24191;&#25773;&#22320;&#22336;</span>
                    <span style="color: #E6DB74; font-weight: bold;">!</span>sock_flag(sk, SOCK_BROADCAST)) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24182;&#19988;&#22871;&#25509;&#21475;&#26412;&#36523;&#19981;&#25903;&#25345;&#21457;&#36865;&#24191;&#25773;&#25253;&#25991;</span>
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
                <span style="color: #F92672;">if</span> (connected) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23545;&#20110;&#24050;&#36830;&#25509;&#30340;&#22871;&#25509;&#21475;&#65292;&#38656;&#35201;&#23558;&#36335;&#30001;&#32531;&#23384;&#39033;&#32531;&#23384;&#21040;&#22871;&#25509;&#21475;&#20013;&#12290;</span>
                        sk_dst_set(sk, dst_clone(&amp;rt-&gt;u.dst));
        }
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#35774;&#32622;&#20102;MSG_CONFIRM&#26631;&#24535;&#65292;&#21017;&#35828;&#26126;&#24212;&#29992;&#23618;&#30693;&#36947;&#32593;&#20851;&#26377;&#25928;&#24182;&#19988;&#21487;&#36798;&#65292;</span>
<span style="color: #75715E;">        &#21017;&#36339;&#36716;&#65292;&#23545;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#36827;&#34892;&#30830;&#35748;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (msg-&gt;msg_flags&amp;MSG_CONFIRM)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">do_confirm</span>;
<span style="color: #AE81FF;">back_from_confirm</span>:
        <span style="color: #E6DB74;">/**&#20174;&#33719;&#21462;&#21040;&#30340;&#36335;&#30001;&#20013;&#33719;&#21462;&#28304;&#22320;&#22336;&#21644;&#30446;&#30340;&#22320;&#22336;&#12290;&#20107;&#23454;&#19978;&#65292;&#22312;&#21457;&#36865;UDP&#25968;&#25454;&#25253;&#26102;&#21487;&#20197;&#19981;&#25351;&#23450;&#30446;&#30340;&#22320;&#22336;&#65292;</span>
<span style="color: #E6DB74;">        &#32780;&#22312;&#21457;&#36865;&#30340;&#25511;&#21046;&#20449;&#24687;&#20013;&#21152;&#20837;&#20005;&#26684;&#25110;&#23485;&#26494;&#28304;&#36335;&#30001;&#36873;&#39033;&#12290;&#22240;&#27492;&#22914;&#26524;&#27492;&#26102;&#36824;&#27809;&#26377;&#33719;&#21462;&#30446;&#30340;&#22320;&#22336;&#65292;</span>
<span style="color: #E6DB74;">        &#21017;&#20174;&#36335;&#30001;&#32531;&#23384;&#39033;&#20013;&#33719;&#21462;*/</span>
        saddr = rt-&gt;rt_src;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>ipc.addr)
                daddr = ipc.addr = rt-&gt;rt_dst;

        <span style="color: #E6DB74;">/** &#20877;&#27425;&#30830;&#35748;UDP&#21457;&#36865;&#29366;&#24577;&#65292;&#22914;&#26524;UDP&#36824;&#22788;&#20110;&#19978;&#27425;&#30340;&#21457;&#36865;&#36807;&#31243;&#20013;&#65292;&#21017;&#35828;&#26126;&#22788;&#29702;&#36807;&#31243;&#23384;&#22312;bug&#12290;</span>
<span style="color: #E6DB74;">        &#25353;&#29031;&#36923;&#36753;&#65292;&#22914;&#26524;UDP&#36824;&#22788;&#22312;&#19978;&#27425;&#21457;&#36865;&#36807;&#31243;&#20013;&#65292;&#21017;&#24212;&#35813;&#24050;&#32463;&#36339;&#36716;&#21040;do_append_data&#22788;&#20102;*/</span>
        lock_sock(sk);
        <span style="color: #F92672;">if</span> (unlikely(up-&gt;pending)) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">The socket is already corked while preparing it.</span><span style="color: #75715E;"> */</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">... which is an evident application bug. --ANK</span><span style="color: #75715E;"> */</span>
                release_sock(sk);

                LIMIT_NETDEBUG(KERN_DEBUG <span style="color: #E6DB74;">"udp cork app bug 2\n"</span>);
                err = -EINVAL;
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        }
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Now cork the socket to pend data.</span>
<span style="color: #75715E;">         *//** </span><span style="color: #75715E;">&#21040;&#27492;&#20026;&#27490;&#38656;&#35201;&#26657;&#39564;&#30340;&#37117;&#24050;&#32463;&#23436;&#25104;&#65292;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#20063;&#24050;&#32463;&#33719;&#21462;&#65292;&#27492;&#26102;&#38656;&#35201;&#32531;&#23384;&#30446;&#30340;&#22320;&#22336;&#12289;</span>
<span style="color: #75715E;">         &#30446;&#30340;&#31471;&#21475;&#12289;&#28304;&#22320;&#22336;&#21644;&#28304;&#31471;&#21475;&#20449;&#24687;&#65292;&#20197;&#20415;&#22312;&#21457;&#36865;&#22788;&#29702;&#26102;&#26041;&#20415;&#33719;&#21462;&#20449;&#24687;&#12290;&#26368;&#21518;&#35774;&#32622;pending&#26631;&#24535;&#65292;</span>
<span style="color: #75715E;">         &#34920;&#31034;&#27491;&#22312;&#22788;&#29702;&#25968;&#25454;</span><span style="color: #75715E;">*/</span>
        inet-&gt;cork.fl.fl4_dst = daddr;
        inet-&gt;cork.fl.fl_ip_dport = dport;
        inet-&gt;cork.fl.fl4_src = saddr;
        inet-&gt;cork.fl.fl_ip_sport = inet-&gt;sport;
        up-&gt;pending = AF_INET;

<span style="color: #AE81FF;">do_append_data</span>: <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;&#25968;&#25454;&#24182;&#21457;&#36865;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32047;&#35745;&#20174;UDP&#22871;&#25509;&#21475;&#21457;&#36865;&#25968;&#25454;&#21040;IP&#23618;&#26102;&#24453;&#21457;&#36865;&#25968;&#25454;&#30340;&#38271;&#24230;</span>
        up-&gt;len += ulen;
        <span style="color: #E6DB74;">/** &#26681;&#25454;&#26159;UDP&#36824;&#26159;UDP_LITE,&#33719;&#21462;&#8220;&#22797;&#21046;&#25968;&#25454;&#21040;UDP&#8221;&#30340;&#20989;&#25968;&#12290;</span>
<span style="color: #E6DB74;">        UDP&#21644;&#36731;&#37327;&#32423;UDP&#30340;&#23454;&#29616;&#20849;&#29992;&#20102;&#19968;&#22871;&#20989;&#25968;&#65292;&#21482;&#26159;&#22312;&#35745;&#31639;&#26657;&#39564;&#21644;&#19978;&#26377;&#20123;&#21435;&#34987;&#12290;&#36731;&#37327;&#32423;UDP&#21487;&#20197;&#22312;&#21457;&#36865;&#21069;</span>
<span style="color: #E6DB74;">        &#32780;&#19981;&#26159;&#22797;&#21046;&#25968;&#25454;&#21040;&#20998;&#29255;&#26102;&#65292;&#23545;&#25968;&#25454;&#21069;&#37096;&#25351;&#23450;&#25968;&#30446;&#30340;&#23383;&#33410;&#25110;&#20840;&#37096;&#25968;&#25454;&#25191;&#34892;&#26657;&#39564;&#21644;&#12290;&#32780;UDP&#22914;&#26524;&#30001;&#36719;&#20214;</span>
<span style="color: #E6DB74;">        &#25191;&#34892;&#26657;&#39564;&#21644;&#65292;&#21017;&#22312;&#22797;&#21046;&#25968;&#25454;&#21040;&#20998;&#29255;&#26102;&#23545;&#25968;&#25454;&#21253;&#20013;&#30340;&#20840;&#37096;&#25968;&#25454;&#25191;&#34892;&#26657;&#39564;&#21644;&#25805;&#20316;&#12290;*/</span>
        getfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35843;&#29992;IP&#23618;&#25509;&#21475;&#20989;&#25968;ip_append_data,&#25353;&#36755;&#20986;&#36335;&#30001;&#26597;&#35810;&#24471;&#21040;&#30340;&#36755;&#20986;&#32593;&#32476;&#35774;&#22791;&#25509;&#21475;&#30340;MTU&#23558;&#25968;&#25454;&#20998;&#21106;&#65292;</span>
<span style="color: #75715E;">        &#24182;&#21019;&#24314;&#23545;&#24212;&#30340;SKB,&#28155;&#21152;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#21457;&#36865;&#38431;&#21015;&#12290;</span><span style="color: #75715E;">*/</span>
        err = ip_append_data(sk, getfrag, msg-&gt;msg_iov, ulen,
                        <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>), &amp;ipc, rt,
                        corkreq ? msg-&gt;msg_flags|MSG_MORE : msg-&gt;msg_flags);
        <span style="color: #F92672;">if</span> (err) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#29983;&#38169;&#35823;&#65292;&#21017;&#28165;&#26970;&#37322;&#25918;&#21457;&#36865;&#38431;&#21015;&#20013;&#30340;SKB,&#24182;&#22797;&#20301;pending&#31561;&#26631;&#24535;</span>
                udp_flush_pending_frames(sk);
        <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>corkreq) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;&#25104;&#21151;&#65292;&#19988;&#26080;&#38656;&#31561;&#24453;&#32452;&#25104;64KB&#25968;&#25454;&#22312;&#21457;&#36865;</span>
                err = udp_push_pending_frames(sk);  <span style="color: #75715E;">///</span><span style="color: #75715E;">&#29983;&#25104;UDP&#25968;&#25454;&#25253;&#65292;&#24182;&#36890;&#36807;IP&#23618;&#25509;&#21475;&#21457;&#36865;</span>
        <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (unlikely(skb_queue_empty(&amp;sk-&gt;sk_write_queue)))<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#38431;&#21015;&#20026;&#31354;</span>
                up-&gt;pending = 0;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#20301;pending&#26631;&#24535;&#12290;</span>
        release_sock(sk);

<span style="color: #AE81FF;">out</span>:
        ip_rt_put(rt); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36882;&#20943;&#36335;&#30001;&#24341;&#29992;</span>
        <span style="color: #F92672;">if</span> (free)
                kfree(ipc.opt);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#37322;&#25918;ipc&#20013;&#30340;&#36873;&#39033;&#20449;&#24687;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>err) {  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#25104;&#21151;&#65292;&#36820;&#22238;&#21457;&#36865;&#30340;&#23383;&#33410;&#25968;</span>
                UDP_INC_STATS_USER(UDP_MIB_OUTDATAGRAMS, is_udplite);
                <span style="color: #F92672;">return</span> len;
        }
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting</span>
<span style="color: #75715E;">         * ENOBUFS might not be good (it's not tunable per se), but otherwise</span>
<span style="color: #75715E;">         * we don't have a good statistic (IpOutDiscards but it can be too many</span>
<span style="color: #75715E;">         * things).  We could add another new stat but at least for now that</span>
<span style="color: #75715E;">         * seems like overkill.</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#22788;&#29702;&#38169;&#35823;</span>
        <span style="color: #F92672;">if</span> (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags)) {
                UDP_INC_STATS_USER(UDP_MIB_SNDBUFERRORS, is_udplite);
        }
        <span style="color: #F92672;">return</span> err;

<span style="color: #AE81FF;">do_confirm</span>: <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#25968;&#25454;&#26102;&#35774;&#32622;&#20102;MSG_CONFIRM&#26631;&#24535;</span>
        dst_confirm(&amp;rt-&gt;u.dst); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30452;&#25509;&#23545;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#36827;&#34892;&#30830;&#35748;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">MSG_PROBE&#29992;&#26469;&#21457;&#29616;&#36335;&#24452;&#65292;&#24182;&#19981;&#30495;&#27491;&#21457;&#36865;&#25968;&#25454;&#12290;&#22312;&#30830;&#35748;&#32593;&#20851;&#21487;&#36798;&#21518;&#65292;&#36824;&#38656;&#26816;&#27979;MSG_PROBE&#26631;&#24535;&#65292;</span>
<span style="color: #75715E;">        &#20174;&#22788;&#29702;&#30340;&#36923;&#36753;&#19978;&#21487;&#20197;&#30475;&#20986;&#65292;MSG_PROBE&#26631;&#24535;&#24517;&#39035;&#21644;MSG_CONFIRM&#26631;&#24535;&#19968;&#36215;&#20351;&#29992;&#65292;&#21542;&#21017;&#27809;&#26377;&#24847;&#20041;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(msg-&gt;msg_flags&amp;MSG_PROBE) || len)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">back_from_confirm</span>;
        err = 0;
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orge26a5fe" class="outline-3">
<h3 id="orge26a5fe"><span class="section-number-3">13.2.</span> udp_push_pending_frames()</h3>
<div class="outline-text-3" id="text-13-2">
<p>
udp_push_pending_frames()将带发送数据打包成一个UDP数据报输出。该函数的逻辑比较简单，在设置了传输层源端口、目的端口和数据长度等字段，准备了校验和之后，即交由ip_push_pending_frames()作进一步处理。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * Push out all pending data as one UDP datagram. Socket is locked.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_push_pending_frames</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udp_sock</span>  *<span style="color: #FD971F;">up</span> = udp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">flowi</span> *<span style="color: #FD971F;">fl</span> = &amp;inet-&gt;cork.fl;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span> *<span style="color: #FD971F;">uh</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span> = 0;
        <span style="color: #66D9EF;">__wsum</span> <span style="color: #FD971F;">csum</span> = 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#21457;&#36865;&#38431;&#21015;&#27809;&#26377;&#25253;&#25991;&#65292;&#21017;&#26080;&#38656;&#20877;&#20316;&#21457;&#36865;&#25805;&#20316;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Grab the skbuff where UDP header space exists.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> ((skb = skb_peek(&amp;sk-&gt;sk_write_queue)) == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * Create a UDP header</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#21021;&#22987;&#21270;UDPheader</span>
        uh = skb-&gt;h.uh;
        uh-&gt;source = fl-&gt;fl_ip_sport;
        uh-&gt;dest = fl-&gt;fl_ip_dport;
        uh-&gt;len = htons(up-&gt;len);
        uh-&gt;check = 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#36731;&#37327;&#32423;UDP,&#21017;&#38656;&#23545;&#25968;&#25454;&#25253;&#30340;&#21069;cscov&#20010;&#23383;&#33410;&#36827;&#34892;&#26657;&#39564;&#21644;&#30340;&#35745;&#31639;</span>
        <span style="color: #F92672;">if</span> (up-&gt;pcflag)                                  <span style="color: #75715E;">/*     </span><span style="color: #75715E;">UDP-Lite</span><span style="color: #75715E;">      */</span>
                csum  = udplite_csum_outgoing(sk, skb);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#31105;&#27490;&#20102;UDP&#25968;&#25454;&#25253;&#26657;&#39564;&#21644;&#65292;&#21017;&#35774;&#32622;SKB&#20013;&#30340;&#26657;&#39564;&#26631;&#24535;&#20026;CHECKSUM_NONE</span>
        <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (sk-&gt;sk_no_check == UDP_CSUM_NOXMIT) {   <span style="color: #75715E;">/* </span><span style="color: #75715E;">UDP csum disabled</span><span style="color: #75715E;"> */</span>
                skb-&gt;ip_summed = CHECKSUM_NONE;
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">send</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30001;&#30828;&#20214;&#25191;&#34892;&#26657;&#39564;&#21644;&#35745;&#31639;</span>
        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL) { <span style="color: #75715E;">/* </span><span style="color: #75715E;">UDP hardware csum</span><span style="color: #75715E;"> */</span>
                udp4_hwcsum_outgoing(sk, skb, fl-&gt;fl4_src,fl-&gt;fl4_dst, up-&gt;len);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">send</span>;
        } <span style="color: #F92672;">else</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20854;&#20182;&#24773;&#20917;&#36827;&#34892;&#26222;&#36890;&#30340;&#26657;&#39564;&#21644;&#35745;&#31639; /*   `normal' UDP    */</span>
                csum = udp_csum_outgoing(sk, skb);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#35745;&#31639;&#24471;&#21040;&#30340;&#26657;&#39564;&#21644;&#35774;&#32622;&#21040;UDP&#39318;&#37096;&#20013;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">add protocol-dependent pseudo-header</span><span style="color: #75715E;"> */</span>
        uh-&gt;check = csum_tcpudp_magic(fl-&gt;fl4_src, fl-&gt;fl4_dst, up-&gt;len,
                                      sk-&gt;sk_protocol, csum             );
        <span style="color: #F92672;">if</span> (uh-&gt;check == 0)
                uh-&gt;check = CSUM_MANGLED_0;

<span style="color: #AE81FF;">send</span>:   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;IP&#23618;&#25509;&#21475;&#36755;&#20986;UDP&#25968;&#25454;&#25253;</span>
        err = ip_push_pending_frames(sk);
<span style="color: #AE81FF;">out</span>:
        up-&gt;len = 0;
        up-&gt;pending = 0;
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org5ccf5bd" class="outline-2">
<h2 id="org5ccf5bd"><span class="section-number-2">14.</span> UDP的输入</h2>
<div class="outline-text-2" id="text-14">
</div>
<div id="outline-container-org70e9736" class="outline-3">
<h3 id="org70e9736"><span class="section-number-3">14.1.</span> UDP接收的入口：udp_rcv()</h3>
<div class="outline-text-3" id="text-14-1">
<p>
UDP层的数据接收，对于套接口而言，就是接收队列的入队操作。在IP层，如果是发送到本地数据，则交由ip_local_deliver_finish()处理，该函数会根据传输层协议类型，交由相应的函数处理，对udp协议来说，就是udp_rcv()，流程图如下：
</p>


<div id="orgb871dcc" class="figure">
<p><img src="image/udp-proto/udp-rcv.png" alt="udp-rcv.png" />
</p>
<p><span class="figure-number">Figure 8: </span>UDP输入流程</p>
</div>

<div class="org-src-container">
<pre class="src src-c">__inline__ <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_rcv</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">return</span> __udp4_lib_rcv(skb, udp_hash, 0);
}

<span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      All we need to do is get the socket, and then do a checksum.</span>
<span style="color: #75715E;"> */</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">__udp4_lib_rcv</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span> <span style="color: #FD971F;">udptable</span>[],
                   <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">is_udplite</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span> *<span style="color: #FD971F;">uh</span> = skb-&gt;h.uh;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> <span style="color: #FD971F;">ulen</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span>*)skb-&gt;dst;
        <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">saddr</span> = skb-&gt;nh.iph-&gt;saddr;
        <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span> = skb-&gt;nh.iph-&gt;daddr;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *  Validate the packet.</span>
<span style="color: #75715E;">         */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;UDP&#25968;&#25454;&#21253;&#38271;&#24230;&#65292;&#19981;&#33021;&#23567;&#20110;UDP&#39318;&#37096;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_may_pull(skb, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>)))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;              <span style="color: #75715E;">/* </span><span style="color: #75715E;">No space for header.</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">UDP&#39318;&#37096;&#20013;&#26631;&#35782;&#30340;&#25968;&#25454;&#38271;&#24230;&#22823;&#20110;&#23454;&#38469;SKB&#20013;UDP&#25968;&#25454;&#25253;&#30340;&#38271;&#24230;</span>
        ulen = ntohs(uh-&gt;len);
        <span style="color: #F92672;">if</span> (ulen &gt; skb-&gt;len)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">short_packet</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;UDP&#30340;&#26657;&#39564;&#21644;</span>
        <span style="color: #F92672;">if</span>(<span style="color: #E6DB74; font-weight: bold;">!</span> is_udplite ) {             <span style="color: #75715E;">/* </span><span style="color: #75715E;">UDP validates ulen.</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (ulen &lt; <span style="color: #F92672;">sizeof</span>(*uh) || pskb_trim_rcsum(skb, ulen))
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">short_packet</span>;
                udp4_csum_init(skb, uh);
        } <span style="color: #F92672;">else</span>  {                       <span style="color: #75715E;">/* </span><span style="color: #75715E;">UDP-Lite validates cscov.</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (udplite4_csum_init(skb, uh))
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">csum_error</span>;
        }
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#25509;&#25910;&#21040;&#30340;UDP&#25968;&#25454;&#25253;&#26159;&#24191;&#25773;&#25110;&#32773;&#32452;&#25773;&#25253;&#25991;&#65292;&#21017;&#35843;&#29992;__udp4_lib_mcast_deliver()&#20316;&#36755;&#20837;&#22788;&#29702;&#65292;</span>
<span style="color: #75715E;">        &#23558;&#20250;&#22810;&#27425;&#20811;&#38534;&#25509;&#25910;&#21040;&#30340;&#25968;&#25454;&#25253;&#65292;&#24182;&#23558;&#20811;&#38534;&#25968;&#25454;&#25253;&#28155;&#21152;&#21040;&#25509;&#25910;&#35813;&#32452;&#25773;&#25253;&#25991;&#30340;&#21508;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#25509;&#25910;&#38431;</span>
<span style="color: #75715E;">        &#21015;&#20013;&#12290;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span>(rt-&gt;rt_flags &amp; (RTCF_BROADCAST|RTCF_MULTICAST))
                <span style="color: #F92672;">return</span> __udp4_lib_mcast_deliver(skb, uh, saddr, daddr, udptable);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22312;udptable&#25955;&#21015;&#34920;&#20013;&#26597;&#25214;&#25152;&#23646;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        sk = __udp4_lib_lookup(saddr, uh-&gt;source, daddr, uh-&gt;dest,
                               skb-&gt;dev-&gt;ifindex, udptable        );
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#25214;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#21017;&#23558;UDP&#25968;&#25454;&#25253;&#28155;&#21152;&#21040;&#20854;&#25509;&#25910;&#38431;&#21015;&#12290;</span>
        <span style="color: #F92672;">if</span> (sk != <span style="color: #AE81FF;">NULL</span>) {
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ret</span> = udp_queue_rcv_skb(sk, skb);
                sock_put(sk);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">a return value &gt; 0 means to resubmit the input, but</span>
<span style="color: #75715E;">                 * it wants the return to be -protocol, or 0</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #F92672;">if</span> (ret &gt; 0)
                        <span style="color: #F92672;">return</span> -ret;
                <span style="color: #F92672;">return</span> 0;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#25214;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#22788;&#29702;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#26597;IPSEC&#21253;&#31574;&#30053;&#26159;&#21542;&#21512;&#27861;&#65292;&#23545;&#26222;&#36890;&#25968;&#25454;&#25253;&#21017;&#36820;&#22238;&#21512;&#27861;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>xfrm4_policy_check(<span style="color: #AE81FF;">NULL</span>, XFRM_POLICY_IN, skb))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
        nf_reset(skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#20301;&#25509;&#25910;&#21040;&#30340;SKB&#20013;&#19982;netfilter&#30456;&#20851;&#30340;&#25968;&#25454;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;&#26657;&#39564;&#21644;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">No socket. Drop packet silently, if checksum is wrong</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (udp_lib_checksum_complete(skb))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">csum_error</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#36807;&#26816;&#27979;&#65292;&#20294;&#27809;&#26377;&#25214;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#21017;&#21457;&#36865;ICMP&#30446;&#30340;&#22320;&#19981;&#21487;&#36798;&#25253;&#25991;</span>
        UDP_INC_STATS_BH(UDP_MIB_NOPORTS, is_udplite);
        icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * Hmm.  We got an UDP packet to a port to which we</span>
<span style="color: #75715E;">         * don't wanna listen.  Ignore it.</span>
<span style="color: #75715E;">         */</span>
        kfree_skb(skb);
        <span style="color: #F92672;">return</span>(0);

<span style="color: #AE81FF;">short_packet</span>:
        LIMIT_NETDEBUG(KERN_DEBUG <span style="color: #E6DB74;">"UDP%s: short packet: From %u.%u.%u.%u:%u %d/%d to %u.%u.%u.%u:%u\n"</span>,
                       is_udplite? <span style="color: #E6DB74;">"-Lite"</span> : <span style="color: #E6DB74;">""</span>,
                       NIPQUAD(saddr),
                       ntohs(uh-&gt;source),
                       ulen,
                       skb-&gt;len,
                       NIPQUAD(daddr),
                       ntohs(uh-&gt;dest));
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;

<span style="color: #AE81FF;">csum_error</span>:
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * RFC1122: OK.  Discards the bad packet silently (as far as</span>
<span style="color: #75715E;">         * the network is concerned, anyway) as per 4.1.3.4 (MUST).</span>
<span style="color: #75715E;">         */</span>
        LIMIT_NETDEBUG(KERN_DEBUG <span style="color: #E6DB74;">"UDP%s: bad checksum. From %d.%d.%d.%d:%d to %d.%d.%d.%d:%d ulen %d\n"</span>,
                       is_udplite? <span style="color: #E6DB74;">"-Lite"</span> : <span style="color: #E6DB74;">""</span>,
                       NIPQUAD(saddr),
                       ntohs(uh-&gt;source),
                       NIPQUAD(daddr),
                       ntohs(uh-&gt;dest),
                       ulen);
<span style="color: #AE81FF;">drop</span>:
        UDP_INC_STATS_BH(UDP_MIB_INERRORS, is_udplite);
        kfree_skb(skb);
        <span style="color: #F92672;">return</span>(0);
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org3b79ddc" class="outline-3">
<h3 id="org3b79ddc"><span class="section-number-3">14.2.</span> UDP组播数据报输入：__udp4_lib_mcast_deliver()</h3>
<div class="outline-text-3" id="text-14-2">
<p>
组播数据报与单播数据报存在很大不同，因此需要单独处理。在接收到组播数据报后，需查找接收该组播数据报的传输控制块，然后将组播数据报克隆后插入到这些传输控制块的接收队列中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Multicasts and broadcasts go to each listener.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> *      Note: called only from the BH handler context,</span>
<span style="color: #75715E;"> *      so we don't need to lock the hashes.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">__udp4_lib_mcast_deliver</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>,
                                    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>  *<span style="color: #FD971F;">uh</span>,
                                    <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">saddr</span>, <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span>,
                                    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span> <span style="color: #FD971F;">udptable</span>[])
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">dif</span>;

        read_lock(&amp;udp_hash_lock);
        <span style="color: #E6DB74;">/** &#26681;&#25454;&#25910;&#21040;&#30340;&#32452;&#25773;&#25968;&#25454;&#25253;&#30340;&#30446;&#30340;&#31471;&#21475;&#65292;&#24471;&#21040;&#25509;&#25910;&#35813;&#32452;&#25773;&#25968;&#25454;&#25253;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;udp_hash</span>
<span style="color: #E6DB74;">        &#25955;&#21015;&#34920;&#20837;&#21475;&#65292;&#28982;&#21518;&#20877;&#26681;&#25454;&#25968;&#25454;&#25253;&#30340;&#30446;&#30340;&#31471;&#21475;&#12289;&#30446;&#30340;&#22320;&#22336;&#12289;&#28304;&#31471;&#21475;&#12289;&#28304;&#22320;&#22336;&#20197;&#21450;&#35813;&#25968;&#25454;&#25253;&#30340;</span>
<span style="color: #E6DB74;">        &#36755;&#20837;&#32593;&#32476;&#35774;&#22791;&#30340;&#32034;&#24341;&#65292;&#26597;&#25214;&#25509;&#25910;&#35813;&#32452;&#25773;&#25968;&#25454;&#25253;&#30340;&#31532;&#19968;&#20010;&#20256;&#36755;&#25511;&#21046;&#22359;&#12290;*/</span>
        sk = sk_head(&amp;udptable[ntohs(uh-&gt;dest) &amp; (UDP_HTABLE_SIZE - 1)]);
        dif = skb-&gt;dev-&gt;ifindex;
        sk = udp_v4_mcast_next(sk, uh-&gt;dest, daddr, uh-&gt;source, saddr, dif);
        <span style="color: #E6DB74;">/** &#22914;&#26524;&#26597;&#25214;&#21040;&#25509;&#25910;&#35813;&#32452;&#25773;&#25968;&#25454;&#25253;&#30340;&#31532;&#19968;&#20010;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#21017;&#20174;&#36825;&#20010;&#20256;&#36755;&#25511;&#21046;&#22359;&#24320;&#22987;&#26597;&#25214;&#33021;</span>
<span style="color: #E6DB74;">        &#25509;&#25910;&#35813;&#32452;&#25773;&#25968;&#25454;&#25253;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#24182;&#23558;&#25509;&#25910;&#21040;&#30340;&#36825;&#20123;&#32452;&#25773;&#25968;&#25454;&#25253;&#20811;&#38534;&#21518;&#65292;&#28155;&#21152;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
<span style="color: #E6DB74;">        &#30340;&#25509;&#25910;&#38431;&#21015;&#20013;*/</span>
        <span style="color: #F92672;">if</span> (sk) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sknext</span> = <span style="color: #AE81FF;">NULL</span>;

                <span style="color: #F92672;">do</span> {
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb1</span> = skb;

                        sknext = udp_v4_mcast_next(sk_next(sk), uh-&gt;dest, daddr,
                                                   uh-&gt;source, saddr, dif);
                        <span style="color: #F92672;">if</span>(sknext)
                                skb1 = skb_clone(skb, GFP_ATOMIC);

                        <span style="color: #F92672;">if</span>(skb1) {
                                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ret</span> = udp_queue_rcv_skb(sk, skb1);
                                <span style="color: #F92672;">if</span> (ret &gt; 0)
                                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">we should probably re-process instead</span>
<span style="color: #75715E;">                                         * of dropping packets here.</span><span style="color: #75715E;"> */</span>
                                        kfree_skb(skb1);
                        }
                        sk = sknext;
                } <span style="color: #F92672;">while</span>(sknext);
        } <span style="color: #F92672;">else</span>
                kfree_skb(skb);
        read_unlock(&amp;udp_hash_lock);
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org57847ee" class="outline-3">
<h3 id="org57847ee"><span class="section-number-3">14.3.</span> udp_queue_rcv_skb()</h3>
<div class="outline-text-3" id="text-14-3">
<p>
将UDP数据报添加到所属传输控制块的接收队列中的功能由udp_queue_rcv_skb()来实现。在添加到接收队列之前，必须先进行数据报类型检测，因为不同类型数据报，如IPSEC协议的封装报文、组播广播数据报、单播数据报，各自的接收处理方式不尽相同。此外还需要进行一些相关的校验，如安全策略检查、校验和检查等。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">returns:</span>
<span style="color: #75715E;"> *  -1: error</span>
<span style="color: #75715E;"> *   0: success</span>
<span style="color: #75715E;"> *  &gt;0: "udp encap" protocol resubmission</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * Note that in the success and error cases, the skb is assumed to</span>
<span style="color: #75715E;"> * have either been requeued or freed.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_queue_rcv_skb</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> * <span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udp_sock</span> *<span style="color: #FD971F;">up</span> = udp_sk(sk);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">rc</span>;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Charge it to the socket, dropping if the queue is full.</span>
<span style="color: #75715E;">         */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23433;&#20840;&#31574;&#30053;&#26816;&#26597;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
                nf_reset(skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#20301;&#25509;&#25910;&#21040;&#30340;SKB&#20013;&#19982;netfilter&#30456;&#20851;&#30340;&#25968;&#25454;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#36890;&#36807;IPSEC&#23553;&#35013;&#30340;&#25253;&#25991;&#65292;&#21017;&#36890;&#36807;udp_encap_rcv()&#22788;&#29702;</span>
        <span style="color: #F92672;">if</span> (up-&gt;encap_type) {
                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                 * This is an encapsulation socket, so let's see if this is</span>
<span style="color: #75715E;">                 * an encapsulated packet.</span>
<span style="color: #75715E;">                 * If it's a keepalive packet, then just eat it.</span>
<span style="color: #75715E;">                 * If it's an encapsulateed packet, then pass it to the</span>
<span style="color: #75715E;">                 * IPsec xfrm input and return the response</span>
<span style="color: #75715E;">                 * appropriately.  Otherwise, just fall through and</span>
<span style="color: #75715E;">                 * pass this up the UDP socket.</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ret</span>;

                ret = udp_encap_rcv(sk, skb);
                <span style="color: #F92672;">if</span> (ret == 0) {
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Eat the packet ..</span><span style="color: #75715E;"> */</span>
                        kfree_skb(skb);
                        <span style="color: #F92672;">return</span> 0;
                }
                <span style="color: #F92672;">if</span> (ret &lt; 0) {
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">process the ESP packet</span><span style="color: #75715E;"> */</span>
                        ret = xfrm4_rcv_encap(skb, up-&gt;encap_type);
                        UDP_INC_STATS_BH(UDP_MIB_INDATAGRAMS, up-&gt;pcflag);
                        <span style="color: #F92672;">return</span> -ret;
                }
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">FALLTHROUGH -- it's a UDP Packet</span><span style="color: #75715E;"> */</span>
        }

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      UDP-Lite specific tests, ignored on UDP sockets</span>
<span style="color: #75715E;">         */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36731;&#37327;&#32423;UDP&#25968;&#25454;&#25253;&#65292;&#21017;&#26657;&#39564;&#35813;&#25968;&#25454;&#25253;&#38656;&#26657;&#39564;&#30340;&#23383;&#33410;&#26159;&#21542;&#26377;&#25928;</span>
        <span style="color: #F92672;">if</span> ((up-&gt;pcflag &amp; UDPLITE_RECV_CC)  &amp;&amp;  UDP_SKB_CB(skb)-&gt;partial_cov) {

                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                 * MIB statistics other than incrementing the error count are</span>
<span style="color: #75715E;">                 * disabled for the following two types of errors: these depend</span>
<span style="color: #75715E;">                 * on the application settings, not on the functioning of the</span>
<span style="color: #75715E;">                 * protocol stack as such.</span>
<span style="color: #75715E;">                 *</span>
<span style="color: #75715E;">                 * RFC 3828 here recommends (sec 3.3): "There should also be a</span>
<span style="color: #75715E;">                 * way ... to ... at least let the receiving application block</span>
<span style="color: #75715E;">                 * delivery of packets with coverage values less than a value</span>
<span style="color: #75715E;">                 * provided by the application."</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #F92672;">if</span> (up-&gt;pcrlen == 0) {          <span style="color: #75715E;">/* </span><span style="color: #75715E;">full coverage was set</span><span style="color: #75715E;">  */</span>
                        LIMIT_NETDEBUG(KERN_WARNING <span style="color: #E6DB74;">"UDPLITE: partial coverage "</span>
                                <span style="color: #E6DB74;">"%d while full coverage %d requested\n"</span>,
                                UDP_SKB_CB(skb)-&gt;cscov, skb-&gt;len);
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
                }
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">The next case involves violating the min. coverage requested</span>
<span style="color: #75715E;">                 * by the receiver. This is subtle: if receiver wants x and x is</span>
<span style="color: #75715E;">                 * greater than the buffersize/MTU then receiver will complain</span>
<span style="color: #75715E;">                 * that it wants x while sender emits packets of smaller size y.</span>
<span style="color: #75715E;">                 * Therefore the above ...()-&gt;partial_cov statement is essential.</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #F92672;">if</span> (UDP_SKB_CB(skb)-&gt;cscov  &lt;  up-&gt;pcrlen) {
                        LIMIT_NETDEBUG(KERN_WARNING
                                <span style="color: #E6DB74;">"UDPLITE: coverage %d too small, need min %d\n"</span>,
                                UDP_SKB_CB(skb)-&gt;cscov, up-&gt;pcrlen);
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
                }
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#23433;&#35013;&#20102;&#22871;&#25509;&#21475;&#36807;&#28388;&#22120;&#19988;&#25253;&#25991;&#38656;&#35201;&#26657;&#39564;&#65292;&#21017;&#26816;&#27979;UDP&#25968;&#25454;&#25253;&#26657;&#39564;&#21644;&#65292;</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_filter &amp;&amp; skb-&gt;ip_summed != CHECKSUM_UNNECESSARY) {
                <span style="color: #F92672;">if</span> (__udp_lib_checksum_complete(skb))
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
                skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#25509;&#25910;&#21040;&#30340;&#25968;&#25454;&#25253;&#28155;&#21152;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#25509;&#25910;&#38431;&#21015;</span>
        <span style="color: #F92672;">if</span> ((rc = sock_queue_rcv_skb(sk,skb)) &lt; 0) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Note that an ENOMEM error is charged twice</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (rc == -ENOMEM)
                        UDP_INC_STATS_BH(UDP_MIB_RCVBUFERRORS, up-&gt;pcflag);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
        }

        UDP_INC_STATS_BH(UDP_MIB_INDATAGRAMS, up-&gt;pcflag);
        <span style="color: #F92672;">return</span> 0;

<span style="color: #AE81FF;">drop</span>:
        UDP_INC_STATS_BH(UDP_MIB_INERRORS, up-&gt;pcflag);
        kfree_skb(skb);
        <span style="color: #F92672;">return</span> -1;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">sock_queue_rcv_skb</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span> = 0;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">skb_len</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Cast skb-&gt;rcvbuf to unsigned... It's pointless, but reduces</span>
<span style="color: #75715E;">           number of warnings when compiling with -W --ANK</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#26816;&#27979;&#29992;&#20110;&#25509;&#25910;&#30340;&#32531;&#23384;&#21040;&#23567;&#26159;&#21542;&#24050;&#32463;&#36798;&#21040;&#20102;&#25509;&#25910;&#32531;&#20914;&#21306;&#22823;&#23567;&#30340;&#19978;&#38480;</span>
        <span style="color: #F92672;">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) + skb-&gt;truesize &gt;=
            (<span style="color: #66D9EF;">unsigned</span>)sk-&gt;sk_rcvbuf) {
                err = -ENOMEM;
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#23433;&#35013;&#20102;&#36807;&#28388;&#22120;&#65292;&#21017;&#21482;&#26377;&#31526;&#21512;&#36807;&#28388;&#35268;&#21017;&#30340;&#25253;&#25991;&#25165;&#33021;&#25918;&#34892;</span>
        err = sk_filter(sk, skb);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        skb-&gt;dev = <span style="color: #AE81FF;">NULL</span>;
        skb_set_owner_r(skb, sk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#25968;&#25454;&#25253;&#30340;&#23487;&#20027;&#20256;&#36755;&#25511;&#21046;&#22359;</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Cache the SKB length before we tack it onto the receive</span>
<span style="color: #75715E;">         * queue.  Once it is added it no longer belongs to us and</span>
<span style="color: #75715E;">         * may be freed by other threads of control pulling packets</span>
<span style="color: #75715E;">         * from the queue.</span>
<span style="color: #75715E;">         */</span>
        skb_len = skb-&gt;len;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28155;&#21152;&#21040;&#25509;&#25910;&#38431;&#21015;</span>
        skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#22871;&#25509;&#21475;&#27809;&#26377;&#20851;&#38381;&#65292;&#21017;&#21796;&#37266;&#31561;&#24453;&#35813;&#22871;&#25509;&#21475;&#30340;&#25509;&#25910;&#36827;&#31243;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sock_flag(sk, SOCK_DEAD))
                sk-&gt;sk_data_ready(sk, skb_len);
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org696af26" class="outline-2">
<h2 id="org696af26"><span class="section-number-2">15.</span> recvmsg系统调用的实现</h2>
<div class="outline-text-2" id="text-15">
<div class="org-src-container">
<pre class="src src-fundamental">sys_recvmsg()
        sockfd_lookp_light()
        sock_recvmsg()
                __sock_recvmsg()             proto_ops
                        sock-&gt;ops-&gt;recvmsg()----------&gt;sock_common_recvmsg()
                                                   proto
                                sk-&gt;prot_recvmsg()----------&gt;udp_recvmsg()
</pre>
</div>

<p>
udp_recvmsg()实现了主动从传输控制块的接收队列中读取数据到用户空间的缓冲区中。
</p>


<div id="orgbd58cf7" class="figure">
<p><img src="image/udp-proto/recvmsg.png" alt="recvmsg.png" />
</p>
<p><span class="figure-number">Figure 9: </span>recvmsg()流程图</p>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      This should be easy, if there is something there we</span>
<span style="color: #75715E;"> *      return it, otherwise we block.</span>
<span style="color: #75715E;"> */</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_recvmsg</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *<span style="color: #FD971F;">iocb</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24322;&#27493;IO&#25511;&#21046;&#22359;&#65292;&#27492;&#22788;&#26410;&#20351;&#29992;</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">msg</span>,
<span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">len</span>,
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">noblock</span>,
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>,
<span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">addr_len</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> *<span style="color: #FD971F;">sin</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> *)msg-&gt;msg_name;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">copied</span>, <span style="color: #FD971F;">err</span>, <span style="color: #FD971F;">copy_only</span>, <span style="color: #FD971F;">is_udplite</span> = IS_UDPLITE(sk);

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Check any passed addresses</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#36890;&#36807;&#36755;&#20986;&#21442;&#25968;&#36820;&#22238;&#21457;&#36865;&#26041;&#30340;&#22320;&#22336;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (addr_len)
                *addr_len=<span style="color: #F92672;">sizeof</span>(*sin);
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#35835;&#21462;&#26631;&#24535;&#20013;&#23384;&#22312;MSG_ERRQUEUE&#26631;&#24535;&#65292;&#21017;&#35828;&#26126;&#38656;&#35201;&#35835;&#21462;&#38169;&#35823;&#20449;&#24687;&#65292;&#22240;&#27492;&#35843;&#29992;ip_recv_error()</span>
<span style="color: #75715E;">        &#20174;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#38169;&#35823;&#38431;&#21015;&#20013;&#35835;&#21462;&#38169;&#35823;&#20449;&#24687;&#21518;&#36820;&#22238;&#12290;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (flags &amp; MSG_ERRQUEUE)
                <span style="color: #F92672;">return</span> ip_recv_error(sk, msg, len);

<span style="color: #AE81FF;">try_again</span>:
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#25509;&#25910;&#38431;&#21015;&#33719;&#21462;UDP&#25968;&#25454;&#25253;&#65292;&#22914;&#26524;&#27809;&#26377;&#65292;&#21017;&#35828;&#26126;&#25509;&#25910;&#38431;&#21015;&#20026;&#31354;&#65292;&#25110;&#32773;&#26159;&#21457;&#29983;&#20102;&#38169;&#35823;&#12290;</span>
        skb = skb_recv_datagram(sk, flags, noblock, &amp;err);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#38656;&#35201;&#22797;&#21046;&#25968;&#25454;&#30340;&#38271;&#24230;&#65288;&#19981;&#21253;&#21547;UDP&#39318;&#37096;&#65289;&#65292;&#22914;&#26524;&#29992;&#25143;&#25552;&#20379;&#30340;&#32531;&#20914;&#21306;&#19981;&#22815;&#65292;&#21017;&#25130;&#26029;&#25968;&#25454;</span>
        copied = skb-&gt;len - <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>);
        <span style="color: #F92672;">if</span> (copied &gt; len) {
                copied = len;
                msg-&gt;msg_flags |= MSG_TRUNC;
        }

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Decide whether to checksum and/or copy data.</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         *      UDP:      checksum may have been computed in HW,</span>
<span style="color: #75715E;">         *                (re-)compute it if message is truncated.</span>
<span style="color: #75715E;">         *      UDP-Lite: always needs to checksum, no HW support.</span>
<span style="color: #75715E;">         */</span>
        copy_only = (skb-&gt;ip_summed==CHECKSUM_UNNECESSARY);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26681;&#25454;SKB&#30340;ip_summed &#21028;&#26029;UDP&#25968;&#25454;&#25253;&#26159;&#21542;&#38656;&#35201;&#25191;&#34892;&#26657;&#39564;&#21644;&#26816;&#27979;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (is_udplite  ||  (<span style="color: #E6DB74; font-weight: bold;">!</span>copy_only  &amp;&amp;  msg-&gt;msg_flags&amp;MSG_TRUNC)) {
                <span style="color: #F92672;">if</span> (__udp_lib_checksum_complete(skb))
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">csum_copy_err</span>;
                copy_only = 1;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#25968;&#25454;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;</span>
        <span style="color: #F92672;">if</span> (copy_only)
                err = skb_copy_datagram_iovec(skb, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>),
                                              msg-&gt;msg_iov, copied       );
        <span style="color: #F92672;">else</span> {
                err = skb_copy_and_csum_datagram_iovec(skb, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>), msg-&gt;msg_iov);

                <span style="color: #F92672;">if</span> (err == -EINVAL)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">csum_copy_err</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#22833;&#36133;&#65292;&#21017;&#37322;&#25918;</span>
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_free</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26356;&#26032;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#26368;&#21518;&#19968;&#20010;&#25968;&#25454;&#21253;&#25509;&#25910;&#30340;&#26102;&#38388;&#25139;&#12290;&#22914;&#26524;&#35774;&#32622;&#20102;SO_RECVTSTAMP&#36873;&#39033;&#65292;</span>
<span style="color: #75715E;">        &#21017;&#36824;&#38656;&#25226;&#25509;&#25910;&#26102;&#38388;&#25139;&#20316;&#20026;&#25511;&#21046;&#20449;&#24687;&#22797;&#21046;&#32473;&#29992;&#25143;&#36827;&#31243;&#12290;</span><span style="color: #75715E;">*/</span>
        sock_recv_timestamp(msg, sk, skb);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Copy the address.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (sin) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#22320;&#22336;&#31561;&#20449;&#24687;</span>
        {
                sin-&gt;sin_family = AF_INET;
                sin-&gt;sin_port = skb-&gt;h.uh-&gt;source;
                sin-&gt;sin_addr.s_addr = skb-&gt;nh.iph-&gt;saddr;
                memset(sin-&gt;sin_zero, 0, <span style="color: #F92672;">sizeof</span>(sin-&gt;sin_zero));
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26681;&#25454;&#25511;&#21046;&#20449;&#24687;&#26631;&#24535;&#20301;&#65288;&#36890;&#36807;&#22871;&#25509;&#21475;&#36873;&#39033;&#35774;&#32622;&#65289;&#65292;&#23558;&#30456;&#24212;&#30340;&#25511;&#21046;&#20449;&#24687;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#12290;</span>
<span style="color: #75715E;">        &#20363;&#22914;&#65292;&#35774;&#32622;&#20102;IP_TOS&#36873;&#39033;&#65292;&#21017;&#25226;IP&#39318;&#37096;&#20013;&#30340;TOS&#22495;&#22797;&#21046;&#21040;&#29992;&#25143;&#31354;&#38388;&#12290;&#36825;&#20010;&#36807;&#31243;&#30001;ip_cmsg_recv()&#23436;&#25104;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (inet-&gt;cmsg_flags)
                ip_cmsg_recv(msg, skb);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#22797;&#21046;&#30340;&#23383;&#33410;&#25968;</span>
        err = copied;
        <span style="color: #F92672;">if</span> (flags &amp; MSG_TRUNC) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#34987;&#25130;&#26029;&#65292;&#21017;&#36820;&#22238;&#21407;&#22987;&#30340;&#23454;&#38469;&#38271;&#24230;&#12290;</span>
                err = skb-&gt;len - <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>);

<span style="color: #AE81FF;">out_free</span>:
        skb_free_datagram(sk, skb);
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> err;

<span style="color: #AE81FF;">csum_copy_err</span>:  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;&#21644;&#22833;&#36133;&#26102;&#30340;&#22788;&#29702;</span>
        UDP_INC_STATS_BH(UDP_MIB_INERRORS, is_udplite);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#26597;&#30475;&#25968;&#25454;&#65292;&#21017;&#24517;&#39035;&#35843;&#29992;skb_kill_datagram&#23558;&#20854;&#21024;&#38500;&#24182;&#37322;&#25918;&#65292;</span>
        skb_kill_datagram(sk, skb, flags);

        <span style="color: #F92672;">if</span> (noblock) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;&#38459;&#22622;&#35835;&#21462;&#65292;&#21017;&#36820;&#22238;EAGAIN</span>
                <span style="color: #F92672;">return</span> -EAGAIN;
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">try_again</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38459;&#22622;&#65292;&#21017;&#32487;&#32493;&#33719;&#21462;&#19979;&#19968;&#20010;&#25968;&#25454;&#25253;</span>
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgd6930b7" class="outline-2">
<h2 id="orgd6930b7"><span class="section-number-2">16.</span> UDP的差错处理：udp_err()</h2>
<div class="outline-text-2" id="text-16">
<p>
udp_err()是UDP协议的差错处理函数。ICMP模块接收到差错报文后，如果传输层协议是UDP,则调用该函数处理。
</p>

<p>
如果错误码小于0,则应该先关闭连接然后将错误码返回给用户进程;如果大于零，则根据ICMP报文的类型和编码作相应的处理。
</p>

<p>
由于ICMP报文内容中负载了原始IP首部（包括选项）和原始IP数据报中的前8个字节，因此可以获取原始的UDP首部的前8个字节。根据UDP首部中的端口号和IP首部中的地址，可以得到发送引起错误报文的传输控制块，然后交给该传输控制块处理。
</p>

<div class="org-src-container">
<pre class="src src-c">__inline__ <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">udp_err</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">info</span>)
{
        <span style="color: #F92672;">return</span> __udp4_lib_err(skb, info, udp_hash);
}

<span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * This routine is called by the ICMP module when it gets some</span>
<span style="color: #75715E;"> * sort of error condition.  If err &lt; 0 then the socket should</span>
<span style="color: #75715E;"> * be closed and the error returned to the user.  If err &gt; 0</span>
<span style="color: #75715E;"> * it's just the icmp type &lt;&lt; 8 | icmp code.</span>
<span style="color: #75715E;"> * Header points to the ip header of the error packet. We move</span>
<span style="color: #75715E;"> * on past this. Then (as it used to claim before adjustment)</span>
<span style="color: #75715E;"> * header points to the first 8 bytes of the udp header.  We need</span>
<span style="color: #75715E;"> * to find the appropriate port.</span>
<span style="color: #75715E;"> */</span>

<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">__udp4_lib_err</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">info</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span> <span style="color: #FD971F;">udptable</span>[])
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>*)skb-&gt;data;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#21407;&#22987;UDP&#39318;&#37096;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span> *<span style="color: #FD971F;">uh</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>*)(skb-&gt;data+(iph-&gt;ihl&lt;&lt;2));
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">type</span> = skb-&gt;h.icmph-&gt;type;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">code</span> = skb-&gt;h.icmph-&gt;code;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">harderr</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;udp&#39318;&#37096;&#31471;&#21475;&#21495;&#21644;ip&#39318;&#37096;&#30340;&#22320;&#22336;&#65292;&#26597;&#25214;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        sk = __udp4_lib_lookup(iph-&gt;daddr, uh-&gt;dest, iph-&gt;saddr, uh-&gt;source,
                               skb-&gt;dev-&gt;ifindex, udptable                  );
        <span style="color: #F92672;">if</span> (sk == <span style="color: #AE81FF;">NULL</span>) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#33719;&#21462;&#21040;</span>
                ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
                <span style="color: #F92672;">return</span>; <span style="color: #75715E;">/* </span><span style="color: #75715E;">No socket for error</span><span style="color: #75715E;"> */</span>
        }

        err = 0;
        harderr = 0;
        inet = inet_sk(sk);

        <span style="color: #F92672;">switch</span> (type) {
        <span style="color: #F92672;">default</span>:
        <span style="color: #F92672;">case</span> ICMP_TIME_EXCEEDED: <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36229;&#26102;&#24046;&#38169;&#65292;&#21017;&#35774;&#32622;&#38169;&#35823;&#21527;&#65292;&#34920;&#31034;&#30001;&#20110;&#27809;&#26377;&#36335;&#30001;&#32780;&#23548;&#33268;&#30446;&#30340;&#19981;&#21487;&#36798;</span>
                err = EHOSTUNREACH;
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> ICMP_SOURCE_QUENCH:<span style="color: #75715E;">//</span><span style="color: #75715E;">&#28304;&#31471;&#34987;&#20851;&#38381;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">case</span> ICMP_PARAMETERPROB:<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21442;&#25968;&#38382;&#39064;&#38169;&#35823;</span>
                err = EPROTO;
                harderr = 1; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33268;&#21629;&#38169;&#35823;</span>
                <span style="color: #F92672;">break</span>;
        <span style="color: #F92672;">case</span> ICMP_DEST_UNREACH: <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30446;&#30340;&#19981;&#21487;&#36798;&#38169;&#35823;</span>
                <span style="color: #F92672;">if</span> (code == ICMP_FRAG_NEEDED) { <span style="color: #75715E;">/* </span><span style="color: #75715E;">Path MTU discovery</span><span style="color: #75715E;"> *///</span><span style="color: #75715E;">&#38656;&#35201;&#20998;&#29255;</span>
                        <span style="color: #F92672;">if</span> (inet-&gt;pmtudisc != IP_PMTUDISC_DONT) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#21551;&#29992;&#20998;&#29255;</span>
                                err = EMSGSIZE;
                                harderr = 1;
                                <span style="color: #F92672;">break</span>;
                        }
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
                }
                err = EHOSTUNREACH;
                <span style="color: #F92672;">if</span> (code &lt;= NR_ICMP_UNREACH) {
                        harderr = icmp_err_convert[code].fatal;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#20986;&#38169;&#30721;&#65292;&#33719;&#21462;&#29992;&#20110;&#35774;&#32622;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#38169;&#35823;&#30721;</span>
                        err = icmp_err_convert[code].errno;
                }
                <span style="color: #F92672;">break</span>;
        }

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      RFC1122: OK.  Passes ICMP errors back to application, as per</span>
<span style="color: #75715E;">         *      4.1.3.3.</span>
<span style="color: #75715E;">         *//*</span><span style="color: #75715E;">&#22914;&#26524;&#20256;&#36755;&#25511;&#21046;&#22359;&#20801;&#35768;&#25509;&#25910;&#25193;&#23637;&#30340;&#21487;&#38752;&#38169;&#35823;&#20449;&#24687;&#65292;&#21017;&#23558;&#38169;&#35823;&#20449;&#24687;&#32452;&#32455;&#21040;&#25253;&#25991;&#20013;&#65292;&#28982;&#21518;&#23558;&#20854;</span>
<span style="color: #75715E;">         &#25554;&#20837;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#20986;&#38169;&#38431;&#21015;sk_error_queue&#20013;&#65292;&#31561;&#24453;&#24212;&#29992;&#31243;&#24207;&#33719;&#21462;&#35814;&#32454;&#30340;&#20986;&#38169;&#20449;&#24687;&#12290;</span>
<span style="color: #75715E;">         &#21542;&#21017;&#65292;&#22914;&#26524;&#26159;&#33268;&#21629;&#38169;&#35823;&#65292;&#21017;&#35760;&#24405;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#24231;&#21518;&#19968;&#27425;&#20986;&#38169;&#30340;&#38169;&#35823;&#21527;&#65292;&#24182;&#36890;&#30693;&#31561;&#24453;&#35813;&#20256;&#36755;</span>
<span style="color: #75715E;">         &#25511;&#21046;&#22359;&#30340;&#36827;&#31243;&#65292;&#22914;&#26524;&#36827;&#31243;&#22312;&#30561;&#30496;&#65292;&#21017;&#23558;&#20854;&#21796;&#37266;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>inet-&gt;recverr) {
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>harderr || sk-&gt;sk_state != TCP_ESTABLISHED)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        } <span style="color: #F92672;">else</span> {
                ip_icmp_error(sk, skb, err, uh-&gt;dest, info, (<span style="color: #66D9EF;">u8</span>*)(uh+1));
        }
        sk-&gt;sk_err = err;
        sk-&gt;sk_error_report(sk);
<span style="color: #AE81FF;">out</span>:
        <span style="color: #A6E22E;">sock_put</span>(sk);
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org2db9e74" class="outline-2">
<h2 id="org2db9e74"><span class="section-number-2">17.</span> 轻量级UDP</h2>
<div class="outline-text-2" id="text-17">
<p>
2.6.20版本的Linux支持UDP-Lite。UDP-Lite协议相对比较新，与UDP协议类似，但更适应网络差错率较大而应用对轻微差错不敏感的情况，例如实时视频播放。
</p>

<p>
传统UDP协议对其负载（Payload）作完整的校验，如果其中哪怕一位发生了变化，那么整个数据包有可能被丢弃。某些情况下，丢弃这样的数据包代价很大。在UPD-Lite中，一个数据包到底需不需要对其负载进行校验，或者是校验多少位，都是有用户控制的，其Length字段用来表示Checksum Coverage,当该字段等于整个UDP数据包（包括UDP首部和数据）的长度时，UDP-Lite产生的包与传统的UDP一样。Linux对UDP-Lite的支持，也是通过在UDP协议的基础上，添加了一个setsockopt选项来实现控制发送/接收Checksum Coverage的：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">val</span> = 20;
<span style="color: #A6E22E;">setsockopt</span>(s, SOL_UDPLITE, UDPLITE_SEND_CSCOV, &amp;val, <span style="color: #F92672;">sizeof</span>(<span style="color: #66D9EF;">int</span>));
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">min</span> = 20;
<span style="color: #A6E22E;">setsockopt</span>(s, SOL_UDPLITE, UDPLITE_RECV_CSCOV, &amp;min, <span style="color: #F92672;">sizeof</span>(<span style="color: #66D9EF;">int</span>));
</pre>
</div>

<p>
创建一个轻量级UDP套接口：
</p>
<div class="org-src-container">
<pre class="src src-c">s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);
s = socket(PF_INET6, SOCK_DGRAM, IPPROTO_UDPLITE);
</pre>
</div>

<p>
Checksum Coverage的范围：
</p>
<ul class="org-ul">
<li>0  表示对整个UDP-Lite数据包进行校验</li>
<li>&gt;=8 表示对UDP-Lite数据包的前Checksum Coverage个字节进行校验</li>
<li>其他值非法</li>
</ul>

<p>
轻量级UDP和传统UDP只在校验和计算上有差别。为了区分不同的UDP,轻量级UDP增加了一个UDP私有控制块：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> *      struct udp_skb_cb  -  UDP(-Lite) private variables</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@header</span><span style="color: #E6DB74;">:      private variables used by IPv4/IPv6</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@cscov</span><span style="color: #E6DB74;">:       checksum coverage length (UDP-Lite only)</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@partial_cov</span><span style="color: #E6DB74;">: if set indicates partial csum coverage</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udp_skb_cb</span> {

        <span style="color: #E6DB74;">/** &#22312;UDP&#22788;&#29702;&#25910;&#21040;&#30340;UDP&#25968;&#25454;&#25253;&#20043;&#21069;&#65292;&#19979;&#23618;&#21327;&#35758;&#20250;&#20808;&#22788;&#29702;&#36825;&#20010;&#25968;&#25454;&#25253;&#65292;&#20182;&#20204;&#21033;&#29992;SKB&#20013;&#30340;</span>
<span style="color: #E6DB74;">        &#25511;&#21046;&#22359;&#35760;&#24405;&#27599;&#19968;&#20010;&#21253;&#20013;&#30340;&#20449;&#24687;&#65292;&#20363;&#22914;IPv4&#20174;IP&#39318;&#37096;&#35299;&#26512;&#20986;IP&#39318;&#37096;&#36873;&#39033;&#12290;&#20026;&#20102;&#19981;&#30772;&#22351;IPv4&#25110;IPv6</span>
<span style="color: #E6DB74;">        &#21327;&#35758;&#23618;&#30340;&#31169;&#26377;&#25968;&#25454;&#65292;&#22312;SKB&#20013;UDP&#31169;&#26377;&#25511;&#21046;&#22359;&#30340;&#21069;&#37096;&#23450;&#20041;&#20102;&#35813;&#32467;&#26500;&#12290;*/</span>
        <span style="color: #F92672;">union</span> {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_skb_parm</span>    <span style="color: #FD971F;">h4</span>;
<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span>(CONFIG_IPV6) || <span style="color: #F92672;">defined</span> (CONFIG_IPV6_MODULE)
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet6_skb_parm</span>   <span style="color: #FD971F;">h6</span>;
<span style="color: #F92672;">#endif</span>
        } <span style="color: #FD971F;">header</span>;
        <span style="color: #66D9EF;">__u16</span>           <span style="color: #FD971F;">cscov</span>;  <span style="color: #75715E;">// </span><span style="color: #75715E;">&#20026;0,&#25972;&#20010;UDP&#25968;&#25454;&#25253;&#25191;&#34892;&#26657;&#39564;&#21644;&#65292; &#25110;&#32773;&gt;=8&#65292;&#23545;&#21069;cscov&#20010;&#23383;&#33410;&#26657;&#39564;</span>
        <span style="color: #66D9EF;">__u8</span>            <span style="color: #FD971F;">partial_cov</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#34920;&#31034;&#25509;&#25910;&#21040;&#30340;&#26159;&#36731;&#37327;&#32423;UDP&#25968;&#25454;&#25253;&#12290;</span>
};
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:56</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
