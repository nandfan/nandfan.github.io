<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>IP: 网际协议</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">IP: 网际协议</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8470d3c">1. 引言</a>
<ul>
<li><a href="#orgc9ee6a4">1.1. IP数据报的输入与输出</a></li>
</ul>
</li>
<li><a href="#orge7840de">2. IP的私有信息控制块</a></li>
<li><a href="#org98bdee8">3. 系统参数</a></li>
<li><a href="#org65d1a18">4. 初始化 inet_init()</a></li>
<li><a href="#orgda8c948">5. IP层套接口选项</a></li>
<li><a href="#org692d55b">6. ipv4_devconf结构</a></li>
<li><a href="#org22fc9e4">7. 套接口的错误队列</a>
<ul>
<li><a href="#orgab6958e">7.1. 添加ICMP差错信息</a></li>
<li><a href="#orge3debd8">7.2. 添加由本地产生的差错信息</a></li>
<li><a href="#org86e6194">7.3. 读取错误信息</a></li>
</ul>
</li>
<li><a href="#orgde0d598">8. 报文控制信息</a>
<ul>
<li><a href="#orgd5c8ead">8.1. IP控制信息块</a></li>
<li><a href="#orgaaea66f">8.2. 报文控制信息的输出</a></li>
<li><a href="#org86f1330">8.3. 报文控制信息的输入</a></li>
</ul>
</li>
<li><a href="#org7eba827">9. 对端信息块</a>
<ul>
<li><a href="#org81d4491">9.1. 系统参数</a></li>
<li><a href="#orge62efc3">9.2. 对端信息块的创建和查找</a></li>
<li><a href="#org0a2c04a">9.3. 对端信息块的删除</a></li>
<li><a href="#org730ba54">9.4. 垃圾回收</a>
<ul>
<li><a href="#orgec2a444">9.4.1. 对端信息块的释放</a></li>
<li><a href="#org57592e7">9.4.2. 同步清理</a></li>
<li><a href="#orgf228225">9.4.3. 异步清理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7288208">10. IP数据包的输入处理</a>
<ul>
<li><a href="#org6628c56">10.1. ip_rcv()</a></li>
<li><a href="#org310f5b5">10.2. ip_rcv_finish()</a></li>
<li><a href="#orgd8a3ba0">10.3. IP数据报输入到本地</a>
<ul>
<li><a href="#orge67637a">10.3.1. ip_local_deliver()</a></li>
<li><a href="#org70347d0">10.3.2. ip_local_deliver_finish()</a></li>
</ul>
</li>
<li><a href="#orgec66667">10.4. IP数据报的转发</a></li>
</ul>
</li>
<li><a href="#orgab307d3">11. IP数据报的输入处理</a>
<ul>
<li><a href="#org57a9c6f">11.1. IP数据报输出到设备</a>
<ul>
<li><a href="#org5f9115e">11.1.1. dst_output()</a></li>
<li><a href="#org8ad72b1">11.1.2. ip_output()</a></li>
<li><a href="#org54041de">11.1.3. ip_finish_output()</a></li>
<li><a href="#orgf17d2ea">11.1.4. ip_finish_output2()</a></li>
</ul>
</li>
<li><a href="#org4c11bd2">11.2. TCP输出的相关接口</a>
<ul>
<li><a href="#org5f69cd5">11.2.1. ip_queue_xmit()</a></li>
<li><a href="#org183116a">11.2.2. ip_build_and_send_pkt()</a></li>
<li><a href="#orgec8b24c">11.2.3. ip_send_reply()</a></li>
</ul>
</li>
<li><a href="#orgf4b0246">11.3. UDP输出接口</a>
<ul>
<li><a href="#org0bc83e7">11.3.1. ip_append_data()</a></li>
<li><a href="#org8e055be">11.3.2. ip_ufo_append_data()</a></li>
<li><a href="#org93b436c">11.3.3. ip_push_pending_frames()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7d39745">12. IP层对GSO的支持</a>
<ul>
<li><a href="#orgc72c95f">12.1. inet_gso_segment()</a></li>
<li><a href="#orgbc54643">12.2. inet_gso_send_check()</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org8470d3c" class="outline-2">
<h2 id="org8470d3c"><span class="section-number-2">1.</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
IP是TCP/IP协议族中的最为核心的协议，TCP UDP ICMP 和 IGMP都是以IP数据报的形式传输。
</p>


<div id="orgd88e105" class="figure">
<p><img src="image/ip-proto/ipv4-proto.png" alt="ipv4-proto.png" />
</p>
<p><span class="figure-number">Figure 1: </span>IPv4协议族中不同层次的协议</p>
</div>
</div>

<div id="outline-container-orgc9ee6a4" class="outline-3">
<h3 id="orgc9ee6a4"><span class="section-number-3">1.1.</span> IP数据报的输入与输出</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在输入数据时，网络层提供输入接口给链路层，并调用传输层输入接口将数据传递到传输层。
</p>

<p>
输出数据时，网络层提供输出接口给传输层，并调用链路层输出接口将数据输出到链路层。
</p>

<p>
在输入输出过程中，都需要查找路由，进行netfilter处理，下图展示了IP层主要函数的调用关系：
</p>


<div id="org664a626" class="figure">
<p><img src="image/ip-proto/ip-layer-func.png" alt="ip-layer-func.png" />
</p>
<p><span class="figure-number">Figure 2: </span>IP层主要函数的调用关系</p>
</div>
</div>
</div>
</div>



<div id="outline-container-orge7840de" class="outline-2">
<h2 id="orge7840de"><span class="section-number-2">2.</span> IP的私有信息控制块</h2>
<div class="outline-text-2" id="text-2">
<p>
IP层在SKB中有个 inet_skb_param 结构的信息控制块 skb_buff-&gt;cb 。IP层通过宏 IPCB 访问该成员。这个信息块主要存储IP选项，以及IP处理中需要设置的标志。
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_skb_parm</span>
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span>       <span style="color: #FD971F;">opt</span>;            <span style="color: #75715E;">/* </span><span style="color: #75715E;">IP&#36873;&#39033;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span>           <span style="color: #FD971F;">flags</span>;

<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">IPSKB_FORWARDED</span>         1   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32452;&#25773;&#21253;&#24050;&#32463;&#36716;&#21457;&#36807;</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">IPSKB_XFRM_TUNNEL_SIZE</span>  2   <span style="color: #75715E;">//</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">IPSKB_XFRM_TRANSFORMED</span>  4   <span style="color: #75715E;">//</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">IPSKB_FRAG_COMPLETE</span>     8           <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23436;&#25104;&#20998;&#29255;</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">IPSKB_REROUTED</span>          16  <span style="color: #75715E;">//</span>
};

<span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">IPCB</span>(<span style="color: #FD971F;">skb</span>) ((<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_skb_parm</span>*)((skb)-&gt;cb))
</pre>
</div>
</div>
</div>


<div id="outline-container-org98bdee8" class="outline-2">
<h2 id="org98bdee8"><span class="section-number-2">3.</span> 系统参数</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>ip_default_ttl  IP数据报的默认生存时间。 可以通过IP_TTL设置数据报的生存时间。</li>

<li>ip_dynaddr</li>

<li>ip_forwarded 标识内核是否转发IP数据报</li>

<li>ip_local_port_range 在自动选择绑定端口时，TCP和UDP使用本地端口的范围。</li>

<li>ip_no_pmtu_disc 路径MTU</li>

<li>forwarding  标识网络设备是否启用ip数据报转发功能</li>

<li>mc_forwarding 是否启用组播路由功能</li>

<li>accept_redirects 是否接受ICMP重定向消息</li>

<li>rp_filter 标识是否对数据包的源地址进行检查</li>

<li>send_redirects 是否可以发送重定向消息</li>

<li>accept_source_route 是否接收存储在源路由选项的IP数据报</li>

<li>log_martians 遇到错误的IP地址时，是否记录到内核日志</li>

<li>disable_xfrm 是否禁止IPSEC加密</li>

<li>disable_policy 是否禁止IPSEC策略</li>

<li>promote_secondaries  在删除主地址时，第二IP地址是否能升级为主IP地址。</li>
</ul>
</div>
</div>


<div id="outline-container-org65d1a18" class="outline-2">
<h2 id="org65d1a18"><span class="section-number-2">4.</span> 初始化 inet_init()</h2>
</div>


<div id="outline-container-orgda8c948" class="outline-2">
<h2 id="orgda8c948"><span class="section-number-2">5.</span> IP层套接口选项</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>IP_OPTIONS 用来设置或者获取数据报的IP选项，最长40字节。可能的选项包括：

<ul class="org-ul">
<li>安全控制限制</li>
<li>记录路由</li>
<li>时间戳</li>
<li>松散源路由选择 访问路径中包含选项内列出的IP地址</li>
<li>严格源路由选择 只能访问选项内列出的IP地址</li>
</ul></li>

<li>IP_PKTINFO 控制是否允许通过IP_PKTOPTIONS选项或recvmsg系统调用来获取和本端地址相关的IP_PKTOPTIONS选项。</li>

<li>IP_RECVTTL 控制是否允许通过IP_PKTOPTIONS选项或recvmsg系统调用获取数据报的TTL</li>

<li>IP_RECVTOS 是否可以获取数据报的TOS</li>

<li>IP_RECVOPTS 是否可以获取IP数据包首部的IP选项</li>

<li>IP_RETOPTS 类似与IP_RECVOPTS, 不同的是获取为处理时间戳选项和记录路由选项的IP选项</li>

<li>IP_PASSSEC 是否可以获取有关安全的信息</li>

<li>IP_TOS 设置或者获取数据报的服务类型</li>

<li>IP_TTL 设置数据报的生存时间</li>

<li>IP_HDRINCL 为1时，发送函数会将IP首部作为数据的一部分包含在发送数据的前部，并使得接收函数也将IP首部作为数据的一部分</li>

<li>IP_MTU_DISCOVER 套接口是否启用路径MTU发现</li>

<li>IP_RECVERR 是否允许接收扩展的可靠错误信息，用户可通过设置了 MSG_ERRQUEUE 标识的 recvmsg() 来接收套接口操作中接收到的错误信息</li>

<li>IP_MTU 获取当前套接口的当前已知路径MTU。</li>

<li>IP_ROUTER_ALERT IP路由器警告选项</li>

<li>IP_PKTOPTIONS 设置了 IP_PKTINFO 或者 IP_RECVTTL 选项后，可通过此选项获取相关信息</li>

<li>IP_FREEBIND 用于标识是否允许绑定非本地主机地址</li>

<li>IP_IPSEC_POLICY 和 IP_XFRM_POLICY 用来设置IPSEC相关策略。</li>
</ul>
</div>
</div>


<div id="outline-container-org692d55b" class="outline-2">
<h2 id="org692d55b"><span class="section-number-2">6.</span> ipv4_devconf结构</h2>
<div class="outline-text-2" id="text-6">
<p>
ipv4_devconf结构是网络设备接口的IPv4系统配置。 内核定义了一个 ipv4_devconf 全局变量，用于所有接口的配置，同时，设备内部也存在自身的一份配置。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ipv4_devconf</span>
{
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">accept_redirects</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#25509;&#25910;ICMP&#37325;&#23450;&#21521;&#25253;&#25991;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">send_redirects</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#21551;&#29992;ICMP&#37325;&#23450;&#21521;&#25253;&#25991;&#36755;&#20986;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">secure_redirects</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#25509;&#25910;ICMP&#37325;&#23450;&#21521;&#25253;&#25991;&#65292;&#21482;&#38024;&#23545;&#20855;&#26377;&#36335;&#30001;&#21151;&#33021;&#30340;&#32593;&#20851;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">shared_media</span>;
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">accept_source_route</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#25509;&#25910;&#24102;&#26377;SRR&#36873;&#39033;&#30340;&#25968;&#25454;&#25253;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">rp_filter</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#21551;&#29992;&#36890;&#36807;&#21453;&#21521;&#36335;&#24452;&#22238;&#28335;&#36827;&#34892;&#28304;&#22320;&#22336;&#39564;&#35777;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">proxy_arp</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#21551;&#29992;ARP&#20195;&#29702;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">bootp_relay</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#25509;&#25910;&#28304;&#22320;&#22336;&#20026; 0.b.c.d &#19988;&#30446;&#30340;&#22320;&#22336;&#38750;&#26412;&#26426;&#30340;&#25968;&#25454;&#25253;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">log_martians</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#24040;&#40575;&#38750;&#27861;&#22320;&#22336;&#30340;&#25968;&#25454;&#25253;&#21040;&#20869;&#26680;&#26085;&#24535;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">forwarding</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#21551;&#29992;ip&#25968;&#25454;&#25253;&#36716;&#21457;&#21151;&#33021;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">mc_forwarding</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#36827;&#34892;&#32452;&#25773;&#36335;&#30001;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">tag</span>;
        <span style="color: #66D9EF;">int</span>   <span style="color: #FD971F;">arp_filter</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20801;&#35768;&#20174;&#20854;&#20182;&#30340;&#32593;&#32476;&#35774;&#22791;&#36755;&#20986;ARP&#24212;&#31572;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">arp_announce</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;ARP&#35831;&#27714;&#26102;&#65292;&#30001;IP&#25968;&#25454;&#25253;&#30830;&#23450;&#28304;IP&#22320;&#22336;&#30340;&#35268;&#21017;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">arp_ignore</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25509;&#25910;ARP&#35831;&#27714;&#25253;&#25991;&#30340;&#36807;&#28388;&#35268;&#21017;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">arp_accept</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#22788;&#29702;&#38750;ARP&#35831;&#27714;&#32780;&#25509;&#25910;&#30340;ARP&#24212;&#31572;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">medium_id</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#21306;&#20998;&#19981;&#21516;&#23186;&#20171;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">no_xfrm</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#21551;&#29992;XFRM</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">no_policy</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#21551;&#29992;&#31574;&#30053;&#36335;&#30001;</span>
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">force_igmp_version</span>;
        <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">promote_secondaries</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22312;&#21024;&#38500;&#20027;&#22320;&#22336;&#26102;&#65292;&#31532;&#20108;IP&#22320;&#22336;&#26159;&#21542;&#33021;&#21319;&#32423;&#20026;&#20027;IP&#22320;&#22336;</span>
        <span style="color: #66D9EF;">void</span>    *<span style="color: #FD971F;">sysctl</span>; <span style="color: #75715E;">//</span>
};
</pre>
</div>
</div>
</div>


<div id="outline-container-org22fc9e4" class="outline-2">
<h2 id="org22fc9e4"><span class="section-number-2">7.</span> 套接口的错误队列</h2>
<div class="outline-text-2" id="text-7">
<p>
传输控制块中有一个用于保存错误信息的队列 sk_err_queue，当ICMP接收到差错信息或者UDP RAW套接口输出报文错误时，会产生描述错误信息的SKB并添加到该队列。   应用程序可以通过设置 IP_RECVERR 选项，在通过设置了MSG_ERRQUEUE参数的flag，调用recvmsg系统调用来获取错误信息。
</p>


<p>
UDP和RAW套接口使用recvmsg从套接口接收数据时，通过设置MSG_ERRQUEUE标志，之接收错误队列的信息。 这个功能主要通过 ip_recv_error() 来完成。
</p>



<div id="orge718d84" class="figure">
<p><img src="dot/ip-proto/errqueue-func.png" alt="errqueue-func.png" />
</p>
</div>


<div id="orgb0e0ed0" class="figure">
<p><img src="image/ip-proto/sk-err-queue-func.png" alt="sk-err-queue-func.png" />
</p>
</div>


<p>
对于基于连接的套接口，IP_RECVERR选项具有不同含义，错误信息不会保存到错误队列，而是立即传递所有接收到的错误信息给用户进程。 因此TCP没有错误队列。
</p>


<p>
错误信息通过 struct sock_exterr_skb 结构来定义，保存在SKB控制块中，通过 SKB_EXT_ERR 宏来访问SKB控制块中的错误信息。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock_exterr_skb</span>
{
        <span style="color: #F92672;">union</span> {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_skb_parm</span>    <span style="color: #FD971F;">h4</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet6_skb_parm</span>   <span style="color: #FD971F;">h6</span>;
        } <span style="color: #FD971F;">header</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#19982;IP&#25511;&#21046;&#22359;&#20860;&#23481;&#65292;&#21487;&#20197;&#23384;&#20648;IP&#36873;&#39033;&#20449;&#24687;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock_extended_err</span>        <span style="color: #FD971F;">ee</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35760;&#24405;&#20986;&#38169;&#20449;&#24687;</span>
        <span style="color: #66D9EF;">u16</span>                             <span style="color: #FD971F;">addr_offset</span>;   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21407;&#22987;&#25968;&#25454;&#21253;&#30340;&#30446;&#30340;&#22320;&#22336;&#22312;&#36127;&#36733;ICMP&#25253;&#25991;&#30340;IP&#25968;&#25454;&#25253;&#20013;&#30340;&#20559;&#31227;&#37327;</span>
        <span style="color: #66D9EF;">__be16</span>                  <span style="color: #FD971F;">port</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23545;&#20110;UDP&#26159;&#20986;&#38169;&#25253;&#25991;&#30340;&#30446;&#30340;&#31471;&#21475;&#65292;&#20854;&#20182;&#24773;&#20917;&#20026;0</span>
};

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock_extended_err</span>
{
        <span style="color: #66D9EF;">__u32</span>   <span style="color: #FD971F;">ee_errno</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38169;&#35823;&#30721;</span>
        <span style="color: #66D9EF;">__u8</span>    <span style="color: #FD971F;">ee_origin</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20986;&#38169;&#20449;&#24687;&#30340;&#26469;&#28304;</span>
        <span style="color: #66D9EF;">__u8</span>    <span style="color: #FD971F;">ee_type</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26469;&#33258;ICMP&#28040;&#24687;&#26102;&#65292;&#34920;&#31034;ICMP&#24046;&#38169;&#28040;&#24687;&#30340;&#31867;&#22411;</span>
        <span style="color: #66D9EF;">__u8</span>    <span style="color: #FD971F;">ee_code</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26469;&#33258;ICMP&#28040;&#24687;&#26102;&#65292;&#34920;&#31034;ICMP&#24046;&#38169;&#28040;&#24687;&#30340;&#32534;&#30721;</span>
        <span style="color: #66D9EF;">__u8</span>    <span style="color: #FD971F;">ee_pad</span>;
        <span style="color: #66D9EF;">__u32</span>   <span style="color: #FD971F;">ee_info</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#25193;&#23637;&#20449;&#24687;</span>
        <span style="color: #66D9EF;">__u32</span>   <span style="color: #FD971F;">ee_data</span>;
};
</pre>
</div>
</div>

<div id="outline-container-orgab6958e" class="outline-3">
<h3 id="orgab6958e"><span class="section-number-3">7.1.</span> 添加ICMP差错信息</h3>
<div class="outline-text-3" id="text-7-1">
<p>
ICMP模块收到ICMP差错信息时，调用原始数据包的传输层协议的差错处理例程，传输层的差错处理例程再调用 ip_icmp_error() 将出错信息添加到对应的错误队列。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">ip_icmp_error</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>,
                   <span style="color: #66D9EF;">__be16</span> <span style="color: #FD971F;">port</span>, <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">info</span>, <span style="color: #66D9EF;">u8</span> *<span style="color: #FD971F;">payload</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock_exterr_skb</span> *<span style="color: #FD971F;">serr</span>;

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>inet-&gt;recverr)
                <span style="color: #F92672;">return</span>;
        skb = skb_clone(skb, GFP_ATOMIC);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb)
                <span style="color: #F92672;">return</span>;
        serr = SKB_EXT_ERR(skb);
        serr-&gt;ee.ee_errno = err;
        serr-&gt;ee.ee_origin = SO_EE_ORIGIN_ICMP; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20986;&#38169;&#20449;&#24687;&#26469;&#33258;ICMP&#28040;&#24687;</span>
        serr-&gt;ee.ee_type = skb-&gt;h.icmph-&gt;type;
        serr-&gt;ee.ee_code = skb-&gt;h.icmph-&gt;code;
        serr-&gt;ee.ee_pad = 0;
        serr-&gt;ee.ee_info = info;
        serr-&gt;ee.ee_data = 0;
        serr-&gt;addr_offset = (<span style="color: #66D9EF;">u8</span>*)&amp;(((<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>*)(skb-&gt;h.icmph+1))-&gt;daddr) - skb-&gt;nh.raw;
        serr-&gt;port = port;

        skb-&gt;h.raw = payload;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb_pull(skb, payload - skb-&gt;data) ||
            sock_queue_err_skb(sk, skb)) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28155;&#21152;&#21040;&#38169;&#35823;&#38431;&#21015;&#65292;&#24182;&#21796;&#37266;&#23545;&#24212;&#36827;&#31243;</span>
                kfree_skb(skb);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3debd8" class="outline-3">
<h3 id="orge3debd8"><span class="section-number-3">7.2.</span> 添加由本地产生的差错信息</h3>
<div class="outline-text-3" id="text-7-2">
<p>
UDP 或者 RAW 发送数据时，如果数据长度超过IP数据包能负载的长度，会调用ip_local_error() 将出错信息添加到对应的错误队列。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">ip_local_error</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>, <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span>, <span style="color: #66D9EF;">__be16</span> <span style="color: #FD971F;">port</span>, <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">info</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock_exterr_skb</span> *<span style="color: #FD971F;">serr</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>inet-&gt;recverr)
                <span style="color: #F92672;">return</span>;

        skb = alloc_skb(<span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>), GFP_ATOMIC);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb)
                <span style="color: #F92672;">return</span>;

        iph = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>*)skb_put(skb, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>));
        skb-&gt;nh.iph = iph;
        iph-&gt;daddr = daddr;

        serr = SKB_EXT_ERR(skb);
        serr-&gt;ee.ee_errno = err;
        serr-&gt;ee.ee_origin = SO_EE_ORIGIN_LOCAL; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26469;&#33258;&#26412;&#22320;</span>
        serr-&gt;ee.ee_type = 0;
        serr-&gt;ee.ee_code = 0;
        serr-&gt;ee.ee_pad = 0;
        serr-&gt;ee.ee_info = info;
        serr-&gt;ee.ee_data = 0;
        serr-&gt;addr_offset = (u8*)&amp;iph-&gt;daddr - skb-&gt;nh.raw;
        serr-&gt;port = port;

        skb-&gt;h.raw = skb-&gt;tail;
        __skb_pull(skb, skb-&gt;tail - skb-&gt;data);

        <span style="color: #F92672;">if</span> (sock_queue_err_skb(sk, skb)) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28155;&#21152;&#21040;&#38169;&#35823;&#38431;&#21015;&#65292;&#24182;&#21796;&#37266;&#23545;&#24212;&#36827;&#31243;</span>
                kfree_skb(skb);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org86e6194" class="outline-3">
<h3 id="org86e6194"><span class="section-number-3">7.3.</span> 读取错误信息</h3>
<div class="outline-text-3" id="text-7-3">
<p>
通过将flags设置为 MSG_ERRQUEUE，调用recvmsg()来读取传输控制块错误队列的信息。 UDP和RAW的recvmsg实现中，先检测是否存在MSG_ERRQUEUE标识，之后调用 ip_recv_error() 从错误队列读取错误信息。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_recvmsg</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *<span style="color: #FD971F;">iocb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">msg</span>,
                <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">len</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">noblock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">addr_len</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        <span style="color: #F92672;">if</span> (flags &amp; MSG_ERRQUEUE)
                <span style="color: #F92672;">return</span> ip_recv_error(sk, msg, len);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
}
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">raw_recvmsg</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *<span style="color: #FD971F;">iocb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">msg</span>,
                       <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">len</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">noblock</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">addr_len</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        <span style="color: #F92672;">if</span> (flags &amp; MSG_ERRQUEUE) {
                err = ip_recv_error(sk, msg, len);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        }
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_recv_error</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">msg</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock_exterr_skb</span> *<span style="color: #FD971F;">serr</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, *<span style="color: #FD971F;">skb2</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> *<span style="color: #FD971F;">sin</span>;
        <span style="color: #F92672;">struct</span> {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock_extended_err</span> <span style="color: #FD971F;">ee</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span>       <span style="color: #FD971F;">offender</span>;
        } <span style="color: #FD971F;">errhdr</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">copied</span>;

        err = -EAGAIN;
        skb = skb_dequeue(&amp;sk-&gt;sk_error_queue);
        <span style="color: #F92672;">if</span> (skb == <span style="color: #AE81FF;">NULL</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38431;&#21015;&#27809;&#26377;&#38169;&#35823;&#20449;&#24687;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        copied = skb-&gt;len; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27599;&#27425;&#33719;&#21462;&#25968;&#25454;&#25253;&#30340;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (copied &gt; len) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#36229;&#36807;&#32531;&#20914;&#21306;&#38271;&#24230;&#65292;&#28155;&#21152;MSG_TRUNC&#26631;&#35782;</span>
                msg-&gt;msg_flags |= MSG_TRUNC;
                copied = len;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#25968;&#25454;&#25253;&#30340;&#25968;&#25454;&#22797;&#21046;&#21040;&#32531;&#23384;&#20013;</span>
        err = skb_copy_datagram_iovec(skb, 0, msg-&gt;msg_iov, copied);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_free_skb</span>;
        sock_recv_timestamp(msg, sk, skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35760;&#24405;&#26102;&#38388;&#25139;</span>
        serr = SKB_EXT_ERR(skb);
        sin = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sockaddr_in</span> *)msg-&gt;msg_name;
        <span style="color: #F92672;">if</span> (sin) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#21407;&#22987;&#25968;&#25454;&#25253;&#30340;&#30446;&#30340;&#22320;&#22336;&#21644;&#30446;&#30340;&#31471;&#21475;</span>
                sin-&gt;sin_family = AF_INET;
                sin-&gt;sin_addr.s_addr = *(__be32*)(skb-&gt;nh.raw + serr-&gt;addr_offset);
                sin-&gt;sin_port = serr-&gt;port;
                memset(&amp;sin-&gt;sin_zero, 0, <span style="color: #F92672;">sizeof</span>(sin-&gt;sin_zero));
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#38169;&#35823;&#20449;&#24687;&#22359;&#30340;&#20869;&#23481;</span>
        memcpy(&amp;errhdr.ee, &amp;serr-&gt;ee, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock_extended_err</span>));
        sin = &amp;errhdr.offender;
        sin-&gt;sin_family = AF_UNSPEC;
        <span style="color: #F92672;">if</span> (serr-&gt;ee.ee_origin == SO_EE_ORIGIN_ICMP) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26469;&#33258;ICMP&#30340;&#24046;&#38169;&#28040;&#24687;</span>
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
                sin-&gt;sin_family = AF_INET;
                sin-&gt;sin_addr.s_addr = skb-&gt;nh.iph-&gt;saddr; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#28304;&#22320;&#22336;</span>
                sin-&gt;sin_port = 0;
                memset(&amp;sin-&gt;sin_zero, 0, <span style="color: #F92672;">sizeof</span>(sin-&gt;sin_zero));
                <span style="color: #F92672;">if</span> (inet-&gt;cmsg_flags)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#38656;&#35201;&#33719;&#21462;&#25253;&#25991;&#25511;&#21046;&#20449;&#24687;</span>
                        ip_cmsg_recv(msg, skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#25253;&#25991;&#25511;&#21046;&#20449;&#24687;&#21040;&#28040;&#24687;&#22836;</span>
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#38169;&#35823;&#20449;&#24687;&#30340;&#25193;&#23637;&#20449;&#24687;</span>
        put_cmsg(msg, SOL_IP, IP_RECVERR, <span style="color: #F92672;">sizeof</span>(errhdr), &amp;errhdr);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;MSG_ERRQUEUE&#26631;&#35782;&#65292;&#34920;&#31034;&#25509;&#25910;&#21040;&#30340;&#26159;&#20986;&#38169;&#20449;&#24687;</span>
        msg-&gt;msg_flags |= MSG_ERRQUEUE;
        err = copied;
        spin_lock_bh(&amp;sk-&gt;sk_error_queue.lock);
        sk-&gt;sk_err = 0;
        <span style="color: #F92672;">if</span> ((skb2 = skb_peek(&amp;sk-&gt;sk_error_queue)) != <span style="color: #AE81FF;">NULL</span>) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38431;&#21015;&#19981;&#20026;&#31354;&#65292;&#21796;&#37266;&#31561;&#24453;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#36827;&#31243;</span>
                sk-&gt;sk_err = SKB_EXT_ERR(skb2)-&gt;ee.ee_errno;
                spin_unlock_bh(&amp;sk-&gt;sk_error_queue.lock);
                sk-&gt;sk_error_report(sk);
        } <span style="color: #F92672;">else</span>
                spin_unlock_bh(&amp;sk-&gt;sk_error_queue.lock);
<span style="color: #AE81FF;">out_free_skb</span>:
        kfree_skb(skb);
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgde0d598" class="outline-2">
<h2 id="orgde0d598"><span class="section-number-2">8.</span> 报文控制信息</h2>
<div class="outline-text-2" id="text-8">
<p>
设置 IP_PKTINFO 选项的UDP或者RAW套接口，可以通过recvmsg函数在接收数据的同时，获取报文的控制信息。
</p>

<p>
UDP或者RAW在通过sendmsg函数输出数据时，可以将报文控制信息复制到输出数据的消息头，来发送控制信息。
</p>
</div>

<div id="outline-container-orgd5c8ead" class="outline-3">
<h3 id="orgd5c8ead"><span class="section-number-3">8.1.</span> IP控制信息块</h3>
<div class="outline-text-3" id="text-8-1">
<p>
IP控制信息块由ipcm_cookie结构来描述。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ipcm_cookie</span>
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">UDP&#25110;&#32773;RAW&#25968;&#25454;&#25253;&#30340;&#30446;&#30340;&#22320;&#22336;&#65292;&#21482;&#26377;&#23384;&#22312;IP&#36873;&#39033;&#26102;&#25165;&#35774;&#32622;&#65292;&#29992;&#20316;&#28304;&#36335;&#30001;&#36873;&#39033;&#30340;&#26368;&#21518;&#19968;&#36339;&#22320;&#22336;</span>
        <span style="color: #66D9EF;">__be32</span>          <span style="color: #FD971F;">addr</span>;
        <span style="color: #66D9EF;">int</span>                     <span style="color: #FD971F;">oif</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">UDP&#25110;&#32773;RAW&#25968;&#25454;&#25253;&#30340;&#36755;&#20986;&#32593;&#32476;&#35774;&#22791;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span>       *<span style="color: #FD971F;">opt</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#21521;&#21457;&#36865;&#25968;&#25454;&#25253;&#30340;IP&#36873;&#39033;&#20449;&#24687;</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaaea66f" class="outline-3">
<h3 id="orgaaea66f"><span class="section-number-3">8.2.</span> 报文控制信息的输出</h3>
<div class="outline-text-3" id="text-8-2">
<p>
UDP或者RAW通过sendmsg输出数据时，先检测是否存在控制信息，存在则调用ip_cmsg_send() 将控制信息获取到IP控制信息块中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">udp_sendmsg</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *<span style="color: #FD971F;">iocb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">msg</span>,
                <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">....</span>
        <span style="color: #F92672;">if</span> (msg-&gt;msg_controllen) {
                err = ip_cmsg_send(msg, &amp;ipc);
}
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">raw_sendmsg</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *<span style="color: #FD971F;">iocb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">msg</span>,
                       <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        <span style="color: #F92672;">if</span> (msg-&gt;msg_controllen) {
                err = ip_cmsg_send(msg, &amp;ipc);
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_cmsg_send</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">msg</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ipcm_cookie</span> *<span style="color: #FD971F;">ipc</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cmsghdr</span> *<span style="color: #FD971F;">cmsg</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36941;&#21382;&#28040;&#24687;&#22836;&#20013;&#30340;&#21508;&#31181;&#31867;&#22411;&#30340;&#25511;&#21046;&#20449;&#24687;</span>
        <span style="color: #F92672;">for</span> (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>CMSG_OK(msg, cmsg)) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;&#25511;&#21046;&#20449;&#24687;&#38271;&#24230;</span>
                        <span style="color: #F92672;">return</span> -EINVAL;
                <span style="color: #F92672;">if</span> (cmsg-&gt;cmsg_level != SOL_IP) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#25968;&#25454;&#25253;&#30340;&#25511;&#21046;&#20449;&#24687;&#65292;&#32423;&#21035;&#24517;&#39035;&#20026;SOL_IP</span>
                        <span style="color: #F92672;">continue</span>;
                <span style="color: #F92672;">switch</span> (cmsg-&gt;cmsg_type) {
                <span style="color: #F92672;">case</span> IP_RETOPTS: <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;IP&#36873;&#39033;</span>
                        err = cmsg-&gt;cmsg_len - CMSG_ALIGN(<span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cmsghdr</span>));
                        err = ip_options_get(&amp;ipc-&gt;opt, CMSG_DATA(cmsg), err &lt; 40 ? err : 40);
                        <span style="color: #F92672;">if</span> (err)
                                <span style="color: #F92672;">return</span> err;
                        <span style="color: #F92672;">break</span>;
                <span style="color: #F92672;">case</span> IP_PKTINFO:
                {
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">in_pktinfo</span> *<span style="color: #FD971F;">info</span>;
                        <span style="color: #F92672;">if</span> (cmsg-&gt;cmsg_len != CMSG_LEN(<span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">in_pktinfo</span>)))
                                <span style="color: #F92672;">return</span> -EINVAL;
                        info = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">in_pktinfo</span> *)CMSG_DATA(cmsg);
                        ipc-&gt;oif = info-&gt;ipi_ifindex;
                        ipc-&gt;addr = info-&gt;ipi_spec_dst.s_addr;
                        <span style="color: #F92672;">break</span>;
                }
                <span style="color: #F92672;">default</span>:
                        <span style="color: #F92672;">return</span> -EINVAL;
                }
        }
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org86f1330" class="outline-3">
<h3 id="org86f1330"><span class="section-number-3">8.3.</span> 报文控制信息的输入</h3>
<div class="outline-text-3" id="text-8-3">
<p>
UDP和RAW的套接口设置了IP_PKTINFO报文控制信息的选项后，在调用recvmsg时，会调用ip_cmsg_recv()获取报文的控制信息（正常数据和错误信息都会获取）。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">ip_cmsg_recv</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">msg</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(skb-&gt;sk);
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">flags</span> = inet-&gt;cmsg_flags;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20197;&#19979;&#39034;&#24207;&#25353;&#20351;&#29992;&#39057;&#29575;&#25490;&#24207;</span><span style="color: #75715E;"> */</span>

        <span style="color: #F92672;">if</span> (flags &amp; 1) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#20102;IP_CMSG_PKTINFO&#36873;&#39033;</span>
                ip_cmsg_recv_pktinfo(msg, skb);
        <span style="color: #F92672;">if</span> ((flags&gt;&gt;=1) == 0)
                <span style="color: #F92672;">return</span>;

        <span style="color: #F92672;">if</span> (flags &amp; 1) <span style="color: #75715E;">//</span><span style="color: #75715E;">ttl</span>
                ip_cmsg_recv_ttl(msg, skb);
        <span style="color: #F92672;">if</span> ((flags&gt;&gt;=1) == 0)
                <span style="color: #F92672;">return</span>;

        <span style="color: #F92672;">if</span> (flags &amp; 1) <span style="color: #75715E;">//</span><span style="color: #75715E;">tos</span>
                ip_cmsg_recv_tos(msg, skb);
        <span style="color: #F92672;">if</span> ((flags&gt;&gt;=1) == 0)
                <span style="color: #F92672;">return</span>;

        <span style="color: #F92672;">if</span> (flags &amp; 1) <span style="color: #75715E;">//</span><span style="color: #75715E;">IP_CMSG_RECVOPTS</span>
                ip_cmsg_recv_opts(msg, skb);
        <span style="color: #F92672;">if</span> ((flags&gt;&gt;=1) == 0)
                <span style="color: #F92672;">return</span>;

        <span style="color: #F92672;">if</span> (flags &amp; 1) <span style="color: #75715E;">//</span><span style="color: #75715E;">IP_CMSG_RETOPTS</span>
                ip_cmsg_recv_retopts(msg, skb);
        <span style="color: #F92672;">if</span> ((flags&gt;&gt;=1) == 0)
                <span style="color: #F92672;">return</span>;

        <span style="color: #F92672;">if</span> (flags &amp; 1) <span style="color: #75715E;">//</span><span style="color: #75715E;">IP_CMSG_PASSSEC</span>
                ip_cmsg_recv_security(msg, skb);
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org7eba827" class="outline-2">
<h2 id="org7eba827"><span class="section-number-2">9.</span> 对端信息块</h2>
<div class="outline-text-2" id="text-9">
<p>
对端信息块用来保存对端的一些信息，包括对端地址、传输层时间戳&#x2026;.. 通过 struct inet_peer 结构来描述。
</p>

<p>
对端信息块主要用于在组装IP数据报时防止IP分片攻击，在建立TCP连接时检测连接请求段是否有效，以及序号是否回绕。
</p>

<p>
对端信息块以v4daddr为关键字，peer_root为根，组织成AVL树。
</p>



<div id="org31c0384" class="figure">
<p><img src="dot/ip-proto/inet-peer.png" alt="inet-peer.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span>
{
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">avl_left,avl_right,v4daddr&#29992;&#20110;&#32452;&#25104;AVL&#26641;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span>        *<span style="color: #FD971F;">avl_left</span>, *<span style="color: #FD971F;">avl_right</span>;
        <span style="color: #66D9EF;">__be32</span>          <span style="color: #FD971F;">v4daddr</span>;        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#23545;&#31471;IP&#22320;&#22336;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">__u16</span>                   <span style="color: #FD971F;">avl_height</span>;
        <span style="color: #66D9EF;">__u16</span>                   <span style="color: #FD971F;">ip_id_count</span>;    <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#19979;&#19968;&#20010;IP&#20998;&#29255;&#25968;&#25454;&#25253;&#30340;id&#22495;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span>        *<span style="color: #FD971F;">unused_next</span>, **<span style="color: #FD971F;">unused_prevp</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#26469;&#36830;&#25509;&#21040;inet_peer_unused_head&#38142;&#34920;&#65292;&#35813;&#38142;&#34920;&#30340;&#23545;&#31471;&#20449;&#24687;&#22359;&#37117;&#26159;&#38386;&#32622;&#30340;&#65292;&#21487;&#20197;&#22238;&#25910;</span>
        <span style="color: #66D9EF;">__u32</span>                   <span style="color: #FD971F;">dtime</span>;          <span style="color: #75715E;">/* </span><span style="color: #75715E;">the time of last use of not</span>
<span style="color: #75715E;">                                                 * referenced entries</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">atomic_t</span>                <span style="color: #FD971F;">refcnt</span>;         <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24341;&#29992;&#35745;&#25968;</span>
        <span style="color: #66D9EF;">atomic_t</span>                <span style="color: #FD971F;">rid</span>;            <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#23545;&#31471;&#21457;&#36865;&#20998;&#29255;&#30340;&#35745;&#25968;&#22120;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">__u32</span>                   <span style="color: #FD971F;">tcp_ts</span>;         <span style="color: #75715E;">//</span><span style="color: #75715E;">TCP&#20013;&#26368;&#21518;&#19968;&#20010;ACK&#27573;&#21040;&#36798;&#30340;&#26102;&#38388;</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>           <span style="color: #FD971F;">tcp_ts_stamp</span>;   <span style="color: #75715E;">//</span><span style="color: #75715E;">TCP&#20013;&#35760;&#24405;&#25910;&#21040;&#27573;&#20013;&#30340;&#26102;&#38388;&#25139;</span>
};
</pre>
</div>
</div>

<div id="outline-container-org81d4491" class="outline-3">
<h3 id="org81d4491"><span class="section-number-3">9.1.</span> 系统参数</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>inet_peer_gc_maxtime 垃圾回收的最大时间间隔。</li>

<li>inet_peer_gc_mintime 垃圾回收最小时间间隔</li>

<li>inet_peer_maxttl 对端信息块的最长生存周期</li>

<li>inet_peer_minttl 对端信息块的最短生存周期</li>

<li>inet_peer_threshold 用于计算垃圾回收最大时间间隔以及生存期的阈值</li>
</ul>
</div>
</div>

<div id="outline-container-orge62efc3" class="outline-3">
<h3 id="orge62efc3"><span class="section-number-3">9.2.</span> 对端信息块的创建和查找</h3>
<div class="outline-text-3" id="text-9-2">
<p>
inet_getpeer()函数用来实现创建和查找操作。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span> *<span style="color: #A6E22E;">inet_getpeer</span>(<span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">create</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span> *<span style="color: #FD971F;">p</span>, *<span style="color: #FD971F;">n</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span> **<span style="color: #FD971F;">stack</span>[PEER_MAXDEPTH], ***<span style="color: #FD971F;">stackptr</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20174;AVL&#26641;&#26597;&#25214;</span><span style="color: #75715E;"> */</span>
        read_lock_bh(&amp;peer_pool_lock);
        p = lookup(daddr);
        <span style="color: #F92672;">if</span> (p != peer_avl_empty)
                atomic_inc(&amp;p-&gt;refcnt);
        read_unlock_bh(&amp;peer_pool_lock);

        <span style="color: #F92672;">if</span> (p != peer_avl_empty) {  <span style="color: #75715E;">//</span><span style="color: #75715E;">AVL&#26641;&#20013;&#23384;&#22312;&#23545;&#31471;&#20449;&#24687;&#22359;</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20174;&#26410;&#20351;&#29992;&#38142;&#34920;&#20013;&#31227;&#38500;&#35813;&#23545;&#31471;&#20449;&#24687;&#22359;</span><span style="color: #75715E;">*/</span>
                unlink_from_unused(p);
                <span style="color: #F92672;">return</span> p;
        }

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>create) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#25351;&#23450;&#21019;&#24314;&#26631;&#24535;</span>
                <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20998;&#37197;&#31354;&#38388;</span><span style="color: #75715E;"> */</span>
        n = kmem_cache_alloc(peer_cachep, GFP_ATOMIC);
        n-&gt;v4daddr = daddr;
        atomic_set(&amp;n-&gt;refcnt, 1);
        atomic_set(&amp;n-&gt;rid, 0);
        n-&gt;ip_id_count = secure_ip_id(daddr);
        n-&gt;tcp_ts_stamp = 0;

        write_lock_bh(&amp;peer_pool_lock);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#33719;&#21462;&#32034;&#21518;&#20877;&#27425;&#26816;&#26597;&#26159;&#21542;&#24050;&#32463;&#28155;&#21152;&#21516;&#26679;&#30340;&#23545;&#31471;&#20449;&#24687;&#22359;</span><span style="color: #75715E;"> */</span>
        p = lookup(daddr);
        <span style="color: #F92672;">if</span> (p != peer_avl_empty) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24050;&#32463;&#23384;&#22312;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_free</span>;
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#28155;&#21152;&#21040;AVL&#26641;</span><span style="color: #75715E;">*/</span>
        link_to_pool(n);
        n-&gt;unused_prevp = <span style="color: #AE81FF;">NULL</span>; <span style="color: #75715E;">/* </span><span style="color: #75715E;">not on the list</span><span style="color: #75715E;"> */</span>
        peer_total++;
        write_unlock_bh(&amp;peer_pool_lock);

        <span style="color: #F92672;">if</span> (peer_total &gt;= inet_peer_threshold) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#36229;&#36807;&#38408;&#20540;</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#37322;&#25918; inet_peer_unused_head &#38431;&#39318;&#30340;&#23545;&#31471;&#20449;&#24687;&#22359;</span><span style="color: #75715E;"> */</span>
                cleanup_once(0);
        <span style="color: #F92672;">return</span> n;
<span style="color: #AE81FF;">out_free</span>:
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">The appropriate node is already in the pool.</span><span style="color: #75715E;"> */</span>
        atomic_inc(&amp;p-&gt;refcnt);
        write_unlock_bh(&amp;peer_pool_lock);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Remove the entry from unused list if it was there.</span><span style="color: #75715E;"> */</span>
        unlink_from_unused(p);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Free preallocated the preallocated node.</span><span style="color: #75715E;"> */</span>
        kmem_cache_free(peer_cachep, n);
        <span style="color: #F92672;">return</span> p;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0a2c04a" class="outline-3">
<h3 id="org0a2c04a"><span class="section-number-3">9.3.</span> 对端信息块的删除</h3>
<div class="outline-text-3" id="text-9-3">
<p>
inet_putpeer()函数用来将对端信息块添加到 inet_peer_unused_head 队列。真正的释放操作，通过垃圾回收机制来处理
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">inet_putpeer</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span> *<span style="color: #FD971F;">p</span>)
{
        spin_lock_bh(&amp;inet_peer_unused_lock);
        <span style="color: #F92672;">if</span> (atomic_dec_and_test(&amp;p-&gt;refcnt)) {
                p-&gt;unused_prevp = inet_peer_unused_tailp;
                p-&gt;unused_next = <span style="color: #AE81FF;">NULL</span>;
                *inet_peer_unused_tailp = p;
                inet_peer_unused_tailp = &amp;p-&gt;unused_next;
                p-&gt;dtime = (<span style="color: #66D9EF;">__u32</span>)jiffies;
        }
        spin_unlock_bh(&amp;inet_peer_unused_lock);
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org730ba54" class="outline-3">
<h3 id="org730ba54"><span class="section-number-3">9.4.</span> 垃圾回收</h3>
<div class="outline-text-3" id="text-9-4">
<p>
垃圾回收方式有两种，同步和异步。
</p>

<p>
同步： 创建时发现当前对端信息块总数达到阈值（inet_peer_threshold）触发回收。
异步： 定时器触发。
</p>
</div>

<div id="outline-container-orgec2a444" class="outline-4">
<h4 id="orgec2a444"><span class="section-number-4">9.4.1.</span> 对端信息块的释放</h4>
<div class="outline-text-4" id="text-9-4-1">
<p>
对端信息块闲置时，会被加入 inet_peer_threshold 队列，并记录闲置时间，在清理时，如果时间达到阈值，则过期。使用中的对端信息块不会过期。
</p>

<p>
cleanup_once()用来检测 inet_peer_threshold 队列的第一个闲置对端信息块是否过期，过期则将其释放。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">cleanup_once</span>(<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">ttl</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">ttl&#34920;&#31034;&#36807;&#26399;&#38408;&#20540;</span>
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span> *<span style="color: #FD971F;">p</span>;
        spin_lock_bh(&amp;inet_peer_unused_lock);
        p = inet_peer_unused_head;
        <span style="color: #F92672;">if</span> (p != <span style="color: #AE81FF;">NULL</span>) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38431;&#21015;&#19981;&#20026;&#31354;</span>
                <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">delta</span> = (<span style="color: #66D9EF;">__u32</span>)jiffies - p-&gt;dtime;
                <span style="color: #F92672;">if</span> (delta &lt; ttl) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#36807;&#26399;</span>
                        spin_unlock_bh(&amp;inet_peer_unused_lock);
                        <span style="color: #F92672;">return</span> -1;
                }
                inet_peer_unused_head = p-&gt;unused_next;
                <span style="color: #F92672;">if</span> (p-&gt;unused_next != <span style="color: #AE81FF;">NULL</span>)
                        p-&gt;unused_next-&gt;unused_prevp = p-&gt;unused_prevp;
                <span style="color: #F92672;">else</span>
                        inet_peer_unused_tailp = p-&gt;unused_prevp;
                p-&gt;unused_prevp = <span style="color: #AE81FF;">NULL</span>;
                atomic_inc(&amp;p-&gt;refcnt);
        }
        spin_unlock_bh(&amp;inet_peer_unused_lock);
        <span style="color: #F92672;">if</span> (p == <span style="color: #AE81FF;">NULL</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#21487;&#20197;&#37322;&#25918;&#30340;&#23545;&#31471;&#20449;&#24687;&#22359;</span>
                <span style="color: #F92672;">return</span> -1;
        unlink_from_pool(p); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;AVL&#26641;&#21024;&#38500;&#24182;&#37322;&#25918;</span>
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org57592e7" class="outline-4">
<h4 id="org57592e7"><span class="section-number-4">9.4.2.</span> 同步清理</h4>
<div class="outline-text-4" id="text-9-4-2">
<p>
创建时，如果对端信息块达到阈值，则调用cleanup_once()清理，参数ttl设置为0，表示必须释放一个。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_peer</span> *<span style="color: #A6E22E;">inet_getpeer</span>(<span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">create</span>)
{
        <span style="color: #F92672;">if</span> (peer_total &gt;= inet_peer_threshold)
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21442;&#25968;0 &#34920;&#31034;&#24517;&#39035;&#37322;&#25918;&#19968;&#20010;</span><span style="color: #75715E;">*/</span>
                cleanup_once(0);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf228225" class="outline-4">
<h4 id="orgf228225"><span class="section-number-4">9.4.3.</span> 异步清理</h4>
<div class="outline-text-4" id="text-9-4-3">
<p>
通过peer_periodic_timer定时器进行周期性的垃圾回收，该定时器处理例程为 peer_check_expire()。
</p>

<p>
peer_periodic_timer 定时器的初始间隔在 inet_initpeers 函数中设置，后续则动态计算。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #A6E22E;">DEFINE_TIMER</span>(peer_periodic_timer, peer_check_expire, 0, 0);

<span style="color: #75715E;">/* </span><span style="color: #75715E;">Called with local BH disabled.</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">peer_check_expire</span>(<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">dummy</span>)
{
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">now</span> = jiffies;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ttl</span>;

        <span style="color: #F92672;">if</span> (peer_total &gt;= inet_peer_threshold)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36229;&#20986;&#38408;&#20540;</span>
                ttl = inet_peer_minttl; <span style="color: #75715E;">//</span><span style="color: #75715E;">ttl&#20351;&#29992;&#26368;&#23567;&#29983;&#23384;&#26399;</span>
        <span style="color: #F92672;">else</span>
                ttl = inet_peer_maxttl
                                - (inet_peer_maxttl - inet_peer_minttl) / HZ *
                                        peer_total / inet_peer_threshold * HZ;
        <span style="color: #F92672;">while</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>cleanup_once(ttl)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24490;&#29615;&#26816;&#27979;&#28165;&#29702;</span>
                <span style="color: #F92672;">if</span> (jiffies != now)
                        <span style="color: #F92672;">break</span>;
        }

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#23450;&#26102;&#22120;&#30340;&#19979;&#27425;&#28608;&#27963;&#26102;&#38388;</span>
        <span style="color: #F92672;">if</span> (peer_total &gt;= inet_peer_threshold)
                peer_periodic_timer.expires = jiffies + inet_peer_gc_mintime;
        <span style="color: #F92672;">else</span>
                peer_periodic_timer.expires = jiffies
                        + inet_peer_gc_maxtime
                        - (inet_peer_gc_maxtime - inet_peer_gc_mintime) / HZ *
                                peer_total / inet_peer_threshold * HZ;
        add_timer(&amp;peer_periodic_timer); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28155;&#21152;&#23450;&#26102;&#22120;&#12290;</span>
}
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org7288208" class="outline-2">
<h2 id="org7288208"><span class="section-number-2">10.</span> IP数据包的输入处理</h2>
<div class="outline-text-2" id="text-10">
<p>
ip数据包的接收例程定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">packet_type</span> <span style="color: #FD971F;">ip_packet_type</span> = {
        .type = __constant_htons(ETH_P_IP),
        .func = ip_rcv,
        .gso_send_check = inet_gso_send_check,
        .gso_segment = inet_gso_segment,
};
</pre>
</div>

<p>
网络初始化时，通过 dev_add_pack() 注册到 ptype_base 散列表。
</p>

<p>
ip_rcv() 处理完成后经过 PRE-ROUTING 的netfilter后， 交给ip_rcv_finish()处理， ip_rcv_finish()中根据路由信息，决定是转发（ip_forward()），还是输入到本机（ip_local_deliver()）。
</p>
</div>

<div id="outline-container-org6628c56" class="outline-3">
<h3 id="org6628c56"><span class="section-number-3">10.1.</span> ip_rcv()</h3>
<div class="outline-text-3" id="text-10-1">
<p>
网络设备接收到报文时，根据协议号从ptype_base散列表中查找对应的接收例程。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_rcv</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">dev</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">packet_type</span> *<span style="color: #FD971F;">pt</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">orig_dev</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>;
        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">len</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20002;&#24323;&#21435;&#24448;&#20854;&#20182;&#20027;&#26426;&#30340;&#25968;&#25454;&#25253;</span>
        <span style="color: #F92672;">if</span> (skb-&gt;pkt_type == PACKET_OTHERHOST)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;

        IP_INC_STATS_BH(IPSTATS_MIB_INRECEIVES);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#20849;&#20139;&#25968;&#25454;&#25253;&#65292;&#21017;&#38656;&#35201;&#22797;&#21046;&#19968;&#20010;</span>
        <span style="color: #F92672;">if</span> ((skb = skb_share_check(skb, GFP_ATOMIC)) == <span style="color: #AE81FF;">NULL</span>) {
                IP_INC_STATS_BH(IPSTATS_MIB_INDISCARDS);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;&#25968;&#25454;&#25253;&#38271;&#24230;&#19981;&#33021;&#23567;&#20110;IP&#39318;&#37096;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_may_pull(skb, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>)))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">inhdr_error</span>;
        iph = skb-&gt;nh.iph; <span style="color: #75715E;">//</span><span style="color: #75715E;">IP header</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;IP&#39318;&#37096;&#38271;&#24230;&#21644;&#29256;&#26412;</span>
        <span style="color: #F92672;">if</span> (iph-&gt;ihl &lt; 5 || iph-&gt;version != 4)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">inhdr_error</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#39318;&#37096;&#25658;&#24102;&#30340;&#38271;&#24230;&#26816;&#27979;ip&#25968;&#25454;&#25253;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_may_pull(skb, iph-&gt;ihl*4))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">inhdr_error</span>;
        iph = skb-&gt;nh.iph;
        <span style="color: #F92672;">if</span> (unlikely(ip_fast_csum((<span style="color: #66D9EF;">u8</span> *)iph, iph-&gt;ihl)))<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;&#26657;&#39564;&#21644;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">inhdr_error</span>;
        len = ntohs(iph-&gt;tot_len);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;ip&#25968;&#25454;&#25253;&#24635;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (skb-&gt;len &lt; len || len &lt; (iph-&gt;ihl*4))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">inhdr_error</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;IP&#39318;&#37096;&#20013;&#30340;&#25968;&#25454;&#24635;&#38271;&#24230;&#35774;&#32622;SKB&#30340;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (pskb_trim_rcsum(skb, len)) {
                IP_INC_STATS_BH(IPSTATS_MIB_INDISCARDS);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#28165;&#31354;SKB&#30340;ip&#25511;&#21046;&#22359;</span><span style="color: #75715E;"> */</span>
        memset(IPCB(skb), 0, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_skb_parm</span>));
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;NF_IP_PRE_ROUTING netfilter&#65292;&#20043;&#21518;&#36890;&#36807;ip_rcv_finish()&#23436;&#25104;&#36755;&#20837;</span>
        <span style="color: #F92672;">return</span> NF_HOOK(PF_INET, NF_IP_PRE_ROUTING, skb, dev, <span style="color: #AE81FF;">NULL</span>,
                       ip_rcv_finish);
<span style="color: #AE81FF;">inhdr_error</span>:
        IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
<span style="color: #AE81FF;">drop</span>:
        kfree_skb(skb);
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> NET_RX_DROP;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org310f5b5" class="outline-3">
<h3 id="org310f5b5"><span class="section-number-3">10.2.</span> ip_rcv_finish()</h3>
<div class="outline-text-3" id="text-10-2">
<p>
ip_rcv()结束时，经过neifilter处理后，调用ip_rcv_finish()。
</p>

<p>
ip_rcv_finish() 主要是调用 ip_route_input() 查找输入路由缓存，接着处理IP数据报首部的选项，最后根据路由缓存输入本地或者转发。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_rcv_finish</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span> = skb-&gt;nh.iph;
        <span style="color: #F92672;">if</span> (skb-&gt;dst == <span style="color: #AE81FF;">NULL</span>) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36824;&#27809;&#26377;&#36335;&#30001;&#32531;&#23384;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#25214;&#36335;&#30001;&#32531;&#23384;</span>
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span> = ip_route_input(skb, iph-&gt;daddr, iph-&gt;saddr, iph-&gt;tos, skb-&gt;dev);
                <span style="color: #F92672;">if</span> (unlikely(err)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#25214;&#22833;&#36133;&#65292;&#21017;&#20002;&#24323;</span>
                        <span style="color: #F92672;">if</span> (err == -EHOSTUNREACH)
                                IP_INC_STATS_BH(IPSTATS_MIB_INADDRERRORS);
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
                }
        }

<span style="color: #F92672;">#ifdef</span> CONFIG_NET_CLS_ROUTE <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36335;&#30001;&#34920;&#30340;classifier&#26631;&#31614;&#30456;&#20851;</span>
        <span style="color: #F92672;">if</span> (unlikely(skb-&gt;dst-&gt;tclassid)) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_rt_acct</span> *<span style="color: #FD971F;">st</span> = ip_rt_acct + 256*smp_processor_id();
                <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">idx</span> = skb-&gt;dst-&gt;tclassid;
                st[idx&amp;0xFF].o_packets++;
                st[idx&amp;0xFF].o_bytes+=skb-&gt;len;
                st[(idx&gt;&gt;16)&amp;0xFF].i_packets++;
                st[(idx&gt;&gt;16)&amp;0xFF].i_bytes+=skb-&gt;len;
        }
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21028;&#26029;&#26159;&#21542;&#23384;&#22312;ip&#36873;&#39033;&#65292;&#24182;&#35843;&#29992;ip_rcv_options&#22788;&#29702;&#36873;&#39033;</span>
        <span style="color: #F92672;">if</span> (iph-&gt;ihl &gt; 5 &amp;&amp; ip_rcv_options(skb))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
        <span style="color: #F92672;">return</span> dst_input(skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#36755;&#20837;&#26412;&#22320;&#65292;&#21017;&#35843;&#29992;ip_local_deliver()&#65292;&#36716;&#21457;&#21017;&#35843;&#29992;ip_forward()</span>
<span style="color: #AE81FF;">drop</span>:
        kfree_skb(skb);
        <span style="color: #F92672;">return</span> NET_RX_DROP;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd8a3ba0" class="outline-3">
<h3 id="orgd8a3ba0"><span class="section-number-3">10.3.</span> IP数据报输入到本地</h3>
<div class="outline-text-3" id="text-10-3">
</div>
<div id="outline-container-orge67637a" class="outline-4">
<h4 id="orge67637a"><span class="section-number-4">10.3.1.</span> ip_local_deliver()</h4>
<div class="outline-text-4" id="text-10-3-1">
<p>
此函数处理输入到本地的数据报。
</p>
<ul class="org-ul">
<li>如果是分片，则分片重组</li>
<li>非分片，或者重组完成，则调用NF_IP_LOCAL_IN netfilter，之后通过ip_local_deliver_finish() 完成到本地的输入。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Deliver IP Packets to the higher protocol layers.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_local_deliver</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#39318;&#20808;&#20915;&#23450;&#26159;&#21542;&#38656;&#35201;&#20998;&#29255;&#37325;&#32452;</span>
        <span style="color: #F92672;">if</span> (skb-&gt;nh.iph-&gt;frag_off &amp; htons(IP_MF|IP_OFFSET)) {
                skb = ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER);
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36824;&#26410;&#37325;&#32452;&#23436;&#25104;</span>
                        <span style="color: #F92672;">return</span> 0;
        }
        <span style="color: #F92672;">return</span> NF_HOOK(PF_INET, NF_IP_LOCAL_IN, skb, skb-&gt;dev, <span style="color: #AE81FF;">NULL</span>,
                       ip_local_deliver_finish);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org70347d0" class="outline-4">
<h4 id="org70347d0"><span class="section-number-4">10.3.2.</span> ip_local_deliver_finish()</h4>
<div class="outline-text-4" id="text-10-3-2">
<p>
此函数将数据报从网络层传递到传输层。
</p>
<ul class="org-ul">
<li>首先去掉IP首部。</li>
<li>如果有对应RAW套接口，则需复制一份数据报输入到该套接口。</li>
<li>调用传输层接收例程，将数据报交给传输层处理。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_local_deliver_finish</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ihl</span> = skb-&gt;nh.iph-&gt;ihl*4;
        __skb_pull(skb, ihl);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21435;&#38500;IP&#39318;&#37096;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Point into the IP datagram, just past the header.</span><span style="color: #75715E;"> */</span>
        skb-&gt;h.raw = skb-&gt;data;
        rcu_read_lock();
        {
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">protocol</span> = skb-&gt;nh.iph-&gt;protocol; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;&#23618;&#21327;&#35758;</span>
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hash</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">raw_sk</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_protocol</span> *<span style="color: #FD971F;">ipprot</span>;

        <span style="color: #AE81FF;">resubmit</span>:
                hash = protocol &amp; (MAX_INET_PROTOS - 1); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;hash&#20540;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#39318;&#20808;&#26597;&#25214;raw_v4_htable&#65292;&#20915;&#23450;&#26159;&#21542;&#38656;&#35201;&#36755;&#20837;&#21040;raw&#22871;&#25509;&#21475;</span>
                raw_sk = sk_head(&amp;raw_v4_htable[hash]);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#25214;&#21040;raw&#22871;&#25509;&#21475;&#65292;&#21017;&#36755;&#20837;&#21040;raw</span>
                <span style="color: #F92672;">if</span> (raw_sk &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>raw_v4_input(skb, skb-&gt;nh.iph, hash))
                        raw_sk = <span style="color: #AE81FF;">NULL</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#25214; inet_protos&#25968;&#32452;&#65292;&#33719;&#21462;&#30456;&#20851;&#20256;&#36755;&#23618;&#21327;&#35758;&#25509;&#25910;&#20363;&#31243;</span>
                <span style="color: #F92672;">if</span> ((ipprot = rcu_dereference(inet_protos[hash])) != <span style="color: #AE81FF;">NULL</span>) {
                        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ret</span>;
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>ipprot-&gt;no_policy) {
                                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>xfrm4_policy_check(<span style="color: #AE81FF;">NULL</span>, XFRM_POLICY_IN, skb)) {
                                        kfree_skb(skb);
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
                                }
                                nf_reset(skb);
                        }
                        ret = ipprot-&gt;handler(skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20837;&#21040;&#20256;&#36755;&#23618;</span>
                        <span style="color: #F92672;">if</span> (ret &lt; 0) {
                                protocol = -ret;
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">resubmit</span>;
                        }
                        IP_INC_STATS_BH(IPSTATS_MIB_INDELIVERS);
                } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26410;&#25214;&#21040;&#65292;&#21017;&#38656;&#35201;&#21457;&#36865;icmp &#30446;&#30340;&#19981;&#21487;&#36798;&#25253;&#25991;</span>
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>raw_sk) {
                                <span style="color: #F92672;">if</span> (xfrm4_policy_check(<span style="color: #AE81FF;">NULL</span>, XFRM_POLICY_IN, skb)) {
                                        IP_INC_STATS_BH(IPSTATS_MIB_INUNKNOWNPROTOS);
                                        icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PROT_UNREACH, 0);
                                }
                        } <span style="color: #F92672;">else</span>
                                IP_INC_STATS_BH(IPSTATS_MIB_INDELIVERS);
                        kfree_skb(skb);
                }
        }
 <span style="color: #AE81FF;">out</span>:
        rcu_read_unlock();
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgec66667" class="outline-3">
<h3 id="orgec66667"><span class="section-number-3">10.4.</span> IP数据报的转发</h3>
<div class="outline-text-3" id="text-10-4">

<div id="org22e10a0" class="figure">
<p><img src="image/ip-proto/ip-forward.png" alt="ip-forward.png" />
</p>
<p><span class="figure-number">Figure 3: </span>ip_forward()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_forward</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>;      <span style="color: #75715E;">/* </span><span style="color: #75715E;">Our header</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span>;      <span style="color: #75715E;">/* </span><span style="color: #75715E;">Route we use</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span> * <span style="color: #FD971F;">opt</span> = &amp;(IPCB(skb)-&gt;opt);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#25214;IPsec&#31574;&#30053;&#25968;&#25454;&#24211;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>xfrm4_policy_check(<span style="color: #AE81FF;">NULL</span>, XFRM_POLICY_FWD, skb))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23384;&#22312;&#36335;&#30001;&#35686;&#21578;&#36873;&#39033;&#65292;&#35843;&#29992;ip_call_ra_chain&#23558;&#25968;&#25454;&#25253;&#36755;&#20837;&#21040;&#24863;&#20852;&#36259;&#30340;&#36827;&#31243;</span>
        <span style="color: #F92672;">if</span> (IPCB(skb)-&gt;opt.router_alert &amp;&amp; ip_call_ra_chain(skb))
                <span style="color: #F92672;">return</span> NET_RX_SUCCESS;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">mac&#22320;&#22336;&#26159;&#21542;&#20026;&#25509;&#25910;&#32593;&#32476;&#35774;&#22791;&#30340;mac&#22320;&#22336;</span>
        <span style="color: #F92672;">if</span> (skb-&gt;pkt_type != PACKET_HOST)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
        skb-&gt;ip_summed = CHECKSUM_NONE;
        <span style="color: #F92672;">if</span> (skb-&gt;nh.iph-&gt;ttl &lt;= 1) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;ttl&#20026;1&#25110;&#32773;&#23567;&#20110;1,&#21017;&#20002;&#24323;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">too_many_hops</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">IPSec&#36335;&#30001;&#36873;&#36335;&#21450;&#36716;&#21457;&#22788;&#29702;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>xfrm4_route_forward(skb))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
        rt = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span>*)skb-&gt;dst;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25968;&#25454;&#25253;&#21551;&#29992;&#20102;&#20005;&#26684;&#28304;&#36335;&#30001;&#36873;&#39033;&#65292;&#19988;&#25968;&#25454;&#25253;&#30340;&#19979;&#19968;&#36339;&#19981;&#26159;&#32593;&#20851;</span>
        <span style="color: #F92672;">if</span> (opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_dst != rt-&gt;rt_gateway)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">sr_failed</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#30830;&#20445;SKB&#26377;&#21046;&#23450;&#38271;&#24230;&#30340;headroom&#31354;&#38388;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (skb_cow(skb, LL_RESERVED_SPACE(rt-&gt;u.dst.dev)+rt-&gt;u.dst.header_len))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;
        iph = skb-&gt;nh.iph;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#36882;&#20943;ttl</span><span style="color: #75715E;">*/</span>
        ip_decrease_ttl(iph);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#36335;&#30001;&#20013;&#23384;&#22312;&#37325;&#23450;&#21521;&#26631;&#24535;&#65292;&#21017;&#38656;&#35201;&#21457;&#36865;&#37325;&#23450;&#21521;ICMP&#25253;&#25991;</span>
        <span style="color: #F92672;">if</span> (rt-&gt;rt_flags&amp;RTCF_DOREDIRECT &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>opt-&gt;srr)
                ip_rt_send_redirect(skb);
        skb-&gt;priority = rt_tos2priority(iph-&gt;tos);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">netfilter NF_IP_FORWARD&#25805;&#20316;&#21518;&#65292;&#35843;&#29992; ip_forward_finish</span>
        <span style="color: #F92672;">return</span> NF_HOOK(PF_INET, NF_IP_FORWARD, skb, skb-&gt;dev, rt-&gt;u.dst.dev,
                       ip_forward_finish);
<span style="color: #AE81FF;">sr_failed</span>:
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         *      Strict routing permits no gatewaying</span>
<span style="color: #75715E;">         */</span>
         icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);
         <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">drop</span>;

<span style="color: #AE81FF;">too_many_hops</span>:
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Tell the sender its packet died...</span><span style="color: #75715E;"> */</span>
        IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
        icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
<span style="color: #AE81FF;">drop</span>:
        kfree_skb(skb);
        <span style="color: #F92672;">return</span> NET_RX_DROP;
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_forward_finish</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span> * <span style="color: #FD971F;">opt</span> = &amp;(IPCB(skb)-&gt;opt);
        IP_INC_STATS_BH(IPSTATS_MIB_OUTFORWDATAGRAMS);
        <span style="color: #F92672;">if</span> (unlikely(opt-&gt;optlen))
                ip_forward_options(skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;IP&#25968;&#25454;&#25253;&#36873;&#39033;</span>
        <span style="color: #F92672;">return</span> dst_output(skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#25968;&#25454;&#25253;</span>
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgab307d3" class="outline-2">
<h2 id="orgab307d3"><span class="section-number-2">11.</span> IP数据报的输入处理</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org57a9c6f" class="outline-3">
<h3 id="org57a9c6f"><span class="section-number-3">11.1.</span> IP数据报输出到设备</h3>
<div class="outline-text-3" id="text-11-1">
<p>
转发数据报和本地输出的数据报，都需要经过路由之后，输出到设备，输出到设备的接口为 ip_output()。
</p>

<p>
ip_output并不会直接调用，而是通过输出数据报的目的路由缓存项中的输出接口调用。
</p>

<p>
本地输出的数据报查找到目的路由缓存后，通过NF_IP_LOCAL_OUT的netfilter处理，通过dst_output输出到网络设备。
</p>

<p>
转发的数据报查找路由后，通过NF_IP_FORWARD的netfilter处理后，通过dst_output输出到设备。
</p>
</div>

<div id="outline-container-org5f9115e" class="outline-4">
<h4 id="org5f9115e"><span class="section-number-4">11.1.1.</span> dst_output()</h4>
<div class="outline-text-4" id="text-11-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Output packet to network from transport.</span><span style="color: #75715E;">  */</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">dst_output</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#30340;&#36755;&#20986;&#25509;&#21475;</span>
        <span style="color: #F92672;">return</span> skb-&gt;dst-&gt;output(skb);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8ad72b1" class="outline-4">
<h4 id="org8ad72b1"><span class="section-number-4">11.1.2.</span> ip_output()</h4>
<div class="outline-text-4" id="text-11-1-2">
<p>
对于单播数据报，目的路由缓存项中的输出接口output为ip_output()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_output</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">dev</span> = skb-&gt;dst-&gt;dev;
        IP_INC_STATS(IPSTATS_MIB_OUTREQUESTS);
        skb-&gt;dev = dev; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#36755;&#20986;&#32593;&#32476;&#35774;&#22791;</span>
        skb-&gt;protocol = htons(ETH_P_IP); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32593;&#32476;&#23618;&#21327;&#35758;&#31867;&#22411;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;netfilter&#30340; NF_IP_POST_ROUTING,&#20043;&#21518;&#36890;&#36807; ip_finish_output&#22788;&#29702;</span>
        <span style="color: #F92672;">return</span> NF_HOOK_COND(PF_INET, NF_IP_POST_ROUTING, skb, <span style="color: #AE81FF;">NULL</span>, dev, ip_finish_output, <span style="color: #E6DB74; font-weight: bold;">!</span>(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org54041de" class="outline-4">
<h4 id="org54041de"><span class="section-number-4">11.1.3.</span> ip_finish_output()</h4>
<div class="outline-text-4" id="text-11-1-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_finish_output</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span>(CONFIG_NETFILTER) &amp;&amp; <span style="color: #F92672;">defined</span>(CONFIG_XFRM)
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Policy lookup after SNAT yielded a new policy</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (skb-&gt;dst-&gt;xfrm != <span style="color: #AE81FF;">NULL</span>) {
                IPCB(skb)-&gt;flags |= IPSKB_REROUTED;
                <span style="color: #F92672;">return</span> dst_output(skb);
        }
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22823;&#20110;MTU&#65292;&#21017;&#38656;&#35201;&#20998;&#29255;</span>
        <span style="color: #F92672;">if</span> (skb-&gt;len &gt; dst_mtu(skb-&gt;dst) &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>skb_is_gso(skb))
                <span style="color: #F92672;">return</span> ip_fragment(skb, ip_finish_output2);
        <span style="color: #F92672;">else</span>
                <span style="color: #F92672;">return</span> ip_finish_output2(skb);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf17d2ea" class="outline-4">
<h4 id="orgf17d2ea"><span class="section-number-4">11.1.4.</span> ip_finish_output2()</h4>
<div class="outline-text-4" id="text-11-1-4">
<p>
该函数通过邻居子系统将数据报输出到网络设备。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_finish_output2</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dst_entry</span> *<span style="color: #FD971F;">dst</span> = skb-&gt;dst;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">dev</span> = dst-&gt;dev;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hh_len</span> = LL_RESERVED_SPACE(dev);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26816;&#27979;skb&#21069;&#38754;&#30340;&#31354;&#38388;&#33021;&#21542;&#23384;&#20648;&#38142;&#36335;&#23618;&#39318;&#37096;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (unlikely(skb_headroom(skb) &lt; hh_len &amp;&amp; dev-&gt;hard_header)) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb2</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38656;&#35201;&#20998;&#37197;&#26356;&#22823;&#23384;&#20648;&#21306;&#30340;SKB</span>
                skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));
                <span style="color: #F92672;">if</span> (skb2 == <span style="color: #AE81FF;">NULL</span>) {
                        kfree_skb(skb);
                        <span style="color: #F92672;">return</span> -ENOMEM;
                }
                <span style="color: #F92672;">if</span> (skb-&gt;sk)
                        skb_set_owner_w(skb2, skb-&gt;sk);
                kfree_skb(skb);
                skb = skb2;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32531;&#23384;&#20102;&#38142;&#36335;&#23618;&#39318;&#37096;&#65292;&#30452;&#25509;&#36755;&#20986;</span>
        <span style="color: #F92672;">if</span> (dst-&gt;hh)
                <span style="color: #F92672;">return</span> neigh_hh_output(dst-&gt;hh, skb);
        <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (dst-&gt;neighbour) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23384;&#22312;&#37051;&#23621;&#39033;&#65292;&#36890;&#36807;&#37051;&#23621;&#39033;&#30340;&#26041;&#27861;&#36755;&#20986;</span>
                <span style="color: #F92672;">return</span> dst-&gt;neighbour-&gt;output(skb);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#38142;&#36335;&#23618;&#39318;&#37096;&#65292;&#20063;&#27809;&#26377;&#37051;&#23621;&#39033;&#65292;&#21017;&#38656;&#35201;&#20002;&#24323;</span>
        <span style="color: #F92672;">if</span> (net_ratelimit())
                printk(KERN_DEBUG <span style="color: #E6DB74;">"ip_finish_output2: No header cache and no neighbour!\n"</span>);
        kfree_skb(skb);
        <span style="color: #F92672;">return</span> -EINVAL;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4c11bd2" class="outline-3">
<h3 id="org4c11bd2"><span class="section-number-3">11.2.</span> TCP输出的相关接口</h3>
<div class="outline-text-3" id="text-11-2">
<p>
TCP中有几种输出接口，常用的输出接口为 ip_queue_xmit()。 ip_build_and_send_pkt()和ip_send_reply()只有发送特定段时才会调用。
</p>
</div>

<div id="outline-container-org5f69cd5" class="outline-4">
<h4 id="org5f69cd5"><span class="section-number-4">11.2.1.</span> ip_queue_xmit()</h4>
<div class="outline-text-4" id="text-11-2-1">

<div id="org54a1256" class="figure">
<p><img src="image/ip-proto/ip-queue-xmit.png" alt="ip-queue-xmit.png" />
</p>
<p><span class="figure-number">Figure 4: </span>ip_queue_xmit()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;">skb: &#24453;&#23553;&#35013;&#20026;ip&#25968;&#25454;&#25253;&#30340;TCP&#27573;</span>
<span style="color: #75715E;">ipfragok&#65306; &#26631;&#35782;&#25968;&#25454;&#26159;&#21542;&#24050;&#32463;&#23436;&#25104;&#20998;&#29255;</span>
<span style="color: #75715E;">*/</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_queue_xmit</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ipfragok</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span> = skb-&gt;sk;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span> *<span style="color: #FD971F;">opt</span> = inet-&gt;opt;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#24050;&#32463;&#20934;&#22791;&#22909;&#36335;&#30001;&#32531;&#23384;&#65292;&#21017;&#26080;&#38656;&#22312;&#26597;&#25214;&#36335;&#30001;</span><span style="color: #75715E;"> */</span>
        rt = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *) skb-&gt;dst;
        <span style="color: #F92672;">if</span> (rt != <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">packet_routed</span>;


        rt = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *)__sk_dst_check(sk, 0); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#30475;&#35813;&#25968;&#25454;&#25253;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#26159;&#21542;&#24050;&#32463;&#32531;&#23384;&#20102;&#36755;&#20986;&#36335;&#30001;&#65292;&#24182;&#26816;&#26597;&#26159;&#21542;&#36807;&#26399;</span>
        <span style="color: #F92672;">if</span> (rt == <span style="color: #AE81FF;">NULL</span>) {
                <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#25214;&#36335;&#30001;</span>
                daddr = inet-&gt;daddr;
                <span style="color: #F92672;">if</span>(opt &amp;&amp; opt-&gt;srr)
                        daddr = opt-&gt;faddr;
                {
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">flowi</span> <span style="color: #FD971F;">fl</span> = { .oif = sk-&gt;sk_bound_dev_if,
                                            .nl_u = { .ip4_u =
                                                      { .daddr = daddr,
                                                        .saddr = inet-&gt;saddr,
                                                        .tos = RT_CONN_FLAGS(sk) } },
                                            .proto = sk-&gt;sk_protocol,
                                            .uli_u = { .ports =
                                                       { .sport = inet-&gt;sport,
                                                         .dport = inet-&gt;dport } } };
                        security_sk_classify_flow(sk, &amp;fl);
                        <span style="color: #F92672;">if</span> (ip_route_output_flow(&amp;rt, &amp;fl, sk, 0))<span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#26597;&#25214;&#22833;&#36133;&#65292;&#20256;&#36755;&#23618;&#30340;&#37325;&#20256;&#26426;&#21046;&#20250;&#20445;&#25345;&#37325;&#35797;&#65292;&#30452;&#21040;&#26597;&#21040;&#36335;&#30001;&#25110;&#32773;&#36830;&#25509;&#36229;&#26102;</span><span style="color: #75715E;">*/</span>
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">no_route</span>;
                }
                sk_setup_caps(sk, &amp;rt-&gt;u.dst);
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#25214;&#21040;&#36335;&#30001;</span>
        skb-&gt;dst = dst_clone(&amp;rt-&gt;u.dst);
<span style="color: #AE81FF;">packet_routed</span>:
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#23384;&#22312;&#20005;&#26684;&#36335;&#30001;&#36873;&#39033;&#65292;&#19988;&#19979;&#19968;&#36339;&#22320;&#22336;&#21644;&#32593;&#20851;&#19981;&#21516;&#65292;&#21017;&#20002;&#24323;</span>
        <span style="color: #F92672;">if</span> (opt &amp;&amp; opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_dst != rt-&gt;rt_gateway)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">no_route</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#24320;&#22987;&#35774;&#32622;IP&#39318;&#37096;&#65292;&#26377;&#36873;&#39033;&#21017;&#26500;&#24314;IP&#36873;&#39033;</span><span style="color: #75715E;"> */</span>
        iph = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *) skb_push(skb, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>) + (opt ? opt-&gt;optlen : 0));
        *((<span style="color: #66D9EF;">__be16</span> *)iph) = htons((4 &lt;&lt; 12) | (5 &lt;&lt; 8) | (inet-&gt;tos &amp; 0xff));
        iph-&gt;tot_len = htons(skb-&gt;len);
        <span style="color: #F92672;">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;u.dst) &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>ipfragok)
                iph-&gt;frag_off = htons(IP_DF);
        <span style="color: #F92672;">else</span>
                iph-&gt;frag_off = 0;
        iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;u.dst);
        iph-&gt;protocol = sk-&gt;sk_protocol;
        iph-&gt;saddr    = rt-&gt;rt_src;
        iph-&gt;daddr    = rt-&gt;rt_dst;
        skb-&gt;nh.iph   = iph;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Transport layer set skb-&gt;h.foo itself.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (opt &amp;&amp; opt-&gt;optlen) {
                iph-&gt;ihl += opt-&gt;optlen &gt;&gt; 2;
                ip_options_build(skb, opt, inet-&gt;daddr, rt, 0);
        }
        ip_select_ident_more(iph, &amp;rt-&gt;u.dst, sk,
                             (skb_shinfo(skb)-&gt;gso_segs ?: 1) - 1);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#28155;&#21152;IP&#26657;&#39564;&#21644;</span><span style="color: #75715E;"> */</span>
        ip_send_check(iph);
        skb-&gt;priority = sk-&gt;sk_priority;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;netfilter&#30340;NF_IP_LOCAL_OUT&#21518;&#65292;&#36890;&#36807;dst_output&#36755;&#20986;</span>
        <span style="color: #F92672;">return</span> NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, <span style="color: #AE81FF;">NULL</span>, rt-&gt;u.dst.dev,
                       dst_output);
<span style="color: #AE81FF;">no_route</span>:
        IP_INC_STATS(IPSTATS_MIB_OUTNOROUTES);
        kfree_skb(skb);
        <span style="color: #F92672;">return</span> -EHOSTUNREACH;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org183116a" class="outline-4">
<h4 id="org183116a"><span class="section-number-4">11.2.2.</span> ip_build_and_send_pkt()</h4>
<div class="outline-text-4" id="text-11-2-2">
<p>
该函数用于在TCP建立连接过程中，打包输出SYN+ACK类型的TCP段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_build_and_send_pkt</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
                          <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">saddr</span>, <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span> *<span style="color: #FD971F;">opt</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *)skb-&gt;dst;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26500;&#24314;IP&#39318;&#37096;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (opt)
                iph=(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *)skb_push(skb,<span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>) + opt-&gt;optlen);
        <span style="color: #F92672;">else</span>
                iph=(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *)skb_push(skb,<span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>));

        iph-&gt;version  = 4; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29256;&#26412;</span>
        iph-&gt;ihl      = 5; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#39318;&#37096;&#38271;&#24230;</span>
        iph-&gt;tos      = inet-&gt;tos; <span style="color: #75715E;">//</span><span style="color: #75715E;">tos</span>
        <span style="color: #F92672;">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;u.dst))<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#25351;&#23450;&#20102;&#19981;&#20998;&#29255;</span>
                iph-&gt;frag_off = htons(IP_DF);
        <span style="color: #F92672;">else</span>
                iph-&gt;frag_off = 0;
        iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;u.dst);
        iph-&gt;daddr    = rt-&gt;rt_dst;
        iph-&gt;saddr    = rt-&gt;rt_src;
        iph-&gt;protocol = sk-&gt;sk_protocol;
        iph-&gt;tot_len  = htons(skb-&gt;len);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;ip&#25968;&#25454;&#25253;&#30340;id, &#22914;&#26524;&#19981;&#20998;&#29255;&#65292;&#21017;&#20351;&#29992;&#22871;&#25509;&#21475;&#30340;id, &#21542;&#21017;&#20351;&#29992;&#23545;&#31471;&#20449;&#24687;&#22359;&#30340;ip_id_count&#25104;&#21592;</span>
        ip_select_ident(iph, &amp;rt-&gt;u.dst, sk);
        skb-&gt;nh.iph   = iph;

        <span style="color: #F92672;">if</span> (opt &amp;&amp; opt-&gt;optlen) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;IP&#36873;&#39033;</span>
                iph-&gt;ihl += opt-&gt;optlen&gt;&gt;2;
                ip_options_build(skb, opt, daddr, rt, 0);
        }
        ip_send_check(iph); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;IP&#25968;&#25454;&#25253;&#30340;&#26657;&#39564;&#21644;</span>
        skb-&gt;priority = sk-&gt;sk_priority;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35843;&#29992;netfilter&#30340;NF_IP_LOCAL_OUT, &#20043;&#21518;&#36890;&#36807;dst_output&#36755;&#20986;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">return</span> NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, <span style="color: #AE81FF;">NULL</span>, rt-&gt;u.dst.dev,
                       dst_output);
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgec8b24c" class="outline-4">
<h4 id="orgec8b24c"><span class="section-number-4">11.2.3.</span> ip_send_reply()</h4>
<div class="outline-text-4" id="text-11-2-3">
<p>
该函数用于构造RST和ACK段，并输出。分别在 tcp_v4_send_reset() 和 tcp_v4_send_ack() 中调用。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_reply_arg</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kvec</span> <span style="color: #FD971F;">iov</span>[1];  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26631;&#35782;&#24453;&#36755;&#20986;&#25968;&#25454;&#30340;&#20301;&#32622;&#21450;&#38271;&#24230;</span>
        <span style="color: #66D9EF;">__wsum</span>      <span style="color: #FD971F;">csum</span>;    <span style="color: #75715E;">//</span><span style="color: #75715E;">TCP&#20266;&#39318;&#37096;&#26657;&#39564;&#21644;</span>
        <span style="color: #66D9EF;">int</span>         <span style="color: #FD971F;">csumoffset</span>; <span style="color: #75715E;">/* </span><span style="color: #75715E;">Tcp&#39318;&#37096;&#20013;&#30340;&#26657;&#39564;&#21644;&#23383;&#27573;&#22312;&#39318;&#37096;&#20013;&#30340;&#20559;&#31227;</span><span style="color: #75715E;">*/</span>
};

<span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Generic function to send a packet as reply to another packet.</span>
<span style="color: #75715E;"> *      Used to send TCP resets so far. ICMP should use this function too.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> *      Should run single threaded per socket because it uses the sock</span>
<span style="color: #75715E;"> *      structure to pass arguments.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> *      LATER: switch from ip_build_xmit to ip_append_*</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">ip_send_reply</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_reply_arg</span> *<span style="color: #FD971F;">arg</span>,
                   <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span>       <span style="color: #FD971F;">opt</span>;
                <span style="color: #66D9EF;">char</span>                    <span style="color: #FD971F;">data</span>[40];
        } <span style="color: #FD971F;">replyopts</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ipcm_cookie</span> <span style="color: #FD971F;">ipc</span>;
        <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">daddr</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span>*)skb-&gt;dst;

        <span style="color: #F92672;">if</span> (ip_options_echo(&amp;replyopts.opt, skb))<span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#36873;&#39033;</span>
                <span style="color: #F92672;">return</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;SKB&#30340;&#36755;&#20837;&#36335;&#30001;&#65292;&#33719;&#21462;&#23545;&#31471;IP&#22320;&#22336;</span>
        daddr = ipc.addr = rt-&gt;rt_src;
        ipc.opt = <span style="color: #AE81FF;">NULL</span>;

        <span style="color: #F92672;">if</span> (replyopts.opt.optlen) {
                ipc.opt = &amp;replyopts.opt;

                <span style="color: #F92672;">if</span> (ipc.opt-&gt;srr) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21551;&#29992;&#20102;&#28304;&#36335;&#30001;&#36873;&#39033;</span>
                        daddr = replyopts.opt.faddr;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#19979;&#19968;&#36339;ip&#22320;&#22336;&#20316;&#20026;&#30446;&#30340;&#22320;&#22336;</span>
        }

        {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26597;&#25214;&#36335;&#30001;</span>
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">flowi</span> <span style="color: #FD971F;">fl</span> = { .nl_u = { .ip4_u =
                                              { .daddr = daddr,
                                                .saddr = rt-&gt;rt_spec_dst,
                                                .tos = RT_TOS(skb-&gt;nh.iph-&gt;tos) } },
                                    <span style="color: #75715E;">/* </span><span style="color: #75715E;">Not quite clean, but right.</span><span style="color: #75715E;"> */</span>
                                    .uli_u = { .ports =
                                               { .sport = skb-&gt;h.th-&gt;dest,
                                                 .dport = skb-&gt;h.th-&gt;source } },
                                    .proto = sk-&gt;sk_protocol };
                security_skb_classify_flow(skb, &amp;fl);
                <span style="color: #F92672;">if</span> (ip_route_output_key(&amp;rt, &amp;fl))
                        <span style="color: #F92672;">return</span>;
        }

        bh_lock_sock(sk);
        inet-&gt;tos = skb-&gt;nh.iph-&gt;tos;
        sk-&gt;sk_priority = skb-&gt;priority;
        sk-&gt;sk_protocol = skb-&gt;nh.iph-&gt;protocol;
        ip_append_data(sk, ip_reply_glue_bits, arg-&gt;iov-&gt;iov_base, len, 0,
                       &amp;ipc, rt, MSG_DONTWAIT);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28155;&#21152;&#25968;&#25454;</span>
        <span style="color: #F92672;">if</span> ((skb = skb_peek(&amp;sk-&gt;sk_write_queue)) != <span style="color: #AE81FF;">NULL</span>) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38431;&#21015;&#19981;&#20026;&#31354;</span>
                <span style="color: #F92672;">if</span> (arg-&gt;csumoffset &gt;= 0)
                        *((<span style="color: #66D9EF;">__sum16</span> *)skb-&gt;h.raw + arg-&gt;csumoffset) = csum_fold(csum_add(skb-&gt;csum, arg-&gt;csum));
                skb-&gt;ip_summed = CHECKSUM_NONE;
                ip_push_pending_frames(sk);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#25968;&#25454;</span>
        }
        bh_unlock_sock(sk);
        ip_rt_put(rt);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf4b0246" class="outline-3">
<h3 id="orgf4b0246"><span class="section-number-3">11.3.</span> UDP输出接口</h3>
<div class="outline-text-3" id="text-11-3">
</div>
<div id="outline-container-org0bc83e7" class="outline-4">
<h4 id="org0bc83e7"><span class="section-number-4">11.3.1.</span> ip_append_data()</h4>
<div class="outline-text-4" id="text-11-3-1">
<p>
ip_append_data()函数主要用于 UDP 和 RAW 套接口，tcp中发送ACK和RST时，也会调用该函数。
</p>

<p>
ip_append_data()用于将大的数据包分成多个不大于MTU的SKB，为网络层的分片做准备。
</p>
<ul class="org-ul">
<li>如果先前的输出队列非空，则先向队列最后一个SKB填充</li>
<li>如果网络设备支持聚合分散I/O，则将数据写到frags指向的页面，如果页面填满，则再次分配页面。</li>
<li>进入下次循环，分配SKB，通过getfrag从传输层复制数据，并添加到输出队列的末尾。</li>
</ul>


<div id="org4362fde" class="figure">
<p><img src="image/ip-proto/ip-append-data.png" alt="ip-append-data.png" />
</p>
<p><span class="figure-number">Figure 5: </span>ip_append_data()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_append_data</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
                   <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">getfrag</span>(<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">from</span>, <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">to</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">offset</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>,
                               <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">odd</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>),
                   <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">from</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">length</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">transhdrlen</span>,
                   <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ipcm_cookie</span> *<span style="color: #FD971F;">ipc</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span>,
                   <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>);
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> ip_append_data参数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">参数</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">sk</td>
<td class="org-left">数据的传输控制块</td>
</tr>

<tr>
<td class="org-left">getfrag</td>
<td class="org-left">用于复制数据到SKB,不同传输层的复制方法也不同</td>
</tr>

<tr>
<td class="org-left">from</td>
<td class="org-left">输出数据的的数据块地址，指向内核空间或者用户空间</td>
</tr>

<tr>
<td class="org-left">length</td>
<td class="org-left">数据长度</td>
</tr>

<tr>
<td class="org-left">transhdrlen</td>
<td class="org-left">传输层首部长度</td>
</tr>

<tr>
<td class="org-left">ipc</td>
<td class="org-left">传递到IP层的临时信息块</td>
</tr>

<tr>
<td class="org-left">rt</td>
<td class="org-left">路由缓存项</td>
</tr>

<tr>
<td class="org-left">flags</td>
<td class="org-left">输出数据的标志</td>
</tr>
</tbody>
</table>

<p>
<i><b>int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb);</b></i>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> getfrag参数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">参数</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">from</td>
<td class="org-left">待复制数据</td>
</tr>

<tr>
<td class="org-left">to</td>
<td class="org-left">将要复制到的位置</td>
</tr>

<tr>
<td class="org-left">offset</td>
<td class="org-left">待复制数据的偏移</td>
</tr>

<tr>
<td class="org-left">len</td>
<td class="org-left">复制长度</td>
</tr>

<tr>
<td class="org-left">odd</td>
<td class="org-left">从上一个SKB中剩余下来并复制到此SKB的长度</td>
</tr>

<tr>
<td class="org-left">skb</td>
<td class="org-left">数据的SKB</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> 不同的getfrag</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">getfrag</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ip_generic_getfrag</td>
<td class="org-left">用于复制UDP或者RAW的数据</td>
</tr>

<tr>
<td class="org-left">udplite_getfrag</td>
<td class="org-left">用于复制轻量级UDP的数据</td>
</tr>

<tr>
<td class="org-left">ip_reply_glue_bits</td>
<td class="org-left">用于在TCP中复制RST和ACK段的数据</td>
</tr>

<tr>
<td class="org-left">icmp_glue_bits</td>
<td class="org-left">用于复制ICMP报文</td>
</tr>
</tbody>
</table>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      ip_append_data() and ip_append_page() can make one large IP datagram</span>
<span style="color: #75715E;"> *      from many pieces of data. Each pieces will be holded on the socket</span>
<span style="color: #75715E;"> *      until ip_push_pending_frames() is called. Each piece can be a page</span>
<span style="color: #75715E;"> *      or non-page data.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> *      Not only UDP, other transport protocols - e.g. raw sockets - can use</span>
<span style="color: #75715E;"> *      this interface potentially.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> *      LATER: length must be adjusted by pad at tail, when it is required.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_append_data</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
                   <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">getfrag</span>(<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">from</span>, <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">to</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">offset</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>,
                               <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">odd</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>),
                   <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">from</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">length</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">transhdrlen</span>,
                   <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ipcm_cookie</span> *<span style="color: #FD971F;">ipc</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span>,
                   <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;

        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span> *<span style="color: #FD971F;">opt</span> = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hh_len</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">exthdrlen</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#35760;&#24405;IPsec&#20013;&#30340;&#25193;&#23637;&#39318;&#37096;&#30340;&#38271;&#24230;</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mtu</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">copy</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">offset</span> = 0;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">maxfraglen</span>, <span style="color: #FD971F;">fragheaderlen</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">csummode</span> = CHECKSUM_NONE;

        <span style="color: #F92672;">if</span> (flags&amp;MSG_PROBE) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27492;&#26631;&#35782;&#20195;&#34920;&#36827;&#34892;&#36335;&#24452;MTU&#25506;&#27979;&#65292;&#19981;&#20250;&#20256;&#36882;&#25968;&#25454;</span>
                <span style="color: #F92672;">return</span> 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#36755;&#20986;&#38431;&#21015;&#20026;&#31354;</span>
        <span style="color: #F92672;">if</span> (skb_queue_empty(&amp;sk-&gt;sk_write_queue)) {
                opt = ipc-&gt;opt;
                <span style="color: #F92672;">if</span> (opt) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23384;&#22312;ip&#36873;&#39033;&#65292;&#21017;&#38656;&#35201;&#23558;&#36873;&#39033;&#22797;&#21046;&#21040;&#20020;&#26102;&#20449;&#24687;&#22359;</span>
                        <span style="color: #F92672;">if</span> (inet-&gt;cork.opt == <span style="color: #AE81FF;">NULL</span>) {
                                inet-&gt;cork.opt = kmalloc(<span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span>) + 40, sk-&gt;sk_allocation);
                                <span style="color: #F92672;">if</span> (unlikely(inet-&gt;cork.opt == <span style="color: #AE81FF;">NULL</span>))
                                        <span style="color: #F92672;">return</span> -ENOBUFS;
                        }
                        memcpy(inet-&gt;cork.opt, opt, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span>)+opt-&gt;optlen);
                        inet-&gt;cork.flags |= IPCORK_OPT; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26631;&#35782;&#20020;&#26102;&#20449;&#24687;&#22359;&#20013;&#23384;&#22312;IP&#36873;&#39033;</span>
                        inet-&gt;cork.addr = ipc-&gt;addr;
                }
                dst_hold(&amp;rt-&gt;u.dst);
                inet-&gt;cork.fragsize = mtu = dst_mtu(rt-&gt;u.dst.path); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#29255;&#22823;&#23567;</span>
                inet-&gt;cork.rt = rt;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36335;&#30001;</span>
                inet-&gt;cork.length = 0;
                sk-&gt;sk_sndmsg_page = <span style="color: #AE81FF;">NULL</span>;
                sk-&gt;sk_sndmsg_off = 0;
                <span style="color: #F92672;">if</span> ((exthdrlen = rt-&gt;u.dst.header_len) != 0) {
                        length += exthdrlen;
                        transhdrlen += exthdrlen;
                }
        } <span style="color: #F92672;">else</span> { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#38431;&#21015;&#19981;&#20026;&#31354;</span>
                rt = inet-&gt;cork.rt; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20351;&#29992;&#19978;&#27425;&#30340;&#36335;&#30001;</span>
                <span style="color: #F92672;">if</span> (inet-&gt;cork.flags &amp; IPCORK_OPT)
                        opt = inet-&gt;cork.opt;

                transhdrlen = 0;
                exthdrlen = 0;
                mtu = inet-&gt;cork.fragsize;
        }
        hh_len = LL_RESERVED_SPACE(rt-&gt;u.dst.dev);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#38142;&#36335;&#23618;&#39318;&#37096;&#38271;&#24230;</span>
        fragheaderlen = <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>) + (opt ? opt-&gt;optlen : 0); <span style="color: #75715E;">//</span><span style="color: #75715E;">IP&#39318;&#37096;&#38271;&#24230;&#38656;&#35201;4&#23383;&#33410;&#23545;&#40784;</span>
        maxfraglen = ((mtu - fragheaderlen) &amp; ~7) + fragheaderlen;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#30340;&#25968;&#25454;&#25253;&#38271;&#24230;&#22823;&#20110;&#19968;&#20010;IP&#25968;&#25454;&#25253;&#33021;&#23481;&#32435;&#30340;&#38271;&#24230;&#65292;&#36820;&#22238;EMSGSIZE&#20986;&#38169;&#28040;&#24687;</span>
        <span style="color: #F92672;">if</span> (inet-&gt;cork.length + length &gt; 0xFFFF - fragheaderlen) {
                ip_local_error(sk, EMSGSIZE, rt-&gt;rt_dst, inet-&gt;dport, mtu-exthdrlen);
                <span style="color: #F92672;">return</span> -EMSGSIZE;
        }

        <span style="color: #F92672;">if</span> (transhdrlen &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22823;&#20110;0,&#35828;&#26126;&#26159;&#39318;&#29255;&#25968;&#25454;</span>
            length + fragheaderlen &lt;= mtu &amp;&amp;
            rt-&gt;u.dst.dev-&gt;features &amp; NETIF_F_ALL_CSUM &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32593;&#32476;&#35774;&#22791;&#25903;&#25345;&#26657;&#39564;&#21644;</span>
            <span style="color: #E6DB74; font-weight: bold;">!</span>exthdrlen)
                csummode = CHECKSUM_PARTIAL;

        inet-&gt;cork.length += length;
        <span style="color: #F92672;">if</span> (((length &gt; mtu) &amp;&amp; (sk-&gt;sk_protocol == IPPROTO_UDP)) &amp;&amp;<span style="color: #75715E;">//</span><span style="color: #75715E;">UDP&#25968;&#25454;&#25253;&#24182;&#19988;&#38656;&#35201;&#20998;&#29255;</span>
                        (rt-&gt;u.dst.dev-&gt;features &amp; NETIF_F_UFO)) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#32593;&#32476;&#35774;&#22791;&#25903;&#25345;UDP&#20998;&#29255;&#21368;&#36733;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">ip_ufo_append_data()&#36827;&#34892;&#20998;&#29255;&#22788;&#29702;</span>
                err = ip_ufo_append_data(sk, getfrag, from, length, hh_len,
                                         fragheaderlen, transhdrlen, mtu,
                                         flags);
                <span style="color: #F92672;">if</span> (err)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">error</span>;
                <span style="color: #F92672;">return</span> 0;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">So, what's going on in the loop below?</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         * We use calculated fragment length to generate chained skb,</span>
<span style="color: #75715E;">         * each of segments is IP fragment ready for sending to network after</span>
<span style="color: #75715E;">         * adding appropriate IP header.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38431;&#21015;&#26411;&#23614;&#30340;SKB&#20026;&#31354;&#65292;&#21017;&#38656;&#35201;&#20998;&#37197;</span>
        <span style="color: #F92672;">if</span> ((skb = skb_peek_tail(&amp;sk-&gt;sk_write_queue)) == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">alloc_new_skb</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24320;&#22987;&#24490;&#29615;&#22788;&#29702;&#25968;&#25454;</span>
        <span style="color: #F92672;">while</span> (length &gt; 0) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Check if the remaining data fits into current packet.</span><span style="color: #75715E;"> */</span>
                copy = mtu - skb-&gt;len;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26368;&#21518;&#19968;&#20010;SKB&#30340;&#21097;&#20313;&#31354;&#38388;&#33021;&#21542;&#23481;&#32435;&#25152;&#26377;&#25968;&#25454;</span>
                <span style="color: #F92672;">if</span> (copy &lt; length)
                        copy = maxfraglen - skb-&gt;len;
                <span style="color: #F92672;">if</span> (copy &lt;= 0) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23567;&#20110;0,&#35828;&#26126;&#19978;&#19968;&#20010;SKB&#19981;&#33021;&#22635;&#20805;&#65292;&#38656;&#37325;&#26032;&#20998;&#37197;</span>
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#25968;&#25454;&#22797;&#21046;&#21040;&#26032;&#20998;&#37197;&#30340;SKB&#20013;</span>
                        <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">data</span>;
                        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">datalen</span>;
                        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fraglen</span>;
                        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fraggap</span>;
                        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">alloclen</span>;
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb_prev</span>;
<span style="color: #AE81FF;">alloc_new_skb</span>:
                        skb_prev = skb;
                        <span style="color: #F92672;">if</span> (skb_prev)
                                <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#19978;&#19968;&#20010;SKB&#20013;&#23384;&#22312;&#22810;&#20313;8&#23383;&#33410;&#23545;&#40784;&#30340;MTU&#25968;&#25454;&#65292;</span>
<span style="color: #75715E;">                                &#21017;&#23558;&#36825;&#20123;&#25968;&#25454;&#31227;&#21160;&#21040;&#24403;&#21069;SKB,&#20197;&#30830;&#20445;&#26368;&#21518;&#19968;&#20010;IP&#20998;</span>
<span style="color: #75715E;">                                &#29255;&#20043;&#22806;&#30340;&#25968;&#25454;&#33021;&#22815;4&#23383;&#33410;&#23545;&#40784;&#12290;&#22240;&#27492;&#35201;&#35745;&#31639;&#31227;&#21160;&#21040;&#24403;</span>
<span style="color: #75715E;">                                &#21069;SKB&#30340;&#30340;&#25968;&#25454;&#38271;&#24230;</span>
<span style="color: #75715E;">                                */</span>
                                fraggap = skb_prev-&gt;len - maxfraglen;
                        <span style="color: #F92672;">else</span>
                                fraggap = 0;

                        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                         * If remaining data exceeds the mtu,</span>
<span style="color: #75715E;">                         * we know we need more fragment(s).</span>
<span style="color: #75715E;">                         */</span>
                        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#21097;&#20313;&#25968;&#25454;&#36229;&#36807;MTU,&#21017;&#38656;&#35201;&#26356;&#22810;&#30340;&#20998;&#29255;</span><span style="color: #75715E;">*/</span>
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#38656;&#35201;&#22797;&#21046;&#21040;&#26032;SKB&#30340;&#38271;&#24230;</span>
                        datalen = length + fraggap;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25968;&#25454;&#38271;&#24230;&#26080;&#27861;&#25918;&#22312;&#19968;&#20010;MTU&#20013;&#65292;&#37325;&#26032;&#35745;&#31639;&#38271;&#24230;</span>
                        <span style="color: #F92672;">if</span> (datalen &gt; mtu - fragheaderlen)
                                datalen = maxfraglen - fragheaderlen;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#19977;&#23618;&#39318;&#37096;&#21644;&#25968;&#25454;&#30340;&#24635;&#38271;&#24230;</span>
                        fraglen = datalen + fragheaderlen;
                        <span style="color: #F92672;">if</span> ((flags &amp; MSG_MORE) &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21518;&#32493;&#36824;&#26377;&#25968;&#25454;&#36755;&#20986;</span>
                            <span style="color: #E6DB74; font-weight: bold;">!</span>(rt-&gt;u.dst.dev-&gt;features&amp;NETIF_F_SG)) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#22791;&#19981;&#25903;&#25345;&#32858;&#21512;&#20998;&#25955;I/O</span>
                                alloclen = mtu;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;mtu&#20316;&#20026;skb&#30340;&#20998;&#37197;&#38271;&#24230;</span>
                        <span style="color: #F92672;">else</span><span style="color: #75715E;">//</span><span style="color: #75715E;">&#25353;&#25968;&#25454;&#38271;&#24230;&#20998;&#37197;SKB</span>
                                alloclen = datalen + fragheaderlen;

                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">The last fragment gets additional space at tail.</span>
<span style="color: #75715E;">                         * Note, with MSG_MORE we overallocate on fragments,</span>
<span style="color: #75715E;">                         * because we have no idea what fragment will be</span>
<span style="color: #75715E;">                         * the last.</span>
<span style="color: #75715E;">                         */</span>

                        <span style="color: #F92672;">if</span> (datalen == length + fraggap)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26368;&#21518;&#19968;&#20010;&#20998;&#29255;</span>
                                alloclen += rt-&gt;u.dst.trailer_len; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#30446;&#30340;&#36335;&#30001;&#21551;&#29992;IPSec,&#21017;&#38656;&#35201;&#22686;&#21152;&#23545;&#24212;&#30340;&#20998;&#37197;&#31354;&#38388;</span>

                        <span style="color: #F92672;">if</span> (transhdrlen) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23384;&#22312;&#20256;&#36755;&#23618;&#39318;&#37096;&#65292;&#35828;&#26126;&#26159;&#20998;&#32452;&#30340;&#39318;&#20010;&#20998;&#29255;</span>
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38656;&#35201;&#32771;&#34385;&#36755;&#20986;&#36229;&#26102;&#65292;&#20256;&#36755;&#23618;&#26159;&#21542;&#38169;&#35823;&#31561;&#24773;&#20917;</span>
                                skb = sock_alloc_send_skb(sk,
                                                alloclen + hh_len + 15,
                                                (flags &amp; MSG_DONTWAIT), &amp;err);
                        } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#26159;&#39318;&#20010;&#20998;&#29255;</span>
                                skb = <span style="color: #AE81FF;">NULL</span>;
                                <span style="color: #F92672;">if</span> (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &lt;=
                                    2 * sk-&gt;sk_sndbuf)
                                        skb = sock_wmalloc(sk,
                                                           alloclen + hh_len + 15, 1,
                                                           sk-&gt;sk_allocation);
                                <span style="color: #F92672;">if</span> (unlikely(skb == <span style="color: #AE81FF;">NULL</span>))
                                        err = -ENOBUFS;
                        }
                        <span style="color: #F92672;">if</span> (skb == <span style="color: #AE81FF;">NULL</span>)
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">error</span>;

                        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                         *      Fill in the control structures</span>
<span style="color: #75715E;">                         *///</span><span style="color: #75715E;">&#22635;&#20805;&#29992;&#20110;&#26657;&#39564;&#30340;&#25511;&#21046;&#20449;&#24687;</span>
                        skb-&gt;ip_summed = csummode;
                        skb-&gt;csum = 0;
                        skb_reserve(skb, hh_len);
                        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                         *      Find where to start putting bytes.</span>
<span style="color: #75715E;">                         */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#39044;&#30041;&#29992;&#20110;&#23384;&#25918;&#20108;&#23618;&#39318;&#37096;&#12289;&#19977;&#23618;&#39318;&#37096;&#21644;&#25968;&#25454;&#30340;&#31354;&#38388;&#65292;&#24182;&#35774;&#32622;SKB&#30340;&#25351;&#21521;&#19977;&#23618;&#12289;&#22235;&#23618;&#30340;&#25351;&#38024;</span>
                        data = skb_put(skb, fraglen);
                        skb-&gt;nh.raw = data + exthdrlen;
                        data += fragheaderlen;
                        skb-&gt;h.raw = data + exthdrlen;

                        <span style="color: #F92672;">if</span> (fraggap) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35828;&#26126;&#19978;&#19968;&#20010;SKB&#30340;&#25968;&#25454;&#36229;&#36807;8&#23383;&#33410;&#23545;&#40784;MTU</span>
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#25968;&#25454;&#21644;&#20256;&#36755;&#23618;&#39318;&#37096;&#22797;&#21046;&#21040;&#24403;&#21069;SKB</span>
                                skb-&gt;csum = skb_copy_and_csum_bits(
                                        skb_prev, maxfraglen,
                                        data + transhdrlen, fraggap, 0);
                                skb_prev-&gt;csum = csum_sub(skb_prev-&gt;csum,
                                                          skb-&gt;csum);
                                data += fraggap;
                                pskb_trim_unique(skb_prev, maxfraglen);
                        }
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25509;&#30528;&#22797;&#21046;&#21097;&#19979;&#30340;&#25968;&#25454;</span>
                        copy = datalen - transhdrlen - fraggap;
                        <span style="color: #F92672;">if</span> (copy &gt; 0 &amp;&amp; getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) &lt; 0) {
                                err = -EFAULT;
                                kfree_skb(skb);
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">error</span>;
                        }
                        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#23436;&#25104;&#26412;&#27425;&#25968;&#25454;&#30340;&#22797;&#21046;</span><span style="color: #75715E;">*/</span>

                        offset += copy; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19979;&#19968;&#27425;&#22797;&#21046;&#25968;&#25454;&#30340;&#20559;&#31227;</span>
                        length -= datalen - fraggap; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21097;&#20313;&#25968;&#25454;&#38271;&#24230;</span>
                        transhdrlen = 0;
                        exthdrlen = 0;
                        csummode = CHECKSUM_NONE;

                        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                         * Put the packet on the pending queue.</span>
<span style="color: #75715E;">                         */</span>
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;SKB&#28155;&#21152;&#33267;&#36755;&#20986;&#38431;&#21015;</span>
                        __skb_queue_tail(&amp;sk-&gt;sk_write_queue, skb);
                        <span style="color: #F92672;">continue</span>;
                }

                <span style="color: #F92672;">if</span> (copy &gt; length)  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19978;&#20010;SKB&#21097;&#20313;&#31354;&#38388;&#22823;&#20110;&#21097;&#20313;&#30340;&#24453;&#21457;&#36865;&#25968;&#25454;&#65292;&#21017;&#21487;&#20197;&#30452;&#25509;&#22797;&#21046;</span>
                        copy = length;

                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(rt-&gt;u.dst.dev-&gt;features&amp;NETIF_F_SG)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#22791;&#19981;&#25903;&#25345;&#32858;&#21512;&#20998;&#25955;I/O</span>
                        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">off</span>;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#25968;&#25454;&#21040;SKB&#30340;&#32447;&#24615;&#21306;</span>
                        off = skb-&gt;len;
                        <span style="color: #F92672;">if</span> (getfrag(from, skb_put(skb, copy),
                                        offset, copy, off, skb) &lt; 0) {
                                __skb_trim(skb, off);
                                err = -EFAULT;
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">error</span>;
                        }
                } <span style="color: #F92672;">else</span> { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25903;&#25345;&#32858;&#21512;&#20998;&#25955;I/O&#65292;&#21017;&#22797;&#21046;&#21040;&#32858;&#21512;&#20998;&#25955;I/O&#21306;&#22495;</span>
                        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span> = skb_shinfo(skb)-&gt;nr_frags;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#20998;&#29255;&#25968;&#32452;&#30340;&#26368;&#21518;&#20998;&#29255;</span>
                        <span style="color: #66D9EF;">skb_frag_t</span> *<span style="color: #FD971F;">frag</span> = &amp;skb_shinfo(skb)-&gt;frags[i-1];
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> *<span style="color: #FD971F;">page</span> = sk-&gt;sk_sndmsg_page;
                        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">off</span> = sk-&gt;sk_sndmsg_off; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24050;&#20351;&#29992;&#25968;&#25454;&#30340;&#32467;&#26463;&#20301;&#32622;&#20559;&#31227;</span>
                        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">left</span>;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">page&#20013;&#23384;&#22312;&#21097;&#20313;&#31354;&#38388;</span>
                        <span style="color: #F92672;">if</span> (page &amp;&amp; (left = PAGE_SIZE - off) &gt; 0) {
                                <span style="color: #F92672;">if</span> (copy &gt;= left) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24453;&#22797;&#21046;&#25968;&#25454;&#22823;&#20110;&#21097;&#20313;&#31354;&#38388;</span>
                                        copy = left;
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#32531;&#23384;&#39029;&#19981;&#26159;&#26368;&#21518;&#19968;&#20010;&#32858;&#21512;&#20998;&#25955;I/O&#30340;&#39029;&#38754;</span>
                                <span style="color: #F92672;">if</span> (page != frag-&gt;page) {
                                        <span style="color: #F92672;">if</span> (i == MAX_SKB_FRAGS) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#32858;&#21512;&#20998;&#25955;I/O&#25968;&#25454;&#36824;&#27809;&#26377;&#28385;</span>
                                                err = -EMSGSIZE;
                                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">error</span>;
                                        }
                                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30452;&#25509;&#20351;&#29992;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#32531;&#23384;&#39029;</span>
                                        get_page(page);
                                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#32531;&#23384;&#39029;&#28155;&#21152;&#33267;&#32858;&#21512;&#20998;&#25955;I/O&#39029;&#25968;&#32452;&#20013;</span>
                                        skb_fill_page_desc(skb, i, page, sk-&gt;sk_sndmsg_off, 0);
                                        frag = &amp;skb_shinfo(skb)-&gt;frags[i];
                                }
                        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (i &lt; MAX_SKB_FRAGS) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32858;&#21512;&#20998;&#25955;I/O&#39029;&#25968;&#32452;&#27809;&#26377;&#36798;&#21040;&#19978;&#38480;</span>
                                <span style="color: #F92672;">if</span> (copy &gt; PAGE_SIZE)
                                        copy = PAGE_SIZE;
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;&#39029;&#38754;</span>
                                page = alloc_pages(sk-&gt;sk_allocation, 0);
                                <span style="color: #F92672;">if</span> (page == <span style="color: #AE81FF;">NULL</span>)  {
                                        err = -ENOMEM;
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">error</span>;
                                }
                                sk-&gt;sk_sndmsg_page = page;
                                sk-&gt;sk_sndmsg_off = 0;
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28155;&#21152;&#21040;&#32858;&#21512;&#20998;&#25955;I/O&#39029;&#38754;&#25968;&#32452;</span>
                                skb_fill_page_desc(skb, i, page, 0, 0);
                                frag = &amp;skb_shinfo(skb)-&gt;frags[i];
                                skb-&gt;truesize += PAGE_SIZE; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#32531;&#23384;&#22823;&#23567;</span>
                                atomic_add(PAGE_SIZE, &amp;sk-&gt;sk_wmem_alloc);
                        } <span style="color: #F92672;">else</span> {
                                err = -EMSGSIZE;
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">error</span>;
                        }
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#24453;&#21457;&#36865;&#25968;&#25454;&#22797;&#21046;&#21040;&#25351;&#23450;&#39029;&#38754;</span>
                        <span style="color: #F92672;">if</span> (getfrag(from, page_address(frag-&gt;page)+frag-&gt;page_offset+frag-&gt;size, offset, copy, skb-&gt;len, skb) &lt; 0) {
                                err = -EFAULT;
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">error</span>;
                        }
                        sk-&gt;sk_sndmsg_off += copy;
                        frag-&gt;size += copy;
                        skb-&gt;len += copy;
                        skb-&gt;data_len += copy;
                }
                offset += copy;
                length -= copy;
        }
        <span style="color: #F92672;">return</span> 0;
<span style="color: #AE81FF;">error</span>:
        inet-&gt;cork.length -= length;
        IP_INC_STATS(IPSTATS_MIB_OUTDISCARDS);
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8e055be" class="outline-4">
<h4 id="org8e055be"><span class="section-number-4">11.3.2.</span> ip_ufo_append_data()</h4>
<div class="outline-text-4" id="text-11-3-2">
<p>
该函数将数据复制到输出队列末尾SKB的聚合分散I/O页面中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_ufo_append_data</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
                        <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">getfrag</span>(<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">from</span>, <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">to</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">offset</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>,
                               <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">odd</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>),
                        <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">from</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">length</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hh_len</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fragheaderlen</span>,
                        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">transhdrlen</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mtu</span>,<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">There is support for UDP fragmentation offload by network</span>
<span style="color: #75715E;">         * device, so create one single skb packet containing complete</span>
<span style="color: #75715E;">         * udp datagram</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> ((skb = skb_peek_tail(&amp;sk-&gt;sk_write_queue)) == <span style="color: #AE81FF;">NULL</span>) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#38431;&#21015;&#20026;&#31354;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;&#26032;&#30340;SKB,&#24182;&#22312;SKB&#32447;&#24615;&#21306;&#39044;&#30041;&#38142;&#36335;&#23618;&#12289;&#32593;&#32476;&#23618;&#12289;&#20256;&#36755;&#23618;&#39318;&#37096;&#31354;&#38388;&#12290;</span>
                skb = sock_alloc_send_skb(sk,
                        hh_len + fragheaderlen + transhdrlen + 20,
                        (flags &amp; MSG_DONTWAIT), &amp;err);
                <span style="color: #F92672;">if</span> (skb == <span style="color: #AE81FF;">NULL</span>)
                        <span style="color: #F92672;">return</span> err;
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">reserve space for Hardware header</span><span style="color: #75715E;"> */</span>
                skb_reserve(skb, hh_len);
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">create space for UDP/IP header</span><span style="color: #75715E;"> */</span>
                skb_put(skb,fragheaderlen + transhdrlen);
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">initialize network header pointer</span><span style="color: #75715E;"> */</span>
                skb-&gt;nh.raw = skb-&gt;data;
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">initialize protocol header pointer</span><span style="color: #75715E;"> */</span>
                skb-&gt;h.raw = skb-&gt;data + fragheaderlen;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#26657;&#39564;&#30456;&#20851;&#20449;&#24687;</span>
                skb-&gt;ip_summed = CHECKSUM_PARTIAL;
                skb-&gt;csum = 0;
                sk-&gt;sk_sndmsg_off = 0;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#25968;&#25454;&#22797;&#21046;&#21040;&#32858;&#21512;&#20998;&#25955;I/O&#39029;&#38754;&#20013;</span>
        err = skb_append_datato_frags(sk,skb, getfrag, from,
                               (length - transhdrlen));
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>err) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">specify the length of each IP datagram fragment</span><span style="color: #75715E;">*/</span>
                skb_shinfo(skb)-&gt;gso_size = mtu - fragheaderlen;
                skb_shinfo(skb)-&gt;gso_type = SKB_GSO_UDP;
                __skb_queue_tail(&amp;sk-&gt;sk_write_queue, skb);

                <span style="color: #F92672;">return</span> 0;
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">There is not enough support do UFO ,</span>
<span style="color: #75715E;">         * so follow normal path</span>
<span style="color: #75715E;">         */</span>
        kfree_skb(skb);
        <span style="color: #F92672;">return</span> err;
}

</pre>
</div>

<ul class="org-ul">
<li>skb_append_datato_frags()函数用于将数据复制到SKB的聚合分散I/O页面中，直到复制完成或者SKB空间已满。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * skb_append_datato_frags: - append the user data to a skb</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@sk</span><span style="color: #E6DB74;">: sock  structure</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@skb</span><span style="color: #E6DB74;">: skb structure to be appened with user data.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@getfrag</span><span style="color: #E6DB74;">: call back function to be used for getting the user data</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@from</span><span style="color: #E6DB74;">: pointer to user message iov</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@length</span><span style="color: #E6DB74;">: length of the iov message</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * Description: This procedure append the user data in the fragment part</span>
<span style="color: #E6DB74;"> * of the skb if any page alloc fails user this procedure returns  -ENOMEM</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">skb_append_datato_frags</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>,
                        <span style="color: #66D9EF;">int</span> (*<span style="color: #A6E22E;">getfrag</span>)(<span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">from</span>, <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">to</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">offset</span>,
                                        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">odd</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>),
                        <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">from</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">length</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">frg_cnt</span> = 0;
        <span style="color: #66D9EF;">skb_frag_t</span> *<span style="color: #FD971F;">frag</span> = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> *<span style="color: #FD971F;">page</span> = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">copy</span>, <span style="color: #FD971F;">left</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">offset</span> = 0;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ret</span>;

        <span style="color: #F92672;">do</span> {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Return error if we don't have space for new frag</span><span style="color: #75715E;"> */</span>
                frg_cnt = skb_shinfo(skb)-&gt;nr_frags; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#24403;&#21069;&#30340;frags&#25968;&#32452;&#39033;&#30340;&#25968;&#30446;</span>
                <span style="color: #F92672;">if</span> (frg_cnt &gt;= MAX_SKB_FRAGS)
                        <span style="color: #F92672;">return</span> -EFAULT;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20998;&#37197;&#31354;&#38386;&#39029;</span><span style="color: #75715E;"> */</span>
                page = alloc_pages(sk-&gt;sk_allocation, 0);
                <span style="color: #F92672;">if</span> (page == <span style="color: #AE81FF;">NULL</span>)
                        <span style="color: #F92672;">return</span> -ENOMEM;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#19979;&#19968;&#20010;frag&#25968;&#32452;&#39033;</span><span style="color: #75715E;"> */</span>
                sk-&gt;sk_sndmsg_page = page;
                sk-&gt;sk_sndmsg_off = 0;
                skb_fill_page_desc(skb, frg_cnt, page, 0, 0);
                skb-&gt;truesize += PAGE_SIZE;
                atomic_add(PAGE_SIZE, &amp;sk-&gt;sk_wmem_alloc);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">get the new initialized frag</span><span style="color: #75715E;"> */</span>
                frg_cnt = skb_shinfo(skb)-&gt;nr_frags;
                frag = &amp;skb_shinfo(skb)-&gt;frags[frg_cnt - 1];

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">copy the user data to page</span><span style="color: #75715E;"> */</span>
                left = PAGE_SIZE - frag-&gt;page_offset;
                copy = (length &gt; left)? left : length;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#25968;&#25454;</span>
                ret = getfrag(from, (page_address(frag-&gt;page) +
                            frag-&gt;page_offset + frag-&gt;size),
                            offset, copy, 0, skb);
                <span style="color: #F92672;">if</span> (ret &lt; 0)
                        <span style="color: #F92672;">return</span> -EFAULT;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">copy was successful so update the size parameters</span><span style="color: #75715E;"> */</span>
                sk-&gt;sk_sndmsg_off += copy;
                frag-&gt;size += copy;
                skb-&gt;len += copy;
                skb-&gt;data_len += copy;
                offset += copy;
                length -= copy;

        } <span style="color: #F92672;">while</span> (length &gt; 0);
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org93b436c" class="outline-4">
<h4 id="org93b436c"><span class="section-number-4">11.3.3.</span> ip_push_pending_frames()</h4>
<div class="outline-text-4" id="text-11-3-3">
<p>
该函数将输出队列上的多个分片合成一个完整的IP数据报，并通过ip_output()输出。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *      Combined all pending IP fragments on the socket as one IP datagram</span>
<span style="color: #75715E;"> *      and push them out.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">ip_push_pending_frames</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, *<span style="color: #FD971F;">tmp_skb</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> **<span style="color: #FD971F;">tail_skb</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ip_options</span> *<span style="color: #FD971F;">opt</span> = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rtable</span> *<span style="color: #FD971F;">rt</span> = inet-&gt;cork.rt;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>;
        <span style="color: #66D9EF;">__be16</span> <span style="color: #FD971F;">df</span> = 0;
        <span style="color: #66D9EF;">__u8</span> <span style="color: #FD971F;">ttl</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span> = 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#38431;&#21015;&#20026;&#31354;&#65292;&#26080;&#38656;&#22788;&#29702;</span>
        <span style="color: #F92672;">if</span> ((skb = __skb_dequeue(&amp;sk-&gt;sk_write_queue)) == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        tail_skb = &amp;(skb_shinfo(skb)-&gt;frag_list); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;fraglist&#38142;&#34920;&#29992;&#20110;&#23384;&#25918;&#22788;&#29702;&#21518;&#30340;&#20998;&#29255;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26657;&#27491;IP&#39318;&#37096;&#20301;&#32622;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (skb-&gt;data &lt; skb-&gt;nh.raw)
                __skb_pull(skb, skb-&gt;nh.raw - skb-&gt;data);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24490;&#29615;&#22788;&#29702;&#36755;&#20986;&#38431;&#21015;&#30340;SKB</span>
        <span style="color: #F92672;">while</span> ((tmp_skb = __skb_dequeue(&amp;sk-&gt;sk_write_queue)) != <span style="color: #AE81FF;">NULL</span>) {
                __skb_pull(tmp_skb, skb-&gt;h.raw - skb-&gt;nh.raw);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38142;&#25509;&#21040;frag_list&#38142;&#34920;&#30340;&#26411;&#23614;</span>
                *tail_skb = tmp_skb;
                tail_skb = &amp;(tmp_skb-&gt;next);
                skb-&gt;len += tmp_skb-&gt;len;
                skb-&gt;data_len += tmp_skb-&gt;len;
                skb-&gt;truesize += tmp_skb-&gt;truesize;
                __sock_put(tmp_skb-&gt;sk);
                tmp_skb-&gt;destructor = <span style="color: #AE81FF;">NULL</span>;
                tmp_skb-&gt;sk = <span style="color: #AE81FF;">NULL</span>;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Unless user demanded real pmtu discovery (IP_PMTUDISC_DO), we allow</span>
<span style="color: #75715E;">         * to fragment the frame generated here. No matter, what transforms</span>
<span style="color: #75715E;">         * how transforms change size of the packet, it will come out.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (inet-&gt;pmtudisc != IP_PMTUDISC_DO)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#21551;&#29992;&#36335;&#24452;MTU&#21457;&#29616;&#65292;&#21017;&#21487;&#20197;&#20998;&#29255;</span>
                skb-&gt;local_df = 1;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">DF bit is set when we want to see DF on outgoing frames.</span>
<span style="color: #75715E;">         * If local_df is set too, we still allow to fragment this frame</span>
<span style="color: #75715E;">         * locally.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (inet-&gt;pmtudisc == IP_PMTUDISC_DO ||  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21551;&#21160;&#36335;&#24452;MTU&#21457;&#29616;</span>
            (skb-&gt;len &lt;= dst_mtu(&amp;rt-&gt;u.dst) &amp;&amp;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25968;&#25454;&#25253;&#38271;&#24230;&#23567;&#20110;MTU</span>
             ip_dont_fragment(sk, &amp;rt-&gt;u.dst))) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#23450;&#20102;&#31105;&#27490;&#20998;&#29255;&#26631;&#24535;</span>
                df = htons(IP_DF); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31105;&#27490;&#20998;&#29255;</span>

        <span style="color: #F92672;">if</span> (inet-&gt;cork.flags &amp; IPCORK_OPT)  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#25351;&#23450;&#20102;IP&#36873;&#39033;&#20449;&#24687;</span>
                opt = inet-&gt;cork.opt;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">ttl</span>
        <span style="color: #F92672;">if</span> (rt-&gt;rt_type == RTN_MULTICAST)
                ttl = inet-&gt;mc_ttl;
        <span style="color: #F92672;">else</span>
                ttl = ip_select_ttl(inet, &amp;rt-&gt;u.dst);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26500;&#24314;IP&#39318;&#37096;</span>
        iph = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *)skb-&gt;data;
        iph-&gt;version = 4;
        iph-&gt;ihl = 5;
        <span style="color: #F92672;">if</span> (opt) {
                iph-&gt;ihl += opt-&gt;optlen&gt;&gt;2;
                ip_options_build(skb, opt, inet-&gt;cork.addr, rt, 0);
        }
        iph-&gt;tos = inet-&gt;tos;
        iph-&gt;tot_len = htons(skb-&gt;len);
        iph-&gt;frag_off = df;
        ip_select_ident(iph, &amp;rt-&gt;u.dst, sk);
        iph-&gt;ttl = ttl;
        iph-&gt;protocol = sk-&gt;sk_protocol;
        iph-&gt;saddr = rt-&gt;rt_src;
        iph-&gt;daddr = rt-&gt;rt_dst;
        ip_send_check(iph);

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#25968;&#25454;&#25253;&#20248;&#20808;&#32423;&#20197;&#21450;&#30446;&#30340;&#36335;&#30001;</span>
        skb-&gt;priority = sk-&gt;sk_priority;
        skb-&gt;dst = dst_clone(&amp;rt-&gt;u.dst);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Netfilter gets whole the not fragmented skb.</span><span style="color: #75715E;"> */</span>
        err = NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, <span style="color: #AE81FF;">NULL</span>,
                      skb-&gt;dst-&gt;dev, dst_output);
        <span style="color: #F92672;">if</span> (err) {
                <span style="color: #F92672;">if</span> (err &gt; 0)
                        err = inet-&gt;recverr ? net_xmit_errno(err) : 0;
                <span style="color: #F92672;">if</span> (err)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">error</span>;
        }
<span style="color: #AE81FF;">out</span>:
        inet-&gt;cork.flags &amp;= ~IPCORK_OPT;
        kfree(inet-&gt;cork.opt);
        inet-&gt;cork.opt = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #F92672;">if</span> (inet-&gt;cork.rt) {
                ip_rt_put(inet-&gt;cork.rt);
                inet-&gt;cork.rt = <span style="color: #AE81FF;">NULL</span>;
        }
        <span style="color: #F92672;">return</span> err;

<span style="color: #AE81FF;">error</span>:
        IP_INC_STATS(IPSTATS_MIB_OUTDISCARDS);
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
}
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org7d39745" class="outline-2">
<h2 id="org7d39745"><span class="section-number-2">12.</span> IP层对GSO的支持</h2>
<div class="outline-text-2" id="text-12">
<p>
IP层的GSO操作接口只是用来给链路层访问传输层。
</p>
</div>

<div id="outline-container-orgc72c95f" class="outline-3">
<h3 id="orgc72c95f"><span class="section-number-3">12.1.</span> inet_gso_segment()</h3>
<div class="outline-text-3" id="text-12-1">
<p>
ip层的gso_segment接口的实现为 inet_gso_segment() 函数，该函数根据数据包获取对应的传输层接口，并完成GSO分段，之后对分段后的数据报重新计算校验和。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #A6E22E;">inet_gso_segment</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">features</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">segs</span> = ERR_PTR(-EINVAL);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_protocol</span> *<span style="color: #FD971F;">ops</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">proto</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ihl</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">id</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;SKB&#30340;gso_type</span>
        <span style="color: #F92672;">if</span> (unlikely(skb_shinfo(skb)-&gt;gso_type &amp;
                     ~(SKB_GSO_TCPV4 |
                       SKB_GSO_UDP |
                       SKB_GSO_DODGY |
                       SKB_GSO_TCP_ECN |
                       0)))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">SKB&#25968;&#25454;&#25253;&#38271;&#24230;&#33267;&#23569;&#22823;&#20110;IP&#39318;&#37096;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_may_pull(skb, <span style="color: #F92672;">sizeof</span>(*iph))))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        iph = skb-&gt;nh.iph;
        ihl = iph-&gt;ihl * 4;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;IP&#39318;&#37096;&#20013;&#30340;&#38271;&#24230;&#26159;&#21542;&#26377;&#25928;</span>
        <span style="color: #F92672;">if</span> (ihl &lt; <span style="color: #F92672;">sizeof</span>(*iph))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;IP&#39318;&#37096;&#20013;&#30340;&#38271;&#24230;&#65292;&#26657;&#39564;&#25968;&#25454;&#21253;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_may_pull(skb, ihl)))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        skb-&gt;h.raw = __skb_pull(skb, ihl);
        iph = skb-&gt;nh.iph;
        id = ntohs(iph-&gt;id);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;IP&#39318;&#37096;&#30340;id&#23383;&#27573;</span>
        proto = iph-&gt;protocol &amp; (MAX_INET_PROTOS - 1);
        segs = ERR_PTR(-EPROTONOSUPPORT);

        rcu_read_lock();
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;IP&#39318;&#37096;&#30340;&#20256;&#36755;&#23618;&#21327;&#35758;&#65292;&#33719;&#21462;&#23545;&#24212;&#30340;&#20256;&#36755;&#23618;&#21327;&#35758;&#25509;&#21475;</span>
        ops = rcu_dereference(inet_protos[proto]);
        <span style="color: #F92672;">if</span> (likely(ops &amp;&amp; ops-&gt;gso_segment))
                segs = ops-&gt;gso_segment(skb, features);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36827;&#34892;GSO&#36719;&#20998;&#27573;&#65292;&#25152;&#26377;&#20998;&#27573;&#36890;&#36807;skb&#30340;next&#38142;&#25509; &#65288;tcp&#20026;tcp_tso_segment()&#65289;</span>
        rcu_read_unlock();

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>segs || unlikely(IS_ERR(segs)))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        skb = segs;
        <span style="color: #F92672;">do</span> { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24490;&#29615;&#35745;&#31639;&#25152;&#26377;&#20998;&#27573;&#30340;IP&#26657;&#39564;&#21644;</span>
                iph = skb-&gt;nh.iph;
                iph-&gt;id = htons(id++);
                iph-&gt;tot_len = htons(skb-&gt;len - skb-&gt;mac_len);
                iph-&gt;check = 0;
                iph-&gt;check = ip_fast_csum(skb-&gt;nh.raw, iph-&gt;ihl);
        } <span style="color: #F92672;">while</span> ((skb = skb-&gt;next));

<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> segs;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbc54643" class="outline-3">
<h3 id="orgbc54643"><span class="section-number-3">12.2.</span> inet_gso_send_check()</h3>
<div class="outline-text-3" id="text-12-2">
<p>
IP层的gso_send_check的接口通过 inet_gso_send_check() 函数实现。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">inet_gso_send_check</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_protocol</span> *<span style="color: #FD971F;">ops</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">proto</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ihl</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span> = -EINVAL;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33267;&#23569;&#22823;&#20110;IP&#39318;&#37096;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_may_pull(skb, <span style="color: #F92672;">sizeof</span>(*iph))))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        iph = skb-&gt;nh.iph;
        ihl = iph-&gt;ihl * 4;
        <span style="color: #F92672;">if</span> (ihl &lt; <span style="color: #F92672;">sizeof</span>(*iph)) <span style="color: #75715E;">//</span><span style="color: #75715E;">IP&#39318;&#37096;&#38271;&#24230;&#20540;&#26159;&#21542;&#26377;&#25928;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;IP&#39318;&#37096;&#38271;&#24230;&#26657;&#39564;&#25968;&#25454;&#21253;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_may_pull(skb, ihl)))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;

        skb-&gt;h.raw = __skb_pull(skb, ihl);
        iph = skb-&gt;nh.iph;
        proto = iph-&gt;protocol &amp; (MAX_INET_PROTOS - 1);
        err = -EPROTONOSUPPORT;

        rcu_read_lock();
        ops = rcu_dereference(inet_protos[proto]); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#20256;&#36755;&#23618;&#21327;&#35758;&#25509;&#21475;</span>
        <span style="color: #F92672;">if</span> (likely(ops &amp;&amp; ops-&gt;gso_send_check))
                err = ops-&gt;gso_send_check(skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#20256;&#36755;&#23618;&#30340;&#25509;&#21475;&#65288;tcp&#20026; tcp_v4_gso_send_check()&#65289;</span>
        rcu_read_unlock();

<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:55</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
