<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2021-12-31 Fri 23:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>IP: 网际协议</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="nandfan" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
	     margin-bottom: .2em; }
  .subtitle { text-align: center;
	      font-size: medium;
	      font-weight: bold;
	      margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
	    padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">IP: 网际协议</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd892bf5">1. 引言</a>
<ul>
<li><a href="#org34971c5">1.1. IP数据报的输入与输出</a></li>
</ul>
</li>
<li><a href="#orgafd6292">2. IP的私有信息控制块</a></li>
<li><a href="#orga9d92c7">3. 系统参数</a></li>
<li><a href="#orgd588053">4. 初始化 inet_init()</a></li>
<li><a href="#orgacb4b0d">5. IP层套接口选项</a></li>
<li><a href="#orgf4c3c83">6. ipv4_devconf结构</a></li>
<li><a href="#orgf5224f2">7. 套接口的错误队列</a>
<ul>
<li><a href="#orge06a80a">7.1. 添加ICMP差错信息</a></li>
<li><a href="#org326f913">7.2. 添加由本地产生的差错信息</a></li>
<li><a href="#orgca2edf6">7.3. 读取错误信息</a></li>
</ul>
</li>
<li><a href="#org356b05a">8. 报文控制信息</a>
<ul>
<li><a href="#org784de80">8.1. IP控制信息块</a></li>
<li><a href="#org20af58d">8.2. 报文控制信息的输出</a></li>
<li><a href="#org7946113">8.3. 报文控制信息的输入</a></li>
</ul>
</li>
<li><a href="#org639179b">9. 对端信息块</a>
<ul>
<li><a href="#org21bd5b3">9.1. 系统参数</a></li>
<li><a href="#org7241c81">9.2. 对端信息块的创建和查找</a></li>
<li><a href="#org9becd54">9.3. 对端信息块的删除</a></li>
<li><a href="#org457e342">9.4. 垃圾回收</a>
<ul>
<li><a href="#org427abc3">9.4.1. 对端信息块的释放</a></li>
<li><a href="#org3934a87">9.4.2. 同步清理</a></li>
<li><a href="#org72994f7">9.4.3. 异步清理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8d65c9d">10. IP数据包的输入处理</a>
<ul>
<li><a href="#orga9caab6">10.1. ip_rcv()</a></li>
<li><a href="#org8fc04ab">10.2. ip_rcv_finish()</a></li>
<li><a href="#orgf6df8e8">10.3. IP数据报输入到本地</a>
<ul>
<li><a href="#org3ad978b">10.3.1. ip_local_deliver()</a></li>
<li><a href="#org604d37c">10.3.2. ip_local_deliver_finish()</a></li>
</ul>
</li>
<li><a href="#org9829f53">10.4. IP数据报的转发</a></li>
</ul>
</li>
<li><a href="#org32eef23">11. IP数据报的输入处理</a>
<ul>
<li><a href="#orgf49ac25">11.1. IP数据报输出到设备</a>
<ul>
<li><a href="#org55a290b">11.1.1. dst_output()</a></li>
<li><a href="#org9a685c0">11.1.2. ip_output()</a></li>
<li><a href="#orgc182d82">11.1.3. ip_finish_output()</a></li>
<li><a href="#org6def299">11.1.4. ip_finish_output2()</a></li>
</ul>
</li>
<li><a href="#org34c9bc6">11.2. TCP输出的相关接口</a>
<ul>
<li><a href="#org9f25555">11.2.1. ip_queue_xmit()</a></li>
<li><a href="#orga7c26b6">11.2.2. ip_build_and_send_pkt()</a></li>
<li><a href="#org976b9b2">11.2.3. ip_send_reply()</a></li>
</ul>
</li>
<li><a href="#org00e4e0d">11.3. UDP输出接口</a>
<ul>
<li><a href="#orgf44ff8d">11.3.1. ip_append_data()</a></li>
<li><a href="#org36da131">11.3.2. ip_ufo_append_data()</a></li>
<li><a href="#orgdf2bc62">11.3.3. ip_push_pending_frames()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org530314d">12. IP层对GSO的支持</a>
<ul>
<li><a href="#org38d26fc">12.1. inet_gso_segment()</a></li>
<li><a href="#org0445795">12.2. inet_gso_send_check()</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgd892bf5" class="outline-2">
<h2 id="orgd892bf5"><span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
IP是TCP/IP协议族中的最为核心的协议，TCP UDP ICMP 和 IGMP都是以IP数据报的形式传输。
</p>


<div class="figure">
<p><img src="image/ip-proto/ipv4-proto.png" alt="ipv4-proto.png" />
</p>
<p><span class="figure-number">Figure 1: </span>IPv4协议族中不同层次的协议</p>
</div>
</div>

<div id="outline-container-org34971c5" class="outline-3">
<h3 id="org34971c5"><span class="section-number-3">1.1</span> IP数据报的输入与输出</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在输入数据时，网络层提供输入接口给链路层，并调用传输层输入接口将数据传递到传输层。
</p>

<p>
输出数据时，网络层提供输出接口给传输层，并调用链路层输出接口将数据输出到链路层。
</p>

<p>
在输入输出过程中，都需要查找路由，进行netfilter处理，下图展示了IP层主要函数的调用关系：
</p>


<div class="figure">
<p><img src="image/ip-proto/ip-layer-func.png" alt="ip-layer-func.png" />
</p>
<p><span class="figure-number">Figure 2: </span>IP层主要函数的调用关系</p>
</div>
</div>
</div>
</div>



<div id="outline-container-orgafd6292" class="outline-2">
<h2 id="orgafd6292"><span class="section-number-2">2</span> IP的私有信息控制块</h2>
<div class="outline-text-2" id="text-2">
<p>
IP层在SKB中有个 inet_skb_param 结构的信息控制块 skb_buff-&gt;cb 。IP层通过宏 IPCB 访问该成员。这个信息块主要存储IP选项，以及IP处理中需要设置的标志。
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_skb_parm</span>
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span>       <span style="color: #FF8C00;">opt</span>;            <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">IP&#36873;&#39033;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span>           <span style="color: #FF8C00;">flags</span>;

<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">IPSKB_FORWARDED</span>         1   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32452;&#25773;&#21253;&#24050;&#32463;&#36716;&#21457;&#36807;</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">IPSKB_XFRM_TUNNEL_SIZE</span>  2   <span style="color: #8B8878;">//</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">IPSKB_XFRM_TRANSFORMED</span>  4   <span style="color: #8B8878;">//</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">IPSKB_FRAG_COMPLETE</span>     8           <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23436;&#25104;&#20998;&#29255;</span>
<span style="color: #FF1493;">#define</span> <span style="color: #FF8C00;">IPSKB_REROUTED</span>          16  <span style="color: #8B8878;">//</span>
};

<span style="color: #FF1493;">#define</span> <span style="color: #87D700;">IPCB</span>(<span style="color: #FF8C00;">skb</span>) ((<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_skb_parm</span>*)((skb)-&gt;cb))
</pre>
</div>
</div>
</div>


<div id="outline-container-orga9d92c7" class="outline-2">
<h2 id="orga9d92c7"><span class="section-number-2">3</span> 系统参数</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>ip_default_ttl  IP数据报的默认生存时间。 可以通过IP_TTL设置数据报的生存时间。</li>

<li>ip_dynaddr</li>

<li>ip_forwarded 标识内核是否转发IP数据报</li>

<li>ip_local_port_range 在自动选择绑定端口时，TCP和UDP使用本地端口的范围。</li>

<li>ip_no_pmtu_disc 路径MTU</li>

<li>forwarding  标识网络设备是否启用ip数据报转发功能</li>

<li>mc_forwarding 是否启用组播路由功能</li>

<li>accept_redirects 是否接受ICMP重定向消息</li>

<li>rp_filter 标识是否对数据包的源地址进行检查</li>

<li>send_redirects 是否可以发送重定向消息</li>

<li>accept_source_route 是否接收存储在源路由选项的IP数据报</li>

<li>log_martians 遇到错误的IP地址时，是否记录到内核日志</li>

<li>disable_xfrm 是否禁止IPSEC加密</li>

<li>disable_policy 是否禁止IPSEC策略</li>

<li>promote_secondaries  在删除主地址时，第二IP地址是否能升级为主IP地址。</li>
</ul>
</div>
</div>


<div id="outline-container-orgd588053" class="outline-2">
<h2 id="orgd588053"><span class="section-number-2">4</span> 初始化 inet_init()</h2>
</div>


<div id="outline-container-orgacb4b0d" class="outline-2">
<h2 id="orgacb4b0d"><span class="section-number-2">5</span> IP层套接口选项</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>IP_OPTIONS 用来设置或者获取数据报的IP选项，最长40字节。可能的选项包括：

<ul class="org-ul">
<li>安全控制限制</li>
<li>记录路由</li>
<li>时间戳</li>
<li>松散源路由选择 访问路径中包含选项内列出的IP地址</li>
<li>严格源路由选择 只能访问选项内列出的IP地址</li>
</ul></li>

<li>IP_PKTINFO 控制是否允许通过IP_PKTOPTIONS选项或recvmsg系统调用来获取和本端地址相关的IP_PKTOPTIONS选项。</li>

<li>IP_RECVTTL 控制是否允许通过IP_PKTOPTIONS选项或recvmsg系统调用获取数据报的TTL</li>

<li>IP_RECVTOS 是否可以获取数据报的TOS</li>

<li>IP_RECVOPTS 是否可以获取IP数据包首部的IP选项</li>

<li>IP_RETOPTS 类似与IP_RECVOPTS, 不同的是获取为处理时间戳选项和记录路由选项的IP选项</li>

<li>IP_PASSSEC 是否可以获取有关安全的信息</li>

<li>IP_TOS 设置或者获取数据报的服务类型</li>

<li>IP_TTL 设置数据报的生存时间</li>

<li>IP_HDRINCL 为1时，发送函数会将IP首部作为数据的一部分包含在发送数据的前部，并使得接收函数也将IP首部作为数据的一部分</li>

<li>IP_MTU_DISCOVER 套接口是否启用路径MTU发现</li>

<li>IP_RECVERR 是否允许接收扩展的可靠错误信息，用户可通过设置了 MSG_ERRQUEUE 标识的 recvmsg() 来接收套接口操作中接收到的错误信息</li>

<li>IP_MTU 获取当前套接口的当前已知路径MTU。</li>

<li>IP_ROUTER_ALERT IP路由器警告选项</li>

<li>IP_PKTOPTIONS 设置了 IP_PKTINFO 或者 IP_RECVTTL 选项后，可通过此选项获取相关信息</li>

<li>IP_FREEBIND 用于标识是否允许绑定非本地主机地址</li>

<li>IP_IPSEC_POLICY 和 IP_XFRM_POLICY 用来设置IPSEC相关策略。</li>
</ul>
</div>
</div>


<div id="outline-container-orgf4c3c83" class="outline-2">
<h2 id="orgf4c3c83"><span class="section-number-2">6</span> ipv4_devconf结构</h2>
<div class="outline-text-2" id="text-6">
<p>
ipv4_devconf结构是网络设备接口的IPv4系统配置。 内核定义了一个 ipv4_devconf 全局变量，用于所有接口的配置，同时，设备内部也存在自身的一份配置。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ipv4_devconf</span>
{
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">accept_redirects</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#25509;&#25910;ICMP&#37325;&#23450;&#21521;&#25253;&#25991;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">send_redirects</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#21551;&#29992;ICMP&#37325;&#23450;&#21521;&#25253;&#25991;&#36755;&#20986;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">secure_redirects</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#25509;&#25910;ICMP&#37325;&#23450;&#21521;&#25253;&#25991;&#65292;&#21482;&#38024;&#23545;&#20855;&#26377;&#36335;&#30001;&#21151;&#33021;&#30340;&#32593;&#20851;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">shared_media</span>;
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">accept_source_route</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#25509;&#25910;&#24102;&#26377;SRR&#36873;&#39033;&#30340;&#25968;&#25454;&#25253;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">rp_filter</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#21551;&#29992;&#36890;&#36807;&#21453;&#21521;&#36335;&#24452;&#22238;&#28335;&#36827;&#34892;&#28304;&#22320;&#22336;&#39564;&#35777;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">proxy_arp</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#21551;&#29992;ARP&#20195;&#29702;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">bootp_relay</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#25509;&#25910;&#28304;&#22320;&#22336;&#20026; 0.b.c.d &#19988;&#30446;&#30340;&#22320;&#22336;&#38750;&#26412;&#26426;&#30340;&#25968;&#25454;&#25253;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">log_martians</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#24040;&#40575;&#38750;&#27861;&#22320;&#22336;&#30340;&#25968;&#25454;&#25253;&#21040;&#20869;&#26680;&#26085;&#24535;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">forwarding</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#21551;&#29992;ip&#25968;&#25454;&#25253;&#36716;&#21457;&#21151;&#33021;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">mc_forwarding</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#36827;&#34892;&#32452;&#25773;&#36335;&#30001;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">tag</span>;
	<span style="color: #5FD7FF;">int</span>   <span style="color: #FF8C00;">arp_filter</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20801;&#35768;&#20174;&#20854;&#20182;&#30340;&#32593;&#32476;&#35774;&#22791;&#36755;&#20986;ARP&#24212;&#31572;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">arp_announce</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;ARP&#35831;&#27714;&#26102;&#65292;&#30001;IP&#25968;&#25454;&#25253;&#30830;&#23450;&#28304;IP&#22320;&#22336;&#30340;&#35268;&#21017;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">arp_ignore</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;ARP&#35831;&#27714;&#25253;&#25991;&#30340;&#36807;&#28388;&#35268;&#21017;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">arp_accept</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#22788;&#29702;&#38750;ARP&#35831;&#27714;&#32780;&#25509;&#25910;&#30340;ARP&#24212;&#31572;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">medium_id</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#20110;&#21306;&#20998;&#19981;&#21516;&#23186;&#20171;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">no_xfrm</span>;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#21551;&#29992;XFRM</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">no_policy</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#21551;&#29992;&#31574;&#30053;&#36335;&#30001;</span>
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">force_igmp_version</span>;
	<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">promote_secondaries</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22312;&#21024;&#38500;&#20027;&#22320;&#22336;&#26102;&#65292;&#31532;&#20108;IP&#22320;&#22336;&#26159;&#21542;&#33021;&#21319;&#32423;&#20026;&#20027;IP&#22320;&#22336;</span>
	<span style="color: #5FD7FF;">void</span>    *<span style="color: #FF8C00;">sysctl</span>; <span style="color: #8B8878;">//</span>
};
</pre>
</div>
</div>
</div>


<div id="outline-container-orgf5224f2" class="outline-2">
<h2 id="orgf5224f2"><span class="section-number-2">7</span> 套接口的错误队列</h2>
<div class="outline-text-2" id="text-7">
<p>
传输控制块中有一个用于保存错误信息的队列 sk_err_queue，当ICMP接收到差错信息或者UDP RAW套接口输出报文错误时，会产生描述错误信息的SKB并添加到该队列。   应用程序可以通过设置 IP_RECVERR 选项，在通过设置了MSG_ERRQUEUE参数的flag，调用recvmsg系统调用来获取错误信息。
</p>


<p>
UDP和RAW套接口使用recvmsg从套接口接收数据时，通过设置MSG_ERRQUEUE标志，之接收错误队列的信息。 这个功能主要通过 ip_recv_error() 来完成。
</p>



<div class="figure">
<p><img src="dot/ip-proto/errqueue-func.png" alt="errqueue-func.png" />
</p>
</div>


<div class="figure">
<p><img src="image/ip-proto/sk-err-queue-func.png" alt="sk-err-queue-func.png" />
</p>
</div>


<p>
对于基于连接的套接口，IP_RECVERR选项具有不同含义，错误信息不会保存到错误队列，而是立即传递所有接收到的错误信息给用户进程。 因此TCP没有错误队列。
</p>


<p>
错误信息通过 struct sock_exterr_skb 结构来定义，保存在SKB控制块中，通过 SKB_EXT_ERR 宏来访问SKB控制块中的错误信息。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_exterr_skb</span>
{
	<span style="color: #FF1493;">union</span> {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_skb_parm</span>    <span style="color: #FF8C00;">h4</span>;
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet6_skb_parm</span>   <span style="color: #FF8C00;">h6</span>;
	} <span style="color: #FF8C00;">header</span>;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19982;IP&#25511;&#21046;&#22359;&#20860;&#23481;&#65292;&#21487;&#20197;&#23384;&#20648;IP&#36873;&#39033;&#20449;&#24687;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_extended_err</span>        <span style="color: #FF8C00;">ee</span>;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35760;&#24405;&#20986;&#38169;&#20449;&#24687;</span>
	<span style="color: #5FD7FF;">u16</span>                             <span style="color: #FF8C00;">addr_offset</span>;   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21407;&#22987;&#25968;&#25454;&#21253;&#30340;&#30446;&#30340;&#22320;&#22336;&#22312;&#36127;&#36733;ICMP&#25253;&#25991;&#30340;IP&#25968;&#25454;&#25253;&#20013;&#30340;&#20559;&#31227;&#37327;</span>
	<span style="color: #5FD7FF;">__be16</span>                  <span style="color: #FF8C00;">port</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23545;&#20110;UDP&#26159;&#20986;&#38169;&#25253;&#25991;&#30340;&#30446;&#30340;&#31471;&#21475;&#65292;&#20854;&#20182;&#24773;&#20917;&#20026;0</span>
};

<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_extended_err</span>
{
	<span style="color: #5FD7FF;">__u32</span>   <span style="color: #FF8C00;">ee_errno</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38169;&#35823;&#30721;</span>
	<span style="color: #5FD7FF;">__u8</span>    <span style="color: #FF8C00;">ee_origin</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20986;&#38169;&#20449;&#24687;&#30340;&#26469;&#28304;</span>
	<span style="color: #5FD7FF;">__u8</span>    <span style="color: #FF8C00;">ee_type</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26469;&#33258;ICMP&#28040;&#24687;&#26102;&#65292;&#34920;&#31034;ICMP&#24046;&#38169;&#28040;&#24687;&#30340;&#31867;&#22411;</span>
	<span style="color: #5FD7FF;">__u8</span>    <span style="color: #FF8C00;">ee_code</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26469;&#33258;ICMP&#28040;&#24687;&#26102;&#65292;&#34920;&#31034;ICMP&#24046;&#38169;&#28040;&#24687;&#30340;&#32534;&#30721;</span>
	<span style="color: #5FD7FF;">__u8</span>    <span style="color: #FF8C00;">ee_pad</span>;
	<span style="color: #5FD7FF;">__u32</span>   <span style="color: #FF8C00;">ee_info</span>;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25193;&#23637;&#20449;&#24687;</span>
	<span style="color: #5FD7FF;">__u32</span>   <span style="color: #FF8C00;">ee_data</span>;
};
</pre>
</div>
</div>

<div id="outline-container-orge06a80a" class="outline-3">
<h3 id="orge06a80a"><span class="section-number-3">7.1</span> 添加ICMP差错信息</h3>
<div class="outline-text-3" id="text-7-1">
<p>
ICMP模块收到ICMP差错信息时，调用原始数据包的传输层协议的差错处理例程，传输层的差错处理例程再调用 ip_icmp_error() 将出错信息添加到对应的错误队列。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">ip_icmp_error</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>,
		   <span style="color: #5FD7FF;">__be16</span> <span style="color: #FF8C00;">port</span>, <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">info</span>, <span style="color: #5FD7FF;">u8</span> *<span style="color: #FF8C00;">payload</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_exterr_skb</span> *<span style="color: #FF8C00;">serr</span>;

	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>inet-&gt;recverr)
		<span style="color: #FF1493;">return</span>;
	skb = skb_clone(skb, GFP_ATOMIC);
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb)
		<span style="color: #FF1493;">return</span>;
	serr = SKB_EXT_ERR(skb);
	serr-&gt;ee.ee_errno = err;
	serr-&gt;ee.ee_origin = SO_EE_ORIGIN_ICMP; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20986;&#38169;&#20449;&#24687;&#26469;&#33258;ICMP&#28040;&#24687;</span>
	serr-&gt;ee.ee_type = skb-&gt;h.icmph-&gt;type;
	serr-&gt;ee.ee_code = skb-&gt;h.icmph-&gt;code;
	serr-&gt;ee.ee_pad = 0;
	serr-&gt;ee.ee_info = info;
	serr-&gt;ee.ee_data = 0;
	serr-&gt;addr_offset = (<span style="color: #5FD7FF;">u8</span>*)&amp;(((<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>*)(skb-&gt;h.icmph+1))-&gt;daddr) - skb-&gt;nh.raw;
	serr-&gt;port = port;

	skb-&gt;h.raw = payload;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb_pull(skb, payload - skb-&gt;data) ||
	    sock_queue_err_skb(sk, skb)) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28155;&#21152;&#21040;&#38169;&#35823;&#38431;&#21015;&#65292;&#24182;&#21796;&#37266;&#23545;&#24212;&#36827;&#31243;</span>
		kfree_skb(skb);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org326f913" class="outline-3">
<h3 id="org326f913"><span class="section-number-3">7.2</span> 添加由本地产生的差错信息</h3>
<div class="outline-text-3" id="text-7-2">
<p>
UDP 或者 RAW 发送数据时，如果数据长度超过IP数据包能负载的长度，会调用ip_local_error() 将出错信息添加到对应的错误队列。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">ip_local_error</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>, <span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">daddr</span>, <span style="color: #5FD7FF;">__be16</span> <span style="color: #FF8C00;">port</span>, <span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">info</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_exterr_skb</span> *<span style="color: #FF8C00;">serr</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;

	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>inet-&gt;recverr)
		<span style="color: #FF1493;">return</span>;

	skb = alloc_skb(<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>), GFP_ATOMIC);
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb)
		<span style="color: #FF1493;">return</span>;

	iph = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>*)skb_put(skb, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>));
	skb-&gt;nh.iph = iph;
	iph-&gt;daddr = daddr;

	serr = SKB_EXT_ERR(skb);
	serr-&gt;ee.ee_errno = err;
	serr-&gt;ee.ee_origin = SO_EE_ORIGIN_LOCAL; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26469;&#33258;&#26412;&#22320;</span>
	serr-&gt;ee.ee_type = 0;
	serr-&gt;ee.ee_code = 0;
	serr-&gt;ee.ee_pad = 0;
	serr-&gt;ee.ee_info = info;
	serr-&gt;ee.ee_data = 0;
	serr-&gt;addr_offset = (u8*)&amp;iph-&gt;daddr - skb-&gt;nh.raw;
	serr-&gt;port = port;

	skb-&gt;h.raw = skb-&gt;tail;
	__skb_pull(skb, skb-&gt;tail - skb-&gt;data);

	<span style="color: #FF1493;">if</span> (sock_queue_err_skb(sk, skb)) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28155;&#21152;&#21040;&#38169;&#35823;&#38431;&#21015;&#65292;&#24182;&#21796;&#37266;&#23545;&#24212;&#36827;&#31243;</span>
		kfree_skb(skb);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgca2edf6" class="outline-3">
<h3 id="orgca2edf6"><span class="section-number-3">7.3</span> 读取错误信息</h3>
<div class="outline-text-3" id="text-7-3">
<p>
通过将flags设置为 MSG_ERRQUEUE，调用recvmsg()来读取传输控制块错误队列的信息。 UDP和RAW的recvmsg实现中，先检测是否存在MSG_ERRQUEUE标识，之后调用 ip_recv_error() 从错误队列读取错误信息。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">udp_recvmsg</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">kiocb</span> *<span style="color: #FF8C00;">iocb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">msghdr</span> *<span style="color: #FF8C00;">msg</span>,
		<span style="color: #5FD7FF;">size_t</span> <span style="color: #FF8C00;">len</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">noblock</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flags</span>, <span style="color: #5FD7FF;">int</span> *<span style="color: #FF8C00;">addr_len</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #FF1493;">if</span> (flags &amp; MSG_ERRQUEUE)
		<span style="color: #FF1493;">return</span> ip_recv_error(sk, msg, len);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
}
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">raw_recvmsg</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">kiocb</span> *<span style="color: #FF8C00;">iocb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">msghdr</span> *<span style="color: #FF8C00;">msg</span>,
		       <span style="color: #5FD7FF;">size_t</span> <span style="color: #FF8C00;">len</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">noblock</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flags</span>, <span style="color: #5FD7FF;">int</span> *<span style="color: #FF8C00;">addr_len</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #FF1493;">if</span> (flags &amp; MSG_ERRQUEUE) {
		err = ip_recv_error(sk, msg, len);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	}
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_recv_error</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">msghdr</span> *<span style="color: #FF8C00;">msg</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_exterr_skb</span> *<span style="color: #FF8C00;">serr</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, *<span style="color: #FF8C00;">skb2</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sockaddr_in</span> *<span style="color: #FF8C00;">sin</span>;
	<span style="color: #FF1493;">struct</span> {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_extended_err</span> <span style="color: #FF8C00;">ee</span>;
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sockaddr_in</span>       <span style="color: #FF8C00;">offender</span>;
	} <span style="color: #FF8C00;">errhdr</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">copied</span>;

	err = -EAGAIN;
	skb = skb_dequeue(&amp;sk-&gt;sk_error_queue);
	<span style="color: #FF1493;">if</span> (skb == <span style="color: #AF87FF;">NULL</span>) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38431;&#21015;&#27809;&#26377;&#38169;&#35823;&#20449;&#24687;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	copied = skb-&gt;len; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27599;&#27425;&#33719;&#21462;&#25968;&#25454;&#25253;&#30340;&#38271;&#24230;</span>
	<span style="color: #FF1493;">if</span> (copied &gt; len) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#36229;&#36807;&#32531;&#20914;&#21306;&#38271;&#24230;&#65292;&#28155;&#21152;MSG_TRUNC&#26631;&#35782;</span>
		msg-&gt;msg_flags |= MSG_TRUNC;
		copied = len;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#25968;&#25454;&#25253;&#30340;&#25968;&#25454;&#22797;&#21046;&#21040;&#32531;&#23384;&#20013;</span>
	err = skb_copy_datagram_iovec(skb, 0, msg-&gt;msg_iov, copied);
	<span style="color: #FF1493;">if</span> (err)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out_free_skb</span>;
	sock_recv_timestamp(msg, sk, skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35760;&#24405;&#26102;&#38388;&#25139;</span>
	serr = SKB_EXT_ERR(skb);
	sin = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sockaddr_in</span> *)msg-&gt;msg_name;
	<span style="color: #FF1493;">if</span> (sin) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22797;&#21046;&#21407;&#22987;&#25968;&#25454;&#25253;&#30340;&#30446;&#30340;&#22320;&#22336;&#21644;&#30446;&#30340;&#31471;&#21475;</span>
		sin-&gt;sin_family = AF_INET;
		sin-&gt;sin_addr.s_addr = *(__be32*)(skb-&gt;nh.raw + serr-&gt;addr_offset);
		sin-&gt;sin_port = serr-&gt;port;
		memset(&amp;sin-&gt;sin_zero, 0, <span style="color: #FF1493;">sizeof</span>(sin-&gt;sin_zero));
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22797;&#21046;&#38169;&#35823;&#20449;&#24687;&#22359;&#30340;&#20869;&#23481;</span>
	memcpy(&amp;errhdr.ee, &amp;serr-&gt;ee, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock_extended_err</span>));
	sin = &amp;errhdr.offender;
	sin-&gt;sin_family = AF_UNSPEC;
	<span style="color: #FF1493;">if</span> (serr-&gt;ee.ee_origin == SO_EE_ORIGIN_ICMP) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26469;&#33258;ICMP&#30340;&#24046;&#38169;&#28040;&#24687;</span>
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(sk);
		sin-&gt;sin_family = AF_INET;
		sin-&gt;sin_addr.s_addr = skb-&gt;nh.iph-&gt;saddr; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#28304;&#22320;&#22336;</span>
		sin-&gt;sin_port = 0;
		memset(&amp;sin-&gt;sin_zero, 0, <span style="color: #FF1493;">sizeof</span>(sin-&gt;sin_zero));
		<span style="color: #FF1493;">if</span> (inet-&gt;cmsg_flags)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38656;&#35201;&#33719;&#21462;&#25253;&#25991;&#25511;&#21046;&#20449;&#24687;</span>
			ip_cmsg_recv(msg, skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22797;&#21046;&#25253;&#25991;&#25511;&#21046;&#20449;&#24687;&#21040;&#28040;&#24687;&#22836;</span>
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22797;&#21046;&#38169;&#35823;&#20449;&#24687;&#30340;&#25193;&#23637;&#20449;&#24687;</span>
	put_cmsg(msg, SOL_IP, IP_RECVERR, <span style="color: #FF1493;">sizeof</span>(errhdr), &amp;errhdr);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;MSG_ERRQUEUE&#26631;&#35782;&#65292;&#34920;&#31034;&#25509;&#25910;&#21040;&#30340;&#26159;&#20986;&#38169;&#20449;&#24687;</span>
	msg-&gt;msg_flags |= MSG_ERRQUEUE;
	err = copied;
	spin_lock_bh(&amp;sk-&gt;sk_error_queue.lock);
	sk-&gt;sk_err = 0;
	<span style="color: #FF1493;">if</span> ((skb2 = skb_peek(&amp;sk-&gt;sk_error_queue)) != <span style="color: #AF87FF;">NULL</span>) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38431;&#21015;&#19981;&#20026;&#31354;&#65292;&#21796;&#37266;&#31561;&#24453;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#36827;&#31243;</span>
		sk-&gt;sk_err = SKB_EXT_ERR(skb2)-&gt;ee.ee_errno;
		spin_unlock_bh(&amp;sk-&gt;sk_error_queue.lock);
		sk-&gt;sk_error_report(sk);
	} <span style="color: #FF1493;">else</span>
		spin_unlock_bh(&amp;sk-&gt;sk_error_queue.lock);
<span style="color: #AF87FF;">out_free_skb</span>:
	kfree_skb(skb);
<span style="color: #AF87FF;">out</span>:
	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org356b05a" class="outline-2">
<h2 id="org356b05a"><span class="section-number-2">8</span> 报文控制信息</h2>
<div class="outline-text-2" id="text-8">
<p>
设置 IP_PKTINFO 选项的UDP或者RAW套接口，可以通过recvmsg函数在接收数据的同时，获取报文的控制信息。
</p>

<p>
UDP或者RAW在通过sendmsg函数输出数据时，可以将报文控制信息复制到输出数据的消息头，来发送控制信息。
</p>
</div>

<div id="outline-container-org784de80" class="outline-3">
<h3 id="org784de80"><span class="section-number-3">8.1</span> IP控制信息块</h3>
<div class="outline-text-3" id="text-8-1">
<p>
IP控制信息块由ipcm_cookie结构来描述。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ipcm_cookie</span>
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">UDP&#25110;&#32773;RAW&#25968;&#25454;&#25253;&#30340;&#30446;&#30340;&#22320;&#22336;&#65292;&#21482;&#26377;&#23384;&#22312;IP&#36873;&#39033;&#26102;&#25165;&#35774;&#32622;&#65292;&#29992;&#20316;&#28304;&#36335;&#30001;&#36873;&#39033;&#30340;&#26368;&#21518;&#19968;&#36339;&#22320;&#22336;</span>
	<span style="color: #5FD7FF;">__be32</span>          <span style="color: #FF8C00;">addr</span>;
	<span style="color: #5FD7FF;">int</span>                     <span style="color: #FF8C00;">oif</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">UDP&#25110;&#32773;RAW&#25968;&#25454;&#25253;&#30340;&#36755;&#20986;&#32593;&#32476;&#35774;&#22791;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span>       *<span style="color: #FF8C00;">opt</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25351;&#21521;&#21457;&#36865;&#25968;&#25454;&#25253;&#30340;IP&#36873;&#39033;&#20449;&#24687;</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org20af58d" class="outline-3">
<h3 id="org20af58d"><span class="section-number-3">8.2</span> 报文控制信息的输出</h3>
<div class="outline-text-3" id="text-8-2">
<p>
UDP或者RAW通过sendmsg输出数据时，先检测是否存在控制信息，存在则调用ip_cmsg_send() 将控制信息获取到IP控制信息块中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">udp_sendmsg</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">kiocb</span> *<span style="color: #FF8C00;">iocb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">msghdr</span> *<span style="color: #FF8C00;">msg</span>,
		<span style="color: #5FD7FF;">size_t</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">....</span>
	<span style="color: #FF1493;">if</span> (msg-&gt;msg_controllen) {
		err = ip_cmsg_send(msg, &amp;ipc);
}
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">raw_sendmsg</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">kiocb</span> *<span style="color: #FF8C00;">iocb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">msghdr</span> *<span style="color: #FF8C00;">msg</span>,
		       <span style="color: #5FD7FF;">size_t</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	<span style="color: #FF1493;">if</span> (msg-&gt;msg_controllen) {
		err = ip_cmsg_send(msg, &amp;ipc);
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_cmsg_send</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">msghdr</span> *<span style="color: #FF8C00;">msg</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ipcm_cookie</span> *<span style="color: #FF8C00;">ipc</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">cmsghdr</span> *<span style="color: #FF8C00;">cmsg</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36941;&#21382;&#28040;&#24687;&#22836;&#20013;&#30340;&#21508;&#31181;&#31867;&#22411;&#30340;&#25511;&#21046;&#20449;&#24687;</span>
	<span style="color: #FF1493;">for</span> (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>CMSG_OK(msg, cmsg)) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;&#25511;&#21046;&#20449;&#24687;&#38271;&#24230;</span>
			<span style="color: #FF1493;">return</span> -EINVAL;
		<span style="color: #FF1493;">if</span> (cmsg-&gt;cmsg_level != SOL_IP) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#25968;&#25454;&#25253;&#30340;&#25511;&#21046;&#20449;&#24687;&#65292;&#32423;&#21035;&#24517;&#39035;&#20026;SOL_IP</span>
			<span style="color: #FF1493;">continue</span>;
		<span style="color: #FF1493;">switch</span> (cmsg-&gt;cmsg_type) {
		<span style="color: #FF1493;">case</span> IP_RETOPTS: <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;IP&#36873;&#39033;</span>
			err = cmsg-&gt;cmsg_len - CMSG_ALIGN(<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">cmsghdr</span>));
			err = ip_options_get(&amp;ipc-&gt;opt, CMSG_DATA(cmsg), err &lt; 40 ? err : 40);
			<span style="color: #FF1493;">if</span> (err)
				<span style="color: #FF1493;">return</span> err;
			<span style="color: #FF1493;">break</span>;
		<span style="color: #FF1493;">case</span> IP_PKTINFO:
		{
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">in_pktinfo</span> *<span style="color: #FF8C00;">info</span>;
			<span style="color: #FF1493;">if</span> (cmsg-&gt;cmsg_len != CMSG_LEN(<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">in_pktinfo</span>)))
				<span style="color: #FF1493;">return</span> -EINVAL;
			info = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">in_pktinfo</span> *)CMSG_DATA(cmsg);
			ipc-&gt;oif = info-&gt;ipi_ifindex;
			ipc-&gt;addr = info-&gt;ipi_spec_dst.s_addr;
			<span style="color: #FF1493;">break</span>;
		}
		<span style="color: #FF1493;">default</span>:
			<span style="color: #FF1493;">return</span> -EINVAL;
		}
	}
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org7946113" class="outline-3">
<h3 id="org7946113"><span class="section-number-3">8.3</span> 报文控制信息的输入</h3>
<div class="outline-text-3" id="text-8-3">
<p>
UDP和RAW的套接口设置了IP_PKTINFO报文控制信息的选项后，在调用recvmsg时，会调用ip_cmsg_recv()获取报文的控制信息（正常数据和错误信息都会获取）。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">ip_cmsg_recv</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">msghdr</span> *<span style="color: #FF8C00;">msg</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(skb-&gt;sk);
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #FF8C00;">flags</span> = inet-&gt;cmsg_flags;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20197;&#19979;&#39034;&#24207;&#25353;&#20351;&#29992;&#39057;&#29575;&#25490;&#24207;</span><span style="color: #8B8878;"> */</span>

	<span style="color: #FF1493;">if</span> (flags &amp; 1) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#20102;IP_CMSG_PKTINFO&#36873;&#39033;</span>
		ip_cmsg_recv_pktinfo(msg, skb);
	<span style="color: #FF1493;">if</span> ((flags&gt;&gt;=1) == 0)
		<span style="color: #FF1493;">return</span>;

	<span style="color: #FF1493;">if</span> (flags &amp; 1) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">ttl</span>
		ip_cmsg_recv_ttl(msg, skb);
	<span style="color: #FF1493;">if</span> ((flags&gt;&gt;=1) == 0)
		<span style="color: #FF1493;">return</span>;

	<span style="color: #FF1493;">if</span> (flags &amp; 1) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">tos</span>
		ip_cmsg_recv_tos(msg, skb);
	<span style="color: #FF1493;">if</span> ((flags&gt;&gt;=1) == 0)
		<span style="color: #FF1493;">return</span>;

	<span style="color: #FF1493;">if</span> (flags &amp; 1) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">IP_CMSG_RECVOPTS</span>
		ip_cmsg_recv_opts(msg, skb);
	<span style="color: #FF1493;">if</span> ((flags&gt;&gt;=1) == 0)
		<span style="color: #FF1493;">return</span>;

	<span style="color: #FF1493;">if</span> (flags &amp; 1) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">IP_CMSG_RETOPTS</span>
		ip_cmsg_recv_retopts(msg, skb);
	<span style="color: #FF1493;">if</span> ((flags&gt;&gt;=1) == 0)
		<span style="color: #FF1493;">return</span>;

	<span style="color: #FF1493;">if</span> (flags &amp; 1) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">IP_CMSG_PASSSEC</span>
		ip_cmsg_recv_security(msg, skb);
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org639179b" class="outline-2">
<h2 id="org639179b"><span class="section-number-2">9</span> 对端信息块</h2>
<div class="outline-text-2" id="text-9">
<p>
对端信息块用来保存对端的一些信息，包括对端地址、传输层时间戳&#x2026;.. 通过 struct inet_peer 结构来描述。
</p>

<p>
对端信息块主要用于在组装IP数据报时防止IP分片攻击，在建立TCP连接时检测连接请求段是否有效，以及序号是否回绕。
</p>

<p>
对端信息块以v4daddr为关键字，peer_root为根，组织成AVL树。
</p>



<div class="figure">
<p><img src="dot/ip-proto/inet-peer.png" alt="inet-peer.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span>
{
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">avl_left,avl_right,v4daddr&#29992;&#20110;&#32452;&#25104;AVL&#26641;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span>        *<span style="color: #FF8C00;">avl_left</span>, *<span style="color: #FF8C00;">avl_right</span>;
	<span style="color: #5FD7FF;">__be32</span>          <span style="color: #FF8C00;">v4daddr</span>;        <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23545;&#31471;IP&#22320;&#22336;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">__u16</span>                   <span style="color: #FF8C00;">avl_height</span>;
	<span style="color: #5FD7FF;">__u16</span>                   <span style="color: #FF8C00;">ip_id_count</span>;    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#19979;&#19968;&#20010;IP&#20998;&#29255;&#25968;&#25454;&#25253;&#30340;id&#22495;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span>        *<span style="color: #FF8C00;">unused_next</span>, **<span style="color: #FF8C00;">unused_prevp</span>;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#26469;&#36830;&#25509;&#21040;inet_peer_unused_head&#38142;&#34920;&#65292;&#35813;&#38142;&#34920;&#30340;&#23545;&#31471;&#20449;&#24687;&#22359;&#37117;&#26159;&#38386;&#32622;&#30340;&#65292;&#21487;&#20197;&#22238;&#25910;</span>
	<span style="color: #5FD7FF;">__u32</span>                   <span style="color: #FF8C00;">dtime</span>;          <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">the time of last use of not</span>
<span style="color: #8B8878;">                                                 * referenced entries</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">atomic_t</span>                <span style="color: #FF8C00;">refcnt</span>;         <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24341;&#29992;&#35745;&#25968;</span>
	<span style="color: #5FD7FF;">atomic_t</span>                <span style="color: #FF8C00;">rid</span>;            <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23545;&#31471;&#21457;&#36865;&#20998;&#29255;&#30340;&#35745;&#25968;&#22120;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #5FD7FF;">__u32</span>                   <span style="color: #FF8C00;">tcp_ts</span>;         <span style="color: #8B8878;">//</span><span style="color: #8B8878;">TCP&#20013;&#26368;&#21518;&#19968;&#20010;ACK&#27573;&#21040;&#36798;&#30340;&#26102;&#38388;</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>           <span style="color: #FF8C00;">tcp_ts_stamp</span>;   <span style="color: #8B8878;">//</span><span style="color: #8B8878;">TCP&#20013;&#35760;&#24405;&#25910;&#21040;&#27573;&#20013;&#30340;&#26102;&#38388;&#25139;</span>
};
</pre>
</div>
</div>

<div id="outline-container-org21bd5b3" class="outline-3">
<h3 id="org21bd5b3"><span class="section-number-3">9.1</span> 系统参数</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>inet_peer_gc_maxtime 垃圾回收的最大时间间隔。</li>

<li>inet_peer_gc_mintime 垃圾回收最小时间间隔</li>

<li>inet_peer_maxttl 对端信息块的最长生存周期</li>

<li>inet_peer_minttl 对端信息块的最短生存周期</li>

<li>inet_peer_threshold 用于计算垃圾回收最大时间间隔以及生存期的阈值</li>
</ul>
</div>
</div>

<div id="outline-container-org7241c81" class="outline-3">
<h3 id="org7241c81"><span class="section-number-3">9.2</span> 对端信息块的创建和查找</h3>
<div class="outline-text-3" id="text-9-2">
<p>
inet_getpeer()函数用来实现创建和查找操作。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span> *<span style="color: #87D700;">inet_getpeer</span>(<span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">daddr</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">create</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span> *<span style="color: #FF8C00;">p</span>, *<span style="color: #FF8C00;">n</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span> **<span style="color: #FF8C00;">stack</span>[PEER_MAXDEPTH], ***<span style="color: #FF8C00;">stackptr</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20174;AVL&#26641;&#26597;&#25214;</span><span style="color: #8B8878;"> */</span>
	read_lock_bh(&amp;peer_pool_lock);
	p = lookup(daddr);
	<span style="color: #FF1493;">if</span> (p != peer_avl_empty)
		atomic_inc(&amp;p-&gt;refcnt);
	read_unlock_bh(&amp;peer_pool_lock);

	<span style="color: #FF1493;">if</span> (p != peer_avl_empty) {  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">AVL&#26641;&#20013;&#23384;&#22312;&#23545;&#31471;&#20449;&#24687;&#22359;</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20174;&#26410;&#20351;&#29992;&#38142;&#34920;&#20013;&#31227;&#38500;&#35813;&#23545;&#31471;&#20449;&#24687;&#22359;</span><span style="color: #8B8878;">*/</span>
		unlink_from_unused(p);
		<span style="color: #FF1493;">return</span> p;
	}

	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>create) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27809;&#26377;&#25351;&#23450;&#21019;&#24314;&#26631;&#24535;</span>
		<span style="color: #FF1493;">return</span> <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20998;&#37197;&#31354;&#38388;</span><span style="color: #8B8878;"> */</span>
	n = kmem_cache_alloc(peer_cachep, GFP_ATOMIC);
	n-&gt;v4daddr = daddr;
	atomic_set(&amp;n-&gt;refcnt, 1);
	atomic_set(&amp;n-&gt;rid, 0);
	n-&gt;ip_id_count = secure_ip_id(daddr);
	n-&gt;tcp_ts_stamp = 0;

	write_lock_bh(&amp;peer_pool_lock);
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#33719;&#21462;&#32034;&#21518;&#20877;&#27425;&#26816;&#26597;&#26159;&#21542;&#24050;&#32463;&#28155;&#21152;&#21516;&#26679;&#30340;&#23545;&#31471;&#20449;&#24687;&#22359;</span><span style="color: #8B8878;"> */</span>
	p = lookup(daddr);
	<span style="color: #FF1493;">if</span> (p != peer_avl_empty) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24050;&#32463;&#23384;&#22312;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out_free</span>;
	<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#28155;&#21152;&#21040;AVL&#26641;</span><span style="color: #8B8878;">*/</span>
	link_to_pool(n);
	n-&gt;unused_prevp = <span style="color: #AF87FF;">NULL</span>; <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">not on the list</span><span style="color: #8B8878;"> */</span>
	peer_total++;
	write_unlock_bh(&amp;peer_pool_lock);

	<span style="color: #FF1493;">if</span> (peer_total &gt;= inet_peer_threshold) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#36229;&#36807;&#38408;&#20540;</span>
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#37322;&#25918; inet_peer_unused_head &#38431;&#39318;&#30340;&#23545;&#31471;&#20449;&#24687;&#22359;</span><span style="color: #8B8878;"> */</span>
		cleanup_once(0);
	<span style="color: #FF1493;">return</span> n;
<span style="color: #AF87FF;">out_free</span>:
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">The appropriate node is already in the pool.</span><span style="color: #8B8878;"> */</span>
	atomic_inc(&amp;p-&gt;refcnt);
	write_unlock_bh(&amp;peer_pool_lock);
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Remove the entry from unused list if it was there.</span><span style="color: #8B8878;"> */</span>
	unlink_from_unused(p);
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Free preallocated the preallocated node.</span><span style="color: #8B8878;"> */</span>
	kmem_cache_free(peer_cachep, n);
	<span style="color: #FF1493;">return</span> p;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9becd54" class="outline-3">
<h3 id="org9becd54"><span class="section-number-3">9.3</span> 对端信息块的删除</h3>
<div class="outline-text-3" id="text-9-3">
<p>
inet_putpeer()函数用来将对端信息块添加到 inet_peer_unused_head 队列。真正的释放操作，通过垃圾回收机制来处理
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">inet_putpeer</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span> *<span style="color: #FF8C00;">p</span>)
{
	spin_lock_bh(&amp;inet_peer_unused_lock);
	<span style="color: #FF1493;">if</span> (atomic_dec_and_test(&amp;p-&gt;refcnt)) {
		p-&gt;unused_prevp = inet_peer_unused_tailp;
		p-&gt;unused_next = <span style="color: #AF87FF;">NULL</span>;
		*inet_peer_unused_tailp = p;
		inet_peer_unused_tailp = &amp;p-&gt;unused_next;
		p-&gt;dtime = (<span style="color: #5FD7FF;">__u32</span>)jiffies;
	}
	spin_unlock_bh(&amp;inet_peer_unused_lock);
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org457e342" class="outline-3">
<h3 id="org457e342"><span class="section-number-3">9.4</span> 垃圾回收</h3>
<div class="outline-text-3" id="text-9-4">
<p>
垃圾回收方式有两种，同步和异步。
</p>

<p>
同步： 创建时发现当前对端信息块总数达到阈值（inet_peer_threshold）触发回收。
异步： 定时器触发。
</p>
</div>

<div id="outline-container-org427abc3" class="outline-4">
<h4 id="org427abc3"><span class="section-number-4">9.4.1</span> 对端信息块的释放</h4>
<div class="outline-text-4" id="text-9-4-1">
<p>
对端信息块闲置时，会被加入 inet_peer_threshold 队列，并记录闲置时间，在清理时，如果时间达到阈值，则过期。使用中的对端信息块不会过期。
</p>

<p>
cleanup_once()用来检测 inet_peer_threshold 队列的第一个闲置对端信息块是否过期，过期则将其释放。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">cleanup_once</span>(<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">ttl</span>) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">ttl&#34920;&#31034;&#36807;&#26399;&#38408;&#20540;</span>
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span> *<span style="color: #FF8C00;">p</span>;
	spin_lock_bh(&amp;inet_peer_unused_lock);
	p = inet_peer_unused_head;
	<span style="color: #FF1493;">if</span> (p != <span style="color: #AF87FF;">NULL</span>) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38431;&#21015;&#19981;&#20026;&#31354;</span>
		<span style="color: #5FD7FF;">__u32</span> <span style="color: #FF8C00;">delta</span> = (<span style="color: #5FD7FF;">__u32</span>)jiffies - p-&gt;dtime;
		<span style="color: #FF1493;">if</span> (delta &lt; ttl) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27809;&#26377;&#36807;&#26399;</span>
			spin_unlock_bh(&amp;inet_peer_unused_lock);
			<span style="color: #FF1493;">return</span> -1;
		}
		inet_peer_unused_head = p-&gt;unused_next;
		<span style="color: #FF1493;">if</span> (p-&gt;unused_next != <span style="color: #AF87FF;">NULL</span>)
			p-&gt;unused_next-&gt;unused_prevp = p-&gt;unused_prevp;
		<span style="color: #FF1493;">else</span>
			inet_peer_unused_tailp = p-&gt;unused_prevp;
		p-&gt;unused_prevp = <span style="color: #AF87FF;">NULL</span>;
		atomic_inc(&amp;p-&gt;refcnt);
	}
	spin_unlock_bh(&amp;inet_peer_unused_lock);
	<span style="color: #FF1493;">if</span> (p == <span style="color: #AF87FF;">NULL</span>) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27809;&#26377;&#21487;&#20197;&#37322;&#25918;&#30340;&#23545;&#31471;&#20449;&#24687;&#22359;</span>
		<span style="color: #FF1493;">return</span> -1;
	unlink_from_pool(p); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20174;AVL&#26641;&#21024;&#38500;&#24182;&#37322;&#25918;</span>
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3934a87" class="outline-4">
<h4 id="org3934a87"><span class="section-number-4">9.4.2</span> 同步清理</h4>
<div class="outline-text-4" id="text-9-4-2">
<p>
创建时，如果对端信息块达到阈值，则调用cleanup_once()清理，参数ttl设置为0，表示必须释放一个。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_peer</span> *<span style="color: #87D700;">inet_getpeer</span>(<span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">daddr</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">create</span>)
{
	<span style="color: #FF1493;">if</span> (peer_total &gt;= inet_peer_threshold)
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21442;&#25968;0 &#34920;&#31034;&#24517;&#39035;&#37322;&#25918;&#19968;&#20010;</span><span style="color: #8B8878;">*/</span>
		cleanup_once(0);
</pre>
</div>
</div>
</div>

<div id="outline-container-org72994f7" class="outline-4">
<h4 id="org72994f7"><span class="section-number-4">9.4.3</span> 异步清理</h4>
<div class="outline-text-4" id="text-9-4-3">
<p>
通过peer_periodic_timer定时器进行周期性的垃圾回收，该定时器处理例程为 peer_check_expire()。
</p>

<p>
peer_periodic_timer 定时器的初始间隔在 inet_initpeers 函数中设置，后续则动态计算。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #87D700;">DEFINE_TIMER</span>(peer_periodic_timer, peer_check_expire, 0, 0);

<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Called with local BH disabled.</span><span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">peer_check_expire</span>(<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">dummy</span>)
{
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">now</span> = jiffies;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ttl</span>;

	<span style="color: #FF1493;">if</span> (peer_total &gt;= inet_peer_threshold)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36229;&#20986;&#38408;&#20540;</span>
		ttl = inet_peer_minttl; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">ttl&#20351;&#29992;&#26368;&#23567;&#29983;&#23384;&#26399;</span>
	<span style="color: #FF1493;">else</span>
		ttl = inet_peer_maxttl
				- (inet_peer_maxttl - inet_peer_minttl) / HZ *
					peer_total / inet_peer_threshold * HZ;
	<span style="color: #FF1493;">while</span> (<span style="color: #CDC673; font-weight: bold;">!</span>cleanup_once(ttl)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24490;&#29615;&#26816;&#27979;&#28165;&#29702;</span>
		<span style="color: #FF1493;">if</span> (jiffies != now)
			<span style="color: #FF1493;">break</span>;
	}

	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;&#23450;&#26102;&#22120;&#30340;&#19979;&#27425;&#28608;&#27963;&#26102;&#38388;</span>
	<span style="color: #FF1493;">if</span> (peer_total &gt;= inet_peer_threshold)
		peer_periodic_timer.expires = jiffies + inet_peer_gc_mintime;
	<span style="color: #FF1493;">else</span>
		peer_periodic_timer.expires = jiffies
			+ inet_peer_gc_maxtime
			- (inet_peer_gc_maxtime - inet_peer_gc_mintime) / HZ *
				peer_total / inet_peer_threshold * HZ;
	add_timer(&amp;peer_periodic_timer); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28155;&#21152;&#23450;&#26102;&#22120;&#12290;</span>
}
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org8d65c9d" class="outline-2">
<h2 id="org8d65c9d"><span class="section-number-2">10</span> IP数据包的输入处理</h2>
<div class="outline-text-2" id="text-10">
<p>
ip数据包的接收例程定义：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">packet_type</span> <span style="color: #FF8C00;">ip_packet_type</span> = {
	.type = __constant_htons(ETH_P_IP),
	.func = ip_rcv,
	.gso_send_check = inet_gso_send_check,
	.gso_segment = inet_gso_segment,
};
</pre>
</div>

<p>
网络初始化时，通过 dev_add_pack() 注册到 ptype_base 散列表。
</p>

<p>
ip_rcv() 处理完成后经过 PRE-ROUTING 的netfilter后， 交给ip_rcv_finish()处理， ip_rcv_finish()中根据路由信息，决定是转发（ip_forward()），还是输入到本机（ip_local_deliver()）。
</p>
</div>

<div id="outline-container-orga9caab6" class="outline-3">
<h3 id="orga9caab6"><span class="section-number-3">10.1</span> ip_rcv()</h3>
<div class="outline-text-3" id="text-10-1">
<p>
网络设备接收到报文时，根据协议号从ptype_base散列表中查找对应的接收例程。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_rcv</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">dev</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">packet_type</span> *<span style="color: #FF8C00;">pt</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">orig_dev</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span>;
	<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">len</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20002;&#24323;&#21435;&#24448;&#20854;&#20182;&#20027;&#26426;&#30340;&#25968;&#25454;&#25253;</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;pkt_type == PACKET_OTHERHOST)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;

	IP_INC_STATS_BH(IPSTATS_MIB_INRECEIVES);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#26159;&#20849;&#20139;&#25968;&#25454;&#25253;&#65292;&#21017;&#38656;&#35201;&#22797;&#21046;&#19968;&#20010;</span>
	<span style="color: #FF1493;">if</span> ((skb = skb_share_check(skb, GFP_ATOMIC)) == <span style="color: #AF87FF;">NULL</span>) {
		IP_INC_STATS_BH(IPSTATS_MIB_INDISCARDS);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;&#25968;&#25454;&#25253;&#38271;&#24230;&#19981;&#33021;&#23567;&#20110;IP&#39318;&#37096;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>)))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">inhdr_error</span>;
	iph = skb-&gt;nh.iph; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">IP header</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;IP&#39318;&#37096;&#38271;&#24230;&#21644;&#29256;&#26412;</span>
	<span style="color: #FF1493;">if</span> (iph-&gt;ihl &lt; 5 || iph-&gt;version != 4)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">inhdr_error</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;&#39318;&#37096;&#25658;&#24102;&#30340;&#38271;&#24230;&#26816;&#27979;ip&#25968;&#25454;&#25253;&#38271;&#24230;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, iph-&gt;ihl*4))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">inhdr_error</span>;
	iph = skb-&gt;nh.iph;
	<span style="color: #FF1493;">if</span> (unlikely(ip_fast_csum((<span style="color: #5FD7FF;">u8</span> *)iph, iph-&gt;ihl)))<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;&#26657;&#39564;&#21644;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">inhdr_error</span>;
	len = ntohs(iph-&gt;tot_len);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26816;&#27979;ip&#25968;&#25454;&#25253;&#24635;&#38271;&#24230;</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;len &lt; len || len &lt; (iph-&gt;ihl*4))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">inhdr_error</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;IP&#39318;&#37096;&#20013;&#30340;&#25968;&#25454;&#24635;&#38271;&#24230;&#35774;&#32622;SKB&#30340;&#38271;&#24230;</span>
	<span style="color: #FF1493;">if</span> (pskb_trim_rcsum(skb, len)) {
		IP_INC_STATS_BH(IPSTATS_MIB_INDISCARDS);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
	}
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#28165;&#31354;SKB&#30340;ip&#25511;&#21046;&#22359;</span><span style="color: #8B8878;"> */</span>
	memset(IPCB(skb), 0, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_skb_parm</span>));
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#29992;NF_IP_PRE_ROUTING netfilter&#65292;&#20043;&#21518;&#36890;&#36807;ip_rcv_finish()&#23436;&#25104;&#36755;&#20837;</span>
	<span style="color: #FF1493;">return</span> NF_HOOK(PF_INET, NF_IP_PRE_ROUTING, skb, dev, <span style="color: #AF87FF;">NULL</span>,
		       ip_rcv_finish);
<span style="color: #AF87FF;">inhdr_error</span>:
	IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
<span style="color: #AF87FF;">drop</span>:
	kfree_skb(skb);
<span style="color: #AF87FF;">out</span>:
	<span style="color: #FF1493;">return</span> NET_RX_DROP;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8fc04ab" class="outline-3">
<h3 id="org8fc04ab"><span class="section-number-3">10.2</span> ip_rcv_finish()</h3>
<div class="outline-text-3" id="text-10-2">
<p>
ip_rcv()结束时，经过neifilter处理后，调用ip_rcv_finish()。
</p>

<p>
ip_rcv_finish() 主要是调用 ip_route_input() 查找输入路由缓存，接着处理IP数据报首部的选项，最后根据路由缓存输入本地或者转发。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_rcv_finish</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span> = skb-&gt;nh.iph;
	<span style="color: #FF1493;">if</span> (skb-&gt;dst == <span style="color: #AF87FF;">NULL</span>) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36824;&#27809;&#26377;&#36335;&#30001;&#32531;&#23384;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214;&#36335;&#30001;&#32531;&#23384;</span>
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span> = ip_route_input(skb, iph-&gt;daddr, iph-&gt;saddr, iph-&gt;tos, skb-&gt;dev);
		<span style="color: #FF1493;">if</span> (unlikely(err)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214;&#22833;&#36133;&#65292;&#21017;&#20002;&#24323;</span>
			<span style="color: #FF1493;">if</span> (err == -EHOSTUNREACH)
				IP_INC_STATS_BH(IPSTATS_MIB_INADDRERRORS);
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
		}
	}

<span style="color: #FF1493;">#ifdef</span> CONFIG_NET_CLS_ROUTE <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36335;&#30001;&#34920;&#30340;classifier&#26631;&#31614;&#30456;&#20851;</span>
	<span style="color: #FF1493;">if</span> (unlikely(skb-&gt;dst-&gt;tclassid)) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_rt_acct</span> *<span style="color: #FF8C00;">st</span> = ip_rt_acct + 256*smp_processor_id();
		<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">idx</span> = skb-&gt;dst-&gt;tclassid;
		st[idx&amp;0xFF].o_packets++;
		st[idx&amp;0xFF].o_bytes+=skb-&gt;len;
		st[(idx&gt;&gt;16)&amp;0xFF].i_packets++;
		st[(idx&gt;&gt;16)&amp;0xFF].i_bytes+=skb-&gt;len;
	}
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21028;&#26029;&#26159;&#21542;&#23384;&#22312;ip&#36873;&#39033;&#65292;&#24182;&#35843;&#29992;ip_rcv_options&#22788;&#29702;&#36873;&#39033;</span>
	<span style="color: #FF1493;">if</span> (iph-&gt;ihl &gt; 5 &amp;&amp; ip_rcv_options(skb))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
	<span style="color: #FF1493;">return</span> dst_input(skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#36755;&#20837;&#26412;&#22320;&#65292;&#21017;&#35843;&#29992;ip_local_deliver()&#65292;&#36716;&#21457;&#21017;&#35843;&#29992;ip_forward()</span>
<span style="color: #AF87FF;">drop</span>:
	kfree_skb(skb);
	<span style="color: #FF1493;">return</span> NET_RX_DROP;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf6df8e8" class="outline-3">
<h3 id="orgf6df8e8"><span class="section-number-3">10.3</span> IP数据报输入到本地</h3>
<div class="outline-text-3" id="text-10-3">
</div>
<div id="outline-container-org3ad978b" class="outline-4">
<h4 id="org3ad978b"><span class="section-number-4">10.3.1</span> ip_local_deliver()</h4>
<div class="outline-text-4" id="text-10-3-1">
<p>
此函数处理输入到本地的数据报。
</p>
<ul class="org-ul">
<li>如果是分片，则分片重组</li>
<li>非分片，或者重组完成，则调用NF_IP_LOCAL_IN netfilter，之后通过ip_local_deliver_finish() 完成到本地的输入。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      Deliver IP Packets to the higher protocol layers.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_local_deliver</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#39318;&#20808;&#20915;&#23450;&#26159;&#21542;&#38656;&#35201;&#20998;&#29255;&#37325;&#32452;</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;nh.iph-&gt;frag_off &amp; htons(IP_MF|IP_OFFSET)) {
		skb = ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER);
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36824;&#26410;&#37325;&#32452;&#23436;&#25104;</span>
			<span style="color: #FF1493;">return</span> 0;
	}
	<span style="color: #FF1493;">return</span> NF_HOOK(PF_INET, NF_IP_LOCAL_IN, skb, skb-&gt;dev, <span style="color: #AF87FF;">NULL</span>,
		       ip_local_deliver_finish);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org604d37c" class="outline-4">
<h4 id="org604d37c"><span class="section-number-4">10.3.2</span> ip_local_deliver_finish()</h4>
<div class="outline-text-4" id="text-10-3-2">
<p>
此函数将数据报从网络层传递到传输层。
</p>
<ul class="org-ul">
<li>首先去掉IP首部。</li>
<li>如果有对应RAW套接口，则需复制一份数据报输入到该套接口。</li>
<li>调用传输层接收例程，将数据报交给传输层处理。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_local_deliver_finish</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ihl</span> = skb-&gt;nh.iph-&gt;ihl*4;
	__skb_pull(skb, ihl);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21435;&#38500;IP&#39318;&#37096;</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Point into the IP datagram, just past the header.</span><span style="color: #8B8878;"> */</span>
	skb-&gt;h.raw = skb-&gt;data;
	rcu_read_lock();
	{
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">protocol</span> = skb-&gt;nh.iph-&gt;protocol; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36755;&#23618;&#21327;&#35758;</span>
		<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">hash</span>;
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">raw_sk</span>;
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_protocol</span> *<span style="color: #FF8C00;">ipprot</span>;

	<span style="color: #AF87FF;">resubmit</span>:
		hash = protocol &amp; (MAX_INET_PROTOS - 1); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;hash&#20540;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#39318;&#20808;&#26597;&#25214;raw_v4_htable&#65292;&#20915;&#23450;&#26159;&#21542;&#38656;&#35201;&#36755;&#20837;&#21040;raw&#22871;&#25509;&#21475;</span>
		raw_sk = sk_head(&amp;raw_v4_htable[hash]);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#25214;&#21040;raw&#22871;&#25509;&#21475;&#65292;&#21017;&#36755;&#20837;&#21040;raw</span>
		<span style="color: #FF1493;">if</span> (raw_sk &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>raw_v4_input(skb, skb-&gt;nh.iph, hash))
			raw_sk = <span style="color: #AF87FF;">NULL</span>;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214; inet_protos&#25968;&#32452;&#65292;&#33719;&#21462;&#30456;&#20851;&#20256;&#36755;&#23618;&#21327;&#35758;&#25509;&#25910;&#20363;&#31243;</span>
		<span style="color: #FF1493;">if</span> ((ipprot = rcu_dereference(inet_protos[hash])) != <span style="color: #AF87FF;">NULL</span>) {
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ret</span>;
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>ipprot-&gt;no_policy) {
				<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>xfrm4_policy_check(<span style="color: #AF87FF;">NULL</span>, XFRM_POLICY_IN, skb)) {
					kfree_skb(skb);
					<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
				}
				nf_reset(skb);
			}
			ret = ipprot-&gt;handler(skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20837;&#21040;&#20256;&#36755;&#23618;</span>
			<span style="color: #FF1493;">if</span> (ret &lt; 0) {
				protocol = -ret;
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">resubmit</span>;
			}
			IP_INC_STATS_BH(IPSTATS_MIB_INDELIVERS);
		} <span style="color: #FF1493;">else</span> {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26410;&#25214;&#21040;&#65292;&#21017;&#38656;&#35201;&#21457;&#36865;icmp &#30446;&#30340;&#19981;&#21487;&#36798;&#25253;&#25991;</span>
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>raw_sk) {
				<span style="color: #FF1493;">if</span> (xfrm4_policy_check(<span style="color: #AF87FF;">NULL</span>, XFRM_POLICY_IN, skb)) {
					IP_INC_STATS_BH(IPSTATS_MIB_INUNKNOWNPROTOS);
					icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PROT_UNREACH, 0);
				}
			} <span style="color: #FF1493;">else</span>
				IP_INC_STATS_BH(IPSTATS_MIB_INDELIVERS);
			kfree_skb(skb);
		}
	}
 <span style="color: #AF87FF;">out</span>:
	rcu_read_unlock();
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9829f53" class="outline-3">
<h3 id="org9829f53"><span class="section-number-3">10.4</span> IP数据报的转发</h3>
<div class="outline-text-3" id="text-10-4">

<div class="figure">
<p><img src="image/ip-proto/ip-forward.png" alt="ip-forward.png" />
</p>
<p><span class="figure-number">Figure 6: </span>ip_forward()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_forward</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span>;      <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Our header</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *<span style="color: #FF8C00;">rt</span>;      <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Route we use</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span> * <span style="color: #FF8C00;">opt</span> = &amp;(IPCB(skb)-&gt;opt);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214;IPsec&#31574;&#30053;&#25968;&#25454;&#24211;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>xfrm4_policy_check(<span style="color: #AF87FF;">NULL</span>, XFRM_POLICY_FWD, skb))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23384;&#22312;&#36335;&#30001;&#35686;&#21578;&#36873;&#39033;&#65292;&#35843;&#29992;ip_call_ra_chain&#23558;&#25968;&#25454;&#25253;&#36755;&#20837;&#21040;&#24863;&#20852;&#36259;&#30340;&#36827;&#31243;</span>
	<span style="color: #FF1493;">if</span> (IPCB(skb)-&gt;opt.router_alert &amp;&amp; ip_call_ra_chain(skb))
		<span style="color: #FF1493;">return</span> NET_RX_SUCCESS;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">mac&#22320;&#22336;&#26159;&#21542;&#20026;&#25509;&#25910;&#32593;&#32476;&#35774;&#22791;&#30340;mac&#22320;&#22336;</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;pkt_type != PACKET_HOST)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
	skb-&gt;ip_summed = CHECKSUM_NONE;
	<span style="color: #FF1493;">if</span> (skb-&gt;nh.iph-&gt;ttl &lt;= 1) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;ttl&#20026;1&#25110;&#32773;&#23567;&#20110;1,&#21017;&#20002;&#24323;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">too_many_hops</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">IPSec&#36335;&#30001;&#36873;&#36335;&#21450;&#36716;&#21457;&#22788;&#29702;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>xfrm4_route_forward(skb))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
	rt = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span>*)skb-&gt;dst;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25968;&#25454;&#25253;&#21551;&#29992;&#20102;&#20005;&#26684;&#28304;&#36335;&#30001;&#36873;&#39033;&#65292;&#19988;&#25968;&#25454;&#25253;&#30340;&#19979;&#19968;&#36339;&#19981;&#26159;&#32593;&#20851;</span>
	<span style="color: #FF1493;">if</span> (opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_dst != rt-&gt;rt_gateway)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">sr_failed</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#30830;&#20445;SKB&#26377;&#21046;&#23450;&#38271;&#24230;&#30340;headroom&#31354;&#38388;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (skb_cow(skb, LL_RESERVED_SPACE(rt-&gt;u.dst.dev)+rt-&gt;u.dst.header_len))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;
	iph = skb-&gt;nh.iph;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36882;&#20943;ttl</span><span style="color: #8B8878;">*/</span>
	ip_decrease_ttl(iph);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#36335;&#30001;&#20013;&#23384;&#22312;&#37325;&#23450;&#21521;&#26631;&#24535;&#65292;&#21017;&#38656;&#35201;&#21457;&#36865;&#37325;&#23450;&#21521;ICMP&#25253;&#25991;</span>
	<span style="color: #FF1493;">if</span> (rt-&gt;rt_flags&amp;RTCF_DOREDIRECT &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>opt-&gt;srr)
		ip_rt_send_redirect(skb);
	skb-&gt;priority = rt_tos2priority(iph-&gt;tos);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">netfilter NF_IP_FORWARD&#25805;&#20316;&#21518;&#65292;&#35843;&#29992; ip_forward_finish</span>
	<span style="color: #FF1493;">return</span> NF_HOOK(PF_INET, NF_IP_FORWARD, skb, skb-&gt;dev, rt-&gt;u.dst.dev,
		       ip_forward_finish);
<span style="color: #AF87FF;">sr_failed</span>:
	<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">         *      Strict routing permits no gatewaying</span>
<span style="color: #8B8878;">         */</span>
	 icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);
	 <span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">drop</span>;

<span style="color: #AF87FF;">too_many_hops</span>:
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Tell the sender its packet died...</span><span style="color: #8B8878;"> */</span>
	IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
	icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
<span style="color: #AF87FF;">drop</span>:
	kfree_skb(skb);
	<span style="color: #FF1493;">return</span> NET_RX_DROP;
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_forward_finish</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span> * <span style="color: #FF8C00;">opt</span> = &amp;(IPCB(skb)-&gt;opt);
	IP_INC_STATS_BH(IPSTATS_MIB_OUTFORWDATAGRAMS);
	<span style="color: #FF1493;">if</span> (unlikely(opt-&gt;optlen))
		ip_forward_options(skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;IP&#25968;&#25454;&#25253;&#36873;&#39033;</span>
	<span style="color: #FF1493;">return</span> dst_output(skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#25968;&#25454;&#25253;</span>
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org32eef23" class="outline-2">
<h2 id="org32eef23"><span class="section-number-2">11</span> IP数据报的输入处理</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-orgf49ac25" class="outline-3">
<h3 id="orgf49ac25"><span class="section-number-3">11.1</span> IP数据报输出到设备</h3>
<div class="outline-text-3" id="text-11-1">
<p>
转发数据报和本地输出的数据报，都需要经过路由之后，输出到设备，输出到设备的接口为 ip_output()。
</p>

<p>
ip_output并不会直接调用，而是通过输出数据报的目的路由缓存项中的输出接口调用。
</p>

<p>
本地输出的数据报查找到目的路由缓存后，通过NF_IP_LOCAL_OUT的netfilter处理，通过dst_output输出到网络设备。
</p>

<p>
转发的数据报查找路由后，通过NF_IP_FORWARD的netfilter处理后，通过dst_output输出到设备。
</p>
</div>

<div id="outline-container-org55a290b" class="outline-4">
<h4 id="org55a290b"><span class="section-number-4">11.1.1</span> dst_output()</h4>
<div class="outline-text-4" id="text-11-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Output packet to network from transport.</span><span style="color: #8B8878;">  */</span>
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">dst_output</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#29992;&#30446;&#30340;&#36335;&#30001;&#32531;&#23384;&#30340;&#36755;&#20986;&#25509;&#21475;</span>
	<span style="color: #FF1493;">return</span> skb-&gt;dst-&gt;output(skb);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9a685c0" class="outline-4">
<h4 id="org9a685c0"><span class="section-number-4">11.1.2</span> ip_output()</h4>
<div class="outline-text-4" id="text-11-1-2">
<p>
对于单播数据报，目的路由缓存项中的输出接口output为ip_output()。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_output</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">dev</span> = skb-&gt;dst-&gt;dev;
	IP_INC_STATS(IPSTATS_MIB_OUTREQUESTS);
	skb-&gt;dev = dev; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#36755;&#20986;&#32593;&#32476;&#35774;&#22791;</span>
	skb-&gt;protocol = htons(ETH_P_IP); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32593;&#32476;&#23618;&#21327;&#35758;&#31867;&#22411;</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#29992;netfilter&#30340; NF_IP_POST_ROUTING,&#20043;&#21518;&#36890;&#36807; ip_finish_output&#22788;&#29702;</span>
	<span style="color: #FF1493;">return</span> NF_HOOK_COND(PF_INET, NF_IP_POST_ROUTING, skb, <span style="color: #AF87FF;">NULL</span>, dev, ip_finish_output, <span style="color: #CDC673; font-weight: bold;">!</span>(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc182d82" class="outline-4">
<h4 id="orgc182d82"><span class="section-number-4">11.1.3</span> ip_finish_output()</h4>
<div class="outline-text-4" id="text-11-1-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_finish_output</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
<span style="color: #FF1493;">#if</span> <span style="color: #FF1493;">defined</span>(CONFIG_NETFILTER) &amp;&amp; <span style="color: #FF1493;">defined</span>(CONFIG_XFRM)
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Policy lookup after SNAT yielded a new policy</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;dst-&gt;xfrm != <span style="color: #AF87FF;">NULL</span>) {
		IPCB(skb)-&gt;flags |= IPSKB_REROUTED;
		<span style="color: #FF1493;">return</span> dst_output(skb);
	}
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22823;&#20110;MTU&#65292;&#21017;&#38656;&#35201;&#20998;&#29255;</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;len &gt; dst_mtu(skb-&gt;dst) &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>skb_is_gso(skb))
		<span style="color: #FF1493;">return</span> ip_fragment(skb, ip_finish_output2);
	<span style="color: #FF1493;">else</span>
		<span style="color: #FF1493;">return</span> ip_finish_output2(skb);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org6def299" class="outline-4">
<h4 id="org6def299"><span class="section-number-4">11.1.4</span> ip_finish_output2()</h4>
<div class="outline-text-4" id="text-11-1-4">
<p>
该函数通过邻居子系统将数据报输出到网络设备。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_finish_output2</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">dst_entry</span> *<span style="color: #FF8C00;">dst</span> = skb-&gt;dst;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">dev</span> = dst-&gt;dev;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">hh_len</span> = LL_RESERVED_SPACE(dev);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26816;&#27979;skb&#21069;&#38754;&#30340;&#31354;&#38388;&#33021;&#21542;&#23384;&#20648;&#38142;&#36335;&#23618;&#39318;&#37096;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (unlikely(skb_headroom(skb) &lt; hh_len &amp;&amp; dev-&gt;hard_header)) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb2</span>;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38656;&#35201;&#20998;&#37197;&#26356;&#22823;&#23384;&#20648;&#21306;&#30340;SKB</span>
		skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));
		<span style="color: #FF1493;">if</span> (skb2 == <span style="color: #AF87FF;">NULL</span>) {
			kfree_skb(skb);
			<span style="color: #FF1493;">return</span> -ENOMEM;
		}
		<span style="color: #FF1493;">if</span> (skb-&gt;sk)
			skb_set_owner_w(skb2, skb-&gt;sk);
		kfree_skb(skb);
		skb = skb2;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32531;&#23384;&#20102;&#38142;&#36335;&#23618;&#39318;&#37096;&#65292;&#30452;&#25509;&#36755;&#20986;</span>
	<span style="color: #FF1493;">if</span> (dst-&gt;hh)
		<span style="color: #FF1493;">return</span> neigh_hh_output(dst-&gt;hh, skb);
	<span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (dst-&gt;neighbour) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23384;&#22312;&#37051;&#23621;&#39033;&#65292;&#36890;&#36807;&#37051;&#23621;&#39033;&#30340;&#26041;&#27861;&#36755;&#20986;</span>
		<span style="color: #FF1493;">return</span> dst-&gt;neighbour-&gt;output(skb);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27809;&#26377;&#38142;&#36335;&#23618;&#39318;&#37096;&#65292;&#20063;&#27809;&#26377;&#37051;&#23621;&#39033;&#65292;&#21017;&#38656;&#35201;&#20002;&#24323;</span>
	<span style="color: #FF1493;">if</span> (net_ratelimit())
		printk(KERN_DEBUG <span style="color: #CDC673;">"ip_finish_output2: No header cache and no neighbour!\n"</span>);
	kfree_skb(skb);
	<span style="color: #FF1493;">return</span> -EINVAL;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org34c9bc6" class="outline-3">
<h3 id="org34c9bc6"><span class="section-number-3">11.2</span> TCP输出的相关接口</h3>
<div class="outline-text-3" id="text-11-2">
<p>
TCP中有几种输出接口，常用的输出接口为 ip_queue_xmit()。 ip_build_and_send_pkt()和ip_send_reply()只有发送特定段时才会调用。
</p>
</div>

<div id="outline-container-org9f25555" class="outline-4">
<h4 id="org9f25555"><span class="section-number-4">11.2.1</span> ip_queue_xmit()</h4>
<div class="outline-text-4" id="text-11-2-1">

<div class="figure">
<p><img src="image/ip-proto/ip-queue-xmit.png" alt="ip-queue-xmit.png" />
</p>
<p><span class="figure-number">Figure 7: </span>ip_queue_xmit()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">skb: &#24453;&#23553;&#35013;&#20026;ip&#25968;&#25454;&#25253;&#30340;TCP&#27573;</span>
<span style="color: #8B8878;">ipfragok&#65306; &#26631;&#35782;&#25968;&#25454;&#26159;&#21542;&#24050;&#32463;&#23436;&#25104;&#20998;&#29255;</span>
<span style="color: #8B8878;">*/</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_queue_xmit</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ipfragok</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span> = skb-&gt;sk;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span> *<span style="color: #FF8C00;">opt</span> = inet-&gt;opt;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *<span style="color: #FF8C00;">rt</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#24050;&#32463;&#20934;&#22791;&#22909;&#36335;&#30001;&#32531;&#23384;&#65292;&#21017;&#26080;&#38656;&#22312;&#26597;&#25214;&#36335;&#30001;</span><span style="color: #8B8878;"> */</span>
	rt = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *) skb-&gt;dst;
	<span style="color: #FF1493;">if</span> (rt != <span style="color: #AF87FF;">NULL</span>)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">packet_routed</span>;


	rt = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *)__sk_dst_check(sk, 0); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#30475;&#35813;&#25968;&#25454;&#25253;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#26159;&#21542;&#24050;&#32463;&#32531;&#23384;&#20102;&#36755;&#20986;&#36335;&#30001;&#65292;&#24182;&#26816;&#26597;&#26159;&#21542;&#36807;&#26399;</span>
	<span style="color: #FF1493;">if</span> (rt == <span style="color: #AF87FF;">NULL</span>) {
		<span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">daddr</span>;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214;&#36335;&#30001;</span>
		daddr = inet-&gt;daddr;
		<span style="color: #FF1493;">if</span>(opt &amp;&amp; opt-&gt;srr)
			daddr = opt-&gt;faddr;
		{
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">flowi</span> <span style="color: #FF8C00;">fl</span> = { .oif = sk-&gt;sk_bound_dev_if,
					    .nl_u = { .ip4_u =
						      { .daddr = daddr,
							.saddr = inet-&gt;saddr,
							.tos = RT_CONN_FLAGS(sk) } },
					    .proto = sk-&gt;sk_protocol,
					    .uli_u = { .ports =
						       { .sport = inet-&gt;sport,
							 .dport = inet-&gt;dport } } };
			security_sk_classify_flow(sk, &amp;fl);
			<span style="color: #FF1493;">if</span> (ip_route_output_flow(&amp;rt, &amp;fl, sk, 0))<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#26597;&#25214;&#22833;&#36133;&#65292;&#20256;&#36755;&#23618;&#30340;&#37325;&#20256;&#26426;&#21046;&#20250;&#20445;&#25345;&#37325;&#35797;&#65292;&#30452;&#21040;&#26597;&#21040;&#36335;&#30001;&#25110;&#32773;&#36830;&#25509;&#36229;&#26102;</span><span style="color: #8B8878;">*/</span>
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">no_route</span>;
		}
		sk_setup_caps(sk, &amp;rt-&gt;u.dst);
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214;&#21040;&#36335;&#30001;</span>
	skb-&gt;dst = dst_clone(&amp;rt-&gt;u.dst);
<span style="color: #AF87FF;">packet_routed</span>:
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#23384;&#22312;&#20005;&#26684;&#36335;&#30001;&#36873;&#39033;&#65292;&#19988;&#19979;&#19968;&#36339;&#22320;&#22336;&#21644;&#32593;&#20851;&#19981;&#21516;&#65292;&#21017;&#20002;&#24323;</span>
	<span style="color: #FF1493;">if</span> (opt &amp;&amp; opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_dst != rt-&gt;rt_gateway)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">no_route</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#24320;&#22987;&#35774;&#32622;IP&#39318;&#37096;&#65292;&#26377;&#36873;&#39033;&#21017;&#26500;&#24314;IP&#36873;&#39033;</span><span style="color: #8B8878;"> */</span>
	iph = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *) skb_push(skb, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>) + (opt ? opt-&gt;optlen : 0));
	*((<span style="color: #5FD7FF;">__be16</span> *)iph) = htons((4 &lt;&lt; 12) | (5 &lt;&lt; 8) | (inet-&gt;tos &amp; 0xff));
	iph-&gt;tot_len = htons(skb-&gt;len);
	<span style="color: #FF1493;">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;u.dst) &amp;&amp; <span style="color: #CDC673; font-weight: bold;">!</span>ipfragok)
		iph-&gt;frag_off = htons(IP_DF);
	<span style="color: #FF1493;">else</span>
		iph-&gt;frag_off = 0;
	iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;u.dst);
	iph-&gt;protocol = sk-&gt;sk_protocol;
	iph-&gt;saddr    = rt-&gt;rt_src;
	iph-&gt;daddr    = rt-&gt;rt_dst;
	skb-&gt;nh.iph   = iph;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Transport layer set skb-&gt;h.foo itself.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (opt &amp;&amp; opt-&gt;optlen) {
		iph-&gt;ihl += opt-&gt;optlen &gt;&gt; 2;
		ip_options_build(skb, opt, inet-&gt;daddr, rt, 0);
	}
	ip_select_ident_more(iph, &amp;rt-&gt;u.dst, sk,
			     (skb_shinfo(skb)-&gt;gso_segs ?: 1) - 1);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#28155;&#21152;IP&#26657;&#39564;&#21644;</span><span style="color: #8B8878;"> */</span>
	ip_send_check(iph);
	skb-&gt;priority = sk-&gt;sk_priority;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#29992;netfilter&#30340;NF_IP_LOCAL_OUT&#21518;&#65292;&#36890;&#36807;dst_output&#36755;&#20986;</span>
	<span style="color: #FF1493;">return</span> NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, <span style="color: #AF87FF;">NULL</span>, rt-&gt;u.dst.dev,
		       dst_output);
<span style="color: #AF87FF;">no_route</span>:
	IP_INC_STATS(IPSTATS_MIB_OUTNOROUTES);
	kfree_skb(skb);
	<span style="color: #FF1493;">return</span> -EHOSTUNREACH;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga7c26b6" class="outline-4">
<h4 id="orga7c26b6"><span class="section-number-4">11.2.2</span> ip_build_and_send_pkt()</h4>
<div class="outline-text-4" id="text-11-2-2">
<p>
该函数用于在TCP建立连接过程中，打包输出SYN+ACK类型的TCP段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_build_and_send_pkt</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,
			  <span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">saddr</span>, <span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">daddr</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span> *<span style="color: #FF8C00;">opt</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *<span style="color: #FF8C00;">rt</span> = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *)skb-&gt;dst;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26500;&#24314;IP&#39318;&#37096;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (opt)
		iph=(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *)skb_push(skb,<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>) + opt-&gt;optlen);
	<span style="color: #FF1493;">else</span>
		iph=(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *)skb_push(skb,<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>));

	iph-&gt;version  = 4; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29256;&#26412;</span>
	iph-&gt;ihl      = 5; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#39318;&#37096;&#38271;&#24230;</span>
	iph-&gt;tos      = inet-&gt;tos; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">tos</span>
	<span style="color: #FF1493;">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;u.dst))<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26159;&#21542;&#25351;&#23450;&#20102;&#19981;&#20998;&#29255;</span>
		iph-&gt;frag_off = htons(IP_DF);
	<span style="color: #FF1493;">else</span>
		iph-&gt;frag_off = 0;
	iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;u.dst);
	iph-&gt;daddr    = rt-&gt;rt_dst;
	iph-&gt;saddr    = rt-&gt;rt_src;
	iph-&gt;protocol = sk-&gt;sk_protocol;
	iph-&gt;tot_len  = htons(skb-&gt;len);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;ip&#25968;&#25454;&#25253;&#30340;id, &#22914;&#26524;&#19981;&#20998;&#29255;&#65292;&#21017;&#20351;&#29992;&#22871;&#25509;&#21475;&#30340;id, &#21542;&#21017;&#20351;&#29992;&#23545;&#31471;&#20449;&#24687;&#22359;&#30340;ip_id_count&#25104;&#21592;</span>
	ip_select_ident(iph, &amp;rt-&gt;u.dst, sk);
	skb-&gt;nh.iph   = iph;

	<span style="color: #FF1493;">if</span> (opt &amp;&amp; opt-&gt;optlen) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;IP&#36873;&#39033;</span>
		iph-&gt;ihl += opt-&gt;optlen&gt;&gt;2;
		ip_options_build(skb, opt, daddr, rt, 0);
	}
	ip_send_check(iph); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;IP&#25968;&#25454;&#25253;&#30340;&#26657;&#39564;&#21644;</span>
	skb-&gt;priority = sk-&gt;sk_priority;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#35843;&#29992;netfilter&#30340;NF_IP_LOCAL_OUT, &#20043;&#21518;&#36890;&#36807;dst_output&#36755;&#20986;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">return</span> NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, <span style="color: #AF87FF;">NULL</span>, rt-&gt;u.dst.dev,
		       dst_output);
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org976b9b2" class="outline-4">
<h4 id="org976b9b2"><span class="section-number-4">11.2.3</span> ip_send_reply()</h4>
<div class="outline-text-4" id="text-11-2-3">
<p>
该函数用于构造RST和ACK段，并输出。分别在 tcp_v4_send_reset() 和 tcp_v4_send_ack() 中调用。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_reply_arg</span> {
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">kvec</span> <span style="color: #FF8C00;">iov</span>[1];  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26631;&#35782;&#24453;&#36755;&#20986;&#25968;&#25454;&#30340;&#20301;&#32622;&#21450;&#38271;&#24230;</span>
	<span style="color: #5FD7FF;">__wsum</span>      <span style="color: #FF8C00;">csum</span>;    <span style="color: #8B8878;">//</span><span style="color: #8B8878;">TCP&#20266;&#39318;&#37096;&#26657;&#39564;&#21644;</span>
	<span style="color: #5FD7FF;">int</span>         <span style="color: #FF8C00;">csumoffset</span>; <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Tcp&#39318;&#37096;&#20013;&#30340;&#26657;&#39564;&#21644;&#23383;&#27573;&#22312;&#39318;&#37096;&#20013;&#30340;&#20559;&#31227;</span><span style="color: #8B8878;">*/</span>
};

<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      Generic function to send a packet as reply to another packet.</span>
<span style="color: #8B8878;"> *      Used to send TCP resets so far. ICMP should use this function too.</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> *      Should run single threaded per socket because it uses the sock</span>
<span style="color: #8B8878;"> *      structure to pass arguments.</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> *      LATER: switch from ip_build_xmit to ip_append_*</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">ip_send_reply</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_reply_arg</span> *<span style="color: #FF8C00;">arg</span>,
		   <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(sk);
	<span style="color: #FF1493;">struct</span> {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span>       <span style="color: #FF8C00;">opt</span>;
		<span style="color: #5FD7FF;">char</span>                    <span style="color: #FF8C00;">data</span>[40];
	} <span style="color: #FF8C00;">replyopts</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ipcm_cookie</span> <span style="color: #FF8C00;">ipc</span>;
	<span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">daddr</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *<span style="color: #FF8C00;">rt</span> = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span>*)skb-&gt;dst;

	<span style="color: #FF1493;">if</span> (ip_options_echo(&amp;replyopts.opt, skb))<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#36873;&#39033;</span>
		<span style="color: #FF1493;">return</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;SKB&#30340;&#36755;&#20837;&#36335;&#30001;&#65292;&#33719;&#21462;&#23545;&#31471;IP&#22320;&#22336;</span>
	daddr = ipc.addr = rt-&gt;rt_src;
	ipc.opt = <span style="color: #AF87FF;">NULL</span>;

	<span style="color: #FF1493;">if</span> (replyopts.opt.optlen) {
		ipc.opt = &amp;replyopts.opt;

		<span style="color: #FF1493;">if</span> (ipc.opt-&gt;srr) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21551;&#29992;&#20102;&#28304;&#36335;&#30001;&#36873;&#39033;</span>
			daddr = replyopts.opt.faddr;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#19979;&#19968;&#36339;ip&#22320;&#22336;&#20316;&#20026;&#30446;&#30340;&#22320;&#22336;</span>
	}

	{<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26597;&#25214;&#36335;&#30001;</span>
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">flowi</span> <span style="color: #FF8C00;">fl</span> = { .nl_u = { .ip4_u =
					      { .daddr = daddr,
						.saddr = rt-&gt;rt_spec_dst,
						.tos = RT_TOS(skb-&gt;nh.iph-&gt;tos) } },
				    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Not quite clean, but right.</span><span style="color: #8B8878;"> */</span>
				    .uli_u = { .ports =
					       { .sport = skb-&gt;h.th-&gt;dest,
						 .dport = skb-&gt;h.th-&gt;source } },
				    .proto = sk-&gt;sk_protocol };
		security_skb_classify_flow(skb, &amp;fl);
		<span style="color: #FF1493;">if</span> (ip_route_output_key(&amp;rt, &amp;fl))
			<span style="color: #FF1493;">return</span>;
	}

	bh_lock_sock(sk);
	inet-&gt;tos = skb-&gt;nh.iph-&gt;tos;
	sk-&gt;sk_priority = skb-&gt;priority;
	sk-&gt;sk_protocol = skb-&gt;nh.iph-&gt;protocol;
	ip_append_data(sk, ip_reply_glue_bits, arg-&gt;iov-&gt;iov_base, len, 0,
		       &amp;ipc, rt, MSG_DONTWAIT);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28155;&#21152;&#25968;&#25454;</span>
	<span style="color: #FF1493;">if</span> ((skb = skb_peek(&amp;sk-&gt;sk_write_queue)) != <span style="color: #AF87FF;">NULL</span>) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38431;&#21015;&#19981;&#20026;&#31354;</span>
		<span style="color: #FF1493;">if</span> (arg-&gt;csumoffset &gt;= 0)
			*((<span style="color: #5FD7FF;">__sum16</span> *)skb-&gt;h.raw + arg-&gt;csumoffset) = csum_fold(csum_add(skb-&gt;csum, arg-&gt;csum));
		skb-&gt;ip_summed = CHECKSUM_NONE;
		ip_push_pending_frames(sk);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;&#25968;&#25454;</span>
	}
	bh_unlock_sock(sk);
	ip_rt_put(rt);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org00e4e0d" class="outline-3">
<h3 id="org00e4e0d"><span class="section-number-3">11.3</span> UDP输出接口</h3>
<div class="outline-text-3" id="text-11-3">
</div>
<div id="outline-container-orgf44ff8d" class="outline-4">
<h4 id="orgf44ff8d"><span class="section-number-4">11.3.1</span> ip_append_data()</h4>
<div class="outline-text-4" id="text-11-3-1">
<p>
ip_append_data()函数主要用于 UDP 和 RAW 套接口，tcp中发送ACK和RST时，也会调用该函数。
</p>

<p>
ip_append_data()用于将大的数据包分成多个不大于MTU的SKB，为网络层的分片做准备。
</p>
<ul class="org-ul">
<li>如果先前的输出队列非空，则先向队列最后一个SKB填充</li>
<li>如果网络设备支持聚合分散I/O，则将数据写到frags指向的页面，如果页面填满，则再次分配页面。</li>
<li>进入下次循环，分配SKB，通过getfrag从传输层复制数据，并添加到输出队列的末尾。</li>
</ul>


<div class="figure">
<p><img src="image/ip-proto/ip-append-data.png" alt="ip-append-data.png" />
</p>
<p><span class="figure-number">Figure 8: </span>ip_append_data()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_append_data</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,
		   <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">getfrag</span>(<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">from</span>, <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">to</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">offset</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>,
			       <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">odd</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>),
		   <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">from</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">length</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">transhdrlen</span>,
		   <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ipcm_cookie</span> *<span style="color: #FF8C00;">ipc</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *<span style="color: #FF8C00;">rt</span>,
		   <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flags</span>);
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> ip_append_data参数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">参数</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">sk</td>
<td class="org-left">数据的传输控制块</td>
</tr>

<tr>
<td class="org-left">getfrag</td>
<td class="org-left">用于复制数据到SKB,不同传输层的复制方法也不同</td>
</tr>

<tr>
<td class="org-left">from</td>
<td class="org-left">输出数据的的数据块地址，指向内核空间或者用户空间</td>
</tr>

<tr>
<td class="org-left">length</td>
<td class="org-left">数据长度</td>
</tr>

<tr>
<td class="org-left">transhdrlen</td>
<td class="org-left">传输层首部长度</td>
</tr>

<tr>
<td class="org-left">ipc</td>
<td class="org-left">传递到IP层的临时信息块</td>
</tr>

<tr>
<td class="org-left">rt</td>
<td class="org-left">路由缓存项</td>
</tr>

<tr>
<td class="org-left">flags</td>
<td class="org-left">输出数据的标志</td>
</tr>
</tbody>
</table>

<p>
<i><b>int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb);</b></i>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> getfrag参数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">参数</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">from</td>
<td class="org-left">待复制数据</td>
</tr>

<tr>
<td class="org-left">to</td>
<td class="org-left">将要复制到的位置</td>
</tr>

<tr>
<td class="org-left">offset</td>
<td class="org-left">待复制数据的偏移</td>
</tr>

<tr>
<td class="org-left">len</td>
<td class="org-left">复制长度</td>
</tr>

<tr>
<td class="org-left">odd</td>
<td class="org-left">从上一个SKB中剩余下来并复制到此SKB的长度</td>
</tr>

<tr>
<td class="org-left">skb</td>
<td class="org-left">数据的SKB</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> 不同的getfrag</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">getfrag</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ip_generic_getfrag</td>
<td class="org-left">用于复制UDP或者RAW的数据</td>
</tr>

<tr>
<td class="org-left">udplite_getfrag</td>
<td class="org-left">用于复制轻量级UDP的数据</td>
</tr>

<tr>
<td class="org-left">ip_reply_glue_bits</td>
<td class="org-left">用于在TCP中复制RST和ACK段的数据</td>
</tr>

<tr>
<td class="org-left">icmp_glue_bits</td>
<td class="org-left">用于复制ICMP报文</td>
</tr>
</tbody>
</table>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      ip_append_data() and ip_append_page() can make one large IP datagram</span>
<span style="color: #8B8878;"> *      from many pieces of data. Each pieces will be holded on the socket</span>
<span style="color: #8B8878;"> *      until ip_push_pending_frames() is called. Each piece can be a page</span>
<span style="color: #8B8878;"> *      or non-page data.</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> *      Not only UDP, other transport protocols - e.g. raw sockets - can use</span>
<span style="color: #8B8878;"> *      this interface potentially.</span>
<span style="color: #8B8878;"> *</span>
<span style="color: #8B8878;"> *      LATER: length must be adjusted by pad at tail, when it is required.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_append_data</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,
		   <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">getfrag</span>(<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">from</span>, <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">to</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">offset</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>,
			       <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">odd</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>),
		   <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">from</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">length</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">transhdrlen</span>,
		   <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ipcm_cookie</span> *<span style="color: #FF8C00;">ipc</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *<span style="color: #FF8C00;">rt</span>,
		   <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flags</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;

	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span> *<span style="color: #FF8C00;">opt</span> = <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">hh_len</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">exthdrlen</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#20110;&#35760;&#24405;IPsec&#20013;&#30340;&#25193;&#23637;&#39318;&#37096;&#30340;&#38271;&#24230;</span>
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">mtu</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">copy</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">offset</span> = 0;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">maxfraglen</span>, <span style="color: #FF8C00;">fragheaderlen</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">csummode</span> = CHECKSUM_NONE;

	<span style="color: #FF1493;">if</span> (flags&amp;MSG_PROBE) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27492;&#26631;&#35782;&#20195;&#34920;&#36827;&#34892;&#36335;&#24452;MTU&#25506;&#27979;&#65292;&#19981;&#20250;&#20256;&#36882;&#25968;&#25454;</span>
		<span style="color: #FF1493;">return</span> 0;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#36755;&#20986;&#38431;&#21015;&#20026;&#31354;</span>
	<span style="color: #FF1493;">if</span> (skb_queue_empty(&amp;sk-&gt;sk_write_queue)) {
		opt = ipc-&gt;opt;
		<span style="color: #FF1493;">if</span> (opt) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23384;&#22312;ip&#36873;&#39033;&#65292;&#21017;&#38656;&#35201;&#23558;&#36873;&#39033;&#22797;&#21046;&#21040;&#20020;&#26102;&#20449;&#24687;&#22359;</span>
			<span style="color: #FF1493;">if</span> (inet-&gt;cork.opt == <span style="color: #AF87FF;">NULL</span>) {
				inet-&gt;cork.opt = kmalloc(<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span>) + 40, sk-&gt;sk_allocation);
				<span style="color: #FF1493;">if</span> (unlikely(inet-&gt;cork.opt == <span style="color: #AF87FF;">NULL</span>))
					<span style="color: #FF1493;">return</span> -ENOBUFS;
			}
			memcpy(inet-&gt;cork.opt, opt, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span>)+opt-&gt;optlen);
			inet-&gt;cork.flags |= IPCORK_OPT; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26631;&#35782;&#20020;&#26102;&#20449;&#24687;&#22359;&#20013;&#23384;&#22312;IP&#36873;&#39033;</span>
			inet-&gt;cork.addr = ipc-&gt;addr;
		}
		dst_hold(&amp;rt-&gt;u.dst);
		inet-&gt;cork.fragsize = mtu = dst_mtu(rt-&gt;u.dst.path); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20998;&#29255;&#22823;&#23567;</span>
		inet-&gt;cork.rt = rt;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36335;&#30001;</span>
		inet-&gt;cork.length = 0;
		sk-&gt;sk_sndmsg_page = <span style="color: #AF87FF;">NULL</span>;
		sk-&gt;sk_sndmsg_off = 0;
		<span style="color: #FF1493;">if</span> ((exthdrlen = rt-&gt;u.dst.header_len) != 0) {
			length += exthdrlen;
			transhdrlen += exthdrlen;
		}
	} <span style="color: #FF1493;">else</span> { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#38431;&#21015;&#19981;&#20026;&#31354;</span>
		rt = inet-&gt;cork.rt; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20351;&#29992;&#19978;&#27425;&#30340;&#36335;&#30001;</span>
		<span style="color: #FF1493;">if</span> (inet-&gt;cork.flags &amp; IPCORK_OPT)
			opt = inet-&gt;cork.opt;

		transhdrlen = 0;
		exthdrlen = 0;
		mtu = inet-&gt;cork.fragsize;
	}
	hh_len = LL_RESERVED_SPACE(rt-&gt;u.dst.dev);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38142;&#36335;&#23618;&#39318;&#37096;&#38271;&#24230;</span>
	fragheaderlen = <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>) + (opt ? opt-&gt;optlen : 0); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">IP&#39318;&#37096;&#38271;&#24230;&#38656;&#35201;4&#23383;&#33410;&#23545;&#40784;</span>
	maxfraglen = ((mtu - fragheaderlen) &amp; ~7) + fragheaderlen;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#30340;&#25968;&#25454;&#25253;&#38271;&#24230;&#22823;&#20110;&#19968;&#20010;IP&#25968;&#25454;&#25253;&#33021;&#23481;&#32435;&#30340;&#38271;&#24230;&#65292;&#36820;&#22238;EMSGSIZE&#20986;&#38169;&#28040;&#24687;</span>
	<span style="color: #FF1493;">if</span> (inet-&gt;cork.length + length &gt; 0xFFFF - fragheaderlen) {
		ip_local_error(sk, EMSGSIZE, rt-&gt;rt_dst, inet-&gt;dport, mtu-exthdrlen);
		<span style="color: #FF1493;">return</span> -EMSGSIZE;
	}

	<span style="color: #FF1493;">if</span> (transhdrlen &amp;&amp; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22823;&#20110;0,&#35828;&#26126;&#26159;&#39318;&#29255;&#25968;&#25454;</span>
	    length + fragheaderlen &lt;= mtu &amp;&amp;
	    rt-&gt;u.dst.dev-&gt;features &amp; NETIF_F_ALL_CSUM &amp;&amp; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32593;&#32476;&#35774;&#22791;&#25903;&#25345;&#26657;&#39564;&#21644;</span>
	    <span style="color: #CDC673; font-weight: bold;">!</span>exthdrlen)
		csummode = CHECKSUM_PARTIAL;

	inet-&gt;cork.length += length;
	<span style="color: #FF1493;">if</span> (((length &gt; mtu) &amp;&amp; (sk-&gt;sk_protocol == IPPROTO_UDP)) &amp;&amp;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">UDP&#25968;&#25454;&#25253;&#24182;&#19988;&#38656;&#35201;&#20998;&#29255;</span>
			(rt-&gt;u.dst.dev-&gt;features &amp; NETIF_F_UFO)) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32593;&#32476;&#35774;&#22791;&#25903;&#25345;UDP&#20998;&#29255;&#21368;&#36733;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">ip_ufo_append_data()&#36827;&#34892;&#20998;&#29255;&#22788;&#29702;</span>
		err = ip_ufo_append_data(sk, getfrag, from, length, hh_len,
					 fragheaderlen, transhdrlen, mtu,
					 flags);
		<span style="color: #FF1493;">if</span> (err)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">error</span>;
		<span style="color: #FF1493;">return</span> 0;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">So, what's going on in the loop below?</span>
<span style="color: #8B8878;">         *</span>
<span style="color: #8B8878;">         * We use calculated fragment length to generate chained skb,</span>
<span style="color: #8B8878;">         * each of segments is IP fragment ready for sending to network after</span>
<span style="color: #8B8878;">         * adding appropriate IP header.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38431;&#21015;&#26411;&#23614;&#30340;SKB&#20026;&#31354;&#65292;&#21017;&#38656;&#35201;&#20998;&#37197;</span>
	<span style="color: #FF1493;">if</span> ((skb = skb_peek_tail(&amp;sk-&gt;sk_write_queue)) == <span style="color: #AF87FF;">NULL</span>)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">alloc_new_skb</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24320;&#22987;&#24490;&#29615;&#22788;&#29702;&#25968;&#25454;</span>
	<span style="color: #FF1493;">while</span> (length &gt; 0) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Check if the remaining data fits into current packet.</span><span style="color: #8B8878;"> */</span>
		copy = mtu - skb-&gt;len;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26368;&#21518;&#19968;&#20010;SKB&#30340;&#21097;&#20313;&#31354;&#38388;&#33021;&#21542;&#23481;&#32435;&#25152;&#26377;&#25968;&#25454;</span>
		<span style="color: #FF1493;">if</span> (copy &lt; length)
			copy = maxfraglen - skb-&gt;len;
		<span style="color: #FF1493;">if</span> (copy &lt;= 0) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23567;&#20110;0,&#35828;&#26126;&#19978;&#19968;&#20010;SKB&#19981;&#33021;&#22635;&#20805;&#65292;&#38656;&#37325;&#26032;&#20998;&#37197;</span>
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#25968;&#25454;&#22797;&#21046;&#21040;&#26032;&#20998;&#37197;&#30340;SKB&#20013;</span>
			<span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">data</span>;
			<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">datalen</span>;
			<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">fraglen</span>;
			<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">fraggap</span>;
			<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">alloclen</span>;
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb_prev</span>;
<span style="color: #AF87FF;">alloc_new_skb</span>:
			skb_prev = skb;
			<span style="color: #FF1493;">if</span> (skb_prev)
				<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#22914;&#26524;&#19978;&#19968;&#20010;SKB&#20013;&#23384;&#22312;&#22810;&#20313;8&#23383;&#33410;&#23545;&#40784;&#30340;MTU&#25968;&#25454;&#65292;</span>
<span style="color: #8B8878;">                                &#21017;&#23558;&#36825;&#20123;&#25968;&#25454;&#31227;&#21160;&#21040;&#24403;&#21069;SKB,&#20197;&#30830;&#20445;&#26368;&#21518;&#19968;&#20010;IP&#20998;</span>
<span style="color: #8B8878;">                                &#29255;&#20043;&#22806;&#30340;&#25968;&#25454;&#33021;&#22815;4&#23383;&#33410;&#23545;&#40784;&#12290;&#22240;&#27492;&#35201;&#35745;&#31639;&#31227;&#21160;&#21040;&#24403;</span>
<span style="color: #8B8878;">                                &#21069;SKB&#30340;&#30340;&#25968;&#25454;&#38271;&#24230;</span>
<span style="color: #8B8878;">                                */</span>
				fraggap = skb_prev-&gt;len - maxfraglen;
			<span style="color: #FF1493;">else</span>
				fraggap = 0;

			<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                         * If remaining data exceeds the mtu,</span>
<span style="color: #8B8878;">                         * we know we need more fragment(s).</span>
<span style="color: #8B8878;">                         */</span>
			<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#21097;&#20313;&#25968;&#25454;&#36229;&#36807;MTU,&#21017;&#38656;&#35201;&#26356;&#22810;&#30340;&#20998;&#29255;</span><span style="color: #8B8878;">*/</span>
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;&#38656;&#35201;&#22797;&#21046;&#21040;&#26032;SKB&#30340;&#38271;&#24230;</span>
			datalen = length + fraggap;
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25968;&#25454;&#38271;&#24230;&#26080;&#27861;&#25918;&#22312;&#19968;&#20010;MTU&#20013;&#65292;&#37325;&#26032;&#35745;&#31639;&#38271;&#24230;</span>
			<span style="color: #FF1493;">if</span> (datalen &gt; mtu - fragheaderlen)
				datalen = maxfraglen - fragheaderlen;
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;&#19977;&#23618;&#39318;&#37096;&#21644;&#25968;&#25454;&#30340;&#24635;&#38271;&#24230;</span>
			fraglen = datalen + fragheaderlen;
			<span style="color: #FF1493;">if</span> ((flags &amp; MSG_MORE) &amp;&amp; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21518;&#32493;&#36824;&#26377;&#25968;&#25454;&#36755;&#20986;</span>
			    <span style="color: #CDC673; font-weight: bold;">!</span>(rt-&gt;u.dst.dev-&gt;features&amp;NETIF_F_SG)) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#22791;&#19981;&#25903;&#25345;&#32858;&#21512;&#20998;&#25955;I/O</span>
				alloclen = mtu;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;mtu&#20316;&#20026;skb&#30340;&#20998;&#37197;&#38271;&#24230;</span>
			<span style="color: #FF1493;">else</span><span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25353;&#25968;&#25454;&#38271;&#24230;&#20998;&#37197;SKB</span>
				alloclen = datalen + fragheaderlen;

			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">The last fragment gets additional space at tail.</span>
<span style="color: #8B8878;">                         * Note, with MSG_MORE we overallocate on fragments,</span>
<span style="color: #8B8878;">                         * because we have no idea what fragment will be</span>
<span style="color: #8B8878;">                         * the last.</span>
<span style="color: #8B8878;">                         */</span>

			<span style="color: #FF1493;">if</span> (datalen == length + fraggap)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26368;&#21518;&#19968;&#20010;&#20998;&#29255;</span>
				alloclen += rt-&gt;u.dst.trailer_len; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#30446;&#30340;&#36335;&#30001;&#21551;&#29992;IPSec,&#21017;&#38656;&#35201;&#22686;&#21152;&#23545;&#24212;&#30340;&#20998;&#37197;&#31354;&#38388;</span>

			<span style="color: #FF1493;">if</span> (transhdrlen) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23384;&#22312;&#20256;&#36755;&#23618;&#39318;&#37096;&#65292;&#35828;&#26126;&#26159;&#20998;&#32452;&#30340;&#39318;&#20010;&#20998;&#29255;</span>
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38656;&#35201;&#32771;&#34385;&#36755;&#20986;&#36229;&#26102;&#65292;&#20256;&#36755;&#23618;&#26159;&#21542;&#38169;&#35823;&#31561;&#24773;&#20917;</span>
				skb = sock_alloc_send_skb(sk,
						alloclen + hh_len + 15,
						(flags &amp; MSG_DONTWAIT), &amp;err);
			} <span style="color: #FF1493;">else</span> {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19981;&#26159;&#39318;&#20010;&#20998;&#29255;</span>
				skb = <span style="color: #AF87FF;">NULL</span>;
				<span style="color: #FF1493;">if</span> (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &lt;=
				    2 * sk-&gt;sk_sndbuf)
					skb = sock_wmalloc(sk,
							   alloclen + hh_len + 15, 1,
							   sk-&gt;sk_allocation);
				<span style="color: #FF1493;">if</span> (unlikely(skb == <span style="color: #AF87FF;">NULL</span>))
					err = -ENOBUFS;
			}
			<span style="color: #FF1493;">if</span> (skb == <span style="color: #AF87FF;">NULL</span>)
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">error</span>;

			<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                         *      Fill in the control structures</span>
<span style="color: #8B8878;">                         *///</span><span style="color: #8B8878;">&#22635;&#20805;&#29992;&#20110;&#26657;&#39564;&#30340;&#25511;&#21046;&#20449;&#24687;</span>
			skb-&gt;ip_summed = csummode;
			skb-&gt;csum = 0;
			skb_reserve(skb, hh_len);
			<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                         *      Find where to start putting bytes.</span>
<span style="color: #8B8878;">                         */</span> <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#39044;&#30041;&#29992;&#20110;&#23384;&#25918;&#20108;&#23618;&#39318;&#37096;&#12289;&#19977;&#23618;&#39318;&#37096;&#21644;&#25968;&#25454;&#30340;&#31354;&#38388;&#65292;&#24182;&#35774;&#32622;SKB&#30340;&#25351;&#21521;&#19977;&#23618;&#12289;&#22235;&#23618;&#30340;&#25351;&#38024;</span>
			data = skb_put(skb, fraglen);
			skb-&gt;nh.raw = data + exthdrlen;
			data += fragheaderlen;
			skb-&gt;h.raw = data + exthdrlen;

			<span style="color: #FF1493;">if</span> (fraggap) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35828;&#26126;&#19978;&#19968;&#20010;SKB&#30340;&#25968;&#25454;&#36229;&#36807;8&#23383;&#33410;&#23545;&#40784;MTU</span>
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#25968;&#25454;&#21644;&#20256;&#36755;&#23618;&#39318;&#37096;&#22797;&#21046;&#21040;&#24403;&#21069;SKB</span>
				skb-&gt;csum = skb_copy_and_csum_bits(
					skb_prev, maxfraglen,
					data + transhdrlen, fraggap, 0);
				skb_prev-&gt;csum = csum_sub(skb_prev-&gt;csum,
							  skb-&gt;csum);
				data += fraggap;
				pskb_trim_unique(skb_prev, maxfraglen);
			}
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#30528;&#22797;&#21046;&#21097;&#19979;&#30340;&#25968;&#25454;</span>
			copy = datalen - transhdrlen - fraggap;
			<span style="color: #FF1493;">if</span> (copy &gt; 0 &amp;&amp; getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) &lt; 0) {
				err = -EFAULT;
				kfree_skb(skb);
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">error</span>;
			}
			<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#23436;&#25104;&#26412;&#27425;&#25968;&#25454;&#30340;&#22797;&#21046;</span><span style="color: #8B8878;">*/</span>

			offset += copy; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19979;&#19968;&#27425;&#22797;&#21046;&#25968;&#25454;&#30340;&#20559;&#31227;</span>
			length -= datalen - fraggap; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21097;&#20313;&#25968;&#25454;&#38271;&#24230;</span>
			transhdrlen = 0;
			exthdrlen = 0;
			csummode = CHECKSUM_NONE;

			<span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;">                         * Put the packet on the pending queue.</span>
<span style="color: #8B8878;">                         */</span>
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;SKB&#28155;&#21152;&#33267;&#36755;&#20986;&#38431;&#21015;</span>
			__skb_queue_tail(&amp;sk-&gt;sk_write_queue, skb);
			<span style="color: #FF1493;">continue</span>;
		}

		<span style="color: #FF1493;">if</span> (copy &gt; length)  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19978;&#20010;SKB&#21097;&#20313;&#31354;&#38388;&#22823;&#20110;&#21097;&#20313;&#30340;&#24453;&#21457;&#36865;&#25968;&#25454;&#65292;&#21017;&#21487;&#20197;&#30452;&#25509;&#22797;&#21046;</span>
			copy = length;

		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>(rt-&gt;u.dst.dev-&gt;features&amp;NETIF_F_SG)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#22791;&#19981;&#25903;&#25345;&#32858;&#21512;&#20998;&#25955;I/O</span>
			<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">off</span>;
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22797;&#21046;&#25968;&#25454;&#21040;SKB&#30340;&#32447;&#24615;&#21306;</span>
			off = skb-&gt;len;
			<span style="color: #FF1493;">if</span> (getfrag(from, skb_put(skb, copy),
					offset, copy, off, skb) &lt; 0) {
				__skb_trim(skb, off);
				err = -EFAULT;
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">error</span>;
			}
		} <span style="color: #FF1493;">else</span> { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25903;&#25345;&#32858;&#21512;&#20998;&#25955;I/O&#65292;&#21017;&#22797;&#21046;&#21040;&#32858;&#21512;&#20998;&#25955;I/O&#21306;&#22495;</span>
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span> = skb_shinfo(skb)-&gt;nr_frags;
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#20998;&#29255;&#25968;&#32452;&#30340;&#26368;&#21518;&#20998;&#29255;</span>
			<span style="color: #5FD7FF;">skb_frag_t</span> *<span style="color: #FF8C00;">frag</span> = &amp;skb_shinfo(skb)-&gt;frags[i-1];
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> *<span style="color: #FF8C00;">page</span> = sk-&gt;sk_sndmsg_page;
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">off</span> = sk-&gt;sk_sndmsg_off; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24050;&#20351;&#29992;&#25968;&#25454;&#30340;&#32467;&#26463;&#20301;&#32622;&#20559;&#31227;</span>
			<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">left</span>;
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">page&#20013;&#23384;&#22312;&#21097;&#20313;&#31354;&#38388;</span>
			<span style="color: #FF1493;">if</span> (page &amp;&amp; (left = PAGE_SIZE - off) &gt; 0) {
				<span style="color: #FF1493;">if</span> (copy &gt;= left) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24453;&#22797;&#21046;&#25968;&#25454;&#22823;&#20110;&#21097;&#20313;&#31354;&#38388;</span>
					copy = left;
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#32531;&#23384;&#39029;&#19981;&#26159;&#26368;&#21518;&#19968;&#20010;&#32858;&#21512;&#20998;&#25955;I/O&#30340;&#39029;&#38754;</span>
				<span style="color: #FF1493;">if</span> (page != frag-&gt;page) {
					<span style="color: #FF1493;">if</span> (i == MAX_SKB_FRAGS) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32858;&#21512;&#20998;&#25955;I/O&#25968;&#25454;&#36824;&#27809;&#26377;&#28385;</span>
						err = -EMSGSIZE;
						<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">error</span>;
					}
					<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#30452;&#25509;&#20351;&#29992;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#32531;&#23384;&#39029;</span>
					get_page(page);
					<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#32531;&#23384;&#39029;&#28155;&#21152;&#33267;&#32858;&#21512;&#20998;&#25955;I/O&#39029;&#25968;&#32452;&#20013;</span>
					skb_fill_page_desc(skb, i, page, sk-&gt;sk_sndmsg_off, 0);
					frag = &amp;skb_shinfo(skb)-&gt;frags[i];
				}
			} <span style="color: #FF1493;">else</span> <span style="color: #FF1493;">if</span> (i &lt; MAX_SKB_FRAGS) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32858;&#21512;&#20998;&#25955;I/O&#39029;&#25968;&#32452;&#27809;&#26377;&#36798;&#21040;&#19978;&#38480;</span>
				<span style="color: #FF1493;">if</span> (copy &gt; PAGE_SIZE)
					copy = PAGE_SIZE;
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20998;&#37197;&#39029;&#38754;</span>
				page = alloc_pages(sk-&gt;sk_allocation, 0);
				<span style="color: #FF1493;">if</span> (page == <span style="color: #AF87FF;">NULL</span>)  {
					err = -ENOMEM;
					<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">error</span>;
				}
				sk-&gt;sk_sndmsg_page = page;
				sk-&gt;sk_sndmsg_off = 0;
				<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28155;&#21152;&#21040;&#32858;&#21512;&#20998;&#25955;I/O&#39029;&#38754;&#25968;&#32452;</span>
				skb_fill_page_desc(skb, i, page, 0, 0);
				frag = &amp;skb_shinfo(skb)-&gt;frags[i];
				skb-&gt;truesize += PAGE_SIZE; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#32531;&#23384;&#22823;&#23567;</span>
				atomic_add(PAGE_SIZE, &amp;sk-&gt;sk_wmem_alloc);
			} <span style="color: #FF1493;">else</span> {
				err = -EMSGSIZE;
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">error</span>;
			}
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#24453;&#21457;&#36865;&#25968;&#25454;&#22797;&#21046;&#21040;&#25351;&#23450;&#39029;&#38754;</span>
			<span style="color: #FF1493;">if</span> (getfrag(from, page_address(frag-&gt;page)+frag-&gt;page_offset+frag-&gt;size, offset, copy, skb-&gt;len, skb) &lt; 0) {
				err = -EFAULT;
				<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">error</span>;
			}
			sk-&gt;sk_sndmsg_off += copy;
			frag-&gt;size += copy;
			skb-&gt;len += copy;
			skb-&gt;data_len += copy;
		}
		offset += copy;
		length -= copy;
	}
	<span style="color: #FF1493;">return</span> 0;
<span style="color: #AF87FF;">error</span>:
	inet-&gt;cork.length -= length;
	IP_INC_STATS(IPSTATS_MIB_OUTDISCARDS);
	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org36da131" class="outline-4">
<h4 id="org36da131"><span class="section-number-4">11.3.2</span> ip_ufo_append_data()</h4>
<div class="outline-text-4" id="text-11-3-2">
<p>
该函数将数据复制到输出队列末尾SKB的聚合分散I/O页面中。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_ufo_append_data</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>,
			<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">getfrag</span>(<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">from</span>, <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">to</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">offset</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>,
			       <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">odd</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>),
			<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">from</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">length</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">hh_len</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">fragheaderlen</span>,
			<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">transhdrlen</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">mtu</span>,<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flags</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">There is support for UDP fragmentation offload by network</span>
<span style="color: #8B8878;">         * device, so create one single skb packet containing complete</span>
<span style="color: #8B8878;">         * udp datagram</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">if</span> ((skb = skb_peek_tail(&amp;sk-&gt;sk_write_queue)) == <span style="color: #AF87FF;">NULL</span>) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#38431;&#21015;&#20026;&#31354;</span>
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20998;&#37197;&#26032;&#30340;SKB,&#24182;&#22312;SKB&#32447;&#24615;&#21306;&#39044;&#30041;&#38142;&#36335;&#23618;&#12289;&#32593;&#32476;&#23618;&#12289;&#20256;&#36755;&#23618;&#39318;&#37096;&#31354;&#38388;&#12290;</span>
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags &amp; MSG_DONTWAIT), &amp;err);
		<span style="color: #FF1493;">if</span> (skb == <span style="color: #AF87FF;">NULL</span>)
			<span style="color: #FF1493;">return</span> err;
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">reserve space for Hardware header</span><span style="color: #8B8878;"> */</span>
		skb_reserve(skb, hh_len);
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">create space for UDP/IP header</span><span style="color: #8B8878;"> */</span>
		skb_put(skb,fragheaderlen + transhdrlen);
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">initialize network header pointer</span><span style="color: #8B8878;"> */</span>
		skb-&gt;nh.raw = skb-&gt;data;
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">initialize protocol header pointer</span><span style="color: #8B8878;"> */</span>
		skb-&gt;h.raw = skb-&gt;data + fragheaderlen;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#26657;&#39564;&#30456;&#20851;&#20449;&#24687;</span>
		skb-&gt;ip_summed = CHECKSUM_PARTIAL;
		skb-&gt;csum = 0;
		sk-&gt;sk_sndmsg_off = 0;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#25968;&#25454;&#22797;&#21046;&#21040;&#32858;&#21512;&#20998;&#25955;I/O&#39029;&#38754;&#20013;</span>
	err = skb_append_datato_frags(sk,skb, getfrag, from,
			       (length - transhdrlen));
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>err) {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">specify the length of each IP datagram fragment</span><span style="color: #8B8878;">*/</span>
		skb_shinfo(skb)-&gt;gso_size = mtu - fragheaderlen;
		skb_shinfo(skb)-&gt;gso_type = SKB_GSO_UDP;
		__skb_queue_tail(&amp;sk-&gt;sk_write_queue, skb);

		<span style="color: #FF1493;">return</span> 0;
	}
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">There is not enough support do UFO ,</span>
<span style="color: #8B8878;">         * so follow normal path</span>
<span style="color: #8B8878;">         */</span>
	kfree_skb(skb);
	<span style="color: #FF1493;">return</span> err;
}

</pre>
</div>

<ul class="org-ul">
<li>skb_append_datato_frags()函数用于将数据复制到SKB的聚合分散I/O页面中，直到复制完成或者SKB空间已满。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;"> * skb_append_datato_frags: - append the user data to a skb</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">@sk</span><span style="color: #CDC673;">: sock  structure</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">@skb</span><span style="color: #CDC673;">: skb structure to be appened with user data.</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">@getfrag</span><span style="color: #CDC673;">: call back function to be used for getting the user data</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">@from</span><span style="color: #CDC673;">: pointer to user message iov</span>
<span style="color: #CDC673;"> * </span><span style="color: #AF87FF;">@length</span><span style="color: #CDC673;">: length of the iov message</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> * Description: This procedure append the user data in the fragment part</span>
<span style="color: #CDC673;"> * of the skb if any page alloc fails user this procedure returns  -ENOMEM</span>
<span style="color: #CDC673;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">skb_append_datato_frags</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,
			<span style="color: #5FD7FF;">int</span> (*<span style="color: #87D700;">getfrag</span>)(<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">from</span>, <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">to</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">offset</span>,
					<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">odd</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>),
			<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">from</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">length</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">frg_cnt</span> = 0;
	<span style="color: #5FD7FF;">skb_frag_t</span> *<span style="color: #FF8C00;">frag</span> = <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">page</span> *<span style="color: #FF8C00;">page</span> = <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">copy</span>, <span style="color: #FF8C00;">left</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">offset</span> = 0;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ret</span>;

	<span style="color: #FF1493;">do</span> {
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Return error if we don't have space for new frag</span><span style="color: #8B8878;"> */</span>
		frg_cnt = skb_shinfo(skb)-&gt;nr_frags; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#24403;&#21069;&#30340;frags&#25968;&#32452;&#39033;&#30340;&#25968;&#30446;</span>
		<span style="color: #FF1493;">if</span> (frg_cnt &gt;= MAX_SKB_FRAGS)
			<span style="color: #FF1493;">return</span> -EFAULT;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20998;&#37197;&#31354;&#38386;&#39029;</span><span style="color: #8B8878;"> */</span>
		page = alloc_pages(sk-&gt;sk_allocation, 0);
		<span style="color: #FF1493;">if</span> (page == <span style="color: #AF87FF;">NULL</span>)
			<span style="color: #FF1493;">return</span> -ENOMEM;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#19979;&#19968;&#20010;frag&#25968;&#32452;&#39033;</span><span style="color: #8B8878;"> */</span>
		sk-&gt;sk_sndmsg_page = page;
		sk-&gt;sk_sndmsg_off = 0;
		skb_fill_page_desc(skb, frg_cnt, page, 0, 0);
		skb-&gt;truesize += PAGE_SIZE;
		atomic_add(PAGE_SIZE, &amp;sk-&gt;sk_wmem_alloc);

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">get the new initialized frag</span><span style="color: #8B8878;"> */</span>
		frg_cnt = skb_shinfo(skb)-&gt;nr_frags;
		frag = &amp;skb_shinfo(skb)-&gt;frags[frg_cnt - 1];

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">copy the user data to page</span><span style="color: #8B8878;"> */</span>
		left = PAGE_SIZE - frag-&gt;page_offset;
		copy = (length &gt; left)? left : length;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22797;&#21046;&#25968;&#25454;</span>
		ret = getfrag(from, (page_address(frag-&gt;page) +
			    frag-&gt;page_offset + frag-&gt;size),
			    offset, copy, 0, skb);
		<span style="color: #FF1493;">if</span> (ret &lt; 0)
			<span style="color: #FF1493;">return</span> -EFAULT;

		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">copy was successful so update the size parameters</span><span style="color: #8B8878;"> */</span>
		sk-&gt;sk_sndmsg_off += copy;
		frag-&gt;size += copy;
		skb-&gt;len += copy;
		skb-&gt;data_len += copy;
		offset += copy;
		length -= copy;

	} <span style="color: #FF1493;">while</span> (length &gt; 0);
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdf2bc62" class="outline-4">
<h4 id="orgdf2bc62"><span class="section-number-4">11.3.3</span> ip_push_pending_frames()</h4>
<div class="outline-text-4" id="text-11-3-3">
<p>
该函数将输出队列上的多个分片合成一个完整的IP数据报，并通过ip_output()输出。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *      Combined all pending IP fragments on the socket as one IP datagram</span>
<span style="color: #8B8878;"> *      and push them out.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">ip_push_pending_frames</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *<span style="color: #FF8C00;">sk</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, *<span style="color: #FF8C00;">tmp_skb</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> **<span style="color: #FF8C00;">tail_skb</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">inet_sock</span> *<span style="color: #FF8C00;">inet</span> = inet_sk(sk);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ip_options</span> *<span style="color: #FF8C00;">opt</span> = <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">rtable</span> *<span style="color: #FF8C00;">rt</span> = inet-&gt;cork.rt;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span>;
	<span style="color: #5FD7FF;">__be16</span> <span style="color: #FF8C00;">df</span> = 0;
	<span style="color: #5FD7FF;">__u8</span> <span style="color: #FF8C00;">ttl</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span> = 0;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#38431;&#21015;&#20026;&#31354;&#65292;&#26080;&#38656;&#22788;&#29702;</span>
	<span style="color: #FF1493;">if</span> ((skb = __skb_dequeue(&amp;sk-&gt;sk_write_queue)) == <span style="color: #AF87FF;">NULL</span>)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	tail_skb = &amp;(skb_shinfo(skb)-&gt;frag_list); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;fraglist&#38142;&#34920;&#29992;&#20110;&#23384;&#25918;&#22788;&#29702;&#21518;&#30340;&#20998;&#29255;</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#26657;&#27491;IP&#39318;&#37096;&#20301;&#32622;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;data &lt; skb-&gt;nh.raw)
		__skb_pull(skb, skb-&gt;nh.raw - skb-&gt;data);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24490;&#29615;&#22788;&#29702;&#36755;&#20986;&#38431;&#21015;&#30340;SKB</span>
	<span style="color: #FF1493;">while</span> ((tmp_skb = __skb_dequeue(&amp;sk-&gt;sk_write_queue)) != <span style="color: #AF87FF;">NULL</span>) {
		__skb_pull(tmp_skb, skb-&gt;h.raw - skb-&gt;nh.raw);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38142;&#25509;&#21040;frag_list&#38142;&#34920;&#30340;&#26411;&#23614;</span>
		*tail_skb = tmp_skb;
		tail_skb = &amp;(tmp_skb-&gt;next);
		skb-&gt;len += tmp_skb-&gt;len;
		skb-&gt;data_len += tmp_skb-&gt;len;
		skb-&gt;truesize += tmp_skb-&gt;truesize;
		__sock_put(tmp_skb-&gt;sk);
		tmp_skb-&gt;destructor = <span style="color: #AF87FF;">NULL</span>;
		tmp_skb-&gt;sk = <span style="color: #AF87FF;">NULL</span>;
	}

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Unless user demanded real pmtu discovery (IP_PMTUDISC_DO), we allow</span>
<span style="color: #8B8878;">         * to fragment the frame generated here. No matter, what transforms</span>
<span style="color: #8B8878;">         * how transforms change size of the packet, it will come out.</span>
<span style="color: #8B8878;">         */</span>
	<span style="color: #FF1493;">if</span> (inet-&gt;pmtudisc != IP_PMTUDISC_DO)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27809;&#26377;&#21551;&#29992;&#36335;&#24452;MTU&#21457;&#29616;&#65292;&#21017;&#21487;&#20197;&#20998;&#29255;</span>
		skb-&gt;local_df = 1;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">DF bit is set when we want to see DF on outgoing frames.</span>
<span style="color: #8B8878;">         * If local_df is set too, we still allow to fragment this frame</span>
<span style="color: #8B8878;">         * locally.</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (inet-&gt;pmtudisc == IP_PMTUDISC_DO ||  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21551;&#21160;&#36335;&#24452;MTU&#21457;&#29616;</span>
	    (skb-&gt;len &lt;= dst_mtu(&amp;rt-&gt;u.dst) &amp;&amp;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25968;&#25454;&#25253;&#38271;&#24230;&#23567;&#20110;MTU</span>
	     ip_dont_fragment(sk, &amp;rt-&gt;u.dst))) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25351;&#23450;&#20102;&#31105;&#27490;&#20998;&#29255;&#26631;&#24535;</span>
		df = htons(IP_DF); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31105;&#27490;&#20998;&#29255;</span>

	<span style="color: #FF1493;">if</span> (inet-&gt;cork.flags &amp; IPCORK_OPT)  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#25351;&#23450;&#20102;IP&#36873;&#39033;&#20449;&#24687;</span>
		opt = inet-&gt;cork.opt;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">ttl</span>
	<span style="color: #FF1493;">if</span> (rt-&gt;rt_type == RTN_MULTICAST)
		ttl = inet-&gt;mc_ttl;
	<span style="color: #FF1493;">else</span>
		ttl = ip_select_ttl(inet, &amp;rt-&gt;u.dst);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26500;&#24314;IP&#39318;&#37096;</span>
	iph = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *)skb-&gt;data;
	iph-&gt;version = 4;
	iph-&gt;ihl = 5;
	<span style="color: #FF1493;">if</span> (opt) {
		iph-&gt;ihl += opt-&gt;optlen&gt;&gt;2;
		ip_options_build(skb, opt, inet-&gt;cork.addr, rt, 0);
	}
	iph-&gt;tos = inet-&gt;tos;
	iph-&gt;tot_len = htons(skb-&gt;len);
	iph-&gt;frag_off = df;
	ip_select_ident(iph, &amp;rt-&gt;u.dst, sk);
	iph-&gt;ttl = ttl;
	iph-&gt;protocol = sk-&gt;sk_protocol;
	iph-&gt;saddr = rt-&gt;rt_src;
	iph-&gt;daddr = rt-&gt;rt_dst;
	ip_send_check(iph);

	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#25968;&#25454;&#25253;&#20248;&#20808;&#32423;&#20197;&#21450;&#30446;&#30340;&#36335;&#30001;</span>
	skb-&gt;priority = sk-&gt;sk_priority;
	skb-&gt;dst = dst_clone(&amp;rt-&gt;u.dst);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Netfilter gets whole the not fragmented skb.</span><span style="color: #8B8878;"> */</span>
	err = NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, <span style="color: #AF87FF;">NULL</span>,
		      skb-&gt;dst-&gt;dev, dst_output);
	<span style="color: #FF1493;">if</span> (err) {
		<span style="color: #FF1493;">if</span> (err &gt; 0)
			err = inet-&gt;recverr ? net_xmit_errno(err) : 0;
		<span style="color: #FF1493;">if</span> (err)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">error</span>;
	}
<span style="color: #AF87FF;">out</span>:
	inet-&gt;cork.flags &amp;= ~IPCORK_OPT;
	kfree(inet-&gt;cork.opt);
	inet-&gt;cork.opt = <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #FF1493;">if</span> (inet-&gt;cork.rt) {
		ip_rt_put(inet-&gt;cork.rt);
		inet-&gt;cork.rt = <span style="color: #AF87FF;">NULL</span>;
	}
	<span style="color: #FF1493;">return</span> err;

<span style="color: #AF87FF;">error</span>:
	IP_INC_STATS(IPSTATS_MIB_OUTDISCARDS);
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
}
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org530314d" class="outline-2">
<h2 id="org530314d"><span class="section-number-2">12</span> IP层对GSO的支持</h2>
<div class="outline-text-2" id="text-12">
<p>
IP层的GSO操作接口只是用来给链路层访问传输层。
</p>
</div>

<div id="outline-container-org38d26fc" class="outline-3">
<h3 id="org38d26fc"><span class="section-number-3">12.1</span> inet_gso_segment()</h3>
<div class="outline-text-3" id="text-12-1">
<p>
ip层的gso_segment接口的实现为 inet_gso_segment() 函数，该函数根据数据包获取对应的传输层接口，并完成GSO分段，之后对分段后的数据报重新计算校验和。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #87D700;">inet_gso_segment</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">features</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">segs</span> = ERR_PTR(-EINVAL);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_protocol</span> *<span style="color: #FF8C00;">ops</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">proto</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ihl</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">id</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26657;&#39564;SKB&#30340;gso_type</span>
	<span style="color: #FF1493;">if</span> (unlikely(skb_shinfo(skb)-&gt;gso_type &amp;
		     ~(SKB_GSO_TCPV4 |
		       SKB_GSO_UDP |
		       SKB_GSO_DODGY |
		       SKB_GSO_TCP_ECN |
		       0)))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">SKB&#25968;&#25454;&#25253;&#38271;&#24230;&#33267;&#23569;&#22823;&#20110;IP&#39318;&#37096;&#38271;&#24230;</span>
	<span style="color: #FF1493;">if</span> (unlikely(<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, <span style="color: #FF1493;">sizeof</span>(*iph))))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;

	iph = skb-&gt;nh.iph;
	ihl = iph-&gt;ihl * 4;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26657;&#39564;IP&#39318;&#37096;&#20013;&#30340;&#38271;&#24230;&#26159;&#21542;&#26377;&#25928;</span>
	<span style="color: #FF1493;">if</span> (ihl &lt; <span style="color: #FF1493;">sizeof</span>(*iph))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;IP&#39318;&#37096;&#20013;&#30340;&#38271;&#24230;&#65292;&#26657;&#39564;&#25968;&#25454;&#21253;&#38271;&#24230;</span>
	<span style="color: #FF1493;">if</span> (unlikely(<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, ihl)))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;

	skb-&gt;h.raw = __skb_pull(skb, ihl);
	iph = skb-&gt;nh.iph;
	id = ntohs(iph-&gt;id);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;IP&#39318;&#37096;&#30340;id&#23383;&#27573;</span>
	proto = iph-&gt;protocol &amp; (MAX_INET_PROTOS - 1);
	segs = ERR_PTR(-EPROTONOSUPPORT);

	rcu_read_lock();
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;IP&#39318;&#37096;&#30340;&#20256;&#36755;&#23618;&#21327;&#35758;&#65292;&#33719;&#21462;&#23545;&#24212;&#30340;&#20256;&#36755;&#23618;&#21327;&#35758;&#25509;&#21475;</span>
	ops = rcu_dereference(inet_protos[proto]);
	<span style="color: #FF1493;">if</span> (likely(ops &amp;&amp; ops-&gt;gso_segment))
		segs = ops-&gt;gso_segment(skb, features);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36827;&#34892;GSO&#36719;&#20998;&#27573;&#65292;&#25152;&#26377;&#20998;&#27573;&#36890;&#36807;skb&#30340;next&#38142;&#25509; &#65288;tcp&#20026;tcp_tso_segment()&#65289;</span>
	rcu_read_unlock();

	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>segs || unlikely(IS_ERR(segs)))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;

	skb = segs;
	<span style="color: #FF1493;">do</span> { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24490;&#29615;&#35745;&#31639;&#25152;&#26377;&#20998;&#27573;&#30340;IP&#26657;&#39564;&#21644;</span>
		iph = skb-&gt;nh.iph;
		iph-&gt;id = htons(id++);
		iph-&gt;tot_len = htons(skb-&gt;len - skb-&gt;mac_len);
		iph-&gt;check = 0;
		iph-&gt;check = ip_fast_csum(skb-&gt;nh.raw, iph-&gt;ihl);
	} <span style="color: #FF1493;">while</span> ((skb = skb-&gt;next));

<span style="color: #AF87FF;">out</span>:
	<span style="color: #FF1493;">return</span> segs;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0445795" class="outline-3">
<h3 id="org0445795"><span class="section-number-3">12.2</span> inet_gso_send_check()</h3>
<div class="outline-text-3" id="text-12-2">
<p>
IP层的gso_send_check的接口通过 inet_gso_send_check() 函数实现。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">inet_gso_send_check</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_protocol</span> *<span style="color: #FF8C00;">ops</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">proto</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ihl</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span> = -EINVAL;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33267;&#23569;&#22823;&#20110;IP&#39318;&#37096;&#38271;&#24230;</span>
	<span style="color: #FF1493;">if</span> (unlikely(<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, <span style="color: #FF1493;">sizeof</span>(*iph))))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;

	iph = skb-&gt;nh.iph;
	ihl = iph-&gt;ihl * 4;
	<span style="color: #FF1493;">if</span> (ihl &lt; <span style="color: #FF1493;">sizeof</span>(*iph)) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">IP&#39318;&#37096;&#38271;&#24230;&#20540;&#26159;&#21542;&#26377;&#25928;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;IP&#39318;&#37096;&#38271;&#24230;&#26657;&#39564;&#25968;&#25454;&#21253;&#38271;&#24230;</span>
	<span style="color: #FF1493;">if</span> (unlikely(<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, ihl)))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;

	skb-&gt;h.raw = __skb_pull(skb, ihl);
	iph = skb-&gt;nh.iph;
	proto = iph-&gt;protocol &amp; (MAX_INET_PROTOS - 1);
	err = -EPROTONOSUPPORT;

	rcu_read_lock();
	ops = rcu_dereference(inet_protos[proto]); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#20256;&#36755;&#23618;&#21327;&#35758;&#25509;&#21475;</span>
	<span style="color: #FF1493;">if</span> (likely(ops &amp;&amp; ops-&gt;gso_send_check))
		err = ops-&gt;gso_send_check(skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#29992;&#20256;&#36755;&#23618;&#30340;&#25509;&#21475;&#65288;tcp&#20026; tcp_v4_gso_send_check()&#65289;</span>
	rcu_read_unlock();

<span style="color: #AF87FF;">out</span>:
	<span style="color: #FF1493;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2021-12-31 Fri 23:00</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
