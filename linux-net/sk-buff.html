<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>套接口缓存</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">套接口缓存</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5bcb939">1. sk_buff 结构</a>
<ul>
<li><a href="#org5017c6f">1.1. SKB组织相关的变量</a></li>
<li><a href="#orgd4fe638">1.2. 数据存储相关的变量</a></li>
<li><a href="#orgcf9945a">1.3. 通用的成员变量</a></li>
<li><a href="#org26bffb0">1.4. 标志性变量</a></li>
<li><a href="#org7a65651">1.5. 特性相关的成员变量</a></li>
</ul>
</li>
<li><a href="#org73e6359">2. skb_shared_info结构</a>
<ul>
<li><a href="#org3a37f41">2.1. 零拷贝</a></li>
<li><a href="#org0923bd0">2.2. 对聚合分散I/O数据的支持</a></li>
<li><a href="#orgd09a9c5">2.3. 对GSO的支持</a></li>
<li><a href="#orgeed3c5d">2.4. 访问skb_shared_info结构</a></li>
</ul>
</li>
<li><a href="#org1edc574">3. 管理函数</a>
<ul>
<li>
<ul>
<li><a href="#org1964e98">3.0.1. SKB缓存池</a></li>
<li><a href="#org1f1c570">3.0.2. 分配SKB</a></li>
<li><a href="#org5ac14cd">3.0.3. 释放SKB</a></li>
<li><a href="#org45f028f">3.0.4. 数据预留和对齐</a></li>
<li><a href="#orgb69bb4a">3.0.5. 克隆和复制SKB</a></li>
<li><a href="#org21203a1">3.0.6. 链表管理函数</a></li>
<li><a href="#org4f0d87e">3.0.7. 添加或删除尾部数据</a></li>
<li><a href="#org5e30e15">3.0.8. 拆分数据：skb_split()</a></li>
<li><a href="#org39039cc">3.0.9. 重新分配SKB的线性数据区：pskb_expand_head()</a></li>
<li><a href="#orgb92031a">3.0.10. 其他函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="org7a65722" class="figure">
<p><img src="image/sk-buff/skbuff.png" alt="skbuff.png" />
</p>
</div>


<p>
linux中使用 <code>sruct sk_buff</code> 数据结构来描述已经接受或者代发送的数据报文信息。后续我们使用“SKB”来指代 <code>struct sk_buff</code> 。
</p>

<p>
SKB的操作函数以及宏定义设计以下文件：
</p>
<ul class="org-ul">
<li>include/linux/skbuff.h，SKB结构定义以及宏定义。</li>
<li>net/core/skbuff.c，操作SKB的函数。</li>
</ul>

<div id="outline-container-org5bcb939" class="outline-2">
<h2 id="org5bcb939"><span class="section-number-2">1.</span> sk_buff 结构</h2>
<div class="outline-text-2" id="text-1">
<p>
struct sk_buff结构定义比较复杂，其成员大致可以分为以下几类：
</p>
<ul class="org-ul">
<li>组织SKB的成员变量。</li>
<li>通用成员变量。</li>
<li>标志性成员变量。</li>
<li>与特性相关的成员变量。</li>
</ul>


<p>
SKB分为两个部分，一部分是SKB描述符（sk_buff结构本身），另一部分为数据缓冲区。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> {
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">These two members must be first.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>          *<span style="color: #FD971F;">next</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>          *<span style="color: #FD971F;">prev</span>;

        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span>             *<span style="color: #FD971F;">sk</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">skb_timeval</span>      <span style="color: #FD971F;">tstamp</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span>       *<span style="color: #FD971F;">dev</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span>       *<span style="color: #FD971F;">input_dev</span>;

        <span style="color: #F92672;">union</span> {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>   *<span style="color: #FD971F;">th</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>   *<span style="color: #FD971F;">uh</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">icmphdr</span>  *<span style="color: #FD971F;">icmph</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">igmphdr</span>  *<span style="color: #FD971F;">igmph</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>    *<span style="color: #FD971F;">ipiph</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ipv6hdr</span>  *<span style="color: #FD971F;">ipv6h</span>;
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span>   *<span style="color: #FD971F;">raw</span>;
        } <span style="color: #FD971F;">h</span>;

        <span style="color: #F92672;">union</span> {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>    *<span style="color: #FD971F;">iph</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ipv6hdr</span>  *<span style="color: #FD971F;">ipv6h</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">arphdr</span>   *<span style="color: #FD971F;">arph</span>;
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span>   *<span style="color: #FD971F;">raw</span>;
        } <span style="color: #FD971F;">nh</span>;

        <span style="color: #F92672;">union</span> {
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span>   *<span style="color: #FD971F;">raw</span>;
        } <span style="color: #FD971F;">mac</span>;

        <span style="color: #F92672;">struct</span>  <span style="color: #66D9EF;">dst_entry</span>       *<span style="color: #FD971F;">dst</span>;
        <span style="color: #F92672;">struct</span>  <span style="color: #66D9EF;">sec_path</span>        *<span style="color: #FD971F;">sp</span>;

        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * This is the control buffer. It is free to use for every</span>
<span style="color: #75715E;">         * layer. Please put your private variables there. If you</span>
<span style="color: #75715E;">         * want to keep them across layers you have to do a skb_clone()</span>
<span style="color: #75715E;">         * first. This is owned by whoever has the skb queued ATM.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #66D9EF;">char</span>                    <span style="color: #FD971F;">cb</span>[48];

        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>            <span style="color: #FD971F;">len</span>,
                                <span style="color: #FD971F;">data_len</span>,
                                <span style="color: #FD971F;">mac_len</span>;
        <span style="color: #F92672;">union</span> {
                <span style="color: #66D9EF;">__wsum</span>          <span style="color: #FD971F;">csum</span>;
                <span style="color: #66D9EF;">__u32</span>           <span style="color: #FD971F;">csum_offset</span>;
        };
        <span style="color: #66D9EF;">__u32</span>                   <span style="color: #FD971F;">priority</span>;
        <span style="color: #66D9EF;">__u8</span>                    <span style="color: #FD971F;">local_df</span>:1,
                                <span style="color: #FD971F;">cloned</span>:1,
                                <span style="color: #FD971F;">ip_summed</span>:2,
                                <span style="color: #FD971F;">nohdr</span>:1,
                                <span style="color: #FD971F;">nfctinfo</span>:3;
        <span style="color: #66D9EF;">__u8</span>                    <span style="color: #FD971F;">pkt_type</span>:3,
                                <span style="color: #FD971F;">fclone</span>:2,
                                <span style="color: #FD971F;">ipvs_property</span>:1;
        <span style="color: #66D9EF;">__be16</span>                  <span style="color: #FD971F;">protocol</span>;

        <span style="color: #66D9EF;">void</span>                    (*<span style="color: #A6E22E;">destructor</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>);
<span style="color: #F92672;">#ifdef</span> CONFIG_NETFILTER
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nf_conntrack</span>     *<span style="color: #FD971F;">nfct</span>;
<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span>(CONFIG_NF_CONNTRACK) || <span style="color: #F92672;">defined</span>(CONFIG_NF_CONNTRACK_MODULE)
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>          *<span style="color: #FD971F;">nfct_reasm</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_BRIDGE_NETFILTER
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nf_bridge_info</span>   *<span style="color: #FD971F;">nf_bridge</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#endif</span> <span style="color: #75715E;">/* </span><span style="color: #75715E;">CONFIG_NETFILTER</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_NET_SCHED
        <span style="color: #66D9EF;">__u16</span>                   <span style="color: #FD971F;">tc_index</span>;       <span style="color: #75715E;">/* </span><span style="color: #75715E;">traffic control index</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_NET_CLS_ACT
        <span style="color: #66D9EF;">__u16</span>                   <span style="color: #FD971F;">tc_verd</span>;        <span style="color: #75715E;">/* </span><span style="color: #75715E;">traffic control verdict</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_NET_DMA
        <span style="color: #66D9EF;">dma_cookie_t</span>            <span style="color: #FD971F;">dma_cookie</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_NETWORK_SECMARK
        <span style="color: #66D9EF;">__u32</span>                   <span style="color: #FD971F;">secmark</span>;
<span style="color: #F92672;">#endif</span>

        <span style="color: #66D9EF;">__u32</span>                   <span style="color: #FD971F;">mark</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">These elements must be at the end, see alloc_skb() for details.</span><span style="color: #75715E;">  */</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>            <span style="color: #FD971F;">truesize</span>;
        <span style="color: #66D9EF;">atomic_t</span>                <span style="color: #FD971F;">users</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span>           *<span style="color: #FD971F;">head</span>,
                                *<span style="color: #FD971F;">data</span>,
                                *<span style="color: #FD971F;">tail</span>,
                                *<span style="color: #FD971F;">end</span>;
};
</pre>
</div>
</div>

<div id="outline-container-org5017c6f" class="outline-3">
<h3 id="org5017c6f"><span class="section-number-3">1.1.</span> SKB组织相关的变量</h3>
<div class="outline-text-3" id="text-1-1">
<p>
sk_buff结构中，很多结构是为了便于组织结构本身，例如下面两个变量。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">next</span>;
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">prev</span>;
</pre>
</div>

<p>
通过这两个指针，将SKB连接成一个双向链表。此链表有一个要求：每个SKB必须能被整个链表头部快速找到，通过在第一个SKB节点前面插入另一个辅助的sk_buff_head结构的头节点，可以认为该sk_buff_head结构就是SKB链表的头节点。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff_head</span> {
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">These two members must be first.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>  *<span style="color: #FD971F;">next</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>  *<span style="color: #FD971F;">prev</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">SKB&#38142;&#34920;&#20013;&#30340;&#33410;&#28857;&#25968;&#37327;&#65292;&#21363;&#38431;&#21015;&#38271;&#24230;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">__u32</span>           <span style="color: #FD971F;">qlen</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#25511;&#21046;&#23545;SKB&#38142;&#34920;&#30340;&#24182;&#21457;&#25805;&#20316;&#30340;&#33258;&#36873;&#38145;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">spinlock_t</span>      <span style="color: #FD971F;">lock</span>;
};
</pre>
</div>


<div id="org9c622f1" class="figure">
<p><img src="image/sk-buff/sk-buff-head.png" alt="sk-buff-head.png" />
</p>
<p><span class="figure-number">Figure 1: </span>SKB链表</p>
</div>
</div>
</div>

<div id="outline-container-orgd4fe638" class="outline-3">
<h3 id="orgd4fe638"><span class="section-number-3">1.2.</span> 数据存储相关的变量</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li><p>
struct sock *sk
</p>

<p>
SKB的宿主传输控制块。SKB的宿主传输控制块在网络数据报文由本地发出或者由本地接受时才有效，使传输控制块与套接口及用户应用程序相关。当一个SKB仅在二层或者三层被转发时（即源IP和目的IP都不是本机地址），指针为NULL。
</p></li>

<li><p>
unsigned int len
</p>

<p>
SKB中数据部分长度，包括线性缓存区中数据长度（data指向），SG类型的聚合分散I/O的数据以及FRAGLIST类型的聚合分散I/O的数据长度。该字段值随着SKB从一个协议向另一个协议层传递而改变，向上传递时，下层首部不再需要，向下层传递时，需要添加本层首部。因此len也包含了协议首部的长度。
</p></li>

<li><p>
unsigned int mac_len
</p>

<p>
二层首部长度
</p></li>

<li><p>
void (*destructor)(struct sk_buff *skb)
</p>

<p>
SKB的析构函数指针，在释放SKB时被调用，完成一些必要的工作。在转发时，SKB没有宿主传输控制块，该指针通常为NULL。通常分别在skb_set_owner_t()和skb_set_owner_w()中被初始化成sock_rfree()和sock_wfree()。当释放SKB后，该SKB不再属于制定的传输控制块，因此要根据释放的SKB的truesize来调整传输控制块的接收和发送缓存区大小（sk_rmem_alloc和sk_wmem_alloc）。
</p></li>

<li><p>
unsigned char *head, *data, *tail, *end
</p>

<p>
head和end分别指向缓冲区的头和尾；data和tail分别指向数据的头和尾。在发送数据时，每一层协议在head和data之间填充协议首部数据，还可能在tail和end之间添加数据。
</p></li>

<li><p>
unsigned int trusize
</p>

<p>
整个数据缓冲区的总长度，包括SKB描述符和数据缓冲区部分（保活线性存储区和聚合分散I/O缓冲区）。
</p></li>

<li><p>
atomic_t users
</p>

<p>
引用计数，用来表示有多少实体引用了该SKB，用于确定SKB的释放时机，计数为0时，SKB才能被释放。注意该计数器之保护SKB描述符，SKB数据缓冲区也有类似的计数器。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgcf9945a" class="outline-3">
<h3 id="orgcf9945a"><span class="section-number-3">1.3.</span> 通用的成员变量</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li><p>
struct skb_timeval tstamp
</p>

<p>
接收时间戳或者发送时间戳。通常在网络设备受到一个数据包之后，通过netif_receive_skb()或者netif_rx()调用net_timestamp()进行设置。
</p></li>

<li><p>
struct net_device *dev
</p>

<p>
网络设备指针。改组段的作用与SKB时发送包还是接收包有关。在初始化网络设备驱动分配接受缓存队列时，将该指针指向收到数据包的网络设备。
</p>

<p>
发送数据包时，该指针指向输出数据包的网络设备。
</p>

<p>
Linux支持多种形式的虚拟网络设备，并由一个虚拟网络设备驱动管理。当这个虚拟设备被使用时，dev指针指向该虚拟设备的net_device结构。在输出时，虚拟设备驱动会在一组设备中选择合适的设备，并将dev指针修改为指向这个设备的net_device结构。而在输入时，当院士网络设备接收到报文后，根据某种算法选择合适的虚拟网络设备，并将dev指针指向这个虚拟设备的net_device结构。因此，某些情况下，此指针会在包处理过程中改变。
</p></li>

<li><p>
struct net_device *input_dev
</p>

<p>
接收报文的原始网络设备。如果是本地生成的，则为NULL，主要用于流量控制。
</p></li>

<li><p>
h（四层）, nh（三层）, mac（二层）
</p>

<p>
分别和i指向各层协议首部的指针。
</p>


<div id="org8efb19e" class="figure">
<p><img src="image/sk-buff/skb-mac-n.png" alt="skb-mac-n.png" />
</p>
<p><span class="figure-number">Figure 2: </span>报文从二层项三层传递时的data指针变化</p>
</div></li>

<li><p>
struct dst_entry *dst
</p>

<p>
目的路由缓存。
</p></li>

<li><p>
char cb[48]
</p>

<p>
SKB信息控制块，是每层协议的似有信息存储空间，由每一层协议自己维护并使用，并只在本层有效。在分配SKB时固定在SKB描述符中，当前为48字节，子沟为每一层协议存储必要的似有信息。在每个协议中，访问该字段的代码通常用宏实现以增强代码的可读性。例如，TCP用此成员存储tcp_sbk_cb结构的数据。
</p></li>

<li><p>
校验和
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">union</span> {
      <span style="color: #66D9EF;">__wsum</span>            <span style="color: #FD971F;">csum</span>;
      <span style="color: #66D9EF;">__u32</span>             <span style="color: #FD971F;">csum_offset</span>;
};
</pre>
</div></li>

<li><p>
__u8 ip_summed:2
</p>

<p>
标记传输层校验和的状态。
</p></li>

<li><p>
__u8 cloned
</p>

<p>
标记所属SKB是否已经克隆。
</p></li>

<li><p>
__u8 pkt_type
</p>

<p>
帧类型，分类是由二层目的地址来决定，对于以太网设备来说，该字段由eth_type_trans()初始化。
</p></li>

<li><p>
__u32 priority
</p>

<p>
发送或者转发数据包QoS类别。如果数据包是本地生成的，套接口层会设置该字段；如果包是转发的，则rt_tos2priority()会根据IP首部中TOS域来计算该字段值。
</p></li>

<li><p>
__be16 protocol
</p>

<p>
从二层设备的角度看到的上层协议，即链路层承载的三层协议类型。典型的协议包括IP、IPv6和ARP。由于每个协议都有各自处理接收数据包的函数，因此该区域被设备驱动用来通知上层电泳那个协议处理函数。由于每个网络驱动都调用netif_rx()来通知上层网络协议的处理函数，因此protocol必须在这些协议处理函数调用前初始化。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org26bffb0" class="outline-3">
<h3 id="org26bffb0"><span class="section-number-3">1.4.</span> 标志性变量</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li><p>
__u8 nohdr:1
</p>

<p>
标识payload是否被单独引用，不存在协议首部。如果被引用，则决不能再修改协议首部，也不能通过skb-&gt;data来访问协议首部。
</p></li>

<li><p>
__u8 local_df
</p>

<p>
表示此SKB在本地允许分片。
</p></li>

<li><p>
__u8 fclone:2
</p>

<p>
当前的克隆状态。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org7a65651" class="outline-3">
<h3 id="org7a65651"><span class="section-number-3">1.5.</span> 特性相关的成员变量</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>__u8 nfct</li>
<li>struct nf_conntrack *nfct;</li>
<li>struct nf_bridge_info *nf_bridge;</li>

<li>__u16 tc_index</li>
<li>__u16 tc_verd</li>
<li>struct sec_path *sp</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org73e6359" class="outline-2">
<h2 id="org73e6359"><span class="section-number-2">2.</span> skb_shared_info结构</h2>
<div class="outline-text-2" id="text-2">
<p>
skb_shared_info 保存了数据块的附加信息，其位置紧邻end指针指向的地址。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">skb_shared_info</span> {
        <span style="color: #66D9EF;">atomic_t</span>        <span style="color: #FD971F;">dataref</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25968;&#25454;&#32531;&#20914;&#21306;&#30340;&#24341;&#29992;&#35745;&#25968;</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>  <span style="color: #FD971F;">nr_frags</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>  <span style="color: #FD971F;">gso_size</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>  <span style="color: #FD971F;">gso_segs</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>  <span style="color: #FD971F;">gso_type</span>;
        <span style="color: #66D9EF;">__be32</span>          <span style="color: #FD971F;">ip6_frag_id</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>  *<span style="color: #FD971F;">frag_list</span>;
        <span style="color: #66D9EF;">skb_frag_t</span>      <span style="color: #FD971F;">frags</span>[MAX_SKB_FRAGS];
};
</pre>
</div>
</div>

<div id="outline-container-org3a37f41" class="outline-3">
<h3 id="org3a37f41"><span class="section-number-3">2.1.</span> 零拷贝</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<b>sendfile系统调用</b>
</p>


<div id="orgefc62ad" class="figure">
<p><img src="image/sk-buff/read-write-copy.png" alt="read-write-copy.png" />
</p>
<p><span class="figure-number">Figure 3: </span>read+write系统调用过程中的数据复制</p>
</div>


<div id="org57304b6" class="figure">
<p><img src="image/sk-buff/open-sendfile-copy.png" alt="open-sendfile-copy.png" />
</p>
<p><span class="figure-number">Figure 4: </span>open+sendfile系统调用过程中的数据复制</p>
</div>
</div>
</div>

<div id="outline-container-org0923bd0" class="outline-3">
<h3 id="org0923bd0"><span class="section-number-3">2.2.</span> 对聚合分散I/O数据的支持</h3>
<div class="outline-text-3" id="text-2-2">
<p>
聚合分散I/O 使得无需将报文组装成一个单块，可以避免大量的拷贝。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">// </span><span style="color: #75715E;">frags&#21644;frag_list &#29992;&#20110;&#25351;&#21521;&#32858;&#21512;&#20998;&#25955; I/O &#25968;&#25454;</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>  <span style="color: #FD971F;">nr_frags</span>;
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>  *<span style="color: #FD971F;">frag_list</span>;
<span style="color: #66D9EF;">skb_frag_t</span>      <span style="color: #FD971F;">frags</span>[MAX_SKB_FRAGS];



<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAX_SKB_FRAGS</span> (65536/PAGE_SIZE + 2)
<span style="color: #F92672;">typedef</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">skb_frag_struct</span> <span style="color: #66D9EF;">skb_frag_t</span>;
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">skb_frag_struct</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> *<span style="color: #FD971F;">page</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25351;&#21521;&#31995;&#32479;&#32531;&#23384;&#39029;&#30340;&#25351;&#38024;</span>
        <span style="color: #66D9EF;">__u16</span> <span style="color: #FD971F;">page_offset</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25968;&#25454;&#36215;&#22987;&#22320;&#22336;&#22312;&#25991;&#20214;&#32531;&#23384;&#39029;&#20013;&#30340;&#20559;&#31227;</span>
        <span style="color: #66D9EF;">__u16</span> <span style="color: #FD971F;">size</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25968;&#25454;&#22312;&#25991;&#20214;&#31995;&#32479;&#32531;&#23384;&#39029;&#20013;&#30340;&#38271;&#24230;</span>
};
</pre>
</div>

<p>
frag_list的使用场景：
</p>
<ul class="org-ul">
<li>在接收分片组后链接多个分片，组成一个完成的IP数据报。</li>
<li>在UDP数据报的输出中，将待分片的SKB链接到第一个SKB中。</li>
<li>用于存放FRAGLIST类型的聚合分散I/O的数据包，如果网络设备支持FRAGLIST类型的聚合分散I/O（lo），则可以直接输出。</li>
</ul>

<p>
分片通过shb_shared_info结构的 nr_frags 和 frag_list 来控制。
</p>

<p>
skb_is_nonlinear()用来测试是否存在聚合分散I/O缓存区（判断data_len成员）。
</p>

<p>
skb_linearize()可以把含有聚合分散I/O的缓存区线性化到线性缓存区。
</p>



<div id="orgfc3f22c" class="figure">
<p><img src="image/sk-buff/linear.png" alt="linear.png" />
</p>
<p><span class="figure-number">Figure 5: </span>未启用聚合分散I/O分片的报文</p>
</div>

<p>
data_len为0，nr_frags 为0， frag_list为NULL。
</p>



<div id="org9e81268" class="figure">
<p><img src="image/sk-buff/nonlinear.png" alt="nonlinear.png" />
</p>
<p><span class="figure-number">Figure 6: </span>启用聚合分散I/O分片的报文</p>
</div>

<p>
数据长度len 为 x+S1+S2。 nr_frags为2，frags_list为NULL，说明为聚合分散I/O分片。
</p>



<div id="org0d39d21" class="figure">
<p><img src="image/sk-buff/nonlinear-shared.png" alt="nonlinear-shared.png" />
</p>
<p><span class="figure-number">Figure 7: </span>启用聚合分散I/O分片的两个报文共享物理内存页</p>
</div>



<div id="orgad12c48" class="figure">
<p><img src="image/sk-buff/nonlinear-fraglist.png" alt="nonlinear-fraglist.png" />
</p>
<p><span class="figure-number">Figure 8: </span>包含FRAGLIST类型的分散聚合I/O数据的报文</p>
</div>

<p>
frag_list不为NULL，说明存在FRAGLIST类型的分散聚合I/O数据。
</p>
</div>
</div>

<div id="outline-container-orgd09a9c5" class="outline-3">
<h3 id="orgd09a9c5"><span class="section-number-3">2.3.</span> 对GSO的支持</h3>
<div class="outline-text-3" id="text-2-3">
<p>
现在很多网络设备都可以完成一些三层四层校验和的计算，有些甚至可以维护四层协议的状态机，通过硬件完成分段或者分片，因此传输层通过网络层提交给设备时可能是GSO段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #75715E;">&#29983;&#25104;GSO&#27573;&#26159;&#30340;MSS&#65292;GSO&#27573;&#26159;MSS&#30340;&#25972;&#25968;&#20493;</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>  <span style="color: #FD971F;">gso_size</span>;
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;gso_size&#20998;&#21106;&#26102;&#20135;&#29983;&#30340;&#27573;&#25968;</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>  <span style="color: #FD971F;">gso_segs</span>;
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#25903;&#25345;&#30340;GSO&#31867;&#22411;</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>  <span style="color: #FD971F;">gso_type</span>;
</pre>
</div>

<p>
常见GSO类型：
</p>
<ul class="org-ul">
<li>SKB_GSO_TCPV4 ipv4的tcp段卸载</li>
<li>SKB_GSO_UDP ipv4的udp分片卸载</li>
<li>SKB_GSO_TCPV6 ipv6的tcp段卸载</li>
</ul>
</div>
</div>

<div id="outline-container-orgeed3c5d" class="outline-3">
<h3 id="orgeed3c5d"><span class="section-number-3">2.4.</span> 访问skb_shared_info结构</h3>
<div class="outline-text-3" id="text-2-4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">#define</span> <span style="color: #A6E22E;">skb_shinfo</span>(<span style="color: #FD971F;">SKB</span>) ((<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">skb_shared_info</span> *)(skb_end_pointer(SKB)))
</pre>
</div>

<p>
sk_buff结构中并没有指向skb_shared_info结构的指针，可以通过上面的宏来访问skb_shared_info结构。
</p>
</div>
</div>
</div>


<div id="outline-container-org1edc574" class="outline-2">
<h2 id="org1edc574"><span class="section-number-2">3.</span> 管理函数</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org1964e98" class="outline-4">
<h4 id="org1964e98"><span class="section-number-4">3.0.1.</span> SKB缓存池</h4>
<div class="outline-text-4" id="text-3-0-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">__init</span> skb_init(<span style="color: #66D9EF;">void</span>)
{
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21019;&#24314;skbuff_head_cache&#39640;&#36895;&#32531;&#23384;&#65292;&#19968;&#33324;&#24773;&#20917;&#19979;&#65292;SKB&#37117;&#26159;&#20174;&#35813;&#32531;&#23384;&#20013;&#20998;&#37197;</span><span style="color: #75715E;"> */</span>
        skbuff_head_cache = kmem_cache_create(<span style="color: #E6DB74;">"skbuff_head_cache"</span>,
                                              <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>),
                                              0,
                                              SLAB_HWCACHE_ALIGN|SLAB_PANIC,
                                              <span style="color: #AE81FF;">NULL</span>, <span style="color: #AE81FF;">NULL</span>);
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">        &#21019;&#24314;skbuff_fclone_cache&#39640;&#36895;&#32531;&#23384;&#12290;</span>

<span style="color: #75715E;">        &#22914;&#26524;&#22312;&#20998;&#37197;&#26102;&#30693;&#36947;SKB&#21487;&#33021;&#34987;&#20811;&#38534;&#65292;&#37027;&#20040;&#24212;&#35813;&#20174;&#35813;&#39640;&#36895;&#32531;&#23384;&#20013;&#20998;&#37197;SKB&#65292;</span>
<span style="color: #75715E;">        &#22312;&#27492;&#39640;&#36895;&#32531;&#23384;&#20013;&#20998;&#37197;SKB&#26102;&#65292;&#20250;&#21516;&#26102;&#20998;&#37197;&#19968;&#20010;&#21518;&#22791;&#30340;SKB&#65292;&#20415;&#20110;&#23558;&#26469;&#20811;&#38534;&#65292;</span>
<span style="color: #75715E;">        &#22914;&#27492;&#65292;&#22312;&#20811;&#38534;&#26102;&#23601;&#26080;&#38656;&#20877;&#27425;&#20998;&#37197;SKB&#65292;&#25552;&#21319;&#25928;&#29575;&#12290;</span>

<span style="color: #75715E;">        &#32467;&#23614;&#30340;atomic_t&#34920;&#31034;&#36825;&#19968;&#23545;SKB&#26377;&#20960;&#20010;&#34987;&#20351;&#29992;</span>
<span style="color: #75715E;">        */</span>
        skbuff_fclone_cache = kmem_cache_create(<span style="color: #E6DB74;">"skbuff_fclone_cache"</span>,
                                                (2*<span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>)) +
                                                <span style="color: #F92672;">sizeof</span>(atomic_t),
                                                0,
                                                SLAB_HWCACHE_ALIGN|SLAB_PANIC,
                                                <span style="color: #AE81FF;">NULL</span>, <span style="color: #AE81FF;">NULL</span>);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1f1c570" class="outline-4">
<h4 id="org1f1c570"><span class="section-number-4">3.0.2.</span> 分配SKB</h4>
<div class="outline-text-4" id="text-3-0-2">
<ol class="org-ol">
<li>alloc_skb()
<ul class="org-ul">
<li>kmem_cache_alloc_node 分配SKB描述符。</li>
<li>kmalloc_node_track_caller分配数据缓存区。</li>
</ul></li>

<li>dev_alloc_skb()，通常用于中断上下文，要求原子操作。</li>
</ol>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #A6E22E;">dev_alloc_skb</span>(<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">length</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">GFP_ATOMIC&#34920;&#31034;&#20998;&#37197;&#36807;&#31243;&#20026;&#21407;&#23376;&#25805;&#20316;</span>
        <span style="color: #F92672;">return</span> __dev_alloc_skb(length, GFP_ATOMIC);
}

<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #A6E22E;">__dev_alloc_skb</span>(<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">length</span>,
                                              <span style="color: #66D9EF;">gfp_t</span> <span style="color: #FD971F;">gfp_mask</span>)
{
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#39044;&#30041;NET_SKB_PAD&#20010;&#23383;&#33410;&#65292;&#29992;&#20110;&#23384;&#20648;&#30828;&#20214;&#24103;&#22836;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span> = alloc_skb(length + NET_SKB_PAD, gfp_mask);
        <span style="color: #F92672;">if</span> (likely(skb))
                skb_reserve(skb, NET_SKB_PAD);
        <span style="color: #F92672;">return</span> skb;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ac14cd" class="outline-4">
<h4 id="org5ac14cd"><span class="section-number-4">3.0.3.</span> 释放SKB</h4>
<div class="outline-text-4" id="text-3-0-3">

<div id="orgbfe069b" class="figure">
<p><img src="image/sk-buff/kfree-skb.png" alt="kfree-skb.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org45f028f" class="outline-4">
<h4 id="org45f028f"><span class="section-number-4">3.0.4.</span> 数据预留和对齐</h4>
<div class="outline-text-4" id="text-3-0-4">
<ol class="org-ol">
<li>skb_reverse()，在数据缓存区头部预留一定的空间。</li>
</ol>


<div id="org98afd0c" class="figure">
<p><img src="image/sk-buff/skb-reverse.png" alt="skb-reverse.png" />
</p>
</div>

<ol class="org-ol">
<li>skb_push()，在数据缓存区前面加入数据。</li>
</ol>


<div id="orgcc2a19b" class="figure">
<p><img src="image/sk-buff/skb-push.png" alt="skb-push.png" />
</p>
</div>

<ol class="org-ol">
<li>skb_put()，修改指向数据末尾的tail指针，使之向下扩大。</li>
</ol>


<div id="orga8ed387" class="figure">
<p><img src="image/sk-buff/skb-put.png" alt="skb-put.png" />
</p>
</div>

<ol class="org-ol">
<li>skb_pull()，将skb的data指针向下移动。</li>
</ol>


<div id="orgae0f725" class="figure">
<p><img src="image/sk-buff/skb-pull.png" alt="skb-pull.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgb69bb4a" class="outline-4">
<h4 id="orgb69bb4a"><span class="section-number-4">3.0.5.</span> 克隆和复制SKB</h4>
<div class="outline-text-4" id="text-3-0-5">
<ol class="org-ol">
<li>skb_clone()，只复制SKB描述符。</li>
</ol>


<div id="org998ab77" class="figure">
<p><img src="image/sk-buff/skb-clone.png" alt="skb-clone.png" />
</p>
<p><span class="figure-number">Figure 9: </span>克隆后的SKB</p>
</div>

<ol class="org-ol">
<li>pskb_copy()，同时复制SKB描述符和数据缓存区。</li>
</ol>


<div id="org1656bd3" class="figure">
<p><img src="image/sk-buff/pskb-copy.png" alt="pskb-copy.png" />
</p>
</div>

<ol class="org-ol">
<li>skb_copy()，同时复制SKB描述符、数据缓存区、聚合分散I/O存储区。</li>
</ol>

<div id="org735fdc0" class="figure">
<p><img src="image/sk-buff/skb-copy.png" alt="skb-copy.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-org21203a1" class="outline-4">
<h4 id="org21203a1"><span class="section-number-4">3.0.6.</span> 链表管理函数</h4>
<div class="outline-text-4" id="text-3-0-6">
<ol class="org-ol">
<li>skb_queue_head_init()，初始化SKB链表头。</li>
<li>skb_quiue_head(), skb_queue_tail() 加入头部和尾部。</li>
<li>skb_dequeue(), skb_dequeue_tail()</li>
<li>skb_queue_purge() 清空SKB链表。</li>
<li>skb_queue_walk() 遍历SKB链表。</li>
</ol>
</div>
</div>

<div id="outline-container-org4f0d87e" class="outline-4">
<h4 id="org4f0d87e"><span class="section-number-4">3.0.7.</span> 添加或删除尾部数据</h4>
<div class="outline-text-4" id="text-3-0-7">
<ol class="org-ol">
<li>skb_add_data() 将用户空间数据添加到SKB数据缓存区尾部。</li>
</ol>

<div id="orgf8b4abe" class="figure">
<p><img src="image/sk-buff/skb-add-data.png" alt="skb-add-data.png" />
</p>
</div>

<ol class="org-ol">
<li>skb_trim()，根据指定长度，删除SKB数据缓存区尾部数据。</li>
</ol>

<div id="org09c6345" class="figure">
<p><img src="image/sk-buff/skb-trim.png" alt="skb-trim.png" />
</p>
</div>

<ol class="org-ol">
<li>pskb_trim()，类似skb_trim，能够可以处理非线性SKB。</li>
</ol>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="image/sk-buff/pskb-trima.png" alt="pskb-trima.png" /></td>
<td class="org-left"><img src="image/sk-buff/pskb-trimb.png" alt="pskb-trimb.png" /></td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org5e30e15" class="outline-4">
<h4 id="org5e30e15"><span class="section-number-4">3.0.8.</span> 拆分数据：skb_split()</h4>
<div class="outline-text-4" id="text-3-0-8">
<ol class="org-ol">
<li>拆分长度不大于线性长度：</li>
</ol>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="image/sk-buff/skb-splita.png" alt="skb-splita.png" /></td>
</tr>

<tr>
<td class="org-left"><img src="image/sk-buff/skb-splitb.png" alt="skb-splitb.png" /></td>
</tr>
</tbody>
</table>

<ol class="org-ol">
<li>拆分长度大于线性长度：</li>
</ol>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="image/sk-buff/skb-split-morea.png" alt="skb-split-morea.png" /></td>
</tr>

<tr>
<td class="org-left"><img src="image/sk-buff/skb-split-moreb.png" alt="skb-split-moreb.png" /></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org39039cc" class="outline-4">
<h4 id="org39039cc"><span class="section-number-4">3.0.9.</span> 重新分配SKB的线性数据区：pskb_expand_head()</h4>
<div class="outline-text-4" id="text-3-0-9">
<p>
根据指定长度重新扩展headroom和tailroom的空间。
</p>


<div id="orgba24983" class="figure">
<p><img src="image/sk-buff/pskb-expand-head.png" alt="pskb-expand-head.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-orgb92031a" class="outline-4">
<h4 id="orgb92031a"><span class="section-number-4">3.0.10.</span> 其他函数</h4>
<div class="outline-text-4" id="text-3-0-10">
<ol class="org-ol">
<li>pskb_may_pull() 检测SKB是否有指定长度</li>
<li>skb_queue_empty() SKB队列是否为空</li>
<li>skb_realloc_headroom() 根据SKB得到新的SKB，确保新SKB有指定的headroom空间</li>
<li>skb_get() 引用SKB</li>
<li>skb_shared() SKB是否被引用多次</li>
<li>skb_share_check() 若SKB被引用多次，则克隆SKB，并返回SKB。</li>
<li>skb_unshare() 如果SKB被克隆，则复制SKB，返回复制的SKB。</li>
<li>skb_orphan() 使得SKB不属于任何传输控制块。</li>
<li>skb_cow() 确保SKB存在指定的headroom空间，若不足，则重新分配。</li>
<li>skb_pagelen() 获取SKB线性数据区和SG类型的聚合分散I/O分片中的数据长度（不包括frag_list的数据）。</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:55</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
