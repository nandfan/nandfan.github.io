<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2021-12-31 Fri 22:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>接口层的输入</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="nandfan" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
	     margin-bottom: .2em; }
  .subtitle { text-align: center;
	      font-size: medium;
	      font-weight: bold;
	      margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
	    padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">接口层的输入</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4d5f61a">1. 系统参数</a></li>
<li><a href="#orgf528de5">2. 接口层ioctl</a>
<ul>
<li><a href="#org5aaf040">2.1. SIOCxIFxxx类命令</a></li>
<li><a href="#orgdfcf400">2.2. SIOCETHTOOL</a></li>
<li><a href="#orgd194043">2.3. 私有命令</a></li>
</ul>
</li>
<li><a href="#org0f336fe">3. 接口层初始化</a></li>
<li><a href="#orgeb61cd0">4. softnet_data结构</a></li>
<li><a href="#org84acd85">5. NAPI</a>
<ul>
<li><a href="#orgb00201f">5.1. 网络设备的中断例程</a></li>
<li><a href="#org9de6e05">5.2. 网络输入软中断</a></li>
<li><a href="#org362b0f2">5.3. 轮询处理报文</a></li>
</ul>
</li>
<li><a href="#orgb79327d">6. 非NAPI</a>
<ul>
<li><a href="#orgad2f5b8">6.1. netif_rx()</a></li>
<li><a href="#orge6fbe02">6.2. process_backlog()</a></li>
</ul>
</li>
<li><a href="#orgd889329">7. 接口层数据报文的处理</a>
<ul>
<li><a href="#org229121b">7.1. 报文接收例程</a></li>
<li><a href="#org2d67a66">7.2. netif_receive_skb()</a></li>
<li><a href="#orgb46d485">7.3. dev_queue_xmit_nit()</a></li>
</ul>
</li>
<li><a href="#org812bd92">8. CPU状态变化时的处理</a></li>
<li><a href="#orgd6cce1a">9. netpoll</a>
<ul>
<li><a href="#orge802297">9.1. netpoll结构</a></li>
<li><a href="#orgcdee5cc">9.2. netpoll实例的注册</a></li>
<li><a href="#orgad20c58">9.3. netpoll的输入</a>
<ul>
<li><a href="#orgb1e4166">9.3.1. trap状态</a></li>
<li><a href="#org870f151">9.3.2. netpoll_poll()</a></li>
<li><a href="#orgada9abc">9.3.3. ARP报文处理</a></li>
<li><a href="#org091dbae">9.3.4. ip数据包处理</a></li>
</ul>
</li>
<li><a href="#org84922aa">9.4. netpoll的输出</a>
<ul>
<li><a href="#org668964b">9.4.1. netpoll_send_udp()</a></li>
<li><a href="#org8b34682">9.4.2. netpoll_send_skb()</a></li>
</ul>
</li>
<li><a href="#orgc5d5f77">9.5. tx_work工作队列</a></li>
<li><a href="#org2ffb5dc">9.6. netpoll实例：netconsole</a>
<ul>
<li><a href="#org3899a43">9.6.1. netconsole参数</a></li>
<li><a href="#org9419086">9.6.2. console</a></li>
<li><a href="#orgc468f96">9.6.3. 初始化</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org4d5f61a" class="outline-2">
<h2 id="org4d5f61a"><span class="section-number-2">1</span> 系统参数</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>dev_weigh  数据包输入软中断中，单个网络设备可读取的报文配额。</li>

<li>netdev_budget 数据包输入软中断中，所有网络设备可从网络设备读取的报文总配额。</li>

<li>netdev_max_backlog 非NAPI链路层的缓存队列长度上限。</li>

<li>message_burst和message_const 用来限制网络模块警告消息的频率，message_const 为记录的时间间隔， message_burst为最多连续记录消息的次数。</li>
</ul>
</div>
</div>


<div id="outline-container-orgf528de5" class="outline-2">
<h2 id="orgf528de5"><span class="section-number-2">2</span> 接口层ioctl</h2>
<div class="outline-text-2" id="text-2">
<p>
对于接口层的ioctl操作，最终由 dev_ioctl() 和 inet_ioctl() 处理。
</p>


<div class="figure">
<p><img src="image/itf-input/ioctl-func.png" alt="ioctl-func.png" />
</p>
<p><span class="figure-number">Figure 1: </span>接口层ioctl函数调用关系</p>
</div>
</div>


<div id="outline-container-org5aaf040" class="outline-3">
<h3 id="org5aaf040"><span class="section-number-3">2.1</span> SIOCxIFxxx类命令</h3>
<div class="outline-text-3" id="text-2-1">
<p>
此类命令执行设置或者读取操作，通过struct ifreq 结构传递参数。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ifreq</span>
{
	<span style="color: #FF1493;">union</span> {
		<span style="color: #5FD7FF;">char</span>    <span style="color: #FF8C00;">ifrn_name</span>[IFNAMSIZ];            <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">if name, e.g. "en0"</span><span style="color: #8B8878;"> */</span>
	} <span style="color: #FF8C00;">ifr_ifrn</span>;

	<span style="color: #FF1493;">union</span> {
		<span style="color: #FF1493;">struct</span>  <span style="color: #5FD7FF;">sockaddr</span> <span style="color: #FF8C00;">ifru_addr</span>;
		<span style="color: #FF1493;">struct</span>  <span style="color: #5FD7FF;">sockaddr</span> <span style="color: #FF8C00;">ifru_dstaddr</span>;
		<span style="color: #FF1493;">struct</span>  <span style="color: #5FD7FF;">sockaddr</span> <span style="color: #FF8C00;">ifru_broadaddr</span>;
		<span style="color: #FF1493;">struct</span>  <span style="color: #5FD7FF;">sockaddr</span> <span style="color: #FF8C00;">ifru_netmask</span>;
		<span style="color: #FF1493;">struct</span>  <span style="color: #5FD7FF;">sockaddr</span> <span style="color: #FF8C00;">ifru_hwaddr</span>;
		<span style="color: #5FD7FF;">short</span>   <span style="color: #FF8C00;">ifru_flags</span>;
		<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">ifru_ivalue</span>;
		<span style="color: #5FD7FF;">int</span>     <span style="color: #FF8C00;">ifru_mtu</span>;
		<span style="color: #FF1493;">struct</span>  <span style="color: #5FD7FF;">ifmap</span> <span style="color: #FF8C00;">ifru_map</span>;
		<span style="color: #5FD7FF;">char</span>    <span style="color: #FF8C00;">ifru_slave</span>[IFNAMSIZ];   <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Just fits the size</span><span style="color: #8B8878;"> */</span>
		<span style="color: #5FD7FF;">char</span>    <span style="color: #FF8C00;">ifru_newname</span>[IFNAMSIZ];
		<span style="color: #5FD7FF;">void</span> <span style="color: #FF8C00;">__user</span> *   ifru_data;
		<span style="color: #FF1493;">struct</span>  <span style="color: #5FD7FF;">if_settings</span> <span style="color: #FF8C00;">ifru_settings</span>;
	} <span style="color: #FF8C00;">ifr_ifru</span>;
};
</pre>
</div>

<p>
#caption: 操作命令
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">命令</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SIOCGIFCONF</td>
<td class="org-left">获取接口配置信息（struct ifconf）</td>
</tr>

<tr>
<td class="org-left">SOICGIFNAME和SIOCSIFNAME</td>
<td class="org-left">接口名称</td>
</tr>

<tr>
<td class="org-left">SOICGIFFLAGS和SIOCSIFFLAG</td>
<td class="org-left">网络设备的标志</td>
</tr>

<tr>
<td class="org-left">SOICGIFMETRIC和SIOCSIFMETRIC</td>
<td class="org-left">网络设备的metric</td>
</tr>

<tr>
<td class="org-left">SIOCGIFMTU和SIOCSIFMTU</td>
<td class="org-left">mtu</td>
</tr>

<tr>
<td class="org-left">SIOCGIFHWADDR和SIOCSIFHWADDR</td>
<td class="org-left">硬件地址</td>
</tr>

<tr>
<td class="org-left">SIOCGIFMAP和SIOCSIFMAP</td>
<td class="org-left">接口的硬件参数，共享内存、I/O基地址、中断等(struct ifmap结构)</td>
</tr>

<tr>
<td class="org-left">SIOCGIFINDEX</td>
<td class="org-left">网络设备索引号</td>
</tr>

<tr>
<td class="org-left">SIOCGIFTXQLEN和SIOCSIFTXQLEN</td>
<td class="org-left">传输队列长度</td>
</tr>

<tr>
<td class="org-left">SIOCGIFADDR和SIOCSIFADDR</td>
<td class="org-left">本地地址</td>
</tr>

<tr>
<td class="org-left">SIOCGIFPFLAGS和SIOCSIFPFLAGS</td>
<td class="org-left">扩展标志</td>
</tr>

<tr>
<td class="org-left">SIOCGIFNETMASK和SIOCSIFNETMASK</td>
<td class="org-left">地址掩码</td>
</tr>

<tr>
<td class="org-left">SIOCADDMULTI和SIOCDELMULTI</td>
<td class="org-left">网络设备的组播过滤器</td>
</tr>

<tr>
<td class="org-left">SIOCSIFHWBROADCAST</td>
<td class="org-left">获取、添加或者删除网络设备的硬件广播地址</td>
</tr>

<tr>
<td class="org-left">SIOCGIFDSTADDR和SIOCSIFDSTADDR</td>
<td class="org-left">点对点的对端IP地址</td>
</tr>

<tr>
<td class="org-left">SIOCGIFBRDADDR和SIOCSIFBRDADDR</td>
<td class="org-left">组播地址</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgdfcf400" class="outline-3">
<h3 id="orgdfcf400"><span class="section-number-3">2.2</span> SIOCETHTOOL</h3>
<div class="outline-text-3" id="text-2-2">
<p>
SIOCETHTOOL是以太网设备的专用操作命令，支持多个子命令，不同子命令有不同的命令结构。 例如 ETHTOOL_GSET和ETHTOOL_SSET分别为获取和设置对应的配置，命令结构为ethtool_cmd结构。
</p>
</div>
</div>

<div id="outline-container-orgd194043" class="outline-3">
<h3 id="orgd194043"><span class="section-number-3">2.3</span> 私有命令</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>SIOCGMIIPHY 获取MII的PHY地址</li>

<li>SIOCGMIIREG和SIOCSMIIREG 获取和设置MII的PHY寄存器</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org0f336fe" class="outline-2">
<h2 id="org0f336fe"><span class="section-number-2">3</span> 接口层初始化</h2>
<div class="outline-text-2" id="text-3">
<p>
net_dev_init() 用来初始化相关的接口层，其优先级为 subsys_initcall。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">/*</span>
<span style="color: #8B8878;"> *       This is called single threaded during boot, so no need</span>
<span style="color: #8B8878;"> *       to take the rtnl semaphore.</span>
<span style="color: #8B8878;"> */</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">__init</span> net_dev_init(<span style="color: #5FD7FF;">void</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>, <span style="color: #FF8C00;">rc</span> = -ENOMEM;
	BUG_ON(<span style="color: #CDC673; font-weight: bold;">!</span>dev_boot_phase);
	<span style="color: #FF1493;">if</span> (dev_proc_init()) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27880;&#20876;&#32479;&#35745;&#30456;&#20851;&#30340;proc&#25991;&#20214;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (netdev_sysfs_init()) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">sysfs&#25991;&#20214;&#31995;&#32479;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;ptype_all&#38142;&#34920; &#21644; ptype_base&#25955;&#21015;&#34920;</span>
	INIT_LIST_HEAD(&amp;ptype_all);
	<span style="color: #FF1493;">for</span> (i = 0; i &lt; 16; i++)
		INIT_LIST_HEAD(&amp;ptype_base[i]);
	<span style="color: #FF1493;">for</span> (i = 0; i &lt; ARRAY_SIZE(dev_name_head); i++) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#22791;&#21517;&#31216;&#25955;&#21015;&#34920;</span>
		INIT_HLIST_HEAD(&amp;dev_name_head[i]);
	<span style="color: #FF1493;">for</span> (i = 0; i &lt; ARRAY_SIZE(dev_index_head); i++)
		INIT_HLIST_HEAD(&amp;dev_index_head[i]); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#22791;&#32034;&#24341;&#25955;&#21015;&#34920;</span>

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#25968;&#25454;&#21253;&#25509;&#25910;&#38431;&#21015;</span><span style="color: #8B8878;"> */</span>
	for_each_possible_cpu(i) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">softnet_data</span> *<span style="color: #FF8C00;">queue</span>;
		queue = &amp;per_cpu(softnet_data, i);
		skb_queue_head_init(&amp;queue-&gt;input_pkt_queue);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25509;&#25910;&#38431;&#21015;</span>
		queue-&gt;completion_queue = <span style="color: #AF87FF;">NULL</span>;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31561;&#24453;&#37322;&#25918;&#38431;&#21015;</span>
		INIT_LIST_HEAD(&amp;queue-&gt;poll_list);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;NAPI&#30340;&#36755;&#20837;&#38431;&#21015;</span>
		set_bit(__LINK_STATE_START, &amp;queue-&gt;backlog_dev.state);
		queue-&gt;backlog_dev.weight = weight_p;
		queue-&gt;backlog_dev.poll = process_backlog;
		atomic_set(&amp;queue-&gt;backlog_dev.refcnt, 1);
	}
	netdev_dma_register();<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27880;&#20876;DMA&#23458;&#25143;&#31471;</span>
	dev_boot_phase = 0;
	open_softirq(NET_TX_SOFTIRQ, net_tx_action, <span style="color: #AF87FF;">NULL</span>); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20837;&#36719;&#20013;&#26029;</span>
	open_softirq(NET_RX_SOFTIRQ, net_rx_action, <span style="color: #AF87FF;">NULL</span>); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#36719;&#20013;&#26029;</span>
	hotcpu_notifier(dev_cpu_callback, 0); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">CPU&#29366;&#24577;&#21464;&#21270;&#30340;&#22238;&#35843;&#20989;&#25968;</span>
	dst_init(); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27880;&#20876;&#32593;&#32476;&#29366;&#24577;&#21464;&#21270;&#30340;&#22238;&#35843;&#20989;&#25968;&#65288;dev_cpu_callback()&#20989;&#25968;&#65289;</span>
	dev_mcast_init();<span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#27880;&#20876;/proc/net/dev_macast &#25991;&#20214;</span>
	rc = 0;
<span style="color: #AF87FF;">out</span>:
	<span style="color: #FF1493;">return</span> rc;
}
<span style="color: #87D700;">subsys_initcall</span>(net_dev_init);
</pre>
</div>
</div>
</div>


<div id="outline-container-orgeb61cd0" class="outline-2">
<h2 id="orgeb61cd0"><span class="section-number-2">4</span> softnet_data结构</h2>
<div class="outline-text-2" id="text-4">
<p>
struct softnet_data 结构描述了与网络软中断处理相关的报文输入和输出队列，每个CPU有一个单独的softnet_data实例。
</p>


<div class="figure">
<p><img src="image/itf-input/softnetdata-layer.png" alt="softnetdata-layer.png" />
</p>
<p><span class="figure-number">Figure 2: </span>softnet_data、接口层、网络层的关系</p>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">softnet_data</span> {
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span>       *<span style="color: #FF8C00;">output_queue</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#36719;&#20013;&#26029;&#20013;&#30340;&#25968;&#25454;&#21253;&#36755;&#20986;&#38431;&#21015;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff_head</span>     <span style="color: #FF8C00;">input_pkt_queue</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;NAPI&#25509;&#21475;&#23618;&#30340;&#32531;&#23384;&#38431;&#21015;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">list_head</span>        <span style="color: #FF8C00;">poll_list</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32593;&#32476;&#35774;&#22791;&#36718;&#35810;&#38431;&#21015;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span>          *<span style="color: #FF8C00;">completion_queue</span>;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31561;&#24453;&#37322;&#25918;&#38431;&#21015;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span>       <span style="color: #FF8C00;">backlog_dev</span>;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;NAPI&#39537;&#21160;&#30340;&#34394;&#25311;&#32593;&#32476;&#35774;&#22791;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">dma_chan</span>         *<span style="color: #FF8C00;">net_dma</span>;
};
</pre>
</div>
</div>
</div>


<div id="outline-container-org84acd85" class="outline-2">
<h2 id="org84acd85"><span class="section-number-2">5</span> NAPI</h2>
<div class="outline-text-2" id="text-5">
<p>
NAPI是中断机制和轮询机制的混合，可以有效提高网络处理速度。
</p>

<p>
NAPI的报文输入流程：
</p>


<div class="figure">
<p><img src="image/itf-input/napi-input.png" alt="napi-input.png" />
</p>
<p><span class="figure-number">Figure 3: </span>NAPI方式输入报文流程</p>
</div>
</div>


<div id="outline-container-orgb00201f" class="outline-3">
<h3 id="orgb00201f"><span class="section-number-3">5.1</span> 网络设备的中断例程</h3>
<div class="outline-text-3" id="text-5-1">
<p>
以e100为例：
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>e100_intr中断例程</label><pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">irqreturn_t</span> <span style="color: #87D700;">e100_intr</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">irq</span>, <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">dev_id</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">netdev</span> = dev_id;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">nic</span> *<span style="color: #FF8C00;">nic</span> = netdev_priv(netdev);
	<span style="color: #5FD7FF;">u8</span> <span style="color: #FF8C00;">stat_ack</span> = readb(&amp;nic-&gt;csr-&gt;scb.stat_ack);
	DPRINTK(INTR, DEBUG, <span style="color: #CDC673;">"stat_ack = 0x%02X\n"</span>, stat_ack);
	<span style="color: #FF1493;">if</span>(stat_ack == stat_ack_not_ours ||     <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20013;&#26029;&#26159;&#21542;&#30001;&#32593;&#32476;&#35774;&#22791;&#28608;&#27963;</span><span style="color: #8B8878;"> */</span>
	   stat_ack == stat_ack_not_present)    <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#35774;&#22791;&#25300;&#20986;</span><span style="color: #8B8878;"> */</span>
		<span style="color: #FF1493;">return</span> IRQ_NONE;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#21709;&#24212;&#20013;&#26029;</span><span style="color: #8B8878;"> */</span>
	writeb(stat_ack, &amp;nic-&gt;csr-&gt;scb.stat_ack);
	<span style="color: #FF1493;">if</span>(stat_ack &amp; stat_ack_rnr)
		nic-&gt;ru_running = RU_SUSPENDED;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32593;&#32476;&#35774;&#22791;&#27491;&#24120;&#65292;&#19988;&#36824;&#26410;&#36718;&#35810;&#25509;&#25910;&#25253;&#25991;</span>
	<span style="color: #FF1493;">if</span>(likely(netif_rx_schedule_prep(netdev))) {
		e100_disable_irq(nic);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31105;&#27490;&#35774;&#22791;&#20013;&#26029;</span>
		__netif_rx_schedule(netdev);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28608;&#27963;&#25253;&#25991;&#25509;&#25910;&#36719;&#20013;&#26029;</span>
	}
	<span style="color: #FF1493;">return</span> IRQ_HANDLED;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9de6e05" class="outline-3">
<h3 id="org9de6e05"><span class="section-number-3">5.2</span> 网络输入软中断</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">net_rx_action</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">softirq_action</span> *<span style="color: #FF8C00;">h</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">softnet_data</span> *<span style="color: #FF8C00;">queue</span> = &amp;__get_cpu_var(softnet_data);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;CPU softnet_data</span>
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">start_time</span> = jiffies;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">budget</span> = netdev_budget; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25253;&#25991;&#25509;&#25910;&#37197;&#39069;</span>
	<span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">have</span>;
	local_irq_disable();
	<span style="color: #FF1493;">while</span> (<span style="color: #CDC673; font-weight: bold;">!</span>list_empty(&amp;queue-&gt;poll_list)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36718;&#35810;&#38431;&#21015;&#30340;&#32593;&#32476;&#35774;&#22791;</span>
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">dev</span>;
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35835;&#21462;&#37197;&#39069;&#29992;&#23613;&#65292;&#25110;&#32773;&#22788;&#29702;&#26102;&#38388;&#22823;&#20110;1ms&#65292;&#21017;&#36864;&#20986;&#22788;&#29702;</span>
		<span style="color: #FF1493;">if</span> (budget &lt;= 0 || jiffies - start_time &gt; 1)
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">softnet_break</span>;
		local_irq_enable();
		dev = list_entry(queue-&gt;poll_list.next,
				 <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span>, poll_list);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21462;&#20986;&#32593;&#32476;&#35774;&#22791;</span>
		have = netpoll_poll_lock(dev);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;&#35774;&#22791;&#26412;&#27425;&#37197;&#39069;&#29992;&#23613;&#25110;&#32773;&#36718;&#35810;&#21518;&#36824;&#26377;&#25253;&#25991;&#26410;&#35835;&#21462;</span>
		<span style="color: #FF1493;">if</span> (dev-&gt;quota &lt;= 0 || dev-&gt;poll(dev, &amp;budget)) {
			netpoll_poll_unlock(have);
			local_irq_disable();
			list_move_tail(&amp;dev-&gt;poll_list, &amp;queue-&gt;poll_list);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#22791;&#31227;&#21160;&#21040;&#38431;&#23614;</span>
			<span style="color: #FF1493;">if</span> (dev-&gt;quota &lt; 0)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#37325;&#26032;&#35774;&#32622;&#35774;&#22791;&#37197;&#39069;</span>
				dev-&gt;quota += dev-&gt;weight;
			<span style="color: #FF1493;">else</span>
				dev-&gt;quota = dev-&gt;weight;
		} <span style="color: #FF1493;">else</span> {
			netpoll_poll_unlock(have);
			dev_put(dev);
			local_irq_disable();
		}
	}
<span style="color: #AF87FF;">out</span>:
	<span style="color: #FF1493;">if</span> (net_dma_client) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">dma_chan</span> *<span style="color: #FF8C00;">chan</span>;
		rcu_read_lock();
		list_for_each_entry_rcu(chan, &amp;net_dma_client-&gt;channels, client_node)
			dma_async_memcpy_issue_pending(chan);
		rcu_read_unlock();
	}
	local_irq_enable();
	<span style="color: #FF1493;">return</span>;
<span style="color: #AF87FF;">softnet_break</span>:
	__get_cpu_var(netdev_rx_stat).time_squeeze++;
	__raise_softirq_irqoff(NET_RX_SOFTIRQ);
	<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org362b0f2" class="outline-3">
<h3 id="org362b0f2"><span class="section-number-3">5.3</span> 轮询处理报文</h3>
<div class="outline-text-3" id="text-5-3">
<p>
e100网络设备驱动通过 e100_poll() 函数处理。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>e100_poll()</label><pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">e100_poll</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">netdev</span>, <span style="color: #5FD7FF;">int</span> *<span style="color: #FF8C00;">budget</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">nic</span> *<span style="color: #FF8C00;">nic</span> = netdev_priv(netdev);
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">work_to_do</span> = min(netdev-&gt;quota, *budget);
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">work_done</span> = 0;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">tx_cleaned</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20174;&#32593;&#32476;&#35774;&#22791;&#35835;&#21462;&#25509;&#25910;&#21040;&#30340;&#25253;&#25991;&#65292;&#24182;&#36890;&#36807; netif_receive_skb() &#36755;&#20837;&#21040;&#19978;&#23618;&#21327;&#35758;&#20013;</span>
	e100_rx_clean(nic, &amp;work_done, work_to_do);
	tx_cleaned = e100_tx_clean(nic); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#37322;&#25918;&#24050;&#32463;&#21457;&#36865;&#30340;&#25253;&#25991;</span>

	<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#22914;&#26524;&#24453;&#36755;&#20986;&#25253;&#25991;&#21644;&#36755;&#20837;&#25253;&#25991;&#37117;&#22788;&#29702;&#23436;&#25104;&#25110;&#32773;&#35774;&#22791;&#26410;&#28608;&#27963;&#65292;&#36864;&#20986;&#36718;&#35810;&#27169;&#24335;</span><span style="color: #8B8878;">*/</span>
	<span style="color: #FF1493;">if</span>((<span style="color: #CDC673; font-weight: bold;">!</span>tx_cleaned &amp;&amp; (work_done == 0)) || <span style="color: #CDC673; font-weight: bold;">!</span>netif_running(netdev)) {
		netif_rx_complete(netdev);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#35774;&#22791;&#20174;&#36718;&#35810;&#38431;&#21015;&#31227;&#38500;</span>
		e100_enable_irq(nic);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24320;&#20013;&#26029;</span>
		<span style="color: #FF1493;">return</span> 0;
	}

	*budget -= work_done; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#24635;&#37197;&#39069;</span>
	netdev-&gt;quota -= work_done;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#32593;&#32476;&#35774;&#22791;&#37197;&#39069;</span>
	<span style="color: #FF1493;">return</span> 1;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgb79327d" class="outline-2">
<h2 id="orgb79327d"><span class="section-number-2">6</span> 非NAPI</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgad2f5b8" class="outline-3">
<h3 id="orgad2f5b8"><span class="section-number-3">6.1</span> netif_rx()</h3>
<div class="outline-text-3" id="text-6-1">
<p>
netif_rx() 将网络设备接收的报文加入到接口层的缓存队列，以便上层协议处理。
</p>

<p>
NAPI网络驱动不会调用该接口接收报文。
</p>

<div class="org-src-container">
<pre class="src src-c">
<span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;"> *      netif_rx        -       post buffer to the network code</span>
<span style="color: #CDC673;"> *      </span><span style="color: #AF87FF;">@skb</span><span style="color: #CDC673;">: buffer to post</span>
<span style="color: #CDC673;"> *      return values:</span>
<span style="color: #CDC673;"> *      NET_RX_SUCCESS  (&#27809;&#26377;&#21457;&#29983;&#25317;&#22622;)</span>
<span style="color: #CDC673;"> *      NET_RX_CN_LOW   (&#36731;&#24230;&#25317;&#22622;)</span>
<span style="color: #CDC673;"> *      NET_RX_CN_MOD   (&#20013;&#24230;&#25317;&#22622;)</span>
<span style="color: #CDC673;"> *      NET_RX_CN_HIGH  (&#39640;&#24230;&#25317;&#22622;)</span>
<span style="color: #CDC673;"> *      NET_RX_DROP     (&#25253;&#25991;&#34987;&#20002;&#24323;)</span>
<span style="color: #CDC673;"> *</span>
<span style="color: #CDC673;"> */</span>

<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">netif_rx</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">softnet_data</span> *<span style="color: #FF8C00;">queue</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">flags</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23558;&#25968;&#25454;&#21253;&#20256;&#36882;&#32473;netpoll&#27169;&#22359;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (netpoll_rx(skb))
		<span style="color: #FF1493;">return</span> NET_RX_DROP;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb-&gt;tstamp.off_sec)
		net_timestamp(skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35760;&#24405;&#25509;&#25910;&#26102;&#38388;&#25139;</span>
	local_irq_save(flags);
	queue = &amp;__get_cpu_var(softnet_data); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;cpu&#32531;&#23384;&#38431;&#21015;</span>
	__get_cpu_var(netdev_rx_stat).total++;
	<span style="color: #FF1493;">if</span> (queue-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38431;&#21015;&#26410;&#28385;</span>
		<span style="color: #FF1493;">if</span> (queue-&gt;input_pkt_queue.qlen) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20837;&#38431;&#21015;&#19981;&#20026;&#31354;</span>
<span style="color: #AF87FF;">enqueue</span>:
			dev_hold(skb-&gt;dev);
			__skb_queue_tail(&amp;queue-&gt;input_pkt_queue, skb);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21152;&#20837;&#36755;&#20837;&#38431;&#21015;</span>
			local_irq_restore(flags);
			<span style="color: #FF1493;">return</span> NET_RX_SUCCESS;
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38431;&#21015;&#20026;&#31354;&#65292;&#35828;&#26126;&#36824;&#26410;&#34987;&#36719;&#20013;&#26029;&#22788;&#29702;&#36807;&#65292;&#23558;backlog_dev&#35774;&#22791;&#21152;&#20837;&#35774;&#22791;&#36718;&#35810;&#38431;&#21015;&#65292;&#24182;&#28608;&#27963;&#25509;&#25910;&#36719;&#20013;&#26029;</span>
		netif_rx_schedule(&amp;queue-&gt;backlog_dev);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">enqueue</span>;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38431;&#21015;&#24050;&#28385;&#65292;&#20002;&#24323;&#25253;&#25991;</span>
	__get_cpu_var(netdev_rx_stat).dropped++;
	local_irq_restore(flags);
	kfree_skb(skb);
	<span style="color: #FF1493;">return</span> NET_RX_DROP;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge6fbe02" class="outline-3">
<h3 id="orge6fbe02"><span class="section-number-3">6.2</span> process_backlog()</h3>
<div class="outline-text-3" id="text-6-2">
<p>
非NAPI方式下， 通过 process_backlog() 函数轮询虚拟网络设备 backlog_dev。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">process_backlog</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">backlog_dev</span>, <span style="color: #5FD7FF;">int</span> *<span style="color: #FF8C00;">budget</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">work</span> = 0;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">quota</span> = min(backlog_dev-&gt;quota, *budget);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">softnet_data</span> *<span style="color: #FF8C00;">queue</span> = &amp;__get_cpu_var(softnet_data);
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">start_time</span> = jiffies;
	backlog_dev-&gt;weight = weight_p;
	<span style="color: #FF1493;">for</span> (;;) {
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">dev</span>;
		local_irq_disable();
		skb = __skb_dequeue(&amp;queue-&gt;input_pkt_queue);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;&#25253;&#25991;</span>
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20026;&#31354;&#21017;&#22788;&#29702;&#23436;&#25104;</span>
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">job_done</span>;
		local_irq_enable();
		dev = skb-&gt;dev;
		netif_receive_skb(skb);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36882;&#21040;&#19978;&#23618;&#21327;&#35758;</span>
		dev_put(dev);
		work++;
		<span style="color: #FF1493;">if</span> (work &gt;= quota || jiffies - start_time &gt; 1) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36798;&#21040;&#37197;&#39069;&#65292;&#25110;&#32773;&#36229;&#26102;</span>
			<span style="color: #FF1493;">break</span>;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26356;&#26032;&#37197;&#39069;</span>
	backlog_dev-&gt;quota -= work;
	*budget -= work;
	<span style="color: #FF1493;">return</span> -1;
<span style="color: #AF87FF;">job_done</span>: <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;&#23436;&#25104;&#21518;&#30340;&#25805;&#20316;</span>
	backlog_dev-&gt;quota -= work;
	*budget -= work;
	list_del(&amp;backlog_dev-&gt;poll_list);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20174;&#35774;&#22791;&#36718;&#35810;&#38431;&#21015;&#31227;&#38500; backlog_dev</span>
	smp_mb__before_clear_bit();
	netif_poll_enable(backlog_dev);
	local_irq_enable();
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgd889329" class="outline-2">
<h2 id="orgd889329"><span class="section-number-2">7</span> 接口层数据报文的处理</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org229121b" class="outline-3">
<h3 id="org229121b"><span class="section-number-3">7.1</span> 报文接收例程</h3>
<div class="outline-text-3" id="text-7-1">
<p>
packet_type结构是网络层输入的接口。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">packet_type</span> {
	<span style="color: #5FD7FF;">__be16</span>          <span style="color: #FF8C00;">type</span>;   <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#38142;&#36335;&#23618;&#25253;&#25991;&#25215;&#36733;&#32593;&#32476;&#23618;&#25253;&#25991;&#30340;&#21327;&#35758;&#21495;</span><span style="color: #8B8878;">*/</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span>       *<span style="color: #FF8C00;">dev</span>;   <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#25351;&#23450;&#25509;&#25910;&#25968;&#25454;&#21253;&#30340;&#35774;&#22791;&#65292;&#20026;NULL&#34920;&#31034;&#25509;&#25910;&#25152;&#26377;&#35774;&#22791;&#30340;&#25968;&#25454;&#21253;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21327;&#35758;&#25509;&#25910;&#22788;&#29702;&#30340;&#20837;&#21475;&#20989;&#25968;&#12290;</span>
	<span style="color: #5FD7FF;">int</span>                     (*<span style="color: #87D700;">func</span>) (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *,
				     <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">packet_type</span> *, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36755;&#23618;&#30340;GSO&#20998;&#27573;&#20989;&#25968;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span>  *(*<span style="color: #87D700;">gso_segment</span>)(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>,<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">features</span>);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#29992;&#20256;&#36755;&#23618;GSO&#20998;&#27573;&#21069;&#65292;&#23545;&#20266;&#39318;&#37096;&#35745;&#31639;&#26657;&#39564;&#21644;&#12290;</span>
	<span style="color: #5FD7FF;">int</span>                     (*<span style="color: #87D700;">gso_send_check</span>)(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>);
	<span style="color: #5FD7FF;">void</span>            *<span style="color: #FF8C00;">af_packet_priv</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23384;&#20648;&#21327;&#35758;&#26063;&#30340;&#31169;&#26377;&#25968;&#25454;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">list_head</span>        <span style="color: #FF8C00;">list</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36830;&#25509;&#19981;&#21516;&#21327;&#35758;&#26063;&#25509;&#25910;&#20363;&#31243;&#30340;&#38142;&#34920;&#20803;&#32032;</span>
};

<span style="color: #8B8878;">//</span><span style="color: #8B8878;">IPv4&#23454;&#20363;&#65306;</span>
<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">packet_type</span> <span style="color: #FF8C00;">ip_packet_type</span> = {
	.type = __constant_htons(ETH_P_IP),
	.func = ip_rcv,
	.gso_send_check = inet_gso_send_check,
	.gso_segment = inet_gso_segment,
};
</pre>
</div>

<p>
大部分的 packet_type 结构的实例通过dev_add_pack()函数添加到 ptype_base 散列表。
</p>

<p>
PF_PACKET协议族，type为 ETH_P_ALL 的packet_type实例则是注册到ptype_all链表。
</p>


<div class="figure">
<p><img src="image/itf-input/ptype-base.png" alt="ptype-base.png" />
</p>
<p><span class="figure-number">Figure 4: </span>ptype_base散列表</p>
</div>
</div>
</div>

<div id="outline-container-org2d67a66" class="outline-3">
<h3 id="org2d67a66"><span class="section-number-3">7.2</span> netif_receive_skb()</h3>
<div class="outline-text-3" id="text-7-2">
<p>
netif_receive_skb()将报文输入到上层协议。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">netif_receive_skb</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">packet_type</span> *<span style="color: #FF8C00;">ptype</span>, *<span style="color: #FF8C00;">pt_prev</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">orig_dev</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">ret</span> = NET_RX_DROP;
	<span style="color: #5FD7FF;">__be16</span> <span style="color: #FF8C00;">type</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22914;&#26524;&#26159;&#36890;&#36807;NAPI&#26041;&#24335;&#36755;&#20837;&#65292;&#21017;&#20808;&#36755;&#20837;&#32473;netpoll&#27169;&#22359;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;dev-&gt;poll &amp;&amp; netpoll_rx(skb))
		<span style="color: #FF1493;">return</span> NET_RX_DROP;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb-&gt;tstamp.off_sec) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26102;&#38388;&#25139;</span>
		net_timestamp(skb);
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb-&gt;input_dev)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#25509;&#25910;&#25253;&#25991;&#30340;&#35774;&#22791;</span>
		skb-&gt;input_dev = skb-&gt;dev;
	orig_dev = skb_bond(skb);  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">bonding&#20013;&#65292;&#33719;&#21462;&#25253;&#25991;&#30340;&#36755;&#20837;&#35774;&#22791;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>orig_dev)
		<span style="color: #FF1493;">return</span> NET_RX_DROP;
	__get_cpu_var(netdev_rx_stat).total++;
	skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data;
	skb-&gt;mac_len = skb-&gt;nh.raw - skb-&gt;mac.raw;
	pt_prev = <span style="color: #AF87FF;">NULL</span>;
	rcu_read_lock();
<span style="color: #FF1493;">#ifdef</span> CONFIG_NET_CLS_ACT <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21253;&#20998;&#31867;&#22120;&#30456;&#20851;</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;tc_verd &amp; TC_NCLS) {
		skb-&gt;tc_verd = CLR_TC_NCLS(skb-&gt;tc_verd);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">ncls</span>;
	}
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36941;&#21382;packet_all&#38142;&#34920;</span>
	list_for_each_entry_rcu(ptype, &amp;ptype_all, list) {
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) {
			<span style="color: #FF1493;">if</span> (pt_prev)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20837;&#25253;&#25991;&#21040;&#23545;&#24212;&#30340;&#21327;&#35758;&#26063;</span>
				ret = deliver_skb(skb, pt_prev, orig_dev);
			pt_prev = ptype;
		}
	}
<span style="color: #FF1493;">#ifdef</span> CONFIG_NET_CLS_ACT
	<span style="color: #FF1493;">if</span> (pt_prev) {
		ret = deliver_skb(skb, pt_prev, orig_dev);
		pt_prev = <span style="color: #AF87FF;">NULL</span>; <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">noone else should process this after</span><span style="color: #8B8878;">*/</span>
	} <span style="color: #FF1493;">else</span> {
		skb-&gt;tc_verd = SET_TC_OK2MUNGE(skb-&gt;tc_verd);
	}
	ret = ing_filter(skb);
	<span style="color: #FF1493;">if</span> (ret == TC_ACT_SHOT || (ret == TC_ACT_STOLEN)) {
		kfree_skb(skb);
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	}
	skb-&gt;tc_verd = 0;
<span style="color: #AF87FF;">ncls</span>:
<span style="color: #FF1493;">#endif</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;bridge&#65292; &#23558;&#25253;&#25991;&#36755;&#20837;&#32473;bridge</span>
	<span style="color: #FF1493;">if</span> (handle_bridge(&amp;skb, &amp;pt_prev, &amp;ret, orig_dev))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	type = skb-&gt;protocol;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36941;&#21382;ptype_base&#25955;&#21015;&#34920;</span>
	list_for_each_entry_rcu(ptype, &amp;ptype_base[ntohs(type)&amp;15], list) {
		<span style="color: #FF1493;">if</span> (ptype-&gt;type == type &amp;&amp;
		    (<span style="color: #CDC673; font-weight: bold;">!</span>ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev)) {
			<span style="color: #FF1493;">if</span> (pt_prev)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20837;&#25253;&#25991;&#21040;&#23545;&#24212;&#30340;&#21327;&#35758;&#26063;</span>
				ret = deliver_skb(skb, pt_prev, orig_dev);
			pt_prev = ptype;
		}
	}
	<span style="color: #FF1493;">if</span> (pt_prev) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20837;&#25253;&#25991;&#21040;&#23545;&#24212;&#30340;&#21327;&#35758;&#26063;</span>
		ret = pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);
	} <span style="color: #FF1493;">else</span> {
		kfree_skb(skb);
		<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">Jamal, now you will not able to escape explaining</span>
<span style="color: #8B8878;">                 * me how you were going to use this. :-)</span>
<span style="color: #8B8878;">                 */</span>
		ret = NET_RX_DROP;
	}
<span style="color: #AF87FF;">out</span>:
	rcu_read_unlock();
	<span style="color: #FF1493;">return</span> ret;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb46d485" class="outline-3">
<h3 id="orgb46d485"><span class="section-number-3">7.3</span> dev_queue_xmit_nit()</h3>
<div class="outline-text-3" id="text-7-3">
<p>
通过 <i>socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))</i> 创建的原始套接字，既可以接收外部输入的数据包，也可以接收本地输出的数据包。
</p>

<p>
dev_queue_xmit_nit() 用于结婚搜本地输出的数据包，链路层输出过程中会调用该函数。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8B8878;">//</span><span style="color: #8B8878;">dev &#36755;&#20986;&#25968;&#25454;&#21253;&#30340;&#32593;&#32476;&#35774;&#22791;</span>
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">skb &#24453;&#36755;&#20986;&#25968;&#25454;&#21253;</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">dev_queue_xmit_nit</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">dev</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">packet_type</span> *<span style="color: #FF8C00;">ptype</span>;
	net_timestamp(skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35760;&#24405;&#26102;&#38388;&#25139;</span>
	rcu_read_lock();
	list_for_each_entry_rcu(ptype, &amp;ptype_all, list) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36941;&#21382;ptype_all</span>
		<span style="color: #FF1493;">if</span> ((ptype-&gt;dev == dev || <span style="color: #CDC673; font-weight: bold;">!</span>ptype-&gt;dev) &amp;&amp;
		    (ptype-&gt;af_packet_priv == <span style="color: #AF87FF;">NULL</span> ||
		     (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sock</span> *)ptype-&gt;af_packet_priv != skb-&gt;sk)) {
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#39069;&#22806;&#36755;&#20837;&#21040;RAW&#65292;&#38656;&#35201;&#20811;&#38534;skb</span>
			<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb2</span>= skb_clone(skb, GFP_ATOMIC);
			<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>skb2)
				<span style="color: #FF1493;">break</span>;
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26657;&#39564;&#25968;&#25454;&#21253;&#30340;&#26377;&#25928;&#24615;</span>
			skb2-&gt;mac.raw = skb2-&gt;data;
			<span style="color: #FF1493;">if</span> (skb2-&gt;nh.raw &lt; skb2-&gt;data ||
			    skb2-&gt;nh.raw &gt; skb2-&gt;tail) {
				<span style="color: #FF1493;">if</span> (net_ratelimit())
					printk(KERN_CRIT <span style="color: #CDC673;">"protocol %04x is "</span>
					       <span style="color: #CDC673;">"buggy, dev %s\n"</span>,
					       skb2-&gt;protocol, dev-&gt;name);
				skb2-&gt;nh.raw = skb2-&gt;data;
			}
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20837;&#21040;RAW&#22871;&#25509;&#23383;</span>
			skb2-&gt;h.raw = skb2-&gt;nh.raw;
			skb2-&gt;pkt_type = PACKET_OUTGOING;
			ptype-&gt;func(skb2, skb-&gt;dev, ptype, skb-&gt;dev);
		}
	}
	rcu_read_unlock();
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org812bd92" class="outline-2">
<h2 id="org812bd92"><span class="section-number-2">8</span> CPU状态变化时的处理</h2>
<div class="outline-text-2" id="text-8">
<p>
CPU有各自的softnet_data队列，当CPU状态变为 CPU_DEAD 时，需要将队列中报文交给其他CPU处理。
</p>

<p>
dev_cpu_callback()函数用来处理cpu状态变化， 通过hotcpu_notifier()注册。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">dev_cpu_callback</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">notifier_block</span> *<span style="color: #FF8C00;">nfb</span>,<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21709;&#24212;cpu&#29366;&#24577;&#21464;&#21270;&#30340;&#20449;&#24687;&#22359;</span>
			    <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">action</span>,  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29366;&#24577;&#21464;&#21270;cpu&#30340;&#24403;&#21069;&#29366;&#24577;</span>
			    <span style="color: #5FD7FF;">void</span> *<span style="color: #FF8C00;">ocpu</span>) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29366;&#24577;&#21464;&#21270;&#30340;cpu</span>
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> **<span style="color: #FF8C00;">list_skb</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> **<span style="color: #FF8C00;">list_net</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">cpu</span>, <span style="color: #FF8C00;">oldcpu</span> = (<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span>)ocpu;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">softnet_data</span> *<span style="color: #FF8C00;">sd</span>, *<span style="color: #FF8C00;">oldsd</span>;
	<span style="color: #FF1493;">if</span> (action != CPU_DEAD) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20043;&#22788;&#29702;CPU_DEAD&#29366;&#24577;</span>
		<span style="color: #FF1493;">return</span> NOTIFY_OK;
	local_irq_disable();
	cpu = smp_processor_id();
	sd = &amp;per_cpu(softnet_data, cpu); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24403;&#21069;cpu&#30340;&#38431;&#21015;</span>
	oldsd = &amp;per_cpu(softnet_data, oldcpu); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#19979;&#32447;cpu&#30340;&#38431;&#21015;</span>

	list_skb = &amp;sd-&gt;completion_queue;
	<span style="color: #FF1493;">while</span> (*list_skb)
		list_skb = &amp;(*list_skb)-&gt;next; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#33719;&#21462;completion_queue&#30340;&#32467;&#26463;&#20301;&#32622;</span>
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#23558;&#19979;&#32447;cpu&#30340;completion_queue &#31227;&#21160;&#33267;&#24403;&#21069;cpu</span><span style="color: #8B8878;">*/</span>
	*list_skb = oldsd-&gt;completion_queue;
	oldsd-&gt;completion_queue = <span style="color: #AF87FF;">NULL</span>;

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#33719;&#21462;output_queue&#30340;&#32467;&#26463;&#20301;&#32622;</span><span style="color: #8B8878;"> */</span>
	list_net = &amp;sd-&gt;output_queue;
	<span style="color: #FF1493;">while</span> (*list_net)
		list_net = &amp;(*list_net)-&gt;next_sched;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#36861;&#21152;&#21040;&#24403;&#21069;cpu&#30340;output_queue</span><span style="color: #8B8878;"> */</span>
	*list_net = oldsd-&gt;output_queue;
	oldsd-&gt;output_queue = <span style="color: #AF87FF;">NULL</span>;

	raise_softirq_irqoff(NET_TX_SOFTIRQ);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#28608;&#27963;&#36755;&#20986;&#36719;&#20013;&#26029;</span>
	local_irq_enable();

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22788;&#29702;&#19979;&#32447;CPU&#30340; input_pkt_queue</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">while</span> ((skb = __skb_dequeue(&amp;oldsd-&gt;input_pkt_queue)))
		netif_rx(skb);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20837;&#21040;&#19978;&#23618;&#21327;&#35758;</span>
	<span style="color: #FF1493;">return</span> NOTIFY_OK;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgd6cce1a" class="outline-2">
<h2 id="orgd6cce1a"><span class="section-number-2">9</span> netpoll</h2>
<div class="outline-text-2" id="text-9">
<p>
netconsole 通过netpoll框架将信息通过UDP发送到监控主机。
</p>
</div>

<div id="outline-container-orge802297" class="outline-3">
<h3 id="orge802297"><span class="section-number-3">9.1</span> netpoll结构</h3>
<div class="outline-text-3" id="text-9-1">
<p>
netpoll实例分为 能接收数据包 和 不能接收数据包 两种类型。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> {
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">dev</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32465;&#23450;&#30340;&#35774;&#22791;</span>
	<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">dev_name</span>[IFNAMSIZ]; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#22791;&#21517;</span>
	<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">name</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">netpoll&#23454;&#20363;&#21517;&#31216;</span>
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25253;&#25991;&#25509;&#25910;&#22788;&#29702;&#20363;&#31243;&#12290;</span>
	<span style="color: #5FD7FF;">void</span> (*<span style="color: #87D700;">rx_hook</span>)(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> *, <span style="color: #5FD7FF;">int</span>, <span style="color: #5FD7FF;">char</span> *, <span style="color: #5FD7FF;">int</span>);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26412;&#26426;ip&#21644;&#36828;&#31471;ip</span>
	<span style="color: #5FD7FF;">u32</span> <span style="color: #FF8C00;">local_ip</span>, <span style="color: #FF8C00;">remote_ip</span>;
	<span style="color: #5FD7FF;">u16</span> <span style="color: #FF8C00;">local_port</span>, <span style="color: #FF8C00;">remote_port</span>;
	<span style="color: #5FD7FF;">u8</span> <span style="color: #FF8C00;">local_mac</span>[ETH_ALEN], <span style="color: #FF8C00;">remote_mac</span>[ETH_ALEN];
};
</pre>
</div>

<p>
如果支持netpoll，则对应网络设备的net_device实例必须实现 npinfo 成员。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll_info</span> {
	<span style="color: #5FD7FF;">atomic_t</span> <span style="color: #FF8C00;">refcnt</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24341;&#29992;&#35745;&#25968;</span>
	<span style="color: #5FD7FF;">spinlock_t</span> <span style="color: #FF8C00;">poll_lock</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32593;&#32476;&#35774;&#22791;poll&#25509;&#21475;&#30340;&#24182;&#21457;&#35775;&#38382;&#38145;</span>
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">poll_owner</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27491;&#20174;&#32593;&#32476;&#35774;&#22791;&#35835;&#21462;&#25968;&#25454;&#21253;&#30340;cpu</span>
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">rx_flags</span>;
	<span style="color: #5FD7FF;">spinlock_t</span> <span style="color: #FF8C00;">rx_lock</span>;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">netpoll&#36755;&#20837;&#25805;&#20316;&#30340;&#24182;&#21457;&#35775;&#38382;&#38145;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> *<span style="color: #FF8C00;">rx_np</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25551;&#36848;netpoll&#30340;&#25509;&#25910;&#20449;&#24687;&#21644;&#21457;&#36865;&#20449;&#24687;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff_head</span> <span style="color: #FF8C00;">arp_tx</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23384;&#20648;&#25509;&#25910;&#30340;arp&#25253;&#25991;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff_head</span> <span style="color: #FF8C00;">txq</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25253;&#25991;&#32531;&#23384;&#38431;&#21015;&#65288;&#20256;&#36755;&#22833;&#36133;&#25110;&#32773;&#35774;&#22791;&#32321;&#24537;&#65289;</span>
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">delayed_work</span> <span style="color: #FF8C00;">tx_work</span>; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#29992;&#20110;&#36755;&#20986;txq&#30340;&#24037;&#20316;&#38431;&#21015;</span>
};
</pre>
</div>

<p>
如果要使用netpoll，还需要实现网络设备的 poll_controller 函数，该函数用来模拟网络设备发生中断，进行中断处理。 例如 e100_netpool。
</p>
</div>
</div>

<div id="outline-container-orgcdee5cc" class="outline-3">
<h3 id="orgcdee5cc"><span class="section-number-3">9.2</span> netpoll实例的注册</h3>
<div class="outline-text-3" id="text-9-2">
<p>
netpoll_setup()函数用来注册netpoll实例。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">netpoll_setup</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> *<span style="color: #FF8C00;">np</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">ndev</span> = <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">in_device</span> *<span style="color: #FF8C00;">in_dev</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll_info</span> *<span style="color: #FF8C00;">npinfo</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">flags</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;

	<span style="color: #FF1493;">if</span> (np-&gt;dev_name)
		ndev = dev_get_by_name(np-&gt;dev_name);
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>ndev) {
		printk(KERN_ERR <span style="color: #CDC673;">"%s: %s doesn't exist, aborting.\n"</span>,
		       np-&gt;name, np-&gt;dev_name);
		<span style="color: #FF1493;">return</span> -ENODEV;
	}

	np-&gt;dev = ndev;  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23558;&#32593;&#32476;&#35774;&#22791;&#21644;netpoll&#23454;&#20363;&#20851;&#32852;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>ndev-&gt;npinfo) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#32593;&#32476;&#35774;&#22791;&#30340;netpoll&#20449;&#24687;&#22359;&#19981;&#23384;&#21017;&#65292;&#21017;&#38656;&#21019;&#24314;</span>
		npinfo = kmalloc(<span style="color: #FF1493;">sizeof</span>(*npinfo), GFP_KERNEL);
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#24037;&#20316;</span>
		npinfo-&gt;rx_flags = 0;
		npinfo-&gt;rx_np = <span style="color: #AF87FF;">NULL</span>;
		spin_lock_init(&amp;npinfo-&gt;poll_lock);
		npinfo-&gt;poll_owner = -1;
		spin_lock_init(&amp;npinfo-&gt;rx_lock);
		skb_queue_head_init(&amp;npinfo-&gt;arp_tx);
		skb_queue_head_init(&amp;npinfo-&gt;txq);
		INIT_DELAYED_WORK(&amp;npinfo-&gt;tx_work, queue_process);
		atomic_set(&amp;npinfo-&gt;refcnt, 1);
	} <span style="color: #FF1493;">else</span> {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23384;&#22312;&#65292;&#30452;&#25509;&#24341;&#29992;</span>
		npinfo = ndev-&gt;npinfo;
		atomic_inc(&amp;npinfo-&gt;refcnt);
	}
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>ndev-&gt;poll_controller) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24517;&#39035;&#23454;&#29616;&#32593;&#32476;&#35774;&#22791;&#30340; poll_controller&#25509;&#21475;</span>
		printk(KERN_ERR <span style="color: #CDC673;">"%s: %s doesn't support polling, aborting.\n"</span>,
		       np-&gt;name, np-&gt;dev_name);
		err = -ENOTSUPP;
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">release</span>;
	}
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>netif_running(ndev)) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#22791;&#36824;&#26410;&#21551;&#21160;</span>
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">atmost</span>, <span style="color: #FF8C00;">atleast</span>;
		printk(KERN_INFO <span style="color: #CDC673;">"%s: device %s not up yet, forcing it\n"</span>,
		       np-&gt;name, np-&gt;dev_name);
		rtnl_lock();
		err = dev_open(ndev);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21551;&#21160;&#35774;&#22791;</span>
		rtnl_unlock();

		atleast = jiffies + HZ/10;
		atmost = jiffies + 4*HZ;
		<span style="color: #FF1493;">while</span> (<span style="color: #CDC673; font-weight: bold;">!</span>netif_carrier_ok(ndev)) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#22791;&#26159;&#21542;&#33021;&#20256;&#36755;&#25968;&#25454;&#21253;</span>
			<span style="color: #FF1493;">if</span> (time_after(jiffies, atmost)) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#31561;&#24453;4s</span>
				printk(KERN_NOTICE
				       <span style="color: #CDC673;">"%s: timeout waiting for carrier\n"</span>,
				       np-&gt;name);
				<span style="color: #FF1493;">break</span>;
			}
			cond_resched();
		}
		<span style="color: #FF1493;">if</span> (time_before(jiffies, atleast)) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22914;&#26524;0.1s&#20869;&#23601;&#21457;&#29616;&#35774;&#22791;&#21487;&#20197;&#20256;&#36882;&#25968;&#25454;&#21253;&#65292;&#21017;&#19981;&#21487;&#20449;&#65292;&#38656;&#35201;&#31561;&#24453;4s</span>
			printk(KERN_NOTICE <span style="color: #CDC673;">"%s: carrier detect appears"</span>
			       <span style="color: #CDC673;">" untrustworthy, waiting 4 seconds\n"</span>,
			       np-&gt;name);
			msleep(4000);
		}
	}
	<span style="color: #FF1493;">if</span> (is_zero_ether_addr(np-&gt;local_mac) &amp;&amp; ndev-&gt;dev_addr)
		memcpy(np-&gt;local_mac, ndev-&gt;dev_addr, 6);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20174;&#32593;&#32476;&#35774;&#22791;&#33719;&#21462;mac&#22320;&#22336;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>np-&gt;local_ip) {
		rcu_read_lock();
		in_dev = __in_dev_get_rcu(ndev);
		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>in_dev || <span style="color: #CDC673; font-weight: bold;">!</span>in_dev-&gt;ifa_list) {
			rcu_read_unlock();
			printk(KERN_ERR <span style="color: #CDC673;">"%s: no IP address for %s, aborting\n"</span>,
			       np-&gt;name, np-&gt;dev_name);
			err = -EDESTADDRREQ;
			<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">release</span>;
		}
		<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20174;&#35774;&#22791;&#33719;&#21462;IP&#22320;&#22336;</span>
		np-&gt;local_ip = ntohl(in_dev-&gt;ifa_list-&gt;ifa_local);
		rcu_read_unlock();
		printk(KERN_INFO <span style="color: #CDC673;">"%s: local IP %d.%d.%d.%d\n"</span>,
		       np-&gt;name, HIPQUAD(np-&gt;local_ip));
	}
	<span style="color: #FF1493;">if</span> (np-&gt;rx_hook) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23454;&#29616;&#20102;rx_hook&#25509;&#21475;</span>
		spin_lock_irqsave(&amp;npinfo-&gt;rx_lock, flags);
		npinfo-&gt;rx_flags |= NETPOLL_RX_ENABLED; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#26631;&#24535;&#65292; &#34920;&#31034;&#21487;&#20197;&#25509;&#25910;&#25968;&#25454;&#21253;</span>
		npinfo-&gt;rx_np = np;
		spin_unlock_irqrestore(&amp;npinfo-&gt;rx_lock, flags);
	}
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#20026;&#21457;&#36865;UDP&#21644;ARP&#24212;&#31572;&#25253;&#25991;&#65292;&#21019;&#24314;SKB&#32531;&#23384;&#21306;</span><span style="color: #8B8878;"> */</span>
	refill_skbs();
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#32465;&#23450;netpoll&#20449;&#24687;&#22359;&#21040;&#35774;&#22791;</span><span style="color: #8B8878;"> */</span>
	ndev-&gt;npinfo = npinfo;
	synchronize_rcu();
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgad20c58" class="outline-3">
<h3 id="orgad20c58"><span class="section-number-3">9.3</span> netpoll的输入</h3>
<div class="outline-text-3" id="text-9-3">
<p>
netpoll_rx() 是netpoll输入的入口函数，由 netif_rx() 和 netif_receive_skb() 函数调用。netpoll的输入之处理两种数据报，如果是ARP报文，则添加到 arp_tx 队列中，等待模拟中断处理; 如果是IP数据报，则输入到netpoll 实例：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">__netpoll_rx</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">proto</span>, <span style="color: #FF8C00;">len</span>, <span style="color: #FF8C00;">ulen</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">udphdr</span> *<span style="color: #FF8C00;">uh</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll_info</span> *<span style="color: #FF8C00;">npi</span> = skb-&gt;dev-&gt;npinfo;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> *<span style="color: #FF8C00;">np</span> = npi-&gt;rx_np;

	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>np)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (skb-&gt;dev-&gt;type != ARPHRD_ETHER)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">ARP&#25253;&#25991;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (skb-&gt;protocol == __constant_htons(ETH_P_ARP) &amp;&amp;
	    atomic_read(&amp;trapped)) {
		skb_queue_tail(&amp;npi-&gt;arp_tx, skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20837;&#21040;arp_tx&#38431;&#21015;</span>
		<span style="color: #FF1493;">return</span> 1;
	}

	proto = ntohs(eth_hdr(skb)-&gt;h_proto);
	<span style="color: #FF1493;">if</span> (proto != ETH_P_IP)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;IP&#25968;&#25454;&#25253;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (skb-&gt;pkt_type == PACKET_OTHERHOST) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;&#26412;&#22320;&#30340;&#25968;&#25454;&#25253;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (skb_shared(skb)) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#25253;&#25991;&#34987;&#20849;&#20139;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	iph = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *)skb-&gt;data;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span>)))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (iph-&gt;ihl &lt; 5 || iph-&gt;version != 4)<span style="color: #8B8878;">//</span><span style="color: #8B8878;">IP&#25968;&#25454;&#25253;&#26080;&#25928;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, iph-&gt;ihl*4))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (ip_fast_csum((<span style="color: #5FD7FF;">u8</span> *)iph, iph-&gt;ihl) != 0)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	len = ntohs(iph-&gt;tot_len);
	<span style="color: #FF1493;">if</span> (skb-&gt;len &lt; len || len &lt; iph-&gt;ihl*4)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (iph-&gt;protocol != IPPROTO_UDP) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;UDP&#25968;&#25454;&#25253;</span>
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	len -= iph-&gt;ihl*4;
	uh = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">udphdr</span> *)(((<span style="color: #5FD7FF;">char</span> *)iph) + iph-&gt;ihl*4);
	ulen = ntohs(uh-&gt;len);
	<span style="color: #FF1493;">if</span> (ulen != len)
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (checksum_udp(skb, uh, ulen, iph-&gt;saddr, iph-&gt;daddr))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (np-&gt;local_ip &amp;&amp; np-&gt;local_ip != ntohl(iph-&gt;daddr))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (np-&gt;remote_ip &amp;&amp; np-&gt;remote_ip != ntohl(iph-&gt;saddr))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	<span style="color: #FF1493;">if</span> (np-&gt;local_port &amp;&amp; np-&gt;local_port != ntohs(uh-&gt;dest))
		<span style="color: #FF1493;">goto</span> <span style="color: #AF87FF;">out</span>;
	np-&gt;rx_hook(np, ntohs(uh-&gt;source),  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20837;&#21040;netpoll&#23454;&#20363;</span>
		    (<span style="color: #5FD7FF;">char</span> *)(uh+1),
		    ulen - <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">udphdr</span>));
	kfree_skb(skb);
	<span style="color: #FF1493;">return</span> 1;
<span style="color: #AF87FF;">out</span>:
	<span style="color: #FF1493;">if</span> (atomic_read(&amp;trapped)) {
		kfree_skb(skb);
		<span style="color: #FF1493;">return</span> 1;
	}
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>

<div id="outline-container-orgb1e4166" class="outline-4">
<h4 id="orgb1e4166"><span class="section-number-4">9.3.1</span> trap状态</h4>
<div class="outline-text-4" id="text-9-3-1">
<p>
netpoll中有一个trapped全局变量，用以标识trap状态，通过netpoll_set_trap()设置当前的trap状态。
</p>

<p>
trap取值：
</p>
<ul class="org-ul">
<li>非0  所有处理的数据包，不满足条件直接丢弃，不传递到协议栈。</li>
<li>0    只处理满足条件的数据包，不满足的传递给协议栈。</li>
</ul>
</div>
</div>

<div id="outline-container-org870f151" class="outline-4">
<h4 id="org870f151"><span class="section-number-4">9.3.2</span> netpoll_poll()</h4>
<div class="outline-text-4" id="text-9-3-2">
<p>
通过netpoll_poll()函数，模拟触发网络设备中断，然后利用其他CPU协助进行数据包轮询处理。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">netpoll_poll</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> *<span style="color: #FF8C00;">np</span>)
{
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>np-&gt;dev || <span style="color: #CDC673; font-weight: bold;">!</span>netif_running(np-&gt;dev) || <span style="color: #CDC673; font-weight: bold;">!</span>np-&gt;dev-&gt;poll_controller)
		<span style="color: #FF1493;">return</span>;
	<span style="color: #8B8878;">/*</span><span style="color: #8B8878;">&#35843;&#29992;poll_controller&#25509;&#21475;&#65292;&#27169;&#25311;&#32593;&#32476;&#35774;&#22791;&#36755;&#20837;&#20013;&#26029;</span><span style="color: #8B8878;"> */</span>
	np-&gt;dev-&gt;poll_controller(np-&gt;dev);
	<span style="color: #FF1493;">if</span> (np-&gt;dev-&gt;poll)
		poll_napi(np);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36827;&#34892;&#36718;&#35810;&#35835;&#21462;&#25253;&#25991;</span>
	service_arp_queue(np-&gt;dev-&gt;npinfo); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;arp_tx&#38431;&#21015;&#30340;ARP&#25253;&#25991;</span>
	zap_completion_queue(); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#37322;&#25918;&#23436;&#25104;&#21457;&#36865;&#30340;&#25968;&#25454;&#21253;</span>
}

<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">poll_napi</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> *<span style="color: #FF8C00;">np</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll_info</span> *<span style="color: #FF8C00;">npinfo</span> = np-&gt;dev-&gt;npinfo;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">budget</span> = 16;
	<span style="color: #FF1493;">if</span> (test_bit(__LINK_STATE_RX_SCHED, &amp;np-&gt;dev-&gt;state) &amp;&amp;<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20004;&#27425;&#25968;&#25454;&#21253;&#36755;&#20837;&#36719;&#20013;&#26029;&#22788;&#29702;&#30340;&#38388;&#38553;</span>
	    npinfo-&gt;poll_owner != smp_processor_id() &amp;&amp; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24403;&#21069;CPU&#19981;&#26159;&#19978;&#27425;&#22788;&#29702;&#36719;&#20013;&#26029;&#30340;CPU</span>
	    spin_trylock(&amp;npinfo-&gt;poll_lock)) {
		npinfo-&gt;rx_flags |= NETPOLL_RX_DROP;
		atomic_inc(&amp;trapped);
		np-&gt;dev-&gt;poll(np-&gt;dev, &amp;budget); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#29992;&#25509;&#21475;&#30340;pool&#25509;&#21475;&#36718;&#35810;&#25509;&#25910;&#25253;&#25991;</span>
		atomic_dec(&amp;trapped);
		npinfo-&gt;rx_flags &amp;= ~NETPOLL_RX_DROP;
		spin_unlock(&amp;npinfo-&gt;poll_lock);
	}
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgada9abc" class="outline-4">
<h4 id="orgada9abc"><span class="section-number-4">9.3.3</span> ARP报文处理</h4>
<div class="outline-text-4" id="text-9-3-3">
<p>
service_arp_queue() 会轮询获取并处理 arp_tx 队列的ARP报文。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">service_arp_queue</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll_info</span> *<span style="color: #FF8C00;">npi</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;
	skb = skb_dequeue(&amp;npi-&gt;arp_tx);
	<span style="color: #FF1493;">while</span> (skb != <span style="color: #AF87FF;">NULL</span>) {
		arp_reply(skb); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22788;&#29702;ARP&#25253;&#25991;</span>
		skb = skb_dequeue(&amp;npi-&gt;arp_tx);
	}
}

<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">arp_reply</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll_info</span> *<span style="color: #FF8C00;">npinfo</span> = skb-&gt;dev-&gt;npinfo;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">arphdr</span> *<span style="color: #FF8C00;">arp</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">arp_ptr</span>;
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">size</span>, <span style="color: #FF8C00;">type</span> = ARPOP_REPLY, <span style="color: #FF8C00;">ptype</span> = ETH_P_ARP;
	<span style="color: #5FD7FF;">__be32</span> <span style="color: #FF8C00;">sip</span>, <span style="color: #FF8C00;">tip</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">sha</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">send_skb</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> *<span style="color: #FF8C00;">np</span> = <span style="color: #AF87FF;">NULL</span>;
	<span style="color: #FF1493;">if</span> (npinfo-&gt;rx_np &amp;&amp; npinfo-&gt;rx_np-&gt;dev == skb-&gt;dev)
		np = npinfo-&gt;rx_np;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>np)
		<span style="color: #FF1493;">return</span>;
	<span style="color: #FF1493;">if</span> (skb-&gt;dev-&gt;flags &amp; IFF_NOARP) <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#22791;&#19981;&#25903;&#25345;ARP</span>
		<span style="color: #FF1493;">return</span>;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>pskb_may_pull(skb, (<span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">arphdr</span>) +
				 (2 * skb-&gt;dev-&gt;addr_len) +
				 (2 * <span style="color: #FF1493;">sizeof</span>(u32)))))  <span style="color: #8B8878;">//</span><span style="color: #8B8878;">ARP&#25253;&#25991;&#26159;&#21542;&#26377;&#25928;</span>
		<span style="color: #FF1493;">return</span>;
	skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data;
	arp = skb-&gt;nh.arph;
	<span style="color: #FF1493;">if</span> ((arp-&gt;ar_hrd != htons(ARPHRD_ETHER) &amp;&amp; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#38750;&#20197;&#22826;&#32593;&#19981;&#22788;&#29702;</span>
	     arp-&gt;ar_hrd != htons(ARPHRD_IEEE802)) ||
	    arp-&gt;ar_pro != htons(ETH_P_IP) ||
	    arp-&gt;ar_op != htons(ARPOP_REQUEST))
		<span style="color: #FF1493;">return</span>;

	arp_ptr = (<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *)(arp+1);
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#33719;&#21462;&#21457;&#36865;&#26041;&#30340;&#30828;&#20214;&#22320;&#22336;&#21644;IP&#22320;&#22336;</span><span style="color: #8B8878;"> */</span>
	sha = arp_ptr;
	arp_ptr += skb-&gt;dev-&gt;addr_len;
	memcpy(&amp;sip, arp_ptr, 4);
	arp_ptr += 4;
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#29992;&#20110;&#26816;&#27979;&#30446;&#30340;&#22320;&#22336;</span><span style="color: #8B8878;"> */</span>
	arp_ptr += skb-&gt;dev-&gt;addr_len;
	memcpy(&amp;tip, arp_ptr, 4);
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#38750;&#26412;&#26426;&#22320;&#22336; &#38750;&#22238;&#29615;&#22320;&#22336; &#38750;&#32452;&#25773;&#22320;&#22336;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (tip != htonl(np-&gt;local_ip) || LOOPBACK(tip) || MULTICAST(tip))
		<span style="color: #FF1493;">return</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26681;&#25454;ARP&#35831;&#27714;&#20998;&#37197;ARP&#24212;&#31572;&#25253;&#25991;</span>
	size = <span style="color: #FF1493;">sizeof</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">arphdr</span>) + 2 * (skb-&gt;dev-&gt;addr_len + 4);
	send_skb = find_skb(np, size + LL_RESERVED_SPACE(np-&gt;dev),
			    LL_RESERVED_SPACE(np-&gt;dev));
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22635;&#20805;ARP&#25253;&#25991;</span>
	send_skb-&gt;nh.raw = send_skb-&gt;data;
	arp = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">arphdr</span> *) skb_put(send_skb, size);
	send_skb-&gt;dev = skb-&gt;dev;
	send_skb-&gt;protocol = htons(ETH_P_ARP);

	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#22635;&#20805;&#20197;&#22826;&#32593;&#24103;&#39318;&#37096;</span><span style="color: #8B8878;"> */</span>
	<span style="color: #FF1493;">if</span> (np-&gt;dev-&gt;hard_header &amp;&amp;
	    np-&gt;dev-&gt;hard_header(send_skb, skb-&gt;dev, ptype,
				 sha, np-&gt;local_mac,
				 send_skb-&gt;len) &lt; 0) {
		kfree_skb(send_skb);
		<span style="color: #FF1493;">return</span>;
	}
	arp-&gt;ar_hrd = htons(np-&gt;dev-&gt;type);
	arp-&gt;ar_pro = htons(ETH_P_IP);
	arp-&gt;ar_hln = np-&gt;dev-&gt;addr_len;
	arp-&gt;ar_pln = 4;
	arp-&gt;ar_op = htons(type);

	arp_ptr=(<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *)(arp + 1);
	memcpy(arp_ptr, np-&gt;dev-&gt;dev_addr, np-&gt;dev-&gt;addr_len);
	arp_ptr += np-&gt;dev-&gt;addr_len;
	memcpy(arp_ptr, &amp;tip, 4);
	arp_ptr += 4;
	memcpy(arp_ptr, sha, np-&gt;dev-&gt;addr_len);
	arp_ptr += np-&gt;dev-&gt;addr_len;
	memcpy(arp_ptr, &amp;sip, 4);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#25253;&#25991;</span>
	netpoll_send_skb(np, send_skb);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org091dbae" class="outline-4">
<h4 id="org091dbae"><span class="section-number-4">9.3.4</span> ip数据包处理</h4>
<div class="outline-text-4" id="text-9-3-4">
<p>
__netpoll_rx() 中，通过检查后， 调用np-&gt;rx_hook 将报文输入给netpoll实例的接收处理例程。
</p>
</div>
</div>
</div>


<div id="outline-container-org84922aa" class="outline-3">
<h3 id="org84922aa"><span class="section-number-3">9.4</span> netpoll的输出</h3>
<div class="outline-text-3" id="text-9-4">
</div>
<div id="outline-container-org668964b" class="outline-4">
<h4 id="org668964b"><span class="section-number-4">9.4.1</span> netpoll_send_udp()</h4>
<div class="outline-text-4" id="text-9-4-1">
<p>
netpoll_send_udp() 是netpoll提供的输出接口，需要输出数据时直接调用即可。
</p>


<div class="figure">
<p><img src="image/itf-input/netpoll-output.png" alt="netpoll-output.png" />
</p>
<p><span class="figure-number">Figure 5: </span>netpoll输出函数的调用关系</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">netpoll_send_udp</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> *<span style="color: #FF8C00;">np</span>, <span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">msg</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">total_len</span>, <span style="color: #FF8C00;">eth_len</span>, <span style="color: #FF8C00;">ip_len</span>, <span style="color: #FF8C00;">udp_len</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">udphdr</span> *<span style="color: #FF8C00;">udph</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *<span style="color: #FF8C00;">iph</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ethhdr</span> *<span style="color: #FF8C00;">eth</span>;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35745;&#31639;&#38271;&#24230;&#65292;&#24182;&#20998;&#37197;SKB</span>
	udp_len = len + <span style="color: #FF1493;">sizeof</span>(*udph);
	ip_len = eth_len = udp_len + <span style="color: #FF1493;">sizeof</span>(*iph);
	total_len = eth_len + ETH_HLEN + NET_IP_ALIGN;
	skb = find_skb(np, total_len, total_len - len);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#22797;&#21046;&#25968;&#25454;</span>
	memcpy(skb-&gt;data, msg, len);
	skb-&gt;len += len;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21021;&#22987;&#21270;UDP&#25968;&#25454;&#21253;&#39318;&#37096;</span>
	skb-&gt;h.uh = udph = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">udphdr</span> *) skb_push(skb, <span style="color: #FF1493;">sizeof</span>(*udph));
	udph-&gt;source = htons(np-&gt;local_port);
	udph-&gt;dest = htons(np-&gt;remote_port);
	udph-&gt;len = htons(udp_len);
	udph-&gt;check = 0;
	udph-&gt;check = csum_tcpudp_magic(htonl(np-&gt;local_ip),
					htonl(np-&gt;remote_ip),
					udp_len, IPPROTO_UDP,
					csum_partial((<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *)udph, udp_len, 0));
	<span style="color: #FF1493;">if</span> (udph-&gt;check == 0)
		udph-&gt;check = CSUM_MANGLED_0;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24320;&#22987;&#21021;&#22987;&#21270;IP&#25968;&#25454;&#21253;&#39318;&#37096;</span>
	skb-&gt;nh.iph = iph = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">iphdr</span> *)skb_push(skb, <span style="color: #FF1493;">sizeof</span>(*iph));
	<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">iph-&gt;version = 4; iph-&gt;ihl = 5;</span><span style="color: #8B8878;"> */</span>
	put_unaligned(0x45, (<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *)iph);
	iph-&gt;tos      = 0;
	put_unaligned(htons(ip_len), &amp;(iph-&gt;tot_len));
	iph-&gt;id       = 0;
	iph-&gt;frag_off = 0;
	iph-&gt;ttl      = 64;
	iph-&gt;protocol = IPPROTO_UDP;
	iph-&gt;check    = 0;
	put_unaligned(htonl(np-&gt;local_ip), &amp;(iph-&gt;saddr));
	put_unaligned(htonl(np-&gt;remote_ip), &amp;(iph-&gt;daddr));
	iph-&gt;check    = ip_fast_csum((<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">char</span> *)iph, iph-&gt;ihl);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24320;&#22987;&#21021;&#22987;&#21270;&#20197;&#22826;&#32593;&#24103;&#39318;&#37096;</span>
	eth = (<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">ethhdr</span> *) skb_push(skb, ETH_HLEN);
	skb-&gt;mac.raw = skb-&gt;data;
	skb-&gt;protocol = eth-&gt;h_proto = htons(ETH_P_IP);
	memcpy(eth-&gt;h_source, np-&gt;local_mac, 6);
	memcpy(eth-&gt;h_dest, np-&gt;remote_mac, 6);
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35774;&#32622;&#36755;&#20986;&#35774;&#22791;</span>
	skb-&gt;dev = np-&gt;dev;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;SKB</span>
	netpoll_send_skb(np, skb);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8b34682" class="outline-4">
<h4 id="org8b34682"><span class="section-number-4">9.4.2</span> netpoll_send_skb()</h4>
<div class="outline-text-4" id="text-9-4-2">
<p>
netpoll_send_skb()用来发送数据包，可以是UDP或者ARP。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">netpoll_send_skb</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> *<span style="color: #FF8C00;">np</span>, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">status</span> = NETDEV_TX_BUSY;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">tries</span>;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">dev</span> = np-&gt;dev;
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll_info</span> *<span style="color: #FF8C00;">npinfo</span> = np-&gt;dev-&gt;npinfo;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#23578;&#26410;&#21019;&#24314;netpoll&#20449;&#24687;&#22359;&#65292;&#25110;&#32773;&#35774;&#22791;&#23578;&#26410;&#25171;&#24320;&#65292;&#25110;&#32773;&#35774;&#22791;&#34987;&#25346;&#36215;</span>
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>npinfo || <span style="color: #CDC673; font-weight: bold;">!</span>netif_running(dev) || <span style="color: #CDC673; font-weight: bold;">!</span>netif_device_present(dev)) {
		__kfree_skb(skb);
		<span style="color: #FF1493;">return</span>;
	}

	<span style="color: #FF1493;">if</span> (skb_queue_len(&amp;npinfo-&gt;txq) == 0 &amp;&amp; <span style="color: #8B8878;">//</span><span style="color: #8B8878;">txq&#38431;&#21015;&#20026;&#31354;</span>
	npinfo-&gt;poll_owner != smp_processor_id()) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#24403;&#21069;cpu&#19981;&#26159;&#19978;&#27425;&#36755;&#20837;&#36719;&#20013;&#26029;&#30340;cpu</span>
		<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">flags</span>;

		local_irq_save(flags);
		<span style="color: #FF1493;">if</span> (netif_tx_trylock(dev)) {
			<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">try until next clock tick</span><span style="color: #8B8878;"> */</span>
			<span style="color: #FF1493;">for</span> (tries = jiffies_to_usecs(1)/USEC_PER_POLL;
					tries &gt; 0; --tries) {
				<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>netif_queue_stopped(dev))
					status = dev-&gt;hard_start_xmit(skb, dev);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36755;&#20986;&#25968;&#25454;&#21253;</span>
				<span style="color: #FF1493;">if</span> (status == NETDEV_TX_OK)
					<span style="color: #FF1493;">break</span>;
				<span style="color: #8B8878;">/* </span><span style="color: #8B8878;">&#27169;&#25311;&#36755;&#20837;&#36719;&#20013;&#26029;&#36755;&#20837;&#25968;&#25454;&#21253;</span><span style="color: #8B8878;"> */</span>
				netpoll_poll(np);
				udelay(USEC_PER_POLL);
			}
			netif_tx_unlock(dev);
		}
		local_irq_restore(flags);
	}

	<span style="color: #FF1493;">if</span> (status != NETDEV_TX_OK) {
		skb_queue_tail(&amp;npinfo-&gt;txq, skb);<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26410;&#25104;&#21151;&#36755;&#20986;&#65292;&#21017;&#25346;&#21040;txq&#38431;&#21015;</span>
		schedule_delayed_work(&amp;npinfo-&gt;tx_work,0); <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35843;&#24230;tx_work&#24037;&#20316;&#38431;&#21015;</span>
	}
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc5d5f77" class="outline-3">
<h3 id="orgc5d5f77"><span class="section-number-3">9.5</span> tx_work工作队列</h3>
<div class="outline-text-3" id="text-9-5">
<p>
tx_work工作队列通过 netpoll_setup() 初始化。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">netpoll_setup</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> *<span style="color: #FF8C00;">np</span>)
{
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">......</span>
	INIT_DELAYED_WORK(&amp;npinfo-&gt;tx_work, queue_process);
}

<span style="color: #8B8878;">//</span><span style="color: #8B8878;">tx_work &#24037;&#20316;&#38431;&#21015;&#36890;&#36807; queue_process &#20363;&#31243;&#22788;&#29702;&#12290;</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">queue_process</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">work_struct</span> *<span style="color: #FF8C00;">work</span>)
{
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll_info</span> *<span style="color: #FF8C00;">npinfo</span> =
		container_of(work, <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll_info</span>, tx_work.work);
	<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">sk_buff</span> *<span style="color: #FF8C00;">skb</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">flags</span>;
	<span style="color: #FF1493;">while</span> ((skb = skb_dequeue(&amp;npinfo-&gt;txq))) { <span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36941;&#21382;txq&#38431;&#21015;&#30340;SKB</span>
		<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">net_device</span> *<span style="color: #FF8C00;">dev</span> = skb-&gt;dev;

		<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>netif_device_present(dev) || <span style="color: #CDC673; font-weight: bold;">!</span>netif_running(dev)) {
			__kfree_skb(skb);
			<span style="color: #FF1493;">continue</span>;
		}

		local_irq_save(flags);
		netif_tx_lock(dev);
		<span style="color: #FF1493;">if</span> (netif_queue_stopped(dev) ||
		    dev-&gt;hard_start_xmit(skb, dev) != NETDEV_TX_OK) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#20256;&#36755;SKB</span>
			skb_queue_head(&amp;npinfo-&gt;txq, skb);
			netif_tx_unlock(dev);
			local_irq_restore(flags);
			<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#21457;&#36865;&#22833;&#36133;&#65292;&#37325;&#26032;&#35843;&#24230;</span>
			schedule_delayed_work(&amp;npinfo-&gt;tx_work, HZ/10);
			<span style="color: #FF1493;">return</span>;
		}
		netif_tx_unlock(dev);
		local_irq_restore(flags);
	}
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2ffb5dc" class="outline-3">
<h3 id="org2ffb5dc"><span class="section-number-3">9.6</span> netpoll实例：netconsole</h3>
<div class="outline-text-3" id="text-9-6">
<p>
netconsole 可以将本机的dmesg系统信息通过网络发送到另一台主机上。
</p>

<p>
netconsole依赖netpoll框架，最终通过 netpoll_send_udp() 发送到监控主机。
</p>
</div>

<div id="outline-container-org3899a43" class="outline-4">
<h4 id="org3899a43"><span class="section-number-4">9.6.1</span> netconsole参数</h4>
<div class="outline-text-4" id="text-9-6-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">config</span>[256];
<span style="color: #87D700;">module_param_string</span>(netconsole, config, 256, 0);
<span style="color: #87D700;">MODULE_PARM_DESC</span>(netconsole, <span style="color: #CDC673;">" netconsole=[src-port]@[src-ip]/[dev],[tgt-port]@&lt;tgt-ip&gt;/[tgt-macaddr]\n"</span>);

<span style="color: #FF1493;">static</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">netpoll</span> <span style="color: #FF8C00;">np</span> = {
	.name = <span style="color: #CDC673;">"netconsole"</span>,
	.dev_name = <span style="color: #CDC673;">"eth0"</span>,
	.local_port = 6665,
	.remote_port = 6666,
	.remote_mac = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
};
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">configured</span> = 0;
</pre>
</div>
</div>
</div>

<div id="outline-container-org9419086" class="outline-4">
<h4 id="org9419086"><span class="section-number-4">9.6.2</span> console</h4>
<div class="outline-text-4" id="text-9-6-2">
<p>
由于需要捕获console信息，需要实现console结构的实例并注册到系统。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">console</span> <span style="color: #FF8C00;">netconsole</span> = {
	.name = <span style="color: #CDC673;">"netcon"</span>,
	.flags = CON_ENABLED | CON_PRINTBUFFER,
	.write = write_msg
};
<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#36890;&#36807;write_msg&#36755;&#20986;console&#20449;&#24687;</span>
<span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">write_msg</span>(<span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">console</span> *<span style="color: #FF8C00;">con</span>, <span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">char</span> *<span style="color: #FF8C00;">msg</span>, <span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">len</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">frag</span>, <span style="color: #FF8C00;">left</span>;
	<span style="color: #5FD7FF;">unsigned</span> <span style="color: #5FD7FF;">long</span> <span style="color: #FF8C00;">flags</span>;
	<span style="color: #FF1493;">if</span> (<span style="color: #CDC673; font-weight: bold;">!</span>np.dev)
		<span style="color: #FF1493;">return</span>;
	local_irq_save(flags);

	<span style="color: #FF1493;">for</span>(left = len; left; ) {
		frag = min(left, MAX_PRINT_CHUNK);
		netpoll_send_udp(&amp;np, msg, frag);
		msg += frag;
		left -= frag;
	}
	local_irq_restore(flags);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc468f96" class="outline-4">
<h4 id="orgc468f96"><span class="section-number-4">9.6.3</span> 初始化</h4>
<div class="outline-text-4" id="text-9-6-3">
<p>
init_netconsole()是netconsole模块的初始化函数。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">init_netconsole</span>(<span style="color: #5FD7FF;">void</span>)
{
	<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">err</span>;

	<span style="color: #FF1493;">if</span>(strlen(config))<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#35299;&#26512;&#21442;&#25968;</span>
		option_setup(config);
	<span style="color: #FF1493;">if</span>(<span style="color: #CDC673; font-weight: bold;">!</span>configured) {<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#26410;&#37197;&#32622;&#21442;&#25968;</span>
		printk(<span style="color: #CDC673;">"netconsole: not configured, aborting\n"</span>);
		<span style="color: #FF1493;">return</span> 0;
	}
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27880;&#20876;netpoll&#23454;&#20363;</span>
	err = netpoll_setup(&amp;np);
	<span style="color: #FF1493;">if</span> (err)
		<span style="color: #FF1493;">return</span> err;
	<span style="color: #8B8878;">//</span><span style="color: #8B8878;">&#27880;&#20876;netconsole&#23454;&#20363;</span>
	register_console(&amp;netconsole);
	printk(KERN_INFO <span style="color: #CDC673;">"netconsole: network logging started\n"</span>);
	<span style="color: #FF1493;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2021-12-31 Fri 22:55</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
