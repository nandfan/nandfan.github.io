<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>接口层的输入</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">接口层的输入</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orge78ec81">1. 系统参数</a></li>
<li><a href="#org1e617a7">2. 接口层ioctl</a>
<ul>
<li><a href="#orge3c3d2a">2.1. SIOCxIFxxx类命令</a></li>
<li><a href="#org4e6b2db">2.2. SIOCETHTOOL</a></li>
<li><a href="#orga8caad0">2.3. 私有命令</a></li>
</ul>
</li>
<li><a href="#org8c85d3d">3. 接口层初始化</a></li>
<li><a href="#org09d3199">4. softnet_data结构</a></li>
<li><a href="#org440e72e">5. NAPI</a>
<ul>
<li><a href="#org9410cf7">5.1. 网络设备的中断例程</a></li>
<li><a href="#org75ffe35">5.2. 网络输入软中断</a></li>
<li><a href="#orge844bd6">5.3. 轮询处理报文</a></li>
</ul>
</li>
<li><a href="#orgc1add95">6. 非NAPI</a>
<ul>
<li><a href="#org622a7cf">6.1. netif_rx()</a></li>
<li><a href="#org704a93b">6.2. process_backlog()</a></li>
</ul>
</li>
<li><a href="#orged4c53b">7. 接口层数据报文的处理</a>
<ul>
<li><a href="#org867e845">7.1. 报文接收例程</a></li>
<li><a href="#orgc96b809">7.2. netif_receive_skb()</a></li>
<li><a href="#org19bd205">7.3. dev_queue_xmit_nit()</a></li>
</ul>
</li>
<li><a href="#orgf32b7f8">8. CPU状态变化时的处理</a></li>
<li><a href="#orgfa5c962">9. netpoll</a>
<ul>
<li><a href="#org649f695">9.1. netpoll结构</a></li>
<li><a href="#org6412641">9.2. netpoll实例的注册</a></li>
<li><a href="#org708bcef">9.3. netpoll的输入</a>
<ul>
<li><a href="#org0b756af">9.3.1. trap状态</a></li>
<li><a href="#orga0aae3c">9.3.2. netpoll_poll()</a></li>
<li><a href="#org8130198">9.3.3. ARP报文处理</a></li>
<li><a href="#org49edf72">9.3.4. ip数据包处理</a></li>
</ul>
</li>
<li><a href="#org8f7dd7f">9.4. netpoll的输出</a>
<ul>
<li><a href="#org0fcbc72">9.4.1. netpoll_send_udp()</a></li>
<li><a href="#orgee58aa4">9.4.2. netpoll_send_skb()</a></li>
</ul>
</li>
<li><a href="#org8f61c84">9.5. tx_work工作队列</a></li>
<li><a href="#org08c7483">9.6. netpoll实例：netconsole</a>
<ul>
<li><a href="#org76fc420">9.6.1. netconsole参数</a></li>
<li><a href="#orgf8341c0">9.6.2. console</a></li>
<li><a href="#org49c3a08">9.6.3. 初始化</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orge78ec81" class="outline-2">
<h2 id="orge78ec81"><span class="section-number-2">1.</span> 系统参数</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>dev_weigh  数据包输入软中断中，单个网络设备可读取的报文配额。</li>

<li>netdev_budget 数据包输入软中断中，所有网络设备可从网络设备读取的报文总配额。</li>

<li>netdev_max_backlog 非NAPI链路层的缓存队列长度上限。</li>

<li>message_burst和message_const 用来限制网络模块警告消息的频率，message_const 为记录的时间间隔， message_burst为最多连续记录消息的次数。</li>
</ul>
</div>
</div>


<div id="outline-container-org1e617a7" class="outline-2">
<h2 id="org1e617a7"><span class="section-number-2">2.</span> 接口层ioctl</h2>
<div class="outline-text-2" id="text-2">
<p>
对于接口层的ioctl操作，最终由 dev_ioctl() 和 inet_ioctl() 处理。
</p>


<div id="org18b6ce3" class="figure">
<p><img src="image/itf-input/ioctl-func.png" alt="ioctl-func.png" />
</p>
<p><span class="figure-number">Figure 1: </span>接口层ioctl函数调用关系</p>
</div>
</div>


<div id="outline-container-orge3c3d2a" class="outline-3">
<h3 id="orge3c3d2a"><span class="section-number-3">2.1.</span> SIOCxIFxxx类命令</h3>
<div class="outline-text-3" id="text-2-1">
<p>
此类命令执行设置或者读取操作，通过struct ifreq 结构传递参数。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ifreq</span>
{
        <span style="color: #F92672;">union</span> {
                <span style="color: #66D9EF;">char</span>    <span style="color: #FD971F;">ifrn_name</span>[IFNAMSIZ];            <span style="color: #75715E;">/* </span><span style="color: #75715E;">if name, e.g. "en0"</span><span style="color: #75715E;"> */</span>
        } <span style="color: #FD971F;">ifr_ifrn</span>;

        <span style="color: #F92672;">union</span> {
                <span style="color: #F92672;">struct</span>  <span style="color: #66D9EF;">sockaddr</span> <span style="color: #FD971F;">ifru_addr</span>;
                <span style="color: #F92672;">struct</span>  <span style="color: #66D9EF;">sockaddr</span> <span style="color: #FD971F;">ifru_dstaddr</span>;
                <span style="color: #F92672;">struct</span>  <span style="color: #66D9EF;">sockaddr</span> <span style="color: #FD971F;">ifru_broadaddr</span>;
                <span style="color: #F92672;">struct</span>  <span style="color: #66D9EF;">sockaddr</span> <span style="color: #FD971F;">ifru_netmask</span>;
                <span style="color: #F92672;">struct</span>  <span style="color: #66D9EF;">sockaddr</span> <span style="color: #FD971F;">ifru_hwaddr</span>;
                <span style="color: #66D9EF;">short</span>   <span style="color: #FD971F;">ifru_flags</span>;
                <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">ifru_ivalue</span>;
                <span style="color: #66D9EF;">int</span>     <span style="color: #FD971F;">ifru_mtu</span>;
                <span style="color: #F92672;">struct</span>  <span style="color: #66D9EF;">ifmap</span> <span style="color: #FD971F;">ifru_map</span>;
                <span style="color: #66D9EF;">char</span>    <span style="color: #FD971F;">ifru_slave</span>[IFNAMSIZ];   <span style="color: #75715E;">/* </span><span style="color: #75715E;">Just fits the size</span><span style="color: #75715E;"> */</span>
                <span style="color: #66D9EF;">char</span>    <span style="color: #FD971F;">ifru_newname</span>[IFNAMSIZ];
                <span style="color: #66D9EF;">void</span> <span style="color: #FD971F;">__user</span> *   ifru_data;
                <span style="color: #F92672;">struct</span>  <span style="color: #66D9EF;">if_settings</span> <span style="color: #FD971F;">ifru_settings</span>;
        } <span style="color: #FD971F;">ifr_ifru</span>;
};
</pre>
</div>

<p>
#caption: 操作命令
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">命令</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SIOCGIFCONF</td>
<td class="org-left">获取接口配置信息（struct ifconf）</td>
</tr>

<tr>
<td class="org-left">SOICGIFNAME和SIOCSIFNAME</td>
<td class="org-left">接口名称</td>
</tr>

<tr>
<td class="org-left">SOICGIFFLAGS和SIOCSIFFLAG</td>
<td class="org-left">网络设备的标志</td>
</tr>

<tr>
<td class="org-left">SOICGIFMETRIC和SIOCSIFMETRIC</td>
<td class="org-left">网络设备的metric</td>
</tr>

<tr>
<td class="org-left">SIOCGIFMTU和SIOCSIFMTU</td>
<td class="org-left">mtu</td>
</tr>

<tr>
<td class="org-left">SIOCGIFHWADDR和SIOCSIFHWADDR</td>
<td class="org-left">硬件地址</td>
</tr>

<tr>
<td class="org-left">SIOCGIFMAP和SIOCSIFMAP</td>
<td class="org-left">接口的硬件参数，共享内存、I/O基地址、中断等(struct ifmap结构)</td>
</tr>

<tr>
<td class="org-left">SIOCGIFINDEX</td>
<td class="org-left">网络设备索引号</td>
</tr>

<tr>
<td class="org-left">SIOCGIFTXQLEN和SIOCSIFTXQLEN</td>
<td class="org-left">传输队列长度</td>
</tr>

<tr>
<td class="org-left">SIOCGIFADDR和SIOCSIFADDR</td>
<td class="org-left">本地地址</td>
</tr>

<tr>
<td class="org-left">SIOCGIFPFLAGS和SIOCSIFPFLAGS</td>
<td class="org-left">扩展标志</td>
</tr>

<tr>
<td class="org-left">SIOCGIFNETMASK和SIOCSIFNETMASK</td>
<td class="org-left">地址掩码</td>
</tr>

<tr>
<td class="org-left">SIOCADDMULTI和SIOCDELMULTI</td>
<td class="org-left">网络设备的组播过滤器</td>
</tr>

<tr>
<td class="org-left">SIOCSIFHWBROADCAST</td>
<td class="org-left">获取、添加或者删除网络设备的硬件广播地址</td>
</tr>

<tr>
<td class="org-left">SIOCGIFDSTADDR和SIOCSIFDSTADDR</td>
<td class="org-left">点对点的对端IP地址</td>
</tr>

<tr>
<td class="org-left">SIOCGIFBRDADDR和SIOCSIFBRDADDR</td>
<td class="org-left">组播地址</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4e6b2db" class="outline-3">
<h3 id="org4e6b2db"><span class="section-number-3">2.2.</span> SIOCETHTOOL</h3>
<div class="outline-text-3" id="text-2-2">
<p>
SIOCETHTOOL是以太网设备的专用操作命令，支持多个子命令，不同子命令有不同的命令结构。 例如 ETHTOOL_GSET和ETHTOOL_SSET分别为获取和设置对应的配置，命令结构为ethtool_cmd结构。
</p>
</div>
</div>

<div id="outline-container-orga8caad0" class="outline-3">
<h3 id="orga8caad0"><span class="section-number-3">2.3.</span> 私有命令</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>SIOCGMIIPHY 获取MII的PHY地址</li>

<li>SIOCGMIIREG和SIOCSMIIREG 获取和设置MII的PHY寄存器</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org8c85d3d" class="outline-2">
<h2 id="org8c85d3d"><span class="section-number-2">3.</span> 接口层初始化</h2>
<div class="outline-text-2" id="text-3">
<p>
net_dev_init() 用来初始化相关的接口层，其优先级为 subsys_initcall。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> *       This is called single threaded during boot, so no need</span>
<span style="color: #75715E;"> *       to take the rtnl semaphore.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">__init</span> net_dev_init(<span style="color: #66D9EF;">void</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>, <span style="color: #FD971F;">rc</span> = -ENOMEM;
        BUG_ON(<span style="color: #E6DB74; font-weight: bold;">!</span>dev_boot_phase);
        <span style="color: #F92672;">if</span> (dev_proc_init()) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27880;&#20876;&#32479;&#35745;&#30456;&#20851;&#30340;proc&#25991;&#20214;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (netdev_sysfs_init()) <span style="color: #75715E;">//</span><span style="color: #75715E;">sysfs&#25991;&#20214;&#31995;&#32479;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;ptype_all&#38142;&#34920; &#21644; ptype_base&#25955;&#21015;&#34920;</span>
        INIT_LIST_HEAD(&amp;ptype_all);
        <span style="color: #F92672;">for</span> (i = 0; i &lt; 16; i++)
                INIT_LIST_HEAD(&amp;ptype_base[i]);
        <span style="color: #F92672;">for</span> (i = 0; i &lt; ARRAY_SIZE(dev_name_head); i++) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#22791;&#21517;&#31216;&#25955;&#21015;&#34920;</span>
                INIT_HLIST_HEAD(&amp;dev_name_head[i]);
        <span style="color: #F92672;">for</span> (i = 0; i &lt; ARRAY_SIZE(dev_index_head); i++)
                INIT_HLIST_HEAD(&amp;dev_index_head[i]); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#22791;&#32034;&#24341;&#25955;&#21015;&#34920;</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#25968;&#25454;&#21253;&#25509;&#25910;&#38431;&#21015;</span><span style="color: #75715E;"> */</span>
        for_each_possible_cpu(i) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softnet_data</span> *<span style="color: #FD971F;">queue</span>;
                queue = &amp;per_cpu(softnet_data, i);
                skb_queue_head_init(&amp;queue-&gt;input_pkt_queue);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#25509;&#25910;&#38431;&#21015;</span>
                queue-&gt;completion_queue = <span style="color: #AE81FF;">NULL</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#31561;&#24453;&#37322;&#25918;&#38431;&#21015;</span>
                INIT_LIST_HEAD(&amp;queue-&gt;poll_list);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;NAPI&#30340;&#36755;&#20837;&#38431;&#21015;</span>
                set_bit(__LINK_STATE_START, &amp;queue-&gt;backlog_dev.state);
                queue-&gt;backlog_dev.weight = weight_p;
                queue-&gt;backlog_dev.poll = process_backlog;
                atomic_set(&amp;queue-&gt;backlog_dev.refcnt, 1);
        }
        netdev_dma_register();<span style="color: #75715E;">//</span><span style="color: #75715E;">&#27880;&#20876;DMA&#23458;&#25143;&#31471;</span>
        dev_boot_phase = 0;
        open_softirq(NET_TX_SOFTIRQ, net_tx_action, <span style="color: #AE81FF;">NULL</span>); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20837;&#36719;&#20013;&#26029;</span>
        open_softirq(NET_RX_SOFTIRQ, net_rx_action, <span style="color: #AE81FF;">NULL</span>); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#36719;&#20013;&#26029;</span>
        hotcpu_notifier(dev_cpu_callback, 0); <span style="color: #75715E;">//</span><span style="color: #75715E;">CPU&#29366;&#24577;&#21464;&#21270;&#30340;&#22238;&#35843;&#20989;&#25968;</span>
        dst_init(); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27880;&#20876;&#32593;&#32476;&#29366;&#24577;&#21464;&#21270;&#30340;&#22238;&#35843;&#20989;&#25968;&#65288;dev_cpu_callback()&#20989;&#25968;&#65289;</span>
        dev_mcast_init();<span style="color: #75715E;">// </span><span style="color: #75715E;">&#27880;&#20876;/proc/net/dev_macast &#25991;&#20214;</span>
        rc = 0;
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">return</span> rc;
}
<span style="color: #A6E22E;">subsys_initcall</span>(net_dev_init);
</pre>
</div>
</div>
</div>


<div id="outline-container-org09d3199" class="outline-2">
<h2 id="org09d3199"><span class="section-number-2">4.</span> softnet_data结构</h2>
<div class="outline-text-2" id="text-4">
<p>
struct softnet_data 结构描述了与网络软中断处理相关的报文输入和输出队列，每个CPU有一个单独的softnet_data实例。
</p>


<div id="orgf8aa9d5" class="figure">
<p><img src="image/itf-input/softnetdata-layer.png" alt="softnetdata-layer.png" />
</p>
<p><span class="figure-number">Figure 2: </span>softnet_data、接口层、网络层的关系</p>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softnet_data</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span>       *<span style="color: #FD971F;">output_queue</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#36719;&#20013;&#26029;&#20013;&#30340;&#25968;&#25454;&#21253;&#36755;&#20986;&#38431;&#21015;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff_head</span>     <span style="color: #FD971F;">input_pkt_queue</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;NAPI&#25509;&#21475;&#23618;&#30340;&#32531;&#23384;&#38431;&#21015;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>        <span style="color: #FD971F;">poll_list</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32593;&#32476;&#35774;&#22791;&#36718;&#35810;&#38431;&#21015;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>          *<span style="color: #FD971F;">completion_queue</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#31561;&#24453;&#37322;&#25918;&#38431;&#21015;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span>       <span style="color: #FD971F;">backlog_dev</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;NAPI&#39537;&#21160;&#30340;&#34394;&#25311;&#32593;&#32476;&#35774;&#22791;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dma_chan</span>         *<span style="color: #FD971F;">net_dma</span>;
};
</pre>
</div>
</div>
</div>


<div id="outline-container-org440e72e" class="outline-2">
<h2 id="org440e72e"><span class="section-number-2">5.</span> NAPI</h2>
<div class="outline-text-2" id="text-5">
<p>
NAPI是中断机制和轮询机制的混合，可以有效提高网络处理速度。
</p>

<p>
NAPI的报文输入流程：
</p>


<div id="org714c586" class="figure">
<p><img src="image/itf-input/napi-input.png" alt="napi-input.png" />
</p>
<p><span class="figure-number">Figure 3: </span>NAPI方式输入报文流程</p>
</div>
</div>


<div id="outline-container-org9410cf7" class="outline-3">
<h3 id="org9410cf7"><span class="section-number-3">5.1.</span> 网络设备的中断例程</h3>
<div class="outline-text-3" id="text-5-1">
<p>
以e100为例：
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>e100_intr中断例程</label><pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">irqreturn_t</span> <span style="color: #A6E22E;">e100_intr</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">irq</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">dev_id</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">netdev</span> = dev_id;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nic</span> *<span style="color: #FD971F;">nic</span> = netdev_priv(netdev);
        <span style="color: #66D9EF;">u8</span> <span style="color: #FD971F;">stat_ack</span> = readb(&amp;nic-&gt;csr-&gt;scb.stat_ack);
        DPRINTK(INTR, DEBUG, <span style="color: #E6DB74;">"stat_ack = 0x%02X\n"</span>, stat_ack);
        <span style="color: #F92672;">if</span>(stat_ack == stat_ack_not_ours ||     <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20013;&#26029;&#26159;&#21542;&#30001;&#32593;&#32476;&#35774;&#22791;&#28608;&#27963;</span><span style="color: #75715E;"> */</span>
           stat_ack == stat_ack_not_present)    <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35774;&#22791;&#25300;&#20986;</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">return</span> IRQ_NONE;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21709;&#24212;&#20013;&#26029;</span><span style="color: #75715E;"> */</span>
        writeb(stat_ack, &amp;nic-&gt;csr-&gt;scb.stat_ack);
        <span style="color: #F92672;">if</span>(stat_ack &amp; stat_ack_rnr)
                nic-&gt;ru_running = RU_SUSPENDED;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32593;&#32476;&#35774;&#22791;&#27491;&#24120;&#65292;&#19988;&#36824;&#26410;&#36718;&#35810;&#25509;&#25910;&#25253;&#25991;</span>
        <span style="color: #F92672;">if</span>(likely(netif_rx_schedule_prep(netdev))) {
                e100_disable_irq(nic);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#31105;&#27490;&#35774;&#22791;&#20013;&#26029;</span>
                __netif_rx_schedule(netdev);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#28608;&#27963;&#25253;&#25991;&#25509;&#25910;&#36719;&#20013;&#26029;</span>
        }
        <span style="color: #F92672;">return</span> IRQ_HANDLED;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org75ffe35" class="outline-3">
<h3 id="org75ffe35"><span class="section-number-3">5.2.</span> 网络输入软中断</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">net_rx_action</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softirq_action</span> *<span style="color: #FD971F;">h</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softnet_data</span> *<span style="color: #FD971F;">queue</span> = &amp;__get_cpu_var(softnet_data);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;CPU softnet_data</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">start_time</span> = jiffies;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">budget</span> = netdev_budget; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25253;&#25991;&#25509;&#25910;&#37197;&#39069;</span>
        <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">have</span>;
        local_irq_disable();
        <span style="color: #F92672;">while</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>list_empty(&amp;queue-&gt;poll_list)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36718;&#35810;&#38431;&#21015;&#30340;&#32593;&#32476;&#35774;&#22791;</span>
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">dev</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35835;&#21462;&#37197;&#39069;&#29992;&#23613;&#65292;&#25110;&#32773;&#22788;&#29702;&#26102;&#38388;&#22823;&#20110;1ms&#65292;&#21017;&#36864;&#20986;&#22788;&#29702;</span>
                <span style="color: #F92672;">if</span> (budget &lt;= 0 || jiffies - start_time &gt; 1)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">softnet_break</span>;
                local_irq_enable();
                dev = list_entry(queue-&gt;poll_list.next,
                                 <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span>, poll_list);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21462;&#20986;&#32593;&#32476;&#35774;&#22791;</span>
                have = netpoll_poll_lock(dev);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#35774;&#22791;&#26412;&#27425;&#37197;&#39069;&#29992;&#23613;&#25110;&#32773;&#36718;&#35810;&#21518;&#36824;&#26377;&#25253;&#25991;&#26410;&#35835;&#21462;</span>
                <span style="color: #F92672;">if</span> (dev-&gt;quota &lt;= 0 || dev-&gt;poll(dev, &amp;budget)) {
                        netpoll_poll_unlock(have);
                        local_irq_disable();
                        list_move_tail(&amp;dev-&gt;poll_list, &amp;queue-&gt;poll_list);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#22791;&#31227;&#21160;&#21040;&#38431;&#23614;</span>
                        <span style="color: #F92672;">if</span> (dev-&gt;quota &lt; 0)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#37325;&#26032;&#35774;&#32622;&#35774;&#22791;&#37197;&#39069;</span>
                                dev-&gt;quota += dev-&gt;weight;
                        <span style="color: #F92672;">else</span>
                                dev-&gt;quota = dev-&gt;weight;
                } <span style="color: #F92672;">else</span> {
                        netpoll_poll_unlock(have);
                        dev_put(dev);
                        local_irq_disable();
                }
        }
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">if</span> (net_dma_client) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dma_chan</span> *<span style="color: #FD971F;">chan</span>;
                rcu_read_lock();
                list_for_each_entry_rcu(chan, &amp;net_dma_client-&gt;channels, client_node)
                        dma_async_memcpy_issue_pending(chan);
                rcu_read_unlock();
        }
        local_irq_enable();
        <span style="color: #F92672;">return</span>;
<span style="color: #AE81FF;">softnet_break</span>:
        __get_cpu_var(netdev_rx_stat).time_squeeze++;
        __raise_softirq_irqoff(NET_RX_SOFTIRQ);
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge844bd6" class="outline-3">
<h3 id="orge844bd6"><span class="section-number-3">5.3.</span> 轮询处理报文</h3>
<div class="outline-text-3" id="text-5-3">
<p>
e100网络设备驱动通过 e100_poll() 函数处理。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>e100_poll()</label><pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">e100_poll</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">netdev</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">budget</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nic</span> *<span style="color: #FD971F;">nic</span> = netdev_priv(netdev);
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">work_to_do</span> = min(netdev-&gt;quota, *budget);
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">work_done</span> = 0;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">tx_cleaned</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#32593;&#32476;&#35774;&#22791;&#35835;&#21462;&#25509;&#25910;&#21040;&#30340;&#25253;&#25991;&#65292;&#24182;&#36890;&#36807; netif_receive_skb() &#36755;&#20837;&#21040;&#19978;&#23618;&#21327;&#35758;&#20013;</span>
        e100_rx_clean(nic, &amp;work_done, work_to_do);
        tx_cleaned = e100_tx_clean(nic); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#37322;&#25918;&#24050;&#32463;&#21457;&#36865;&#30340;&#25253;&#25991;</span>

        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#24453;&#36755;&#20986;&#25253;&#25991;&#21644;&#36755;&#20837;&#25253;&#25991;&#37117;&#22788;&#29702;&#23436;&#25104;&#25110;&#32773;&#35774;&#22791;&#26410;&#28608;&#27963;&#65292;&#36864;&#20986;&#36718;&#35810;&#27169;&#24335;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span>((<span style="color: #E6DB74; font-weight: bold;">!</span>tx_cleaned &amp;&amp; (work_done == 0)) || <span style="color: #E6DB74; font-weight: bold;">!</span>netif_running(netdev)) {
                netif_rx_complete(netdev);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#35774;&#22791;&#20174;&#36718;&#35810;&#38431;&#21015;&#31227;&#38500;</span>
                e100_enable_irq(nic);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#24320;&#20013;&#26029;</span>
                <span style="color: #F92672;">return</span> 0;
        }

        *budget -= work_done; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#24635;&#37197;&#39069;</span>
        netdev-&gt;quota -= work_done;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#32593;&#32476;&#35774;&#22791;&#37197;&#39069;</span>
        <span style="color: #F92672;">return</span> 1;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgc1add95" class="outline-2">
<h2 id="orgc1add95"><span class="section-number-2">6.</span> 非NAPI</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org622a7cf" class="outline-3">
<h3 id="org622a7cf"><span class="section-number-3">6.1.</span> netif_rx()</h3>
<div class="outline-text-3" id="text-6-1">
<p>
netif_rx() 将网络设备接收的报文加入到接口层的缓存队列，以便上层协议处理。
</p>

<p>
NAPI网络驱动不会调用该接口接收报文。
</p>

<div class="org-src-container">
<pre class="src src-c">
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> *      netif_rx        -       post buffer to the network code</span>
<span style="color: #E6DB74;"> *      </span><span style="color: #AE81FF;">@skb</span><span style="color: #E6DB74;">: buffer to post</span>
<span style="color: #E6DB74;"> *      return values:</span>
<span style="color: #E6DB74;"> *      NET_RX_SUCCESS  (&#27809;&#26377;&#21457;&#29983;&#25317;&#22622;)</span>
<span style="color: #E6DB74;"> *      NET_RX_CN_LOW   (&#36731;&#24230;&#25317;&#22622;)</span>
<span style="color: #E6DB74;"> *      NET_RX_CN_MOD   (&#20013;&#24230;&#25317;&#22622;)</span>
<span style="color: #E6DB74;"> *      NET_RX_CN_HIGH  (&#39640;&#24230;&#25317;&#22622;)</span>
<span style="color: #E6DB74;"> *      NET_RX_DROP     (&#25253;&#25991;&#34987;&#20002;&#24323;)</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> */</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">netif_rx</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softnet_data</span> *<span style="color: #FD971F;">queue</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#23558;&#25968;&#25454;&#21253;&#20256;&#36882;&#32473;netpoll&#27169;&#22359;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (netpoll_rx(skb))
                <span style="color: #F92672;">return</span> NET_RX_DROP;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb-&gt;tstamp.off_sec)
                net_timestamp(skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35760;&#24405;&#25509;&#25910;&#26102;&#38388;&#25139;</span>
        local_irq_save(flags);
        queue = &amp;__get_cpu_var(softnet_data); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;cpu&#32531;&#23384;&#38431;&#21015;</span>
        __get_cpu_var(netdev_rx_stat).total++;
        <span style="color: #F92672;">if</span> (queue-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#38431;&#21015;&#26410;&#28385;</span>
                <span style="color: #F92672;">if</span> (queue-&gt;input_pkt_queue.qlen) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20837;&#38431;&#21015;&#19981;&#20026;&#31354;</span>
<span style="color: #AE81FF;">enqueue</span>:
                        dev_hold(skb-&gt;dev);
                        __skb_queue_tail(&amp;queue-&gt;input_pkt_queue, skb);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21152;&#20837;&#36755;&#20837;&#38431;&#21015;</span>
                        local_irq_restore(flags);
                        <span style="color: #F92672;">return</span> NET_RX_SUCCESS;
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38431;&#21015;&#20026;&#31354;&#65292;&#35828;&#26126;&#36824;&#26410;&#34987;&#36719;&#20013;&#26029;&#22788;&#29702;&#36807;&#65292;&#23558;backlog_dev&#35774;&#22791;&#21152;&#20837;&#35774;&#22791;&#36718;&#35810;&#38431;&#21015;&#65292;&#24182;&#28608;&#27963;&#25509;&#25910;&#36719;&#20013;&#26029;</span>
                netif_rx_schedule(&amp;queue-&gt;backlog_dev);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">enqueue</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38431;&#21015;&#24050;&#28385;&#65292;&#20002;&#24323;&#25253;&#25991;</span>
        __get_cpu_var(netdev_rx_stat).dropped++;
        local_irq_restore(flags);
        kfree_skb(skb);
        <span style="color: #F92672;">return</span> NET_RX_DROP;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org704a93b" class="outline-3">
<h3 id="org704a93b"><span class="section-number-3">6.2.</span> process_backlog()</h3>
<div class="outline-text-3" id="text-6-2">
<p>
非NAPI方式下， 通过 process_backlog() 函数轮询虚拟网络设备 backlog_dev。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">process_backlog</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">backlog_dev</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">budget</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">work</span> = 0;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">quota</span> = min(backlog_dev-&gt;quota, *budget);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softnet_data</span> *<span style="color: #FD971F;">queue</span> = &amp;__get_cpu_var(softnet_data);
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">start_time</span> = jiffies;
        backlog_dev-&gt;weight = weight_p;
        <span style="color: #F92672;">for</span> (;;) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">dev</span>;
                local_irq_disable();
                skb = __skb_dequeue(&amp;queue-&gt;input_pkt_queue);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#25253;&#25991;</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#20026;&#31354;&#21017;&#22788;&#29702;&#23436;&#25104;</span>
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">job_done</span>;
                local_irq_enable();
                dev = skb-&gt;dev;
                netif_receive_skb(skb);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36882;&#21040;&#19978;&#23618;&#21327;&#35758;</span>
                dev_put(dev);
                work++;
                <span style="color: #F92672;">if</span> (work &gt;= quota || jiffies - start_time &gt; 1) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36798;&#21040;&#37197;&#39069;&#65292;&#25110;&#32773;&#36229;&#26102;</span>
                        <span style="color: #F92672;">break</span>;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#37197;&#39069;</span>
        backlog_dev-&gt;quota -= work;
        *budget -= work;
        <span style="color: #F92672;">return</span> -1;
<span style="color: #AE81FF;">job_done</span>: <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;&#23436;&#25104;&#21518;&#30340;&#25805;&#20316;</span>
        backlog_dev-&gt;quota -= work;
        *budget -= work;
        list_del(&amp;backlog_dev-&gt;poll_list);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#35774;&#22791;&#36718;&#35810;&#38431;&#21015;&#31227;&#38500; backlog_dev</span>
        smp_mb__before_clear_bit();
        netif_poll_enable(backlog_dev);
        local_irq_enable();
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orged4c53b" class="outline-2">
<h2 id="orged4c53b"><span class="section-number-2">7.</span> 接口层数据报文的处理</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org867e845" class="outline-3">
<h3 id="org867e845"><span class="section-number-3">7.1.</span> 报文接收例程</h3>
<div class="outline-text-3" id="text-7-1">
<p>
packet_type结构是网络层输入的接口。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">packet_type</span> {
        <span style="color: #66D9EF;">__be16</span>          <span style="color: #FD971F;">type</span>;   <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#38142;&#36335;&#23618;&#25253;&#25991;&#25215;&#36733;&#32593;&#32476;&#23618;&#25253;&#25991;&#30340;&#21327;&#35758;&#21495;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span>       *<span style="color: #FD971F;">dev</span>;   <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#25351;&#23450;&#25509;&#25910;&#25968;&#25454;&#21253;&#30340;&#35774;&#22791;&#65292;&#20026;NULL&#34920;&#31034;&#25509;&#25910;&#25152;&#26377;&#35774;&#22791;&#30340;&#25968;&#25454;&#21253;</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21327;&#35758;&#25509;&#25910;&#22788;&#29702;&#30340;&#20837;&#21475;&#20989;&#25968;&#12290;</span>
        <span style="color: #66D9EF;">int</span>                     (*<span style="color: #A6E22E;">func</span>) (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *,
                                     <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">packet_type</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;&#23618;&#30340;GSO&#20998;&#27573;&#20989;&#25968;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span>  *(*<span style="color: #A6E22E;">gso_segment</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>,<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">features</span>);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#20256;&#36755;&#23618;GSO&#20998;&#27573;&#21069;&#65292;&#23545;&#20266;&#39318;&#37096;&#35745;&#31639;&#26657;&#39564;&#21644;&#12290;</span>
        <span style="color: #66D9EF;">int</span>                     (*<span style="color: #A6E22E;">gso_send_check</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>);
        <span style="color: #66D9EF;">void</span>            *<span style="color: #FD971F;">af_packet_priv</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23384;&#20648;&#21327;&#35758;&#26063;&#30340;&#31169;&#26377;&#25968;&#25454;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>        <span style="color: #FD971F;">list</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36830;&#25509;&#19981;&#21516;&#21327;&#35758;&#26063;&#25509;&#25910;&#20363;&#31243;&#30340;&#38142;&#34920;&#20803;&#32032;</span>
};

<span style="color: #75715E;">//</span><span style="color: #75715E;">IPv4&#23454;&#20363;&#65306;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">packet_type</span> <span style="color: #FD971F;">ip_packet_type</span> = {
        .type = __constant_htons(ETH_P_IP),
        .func = ip_rcv,
        .gso_send_check = inet_gso_send_check,
        .gso_segment = inet_gso_segment,
};
</pre>
</div>

<p>
大部分的 packet_type 结构的实例通过dev_add_pack()函数添加到 ptype_base 散列表。
</p>

<p>
PF_PACKET协议族，type为 ETH_P_ALL 的packet_type实例则是注册到ptype_all链表。
</p>


<div id="orgb75ff11" class="figure">
<p><img src="image/itf-input/ptype-base.png" alt="ptype-base.png" />
</p>
<p><span class="figure-number">Figure 4: </span>ptype_base散列表</p>
</div>
</div>
</div>

<div id="outline-container-orgc96b809" class="outline-3">
<h3 id="orgc96b809"><span class="section-number-3">7.2.</span> netif_receive_skb()</h3>
<div class="outline-text-3" id="text-7-2">
<p>
netif_receive_skb()将报文输入到上层协议。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">netif_receive_skb</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">packet_type</span> *<span style="color: #FD971F;">ptype</span>, *<span style="color: #FD971F;">pt_prev</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">orig_dev</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ret</span> = NET_RX_DROP;
        <span style="color: #66D9EF;">__be16</span> <span style="color: #FD971F;">type</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#36890;&#36807;NAPI&#26041;&#24335;&#36755;&#20837;&#65292;&#21017;&#20808;&#36755;&#20837;&#32473;netpoll&#27169;&#22359;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (skb-&gt;dev-&gt;poll &amp;&amp; netpoll_rx(skb))
                <span style="color: #F92672;">return</span> NET_RX_DROP;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb-&gt;tstamp.off_sec) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26102;&#38388;&#25139;</span>
                net_timestamp(skb);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb-&gt;input_dev)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#25509;&#25910;&#25253;&#25991;&#30340;&#35774;&#22791;</span>
                skb-&gt;input_dev = skb-&gt;dev;
        orig_dev = skb_bond(skb);  <span style="color: #75715E;">//</span><span style="color: #75715E;">bonding&#20013;&#65292;&#33719;&#21462;&#25253;&#25991;&#30340;&#36755;&#20837;&#35774;&#22791;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>orig_dev)
                <span style="color: #F92672;">return</span> NET_RX_DROP;
        __get_cpu_var(netdev_rx_stat).total++;
        skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data;
        skb-&gt;mac_len = skb-&gt;nh.raw - skb-&gt;mac.raw;
        pt_prev = <span style="color: #AE81FF;">NULL</span>;
        rcu_read_lock();
<span style="color: #F92672;">#ifdef</span> CONFIG_NET_CLS_ACT <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21253;&#20998;&#31867;&#22120;&#30456;&#20851;</span>
        <span style="color: #F92672;">if</span> (skb-&gt;tc_verd &amp; TC_NCLS) {
                skb-&gt;tc_verd = CLR_TC_NCLS(skb-&gt;tc_verd);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">ncls</span>;
        }
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36941;&#21382;packet_all&#38142;&#34920;</span>
        list_for_each_entry_rcu(ptype, &amp;ptype_all, list) {
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) {
                        <span style="color: #F92672;">if</span> (pt_prev)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20837;&#25253;&#25991;&#21040;&#23545;&#24212;&#30340;&#21327;&#35758;&#26063;</span>
                                ret = deliver_skb(skb, pt_prev, orig_dev);
                        pt_prev = ptype;
                }
        }
<span style="color: #F92672;">#ifdef</span> CONFIG_NET_CLS_ACT
        <span style="color: #F92672;">if</span> (pt_prev) {
                ret = deliver_skb(skb, pt_prev, orig_dev);
                pt_prev = <span style="color: #AE81FF;">NULL</span>; <span style="color: #75715E;">/* </span><span style="color: #75715E;">noone else should process this after</span><span style="color: #75715E;">*/</span>
        } <span style="color: #F92672;">else</span> {
                skb-&gt;tc_verd = SET_TC_OK2MUNGE(skb-&gt;tc_verd);
        }
        ret = ing_filter(skb);
        <span style="color: #F92672;">if</span> (ret == TC_ACT_SHOT || (ret == TC_ACT_STOLEN)) {
                kfree_skb(skb);
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        }
        skb-&gt;tc_verd = 0;
<span style="color: #AE81FF;">ncls</span>:
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;bridge&#65292; &#23558;&#25253;&#25991;&#36755;&#20837;&#32473;bridge</span>
        <span style="color: #F92672;">if</span> (handle_bridge(&amp;skb, &amp;pt_prev, &amp;ret, orig_dev))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        type = skb-&gt;protocol;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36941;&#21382;ptype_base&#25955;&#21015;&#34920;</span>
        list_for_each_entry_rcu(ptype, &amp;ptype_base[ntohs(type)&amp;15], list) {
                <span style="color: #F92672;">if</span> (ptype-&gt;type == type &amp;&amp;
                    (<span style="color: #E6DB74; font-weight: bold;">!</span>ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev)) {
                        <span style="color: #F92672;">if</span> (pt_prev)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20837;&#25253;&#25991;&#21040;&#23545;&#24212;&#30340;&#21327;&#35758;&#26063;</span>
                                ret = deliver_skb(skb, pt_prev, orig_dev);
                        pt_prev = ptype;
                }
        }
        <span style="color: #F92672;">if</span> (pt_prev) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20837;&#25253;&#25991;&#21040;&#23545;&#24212;&#30340;&#21327;&#35758;&#26063;</span>
                ret = pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);
        } <span style="color: #F92672;">else</span> {
                kfree_skb(skb);
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Jamal, now you will not able to escape explaining</span>
<span style="color: #75715E;">                 * me how you were going to use this. :-)</span>
<span style="color: #75715E;">                 */</span>
                ret = NET_RX_DROP;
        }
<span style="color: #AE81FF;">out</span>:
        rcu_read_unlock();
        <span style="color: #F92672;">return</span> ret;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org19bd205" class="outline-3">
<h3 id="org19bd205"><span class="section-number-3">7.3.</span> dev_queue_xmit_nit()</h3>
<div class="outline-text-3" id="text-7-3">
<p>
通过 <i>socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))</i> 创建的原始套接字，既可以接收外部输入的数据包，也可以接收本地输出的数据包。
</p>

<p>
dev_queue_xmit_nit() 用于结婚搜本地输出的数据包，链路层输出过程中会调用该函数。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #75715E;">dev &#36755;&#20986;&#25968;&#25454;&#21253;&#30340;&#32593;&#32476;&#35774;&#22791;</span>
<span style="color: #75715E;">//</span><span style="color: #75715E;">skb &#24453;&#36755;&#20986;&#25968;&#25454;&#21253;</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">dev_queue_xmit_nit</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">dev</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">packet_type</span> *<span style="color: #FD971F;">ptype</span>;
        net_timestamp(skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35760;&#24405;&#26102;&#38388;&#25139;</span>
        rcu_read_lock();
        list_for_each_entry_rcu(ptype, &amp;ptype_all, list) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36941;&#21382;ptype_all</span>
                <span style="color: #F92672;">if</span> ((ptype-&gt;dev == dev || <span style="color: #E6DB74; font-weight: bold;">!</span>ptype-&gt;dev) &amp;&amp;
                    (ptype-&gt;af_packet_priv == <span style="color: #AE81FF;">NULL</span> ||
                     (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *)ptype-&gt;af_packet_priv != skb-&gt;sk)) {
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#39069;&#22806;&#36755;&#20837;&#21040;RAW&#65292;&#38656;&#35201;&#20811;&#38534;skb</span>
                        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb2</span>= skb_clone(skb, GFP_ATOMIC);
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb2)
                                <span style="color: #F92672;">break</span>;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;&#25968;&#25454;&#21253;&#30340;&#26377;&#25928;&#24615;</span>
                        skb2-&gt;mac.raw = skb2-&gt;data;
                        <span style="color: #F92672;">if</span> (skb2-&gt;nh.raw &lt; skb2-&gt;data ||
                            skb2-&gt;nh.raw &gt; skb2-&gt;tail) {
                                <span style="color: #F92672;">if</span> (net_ratelimit())
                                        printk(KERN_CRIT <span style="color: #E6DB74;">"protocol %04x is "</span>
                                               <span style="color: #E6DB74;">"buggy, dev %s\n"</span>,
                                               skb2-&gt;protocol, dev-&gt;name);
                                skb2-&gt;nh.raw = skb2-&gt;data;
                        }
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20837;&#21040;RAW&#22871;&#25509;&#23383;</span>
                        skb2-&gt;h.raw = skb2-&gt;nh.raw;
                        skb2-&gt;pkt_type = PACKET_OUTGOING;
                        ptype-&gt;func(skb2, skb-&gt;dev, ptype, skb-&gt;dev);
                }
        }
        rcu_read_unlock();
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgf32b7f8" class="outline-2">
<h2 id="orgf32b7f8"><span class="section-number-2">8.</span> CPU状态变化时的处理</h2>
<div class="outline-text-2" id="text-8">
<p>
CPU有各自的softnet_data队列，当CPU状态变为 CPU_DEAD 时，需要将队列中报文交给其他CPU处理。
</p>

<p>
dev_cpu_callback()函数用来处理cpu状态变化， 通过hotcpu_notifier()注册。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">dev_cpu_callback</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">notifier_block</span> *<span style="color: #FD971F;">nfb</span>,<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21709;&#24212;cpu&#29366;&#24577;&#21464;&#21270;&#30340;&#20449;&#24687;&#22359;</span>
                            <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">action</span>,  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29366;&#24577;&#21464;&#21270;cpu&#30340;&#24403;&#21069;&#29366;&#24577;</span>
                            <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">ocpu</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29366;&#24577;&#21464;&#21270;&#30340;cpu</span>
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> **<span style="color: #FD971F;">list_skb</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> **<span style="color: #FD971F;">list_net</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cpu</span>, <span style="color: #FD971F;">oldcpu</span> = (<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>)ocpu;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softnet_data</span> *<span style="color: #FD971F;">sd</span>, *<span style="color: #FD971F;">oldsd</span>;
        <span style="color: #F92672;">if</span> (action != CPU_DEAD) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20043;&#22788;&#29702;CPU_DEAD&#29366;&#24577;</span>
                <span style="color: #F92672;">return</span> NOTIFY_OK;
        local_irq_disable();
        cpu = smp_processor_id();
        sd = &amp;per_cpu(softnet_data, cpu); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;cpu&#30340;&#38431;&#21015;</span>
        oldsd = &amp;per_cpu(softnet_data, oldcpu); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19979;&#32447;cpu&#30340;&#38431;&#21015;</span>

        list_skb = &amp;sd-&gt;completion_queue;
        <span style="color: #F92672;">while</span> (*list_skb)
                list_skb = &amp;(*list_skb)-&gt;next; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;completion_queue&#30340;&#32467;&#26463;&#20301;&#32622;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#23558;&#19979;&#32447;cpu&#30340;completion_queue &#31227;&#21160;&#33267;&#24403;&#21069;cpu</span><span style="color: #75715E;">*/</span>
        *list_skb = oldsd-&gt;completion_queue;
        oldsd-&gt;completion_queue = <span style="color: #AE81FF;">NULL</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#33719;&#21462;output_queue&#30340;&#32467;&#26463;&#20301;&#32622;</span><span style="color: #75715E;"> */</span>
        list_net = &amp;sd-&gt;output_queue;
        <span style="color: #F92672;">while</span> (*list_net)
                list_net = &amp;(*list_net)-&gt;next_sched;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#36861;&#21152;&#21040;&#24403;&#21069;cpu&#30340;output_queue</span><span style="color: #75715E;"> */</span>
        *list_net = oldsd-&gt;output_queue;
        oldsd-&gt;output_queue = <span style="color: #AE81FF;">NULL</span>;

        raise_softirq_irqoff(NET_TX_SOFTIRQ);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#28608;&#27963;&#36755;&#20986;&#36719;&#20013;&#26029;</span>
        local_irq_enable();

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22788;&#29702;&#19979;&#32447;CPU&#30340; input_pkt_queue</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">while</span> ((skb = __skb_dequeue(&amp;oldsd-&gt;input_pkt_queue)))
                netif_rx(skb);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20837;&#21040;&#19978;&#23618;&#21327;&#35758;</span>
        <span style="color: #F92672;">return</span> NOTIFY_OK;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgfa5c962" class="outline-2">
<h2 id="orgfa5c962"><span class="section-number-2">9.</span> netpoll</h2>
<div class="outline-text-2" id="text-9">
<p>
netconsole 通过netpoll框架将信息通过UDP发送到监控主机。
</p>
</div>

<div id="outline-container-org649f695" class="outline-3">
<h3 id="org649f695"><span class="section-number-3">9.1.</span> netpoll结构</h3>
<div class="outline-text-3" id="text-9-1">
<p>
netpoll实例分为 能接收数据包 和 不能接收数据包 两种类型。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">dev</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32465;&#23450;&#30340;&#35774;&#22791;</span>
        <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">dev_name</span>[IFNAMSIZ]; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#22791;&#21517;</span>
        <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">name</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">netpoll&#23454;&#20363;&#21517;&#31216;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25253;&#25991;&#25509;&#25910;&#22788;&#29702;&#20363;&#31243;&#12290;</span>
        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">rx_hook</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> *, <span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">char</span> *, <span style="color: #66D9EF;">int</span>);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26412;&#26426;ip&#21644;&#36828;&#31471;ip</span>
        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">local_ip</span>, <span style="color: #FD971F;">remote_ip</span>;
        <span style="color: #66D9EF;">u16</span> <span style="color: #FD971F;">local_port</span>, <span style="color: #FD971F;">remote_port</span>;
        <span style="color: #66D9EF;">u8</span> <span style="color: #FD971F;">local_mac</span>[ETH_ALEN], <span style="color: #FD971F;">remote_mac</span>[ETH_ALEN];
};
</pre>
</div>

<p>
如果支持netpoll，则对应网络设备的net_device实例必须实现 npinfo 成员。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll_info</span> {
        <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">refcnt</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24341;&#29992;&#35745;&#25968;</span>
        <span style="color: #66D9EF;">spinlock_t</span> <span style="color: #FD971F;">poll_lock</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32593;&#32476;&#35774;&#22791;poll&#25509;&#21475;&#30340;&#24182;&#21457;&#35775;&#38382;&#38145;</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">poll_owner</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27491;&#20174;&#32593;&#32476;&#35774;&#22791;&#35835;&#21462;&#25968;&#25454;&#21253;&#30340;cpu</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">rx_flags</span>;
        <span style="color: #66D9EF;">spinlock_t</span> <span style="color: #FD971F;">rx_lock</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">netpoll&#36755;&#20837;&#25805;&#20316;&#30340;&#24182;&#21457;&#35775;&#38382;&#38145;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> *<span style="color: #FD971F;">rx_np</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25551;&#36848;netpoll&#30340;&#25509;&#25910;&#20449;&#24687;&#21644;&#21457;&#36865;&#20449;&#24687;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff_head</span> <span style="color: #FD971F;">arp_tx</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23384;&#20648;&#25509;&#25910;&#30340;arp&#25253;&#25991;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff_head</span> <span style="color: #FD971F;">txq</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25253;&#25991;&#32531;&#23384;&#38431;&#21015;&#65288;&#20256;&#36755;&#22833;&#36133;&#25110;&#32773;&#35774;&#22791;&#32321;&#24537;&#65289;</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">delayed_work</span> <span style="color: #FD971F;">tx_work</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#36755;&#20986;txq&#30340;&#24037;&#20316;&#38431;&#21015;</span>
};
</pre>
</div>

<p>
如果要使用netpoll，还需要实现网络设备的 poll_controller 函数，该函数用来模拟网络设备发生中断，进行中断处理。 例如 e100_netpool。
</p>
</div>
</div>

<div id="outline-container-org6412641" class="outline-3">
<h3 id="org6412641"><span class="section-number-3">9.2.</span> netpoll实例的注册</h3>
<div class="outline-text-3" id="text-9-2">
<p>
netpoll_setup()函数用来注册netpoll实例。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">netpoll_setup</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> *<span style="color: #FD971F;">np</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">ndev</span> = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">in_device</span> *<span style="color: #FD971F;">in_dev</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll_info</span> *<span style="color: #FD971F;">npinfo</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;

        <span style="color: #F92672;">if</span> (np-&gt;dev_name)
                ndev = dev_get_by_name(np-&gt;dev_name);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>ndev) {
                printk(KERN_ERR <span style="color: #E6DB74;">"%s: %s doesn't exist, aborting.\n"</span>,
                       np-&gt;name, np-&gt;dev_name);
                <span style="color: #F92672;">return</span> -ENODEV;
        }

        np-&gt;dev = ndev;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#32593;&#32476;&#35774;&#22791;&#21644;netpoll&#23454;&#20363;&#20851;&#32852;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>ndev-&gt;npinfo) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#32593;&#32476;&#35774;&#22791;&#30340;netpoll&#20449;&#24687;&#22359;&#19981;&#23384;&#21017;&#65292;&#21017;&#38656;&#21019;&#24314;</span>
                npinfo = kmalloc(<span style="color: #F92672;">sizeof</span>(*npinfo), GFP_KERNEL);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#24037;&#20316;</span>
                npinfo-&gt;rx_flags = 0;
                npinfo-&gt;rx_np = <span style="color: #AE81FF;">NULL</span>;
                spin_lock_init(&amp;npinfo-&gt;poll_lock);
                npinfo-&gt;poll_owner = -1;
                spin_lock_init(&amp;npinfo-&gt;rx_lock);
                skb_queue_head_init(&amp;npinfo-&gt;arp_tx);
                skb_queue_head_init(&amp;npinfo-&gt;txq);
                INIT_DELAYED_WORK(&amp;npinfo-&gt;tx_work, queue_process);
                atomic_set(&amp;npinfo-&gt;refcnt, 1);
        } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#23384;&#22312;&#65292;&#30452;&#25509;&#24341;&#29992;</span>
                npinfo = ndev-&gt;npinfo;
                atomic_inc(&amp;npinfo-&gt;refcnt);
        }
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>ndev-&gt;poll_controller) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24517;&#39035;&#23454;&#29616;&#32593;&#32476;&#35774;&#22791;&#30340; poll_controller&#25509;&#21475;</span>
                printk(KERN_ERR <span style="color: #E6DB74;">"%s: %s doesn't support polling, aborting.\n"</span>,
                       np-&gt;name, np-&gt;dev_name);
                err = -ENOTSUPP;
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">release</span>;
        }
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>netif_running(ndev)) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#22791;&#36824;&#26410;&#21551;&#21160;</span>
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">atmost</span>, <span style="color: #FD971F;">atleast</span>;
                printk(KERN_INFO <span style="color: #E6DB74;">"%s: device %s not up yet, forcing it\n"</span>,
                       np-&gt;name, np-&gt;dev_name);
                rtnl_lock();
                err = dev_open(ndev);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21551;&#21160;&#35774;&#22791;</span>
                rtnl_unlock();

                atleast = jiffies + HZ/10;
                atmost = jiffies + 4*HZ;
                <span style="color: #F92672;">while</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>netif_carrier_ok(ndev)) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#22791;&#26159;&#21542;&#33021;&#20256;&#36755;&#25968;&#25454;&#21253;</span>
                        <span style="color: #F92672;">if</span> (time_after(jiffies, atmost)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#31561;&#24453;4s</span>
                                printk(KERN_NOTICE
                                       <span style="color: #E6DB74;">"%s: timeout waiting for carrier\n"</span>,
                                       np-&gt;name);
                                <span style="color: #F92672;">break</span>;
                        }
                        cond_resched();
                }
                <span style="color: #F92672;">if</span> (time_before(jiffies, atleast)) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;0.1s&#20869;&#23601;&#21457;&#29616;&#35774;&#22791;&#21487;&#20197;&#20256;&#36882;&#25968;&#25454;&#21253;&#65292;&#21017;&#19981;&#21487;&#20449;&#65292;&#38656;&#35201;&#31561;&#24453;4s</span>
                        printk(KERN_NOTICE <span style="color: #E6DB74;">"%s: carrier detect appears"</span>
                               <span style="color: #E6DB74;">" untrustworthy, waiting 4 seconds\n"</span>,
                               np-&gt;name);
                        msleep(4000);
                }
        }
        <span style="color: #F92672;">if</span> (is_zero_ether_addr(np-&gt;local_mac) &amp;&amp; ndev-&gt;dev_addr)
                memcpy(np-&gt;local_mac, ndev-&gt;dev_addr, 6);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#32593;&#32476;&#35774;&#22791;&#33719;&#21462;mac&#22320;&#22336;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>np-&gt;local_ip) {
                rcu_read_lock();
                in_dev = __in_dev_get_rcu(ndev);
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>in_dev || <span style="color: #E6DB74; font-weight: bold;">!</span>in_dev-&gt;ifa_list) {
                        rcu_read_unlock();
                        printk(KERN_ERR <span style="color: #E6DB74;">"%s: no IP address for %s, aborting\n"</span>,
                               np-&gt;name, np-&gt;dev_name);
                        err = -EDESTADDRREQ;
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">release</span>;
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#35774;&#22791;&#33719;&#21462;IP&#22320;&#22336;</span>
                np-&gt;local_ip = ntohl(in_dev-&gt;ifa_list-&gt;ifa_local);
                rcu_read_unlock();
                printk(KERN_INFO <span style="color: #E6DB74;">"%s: local IP %d.%d.%d.%d\n"</span>,
                       np-&gt;name, HIPQUAD(np-&gt;local_ip));
        }
        <span style="color: #F92672;">if</span> (np-&gt;rx_hook) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#23454;&#29616;&#20102;rx_hook&#25509;&#21475;</span>
                spin_lock_irqsave(&amp;npinfo-&gt;rx_lock, flags);
                npinfo-&gt;rx_flags |= NETPOLL_RX_ENABLED; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#26631;&#24535;&#65292; &#34920;&#31034;&#21487;&#20197;&#25509;&#25910;&#25968;&#25454;&#21253;</span>
                npinfo-&gt;rx_np = np;
                spin_unlock_irqrestore(&amp;npinfo-&gt;rx_lock, flags);
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20026;&#21457;&#36865;UDP&#21644;ARP&#24212;&#31572;&#25253;&#25991;&#65292;&#21019;&#24314;SKB&#32531;&#23384;&#21306;</span><span style="color: #75715E;"> */</span>
        refill_skbs();
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#32465;&#23450;netpoll&#20449;&#24687;&#22359;&#21040;&#35774;&#22791;</span><span style="color: #75715E;"> */</span>
        ndev-&gt;npinfo = npinfo;
        synchronize_rcu();
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org708bcef" class="outline-3">
<h3 id="org708bcef"><span class="section-number-3">9.3.</span> netpoll的输入</h3>
<div class="outline-text-3" id="text-9-3">
<p>
netpoll_rx() 是netpoll输入的入口函数，由 netif_rx() 和 netif_receive_skb() 函数调用。netpoll的输入之处理两种数据报，如果是ARP报文，则添加到 arp_tx 队列中，等待模拟中断处理; 如果是IP数据报，则输入到netpoll 实例：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">__netpoll_rx</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">proto</span>, <span style="color: #FD971F;">len</span>, <span style="color: #FD971F;">ulen</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span> *<span style="color: #FD971F;">uh</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll_info</span> *<span style="color: #FD971F;">npi</span> = skb-&gt;dev-&gt;npinfo;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> *<span style="color: #FD971F;">np</span> = npi-&gt;rx_np;

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>np)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (skb-&gt;dev-&gt;type != ARPHRD_ETHER)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">ARP&#25253;&#25991;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (skb-&gt;protocol == __constant_htons(ETH_P_ARP) &amp;&amp;
            atomic_read(&amp;trapped)) {
                skb_queue_tail(&amp;npi-&gt;arp_tx, skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20837;&#21040;arp_tx&#38431;&#21015;</span>
                <span style="color: #F92672;">return</span> 1;
        }

        proto = ntohs(eth_hdr(skb)-&gt;h_proto);
        <span style="color: #F92672;">if</span> (proto != ETH_P_IP)<span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;IP&#25968;&#25454;&#25253;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (skb-&gt;pkt_type == PACKET_OTHERHOST) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;&#26412;&#22320;&#30340;&#25968;&#25454;&#25253;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (skb_shared(skb)) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25253;&#25991;&#34987;&#20849;&#20139;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        iph = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *)skb-&gt;data;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_may_pull(skb, <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span>)))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (iph-&gt;ihl &lt; 5 || iph-&gt;version != 4)<span style="color: #75715E;">//</span><span style="color: #75715E;">IP&#25968;&#25454;&#25253;&#26080;&#25928;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_may_pull(skb, iph-&gt;ihl*4))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (ip_fast_csum((<span style="color: #66D9EF;">u8</span> *)iph, iph-&gt;ihl) != 0)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        len = ntohs(iph-&gt;tot_len);
        <span style="color: #F92672;">if</span> (skb-&gt;len &lt; len || len &lt; iph-&gt;ihl*4)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (iph-&gt;protocol != IPPROTO_UDP) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;UDP&#25968;&#25454;&#25253;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        len -= iph-&gt;ihl*4;
        uh = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span> *)(((<span style="color: #66D9EF;">char</span> *)iph) + iph-&gt;ihl*4);
        ulen = ntohs(uh-&gt;len);
        <span style="color: #F92672;">if</span> (ulen != len)
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (checksum_udp(skb, uh, ulen, iph-&gt;saddr, iph-&gt;daddr))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (np-&gt;local_ip &amp;&amp; np-&gt;local_ip != ntohl(iph-&gt;daddr))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (np-&gt;remote_ip &amp;&amp; np-&gt;remote_ip != ntohl(iph-&gt;saddr))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        <span style="color: #F92672;">if</span> (np-&gt;local_port &amp;&amp; np-&gt;local_port != ntohs(uh-&gt;dest))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
        np-&gt;rx_hook(np, ntohs(uh-&gt;source),  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20837;&#21040;netpoll&#23454;&#20363;</span>
                    (<span style="color: #66D9EF;">char</span> *)(uh+1),
                    ulen - <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span>));
        kfree_skb(skb);
        <span style="color: #F92672;">return</span> 1;
<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">if</span> (atomic_read(&amp;trapped)) {
                kfree_skb(skb);
                <span style="color: #F92672;">return</span> 1;
        }
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>

<div id="outline-container-org0b756af" class="outline-4">
<h4 id="org0b756af"><span class="section-number-4">9.3.1.</span> trap状态</h4>
<div class="outline-text-4" id="text-9-3-1">
<p>
netpoll中有一个trapped全局变量，用以标识trap状态，通过netpoll_set_trap()设置当前的trap状态。
</p>

<p>
trap取值：
</p>
<ul class="org-ul">
<li>非0  所有处理的数据包，不满足条件直接丢弃，不传递到协议栈。</li>
<li>0    只处理满足条件的数据包，不满足的传递给协议栈。</li>
</ul>
</div>
</div>

<div id="outline-container-orga0aae3c" class="outline-4">
<h4 id="orga0aae3c"><span class="section-number-4">9.3.2.</span> netpoll_poll()</h4>
<div class="outline-text-4" id="text-9-3-2">
<p>
通过netpoll_poll()函数，模拟触发网络设备中断，然后利用其他CPU协助进行数据包轮询处理。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">netpoll_poll</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> *<span style="color: #FD971F;">np</span>)
{
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>np-&gt;dev || <span style="color: #E6DB74; font-weight: bold;">!</span>netif_running(np-&gt;dev) || <span style="color: #E6DB74; font-weight: bold;">!</span>np-&gt;dev-&gt;poll_controller)
                <span style="color: #F92672;">return</span>;
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#35843;&#29992;poll_controller&#25509;&#21475;&#65292;&#27169;&#25311;&#32593;&#32476;&#35774;&#22791;&#36755;&#20837;&#20013;&#26029;</span><span style="color: #75715E;"> */</span>
        np-&gt;dev-&gt;poll_controller(np-&gt;dev);
        <span style="color: #F92672;">if</span> (np-&gt;dev-&gt;poll)
                poll_napi(np);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36827;&#34892;&#36718;&#35810;&#35835;&#21462;&#25253;&#25991;</span>
        service_arp_queue(np-&gt;dev-&gt;npinfo); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;arp_tx&#38431;&#21015;&#30340;ARP&#25253;&#25991;</span>
        zap_completion_queue(); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#37322;&#25918;&#23436;&#25104;&#21457;&#36865;&#30340;&#25968;&#25454;&#21253;</span>
}

<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">poll_napi</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> *<span style="color: #FD971F;">np</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll_info</span> *<span style="color: #FD971F;">npinfo</span> = np-&gt;dev-&gt;npinfo;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">budget</span> = 16;
        <span style="color: #F92672;">if</span> (test_bit(__LINK_STATE_RX_SCHED, &amp;np-&gt;dev-&gt;state) &amp;&amp;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#20004;&#27425;&#25968;&#25454;&#21253;&#36755;&#20837;&#36719;&#20013;&#26029;&#22788;&#29702;&#30340;&#38388;&#38553;</span>
            npinfo-&gt;poll_owner != smp_processor_id() &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;CPU&#19981;&#26159;&#19978;&#27425;&#22788;&#29702;&#36719;&#20013;&#26029;&#30340;CPU</span>
            spin_trylock(&amp;npinfo-&gt;poll_lock)) {
                npinfo-&gt;rx_flags |= NETPOLL_RX_DROP;
                atomic_inc(&amp;trapped);
                np-&gt;dev-&gt;poll(np-&gt;dev, &amp;budget); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#25509;&#21475;&#30340;pool&#25509;&#21475;&#36718;&#35810;&#25509;&#25910;&#25253;&#25991;</span>
                atomic_dec(&amp;trapped);
                npinfo-&gt;rx_flags &amp;= ~NETPOLL_RX_DROP;
                spin_unlock(&amp;npinfo-&gt;poll_lock);
        }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8130198" class="outline-4">
<h4 id="org8130198"><span class="section-number-4">9.3.3.</span> ARP报文处理</h4>
<div class="outline-text-4" id="text-9-3-3">
<p>
service_arp_queue() 会轮询获取并处理 arp_tx 队列的ARP报文。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">service_arp_queue</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll_info</span> *<span style="color: #FD971F;">npi</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
        skb = skb_dequeue(&amp;npi-&gt;arp_tx);
        <span style="color: #F92672;">while</span> (skb != <span style="color: #AE81FF;">NULL</span>) {
                arp_reply(skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;ARP&#25253;&#25991;</span>
                skb = skb_dequeue(&amp;npi-&gt;arp_tx);
        }
}

<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">arp_reply</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll_info</span> *<span style="color: #FD971F;">npinfo</span> = skb-&gt;dev-&gt;npinfo;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">arphdr</span> *<span style="color: #FD971F;">arp</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">arp_ptr</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">size</span>, <span style="color: #FD971F;">type</span> = ARPOP_REPLY, <span style="color: #FD971F;">ptype</span> = ETH_P_ARP;
        <span style="color: #66D9EF;">__be32</span> <span style="color: #FD971F;">sip</span>, <span style="color: #FD971F;">tip</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">sha</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">send_skb</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> *<span style="color: #FD971F;">np</span> = <span style="color: #AE81FF;">NULL</span>;
        <span style="color: #F92672;">if</span> (npinfo-&gt;rx_np &amp;&amp; npinfo-&gt;rx_np-&gt;dev == skb-&gt;dev)
                np = npinfo-&gt;rx_np;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>np)
                <span style="color: #F92672;">return</span>;
        <span style="color: #F92672;">if</span> (skb-&gt;dev-&gt;flags &amp; IFF_NOARP) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#22791;&#19981;&#25903;&#25345;ARP</span>
                <span style="color: #F92672;">return</span>;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_may_pull(skb, (<span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">arphdr</span>) +
                                 (2 * skb-&gt;dev-&gt;addr_len) +
                                 (2 * <span style="color: #F92672;">sizeof</span>(u32)))))  <span style="color: #75715E;">//</span><span style="color: #75715E;">ARP&#25253;&#25991;&#26159;&#21542;&#26377;&#25928;</span>
                <span style="color: #F92672;">return</span>;
        skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data;
        arp = skb-&gt;nh.arph;
        <span style="color: #F92672;">if</span> ((arp-&gt;ar_hrd != htons(ARPHRD_ETHER) &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38750;&#20197;&#22826;&#32593;&#19981;&#22788;&#29702;</span>
             arp-&gt;ar_hrd != htons(ARPHRD_IEEE802)) ||
            arp-&gt;ar_pro != htons(ETH_P_IP) ||
            arp-&gt;ar_op != htons(ARPOP_REQUEST))
                <span style="color: #F92672;">return</span>;

        arp_ptr = (<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> *)(arp+1);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#33719;&#21462;&#21457;&#36865;&#26041;&#30340;&#30828;&#20214;&#22320;&#22336;&#21644;IP&#22320;&#22336;</span><span style="color: #75715E;"> */</span>
        sha = arp_ptr;
        arp_ptr += skb-&gt;dev-&gt;addr_len;
        memcpy(&amp;sip, arp_ptr, 4);
        arp_ptr += 4;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#29992;&#20110;&#26816;&#27979;&#30446;&#30340;&#22320;&#22336;</span><span style="color: #75715E;"> */</span>
        arp_ptr += skb-&gt;dev-&gt;addr_len;
        memcpy(&amp;tip, arp_ptr, 4);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#38750;&#26412;&#26426;&#22320;&#22336; &#38750;&#22238;&#29615;&#22320;&#22336; &#38750;&#32452;&#25773;&#22320;&#22336;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (tip != htonl(np-&gt;local_ip) || LOOPBACK(tip) || MULTICAST(tip))
                <span style="color: #F92672;">return</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;ARP&#35831;&#27714;&#20998;&#37197;ARP&#24212;&#31572;&#25253;&#25991;</span>
        size = <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">arphdr</span>) + 2 * (skb-&gt;dev-&gt;addr_len + 4);
        send_skb = find_skb(np, size + LL_RESERVED_SPACE(np-&gt;dev),
                            LL_RESERVED_SPACE(np-&gt;dev));
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22635;&#20805;ARP&#25253;&#25991;</span>
        send_skb-&gt;nh.raw = send_skb-&gt;data;
        arp = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">arphdr</span> *) skb_put(send_skb, size);
        send_skb-&gt;dev = skb-&gt;dev;
        send_skb-&gt;protocol = htons(ETH_P_ARP);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22635;&#20805;&#20197;&#22826;&#32593;&#24103;&#39318;&#37096;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (np-&gt;dev-&gt;hard_header &amp;&amp;
            np-&gt;dev-&gt;hard_header(send_skb, skb-&gt;dev, ptype,
                                 sha, np-&gt;local_mac,
                                 send_skb-&gt;len) &lt; 0) {
                kfree_skb(send_skb);
                <span style="color: #F92672;">return</span>;
        }
        arp-&gt;ar_hrd = htons(np-&gt;dev-&gt;type);
        arp-&gt;ar_pro = htons(ETH_P_IP);
        arp-&gt;ar_hln = np-&gt;dev-&gt;addr_len;
        arp-&gt;ar_pln = 4;
        arp-&gt;ar_op = htons(type);

        arp_ptr=(<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> *)(arp + 1);
        memcpy(arp_ptr, np-&gt;dev-&gt;dev_addr, np-&gt;dev-&gt;addr_len);
        arp_ptr += np-&gt;dev-&gt;addr_len;
        memcpy(arp_ptr, &amp;tip, 4);
        arp_ptr += 4;
        memcpy(arp_ptr, sha, np-&gt;dev-&gt;addr_len);
        arp_ptr += np-&gt;dev-&gt;addr_len;
        memcpy(arp_ptr, &amp;sip, 4);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#25253;&#25991;</span>
        netpoll_send_skb(np, send_skb);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org49edf72" class="outline-4">
<h4 id="org49edf72"><span class="section-number-4">9.3.4.</span> ip数据包处理</h4>
<div class="outline-text-4" id="text-9-3-4">
<p>
__netpoll_rx() 中，通过检查后， 调用np-&gt;rx_hook 将报文输入给netpoll实例的接收处理例程。
</p>
</div>
</div>
</div>


<div id="outline-container-org8f7dd7f" class="outline-3">
<h3 id="org8f7dd7f"><span class="section-number-3">9.4.</span> netpoll的输出</h3>
<div class="outline-text-3" id="text-9-4">
</div>
<div id="outline-container-org0fcbc72" class="outline-4">
<h4 id="org0fcbc72"><span class="section-number-4">9.4.1.</span> netpoll_send_udp()</h4>
<div class="outline-text-4" id="text-9-4-1">
<p>
netpoll_send_udp() 是netpoll提供的输出接口，需要输出数据时直接调用即可。
</p>


<div id="org475c4e3" class="figure">
<p><img src="image/itf-input/netpoll-output.png" alt="netpoll-output.png" />
</p>
<p><span class="figure-number">Figure 5: </span>netpoll输出函数的调用关系</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">netpoll_send_udp</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> *<span style="color: #FD971F;">np</span>, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">msg</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">total_len</span>, <span style="color: #FD971F;">eth_len</span>, <span style="color: #FD971F;">ip_len</span>, <span style="color: #FD971F;">udp_len</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span> *<span style="color: #FD971F;">udph</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ethhdr</span> *<span style="color: #FD971F;">eth</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#38271;&#24230;&#65292;&#24182;&#20998;&#37197;SKB</span>
        udp_len = len + <span style="color: #F92672;">sizeof</span>(*udph);
        ip_len = eth_len = udp_len + <span style="color: #F92672;">sizeof</span>(*iph);
        total_len = eth_len + ETH_HLEN + NET_IP_ALIGN;
        skb = find_skb(np, total_len, total_len - len);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#25968;&#25454;</span>
        memcpy(skb-&gt;data, msg, len);
        skb-&gt;len += len;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;UDP&#25968;&#25454;&#21253;&#39318;&#37096;</span>
        skb-&gt;h.uh = udph = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">udphdr</span> *) skb_push(skb, <span style="color: #F92672;">sizeof</span>(*udph));
        udph-&gt;source = htons(np-&gt;local_port);
        udph-&gt;dest = htons(np-&gt;remote_port);
        udph-&gt;len = htons(udp_len);
        udph-&gt;check = 0;
        udph-&gt;check = csum_tcpudp_magic(htonl(np-&gt;local_ip),
                                        htonl(np-&gt;remote_ip),
                                        udp_len, IPPROTO_UDP,
                                        csum_partial((<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> *)udph, udp_len, 0));
        <span style="color: #F92672;">if</span> (udph-&gt;check == 0)
                udph-&gt;check = CSUM_MANGLED_0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24320;&#22987;&#21021;&#22987;&#21270;IP&#25968;&#25454;&#21253;&#39318;&#37096;</span>
        skb-&gt;nh.iph = iph = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *)skb_push(skb, <span style="color: #F92672;">sizeof</span>(*iph));
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">iph-&gt;version = 4; iph-&gt;ihl = 5;</span><span style="color: #75715E;"> */</span>
        put_unaligned(0x45, (<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> *)iph);
        iph-&gt;tos      = 0;
        put_unaligned(htons(ip_len), &amp;(iph-&gt;tot_len));
        iph-&gt;id       = 0;
        iph-&gt;frag_off = 0;
        iph-&gt;ttl      = 64;
        iph-&gt;protocol = IPPROTO_UDP;
        iph-&gt;check    = 0;
        put_unaligned(htonl(np-&gt;local_ip), &amp;(iph-&gt;saddr));
        put_unaligned(htonl(np-&gt;remote_ip), &amp;(iph-&gt;daddr));
        iph-&gt;check    = ip_fast_csum((<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> *)iph, iph-&gt;ihl);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24320;&#22987;&#21021;&#22987;&#21270;&#20197;&#22826;&#32593;&#24103;&#39318;&#37096;</span>
        eth = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ethhdr</span> *) skb_push(skb, ETH_HLEN);
        skb-&gt;mac.raw = skb-&gt;data;
        skb-&gt;protocol = eth-&gt;h_proto = htons(ETH_P_IP);
        memcpy(eth-&gt;h_source, np-&gt;local_mac, 6);
        memcpy(eth-&gt;h_dest, np-&gt;remote_mac, 6);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#36755;&#20986;&#35774;&#22791;</span>
        skb-&gt;dev = np-&gt;dev;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;SKB</span>
        netpoll_send_skb(np, skb);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgee58aa4" class="outline-4">
<h4 id="orgee58aa4"><span class="section-number-4">9.4.2.</span> netpoll_send_skb()</h4>
<div class="outline-text-4" id="text-9-4-2">
<p>
netpoll_send_skb()用来发送数据包，可以是UDP或者ARP。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">netpoll_send_skb</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> *<span style="color: #FD971F;">np</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">status</span> = NETDEV_TX_BUSY;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">tries</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">dev</span> = np-&gt;dev;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll_info</span> *<span style="color: #FD971F;">npinfo</span> = np-&gt;dev-&gt;npinfo;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23578;&#26410;&#21019;&#24314;netpoll&#20449;&#24687;&#22359;&#65292;&#25110;&#32773;&#35774;&#22791;&#23578;&#26410;&#25171;&#24320;&#65292;&#25110;&#32773;&#35774;&#22791;&#34987;&#25346;&#36215;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>npinfo || <span style="color: #E6DB74; font-weight: bold;">!</span>netif_running(dev) || <span style="color: #E6DB74; font-weight: bold;">!</span>netif_device_present(dev)) {
                __kfree_skb(skb);
                <span style="color: #F92672;">return</span>;
        }

        <span style="color: #F92672;">if</span> (skb_queue_len(&amp;npinfo-&gt;txq) == 0 &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">txq&#38431;&#21015;&#20026;&#31354;</span>
        npinfo-&gt;poll_owner != smp_processor_id()) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;cpu&#19981;&#26159;&#19978;&#27425;&#36755;&#20837;&#36719;&#20013;&#26029;&#30340;cpu</span>
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>;

                local_irq_save(flags);
                <span style="color: #F92672;">if</span> (netif_tx_trylock(dev)) {
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">try until next clock tick</span><span style="color: #75715E;"> */</span>
                        <span style="color: #F92672;">for</span> (tries = jiffies_to_usecs(1)/USEC_PER_POLL;
                                        tries &gt; 0; --tries) {
                                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>netif_queue_stopped(dev))
                                        status = dev-&gt;hard_start_xmit(skb, dev);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36755;&#20986;&#25968;&#25454;&#21253;</span>
                                <span style="color: #F92672;">if</span> (status == NETDEV_TX_OK)
                                        <span style="color: #F92672;">break</span>;
                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#27169;&#25311;&#36755;&#20837;&#36719;&#20013;&#26029;&#36755;&#20837;&#25968;&#25454;&#21253;</span><span style="color: #75715E;"> */</span>
                                netpoll_poll(np);
                                udelay(USEC_PER_POLL);
                        }
                        netif_tx_unlock(dev);
                }
                local_irq_restore(flags);
        }

        <span style="color: #F92672;">if</span> (status != NETDEV_TX_OK) {
                skb_queue_tail(&amp;npinfo-&gt;txq, skb);<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26410;&#25104;&#21151;&#36755;&#20986;&#65292;&#21017;&#25346;&#21040;txq&#38431;&#21015;</span>
                schedule_delayed_work(&amp;npinfo-&gt;tx_work,0); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#24230;tx_work&#24037;&#20316;&#38431;&#21015;</span>
        }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8f61c84" class="outline-3">
<h3 id="org8f61c84"><span class="section-number-3">9.5.</span> tx_work工作队列</h3>
<div class="outline-text-3" id="text-9-5">
<p>
tx_work工作队列通过 netpoll_setup() 初始化。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">netpoll_setup</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> *<span style="color: #FD971F;">np</span>)
{
        <span style="color: #75715E;">//</span><span style="color: #75715E;">......</span>
        INIT_DELAYED_WORK(&amp;npinfo-&gt;tx_work, queue_process);
}

<span style="color: #75715E;">//</span><span style="color: #75715E;">tx_work &#24037;&#20316;&#38431;&#21015;&#36890;&#36807; queue_process &#20363;&#31243;&#22788;&#29702;&#12290;</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">queue_process</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">work_struct</span> *<span style="color: #FD971F;">work</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll_info</span> *<span style="color: #FD971F;">npinfo</span> =
                container_of(work, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll_info</span>, tx_work.work);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>;
        <span style="color: #F92672;">while</span> ((skb = skb_dequeue(&amp;npinfo-&gt;txq))) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36941;&#21382;txq&#38431;&#21015;&#30340;SKB</span>
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">net_device</span> *<span style="color: #FD971F;">dev</span> = skb-&gt;dev;

                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>netif_device_present(dev) || <span style="color: #E6DB74; font-weight: bold;">!</span>netif_running(dev)) {
                        __kfree_skb(skb);
                        <span style="color: #F92672;">continue</span>;
                }

                local_irq_save(flags);
                netif_tx_lock(dev);
                <span style="color: #F92672;">if</span> (netif_queue_stopped(dev) ||
                    dev-&gt;hard_start_xmit(skb, dev) != NETDEV_TX_OK) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#20256;&#36755;SKB</span>
                        skb_queue_head(&amp;npinfo-&gt;txq, skb);
                        netif_tx_unlock(dev);
                        local_irq_restore(flags);
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#22833;&#36133;&#65292;&#37325;&#26032;&#35843;&#24230;</span>
                        schedule_delayed_work(&amp;npinfo-&gt;tx_work, HZ/10);
                        <span style="color: #F92672;">return</span>;
                }
                netif_tx_unlock(dev);
                local_irq_restore(flags);
        }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org08c7483" class="outline-3">
<h3 id="org08c7483"><span class="section-number-3">9.6.</span> netpoll实例：netconsole</h3>
<div class="outline-text-3" id="text-9-6">
<p>
netconsole 可以将本机的dmesg系统信息通过网络发送到另一台主机上。
</p>

<p>
netconsole依赖netpoll框架，最终通过 netpoll_send_udp() 发送到监控主机。
</p>
</div>

<div id="outline-container-org76fc420" class="outline-4">
<h4 id="org76fc420"><span class="section-number-4">9.6.1.</span> netconsole参数</h4>
<div class="outline-text-4" id="text-9-6-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">config</span>[256];
<span style="color: #A6E22E;">module_param_string</span>(netconsole, config, 256, 0);
<span style="color: #A6E22E;">MODULE_PARM_DESC</span>(netconsole, <span style="color: #E6DB74;">" netconsole=[src-port]@[src-ip]/[dev],[tgt-port]@&lt;tgt-ip&gt;/[tgt-macaddr]\n"</span>);

<span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">netpoll</span> <span style="color: #FD971F;">np</span> = {
        .name = <span style="color: #E6DB74;">"netconsole"</span>,
        .dev_name = <span style="color: #E6DB74;">"eth0"</span>,
        .local_port = 6665,
        .remote_port = 6666,
        .remote_mac = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
};
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">configured</span> = 0;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf8341c0" class="outline-4">
<h4 id="orgf8341c0"><span class="section-number-4">9.6.2.</span> console</h4>
<div class="outline-text-4" id="text-9-6-2">
<p>
由于需要捕获console信息，需要实现console结构的实例并注册到系统。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">console</span> <span style="color: #FD971F;">netconsole</span> = {
        .name = <span style="color: #E6DB74;">"netcon"</span>,
        .flags = CON_ENABLED | CON_PRINTBUFFER,
        .write = write_msg
};
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#36807;write_msg&#36755;&#20986;console&#20449;&#24687;</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">write_msg</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">console</span> *<span style="color: #FD971F;">con</span>, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">msg</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">frag</span>, <span style="color: #FD971F;">left</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>np.dev)
                <span style="color: #F92672;">return</span>;
        local_irq_save(flags);

        <span style="color: #F92672;">for</span>(left = len; left; ) {
                frag = min(left, MAX_PRINT_CHUNK);
                netpoll_send_udp(&amp;np, msg, frag);
                msg += frag;
                left -= frag;
        }
        local_irq_restore(flags);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org49c3a08" class="outline-4">
<h4 id="org49c3a08"><span class="section-number-4">9.6.3.</span> 初始化</h4>
<div class="outline-text-4" id="text-9-6-3">
<p>
init_netconsole()是netconsole模块的初始化函数。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">init_netconsole</span>(<span style="color: #66D9EF;">void</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;

        <span style="color: #F92672;">if</span>(strlen(config))<span style="color: #75715E;">//</span><span style="color: #75715E;">&#35299;&#26512;&#21442;&#25968;</span>
                option_setup(config);
        <span style="color: #F92672;">if</span>(<span style="color: #E6DB74; font-weight: bold;">!</span>configured) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26410;&#37197;&#32622;&#21442;&#25968;</span>
                printk(<span style="color: #E6DB74;">"netconsole: not configured, aborting\n"</span>);
                <span style="color: #F92672;">return</span> 0;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27880;&#20876;netpoll&#23454;&#20363;</span>
        err = netpoll_setup(&amp;np);
        <span style="color: #F92672;">if</span> (err)
                <span style="color: #F92672;">return</span> err;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27880;&#20876;netconsole&#23454;&#20363;</span>
        register_console(&amp;netconsole);
        printk(KERN_INFO <span style="color: #E6DB74;">"netconsole: network logging started\n"</span>);
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:55</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
