<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
<!-- 2024-06-23 Sun 15:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TCP的输出</title>
<meta name="author" content="nandfan" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../styles/myself/css/worg.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">TCP的输出</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org17aee69">1. 引言</a></li>
<li><a href="#org3f918b3">2. 最大段长度（MSS）</a></li>
<li><a href="#org70182bc">3. sendmsg系统调用在TCP中的实现</a>
<ul>
<li><a href="#orgf499863">3.1. 分割TCP段</a></li>
<li><a href="#org945cb05">3.2. 套接口层的实现</a></li>
<li><a href="#org4e78628">3.3. 传输层接口实现</a>
<ul>
<li><a href="#org4d89a0f">3.3.1. 输出发送队列上的段 tcp_write_xmit()</a></li>
<li><a href="#orgba10666">3.3.2. 输出到网络层：tcp_transmit_skb()</a></li>
<li><a href="#org836dfdb">3.3.3. 输出发送队列上的第一个段：tcp_push_one()</a></li>
<li><a href="#orgc74d0cb">3.3.4. 输出发送队列上的tcp段：__tcp_push_pending_frames()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2e8d8da">4. 对TCP选项的处理</a>
<ul>
<li><a href="#orgc6c73c2">4.1. 构建SYN段的选项</a></li>
<li><a href="#orgbc8bf33">4.2. 构建非SYN段的选项：tcp_build_and_update_options()</a></li>
</ul>
</li>
<li><a href="#org4ac180a">5. Nagle算法</a></li>
<li><a href="#org8449fad">6. ACK的接收</a>
<ul>
<li><a href="#org227b01e">6.1. tcp_ack()</a></li>
<li><a href="#org88565cb">6.2. 发送窗口的更新：tcp_ack_update_window()</a></li>
<li><a href="#org41b6e3c">6.3. 根据SACK选项标记重传队列中段的记分牌：tcp_sacktag_write_queue</a></li>
<li><a href="#org7b741ef">6.4. 重传队列中已经确认段的删除：tcp_clean_rtx_queue()</a></li>
</ul>
</li>
<li><a href="#org24849e9">7. 往返时间测量和RTO的计算</a></li>
<li><a href="#orgdd260a5">8. 路径MTU发现</a>
<ul>
<li><a href="#org6aae981">8.1. 路径MTU发现原理</a></li>
<li><a href="#orgc73bacf">8.2. 路径MTU发现时的黑洞</a></li>
<li><a href="#org3809ec1">8.3. 有关数据结构的初始化</a></li>
<li><a href="#org01f47df">8.4. 创建路径MTU发向TCP段并发送</a></li>
<li><a href="#org795c82b">8.5. 路径MTU发现失败后的处理</a></li>
<li><a href="#org4e89db9">8.6. 处理需要分片的ICMP目的不可达报文</a></li>
<li><a href="#org51f57e6">8.7. 更新当前有效的MSS</a></li>
<li><a href="#orga11995d">8.8. 路径MTU发现成功后的处理</a></li>
</ul>
</li>
<li><a href="#org0295b7a">9. TCP重传接口</a></li>
</ul>
</div>
</div>

<div id="outline-container-org17aee69" class="outline-2">
<h2 id="org17aee69"><span class="section-number-2">1.</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
TCP段是封装在IP数据报中传输的，而IP数据报的传输是不可靠的。因此不能将TCP段发送出去后需要进行跟踪，除非出现三种情况：
</p>
<ul class="org-ul">
<li>在规定时间内，接收方已确认收到该段;</li>
<li>发生超时，在规定时间内没有收到接收方的确认;</li>
<li>确定数据包已经丢失，在后两种情况下，需要从未接收到的位置开始重新发送该数据报。</li>
</ul>



<div id="org4cb31b8" class="figure">
<p><img src="ditaa/tcp-output/skb-list.png" alt="skb-list.png" />
</p>
</div>

<p>
TCP传输控制块中的sk_write_queue字段存储的是发送队列双向链表头。而TCP传输控制块的另外一个成员sk_send_head指向发送队列中下一个要发送的数据包，该字段是用来跟踪哪些包还未发送，而不是用来进行发送的，如果未空，则意味着发送队列上的所有数据包都已经发送过了。
</p>

<p>
在发送方从接收方接收到ACK段后，可以扩大发送窗口，从sk_send_head开始遍历发送队列发送更多的段。
</p>

<p>
每个即将被发送的段都有一些TCP特性相关的信息，这些信息存储在skb-&gt;cb[]控制块中。该控制块提供了多种用途，TCP接收数据包时也经常使用该控制块，如果只是用来做输出处理，则不存在额外的限制。
</p>

<p>
下图描述了与发送有关的个函数之间的关系。
</p>

<div id="orgba6f2dc" class="figure">
<p><img src="image/tcp-output/tcp-send-funcs.png" alt="tcp-send-funcs.png" />
</p>
<p><span class="figure-number">Figure 1: </span>与发送有关的函数之间的关系</p>
</div>

<p>
在TCP输出引擎中，无论是首次发送TCP段，还是重传，或者是建立TCP连接时发送SYN段，都会调用tcp_retransmit_skb()。
</p>
<ul class="org-ul">
<li>最上层的tcp_sendmsg()和tcp_sendpage()都是用来获取数据到SKB中的，无论数据是来自用户层还是页面缓存，最后将套接口缓存加入到传输控制块的发送队列 sk_write_queue 中，并在适当的时候调用tcp_write_xmit()或tcp_push_one()尽力将这些数据报发送出去。</li>
<li>在TCP接收处理ACK段的过程中，会调用tcp_data_snd_check()来检测发送队列是否还有数据包需要发送如果有，则同样调用tcp_write_xmit()处理发送过程。</li>
<li>需要重传数据报时，无论是超时重传还是回应收到的SACK信息，都会调用tcp_retransmit_skb()来处理重传，而该函数最终还是调用tcp_transmit_skb()来发送重传数据报的。</li>
</ul>

<p>
因此应用层无论是发送数据还是响应某种事件（例如收到SACK），或者重传超时定时器到期，都会导致TCP输出相应的段。
</p>

<p>
综上所述，TCP发送方在接收方确认收到数据报之前，始终在发送队列中保留一份SKB的备份。要实现这种备份，使用克隆SKB比较高效。先创建一个纯数据区的TCP包，然后标识该SKB已被克隆，最后TCP发送引擎用克隆的SKB来建立TCP和IPv4首部，如下图：
</p>

<div id="orgf7e006e" class="figure">
<p><img src="ditaa/tcp-output/skb-clone.png" alt="skb-clone.png" />
</p>
</div>

<p>
tcp_write_xmit()从sk_send_head指向的SKB开始遍历，一旦找到可以发送的包，便克隆或复制它。
</p>

<p>
克隆的SKB主要用来构建TCP首部，整个过程在tcp_transmit_skb()中处理。注意：在发送队列sk_write_queue上的SKB与克隆的SKB共享同一个数据区。
</p>

<p>
在构建段时，tcp_sendmsg()和tcp_sendpage()需要在数据区的前部预留足够的空间，不仅要存放TCP首部，还有其他协议层的首部（IPv4）和硬件层的首部，都要填充到数据区的前部。
</p>

<p>
如果发送队列sk_write_queue上的段都发送完了，则将sk_send_head置为空。当应用层有有新的数据包发送时，sk_send_head将从新指向这些新段中的第一个。
</p>

<p>
一个TCP数据包，如果其长度小于MSS,TCP发送函数tcp_sendmsg()和tcp_sendpage()会把更多的数据添加到该数据包的尾部，直到其长度达到MSS为止。
</p>

<p>
假设发送队列sk_write_queue中有三个完整MSS长度的TCP段，且sk_send_head指向其中的第一个。调用tcp_write_xmit()时，会检测sk_send_head所指向的段的一些字段，包括TCP当前的发送窗口、拥塞窗口等，同时还会确定是否启用Nagle算法等。
</p>


<div id="orgbb75748" class="figure">
<p><img src="ditaa/tcp-output/sk-send-head-before.png" alt="sk-send-head-before.png" />
</p>
</div>


<p>
发送前，当前SKB被克隆，克隆的SKB作为参数传入tcp_transmit_skb()作填充和发送处理，完成后调用update_send_head()使sk_send_head指向下一个SKB。
</p>


<div id="orgdf8f01f" class="figure">
<p><img src="ditaa/tcp-output/sk-send-head.png" alt="sk-send-head.png" />
</p>
</div>


<p>
通过以上的处理，在用户发送更多的段之前，已成功的将发送队列中的所有包都发送出去了，sk_send_head置为空，本次发送结束。此时虽然发送队列中的所有段都发送过了，但还需要保存在发送队列中，只是将sk_send_head置为空。
</p>


<div id="orge5a51d4" class="figure">
<p><img src="ditaa/tcp-output/sk-send-head-after.png" alt="sk-send-head-after.png" />
</p>
</div>


<p>
当接收者确认了sk_write_queue上的SKB时，才能够从发送队列上删除并释放SKB。
</p>


<div id="orgf5b2b79" class="figure">
<p><img src="ditaa/tcp-output/sk-send-head-ack.png" alt="sk-send-head-ack.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-org3f918b3" class="outline-2">
<h2 id="org3f918b3"><span class="section-number-2">2.</span> 最大段长度（MSS）</h2>
<div class="outline-text-2" id="text-2">
<p>
TCP提供的是一种面向连接的、可靠的字节流服务。TCP提供可靠性的一种重要措施就是MSS。通过MSS，数据被分割为TCP认为合适发送的数据块，成为段（segment）。段不包括协议首部，只包含数据。与MSS最为相关的一个参数就是网络设备接口的MTU，以太网的MTU是1500B，其中扣除不带选项的IP首部和TCP首部长度个20B，因此MSS值为1460B。
</p>

<p>
在TCP三次握手过程中可以看到，双方都通过TCP选项通告本端能接受的MSS值，该值来源于tcp_sock结构的成员advmss，而advmss又来自路由项中的MSS度量值（metrics[RTAX_ADVMSS-1]）（参见tcp_connect_init()），路由项中的MSS度量值直接由网络设备接口的MTU减去IP首部和TCP首部的计算得到（见rt_set_nexthop()）。因此，在本地以太网中，如果IP和TCP首部都不包含选项，则MSS最大可达1460。如下图：
</p>


<div id="org797b897" class="figure">
<p><img src="image/tcp-output/mss-relacationship.png" alt="mss-relacationship.png" />
</p>
<p><span class="figure-number">Figure 2: </span>MSS的成员关系图</p>
</div>

<p>
tcp_sock成员rx_opt，为tcp_option_received结构类型，记录来自对端的TCP选项通告，其中user_mss是用户通过TCP_MAXSEG选项设置的MSS上限，它和建立连接时对端SYN段中的MSS通告（RFC1122中明确说明通告MSS不包含TCP和IP选项）两者中取最小值作为该连接上的MSS上限，存储在mss_clamp中（也不包含TCP选项），表示对端的MSS。如果没有接收到来自对方通告的MSS，并且没有设置user_mss，则将对端的MSS设置为默认值536B（加上首部，允许576B的IP数据报）。事实上，标识对端MSS的mss_clamp，其初始值就定为536（见tcp_v4_conn_request()），收到来自对端的MSS通告后，再对其修正。
</p>

<p>
而tcp_sock成员mss_cache描述发送方当前有效的MSS，其初始值为536。如果启用路径MTU，则会根据得到的下一跳MTU和对端通告的MSS进行更新。有关通告对端MSS的成员关系图如下：
</p>


<div id="orgaed4772" class="figure">
<p><img src="image/tcp-output/mss-advmss.png" alt="mss-advmss.png" />
</p>
<p><span class="figure-number">Figure 3: </span>有关通告对端MSS的成员关系</p>
</div>

<p>
主要成员意义如下：
</p>
<ul class="org-ul">
<li>metrics[RTAX_MTU]: 与路径关联的MTU，通过路径MTU发现的下一跳MTU会保存在此，初始化值为576或者网络设备的MTU。</li>
<li>icsk_pmtu_cookie: 最近一次更新的路径MTU，inet_connection_sock结构的成员，由metrics[RTAX_MTU]初始化并更新。</li>
<li>mss_cache: 发送方当前有效MSS，tcp_sock结构成员，初始化值为536。</li>
<li>mss_clamp: 当前连接对端接收的MSS上限，tcp_options_received结构成员。在更新mss_cache时必须保证mss_cache不大于mss_clamp。</li>
<li>user_mss: 用户设置的MSS上限，tcp_option_received结构成员，与建立连接时SYN段中MSS两者取最小值作为该连接对端接收MSS的上限，存储在mss_clamp中。</li>
<li>metrics[RTAX_ADVMSS]: 初始化时根据网络设备的MTU计算得到的本端MSS上限。</li>
<li>advmss: 当前连接本端接收MSS上限，tcp_sock结构成员，在建立TCP连接时通告给对端。</li>
</ul>

<p>
与最大段长度有关的一个函数是tcp_current_mss()，用来计算当前有效MSS，需要考虑TCP首部中的SACK选项和IP选项，以及PMTU。参数large_allowed表示是否允许支持TSO模式。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Compute the current effective MSS, taking SACKs and IP options,</span>
<span style="color: #75715E;"> * and even PMTU discovery events into account.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * LARGESEND note: !urg_mode is overkill, only frames up to snd_up</span>
<span style="color: #75715E;"> * cannot be large. However, taking into account rare use of URG, this</span>
<span style="color: #75715E;"> * is not a big flaw.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_current_mss</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">large_allowed</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dst_entry</span> *<span style="color: #FD971F;">dst</span> = __sk_dst_get(sk);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#22871;&#25509;&#21475;&#36335;&#30001;&#32531;&#23384;&#39033;&#65292;&#29992;&#26469;&#20174;&#20013;&#21462;&#20986;MTU</span>
        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">mss_now</span>;
        <span style="color: #66D9EF;">u16</span> <span style="color: #FD971F;">xmit_size_goal</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">doing_tso</span> = 0;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#24403;&#21069;&#26377;&#25928;MSS&#26469;&#21021;&#22987;&#21270;mss_now&#65292;&#29992;&#25143;&#21518;&#32493;&#35745;&#31639;</span>
        mss_now = tp-&gt;mss_cache;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30830;&#23450;&#26159;&#21542;&#25903;&#25345;TSO&#65288;large_allowed&#12289;&#22871;&#25509;&#21475;TSO&#29305;&#24615;&#12289;TCP&#27573;&#26159;&#21542;&#22788;&#20110;&#32039;&#24613;&#27169;&#24335;&#65289;</span>
        <span style="color: #F92672;">if</span> (large_allowed &amp;&amp; sk_can_gso(sk) &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>tp-&gt;urg_mode)
                doing_tso = 1;

        <span style="color: #F92672;">if</span> (dst) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#33719;&#21462;&#21040;&#36335;&#30001;&#65292;&#21017;&#21462;&#20986;PMTU&#19982;&#26368;&#36817;&#19968;&#27425;&#26356;&#26032;&#30340;&#36335;&#24452;MTU&#27604;&#36739;&#65292;&#19981;&#30456;&#31561;&#65292;&#21017;&#26356;&#26032;icsk_pmtu_cookie&#21644;&#24403;&#21069;&#26377;&#25928;MSS</span>
                <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">mtu</span> = dst_mtu(dst);
                <span style="color: #F92672;">if</span> (mtu != inet_csk(sk)-&gt;icsk_pmtu_cookie)
                        mss_now = tcp_sync_mss(sk, mtu);
        }

        <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.eff_sacks) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#25903;&#25345;SACK&#36873;&#39033;&#65292;&#19988;&#19979;&#19968;&#20010;&#24453;&#21457;&#36865;&#27573;&#20013;&#23384;&#22312;SACK&#36873;&#39033;&#65292;&#21017;&#22312;&#26377;&#25928;MSS&#20013;&#20943;&#21435;SACK&#36873;&#39033;&#38271;&#24230;&#12290;</span>
                mss_now -= (TCPOLEN_SACK_BASE_ALIGNED +
                            (tp-&gt;rx_opt.eff_sacks * TCPOLEN_SACK_PERBLOCK));

<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25903;&#25345;MD5&#25968;&#23383;&#31614;&#21517;&#30340;&#35805;&#65292;&#38656;&#35201;&#20943;&#21435;&#31614;&#21517;&#36873;&#39033;&#38271;&#24230;</span>
        <span style="color: #F92672;">if</span> (tp-&gt;af_specific-&gt;md5_lookup(sk, sk))
                mss_now -= TCPOLEN_MD5SIG_ALIGNED;
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#25903;&#25345;TSO,&#21017;&#38656;&#35201;&#37325;&#26032;&#35745;&#31639;&#35813;&#22871;&#25509;&#21475;&#21457;&#36865;&#25968;&#25454;&#25253;&#26102;&#21040;&#32593;&#32476;&#35774;&#22791;&#30340;TCP&#27573;&#30340;&#38271;&#24230;&#12290;</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#39318;&#20808;&#29992;&#24403;&#21069;&#26377;&#25928;MSS&#21021;&#22987;&#21270;xmit_size_goal</span>
        xmit_size_goal = mss_now;

        <span style="color: #F92672;">if</span> (doing_tso) {<span style="color: #75715E;">//</span><span style="color: #75715E;">TSO&#27169;&#24335;&#19979;&#65292;&#27573;&#30340;&#26368;&#22823;&#38271;&#24230;&#20026;64KB&#65292;&#22312;&#20174;&#20013;&#20943;&#21435;IP&#39318;&#37096;&#21450;&#36873;&#39033;&#12289;TCP&#39318;&#37096;&#38271;&#24230;</span>
                xmit_size_goal = (65535 -
                                  inet_csk(sk)-&gt;icsk_af_ops-&gt;net_header_len -
                                  inet_csk(sk)-&gt;icsk_ext_hdr_len -
                                  tp-&gt;tcp_header_len);

                <span style="color: #F92672;">if</span> (tp-&gt;max_window &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25903;&#25345;TSO&#26102;&#65292;TCP&#27573;&#30340;&#38271;&#24230;&#19981;&#33021;&#36229;&#36807;&#25509;&#25910;&#26041;&#26368;&#22823;&#25509;&#25910;&#31383;&#21475;&#30340;&#19968;&#21322;</span>
                    (xmit_size_goal &gt; (tp-&gt;max_window &gt;&gt; 1)))
                        xmit_size_goal = max((tp-&gt;max_window &gt;&gt; 1),
                                             68U - tp-&gt;tcp_header_len);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20445;&#35777;&#25903;&#25345;TSO&#30340;TCP&#27573;&#30340;&#38271;&#24230;&#26159;&#24403;&#21069;&#26377;&#25928;MSS&#30340;&#25972;&#25968;&#20493;</span>
                xmit_size_goal -= (xmit_size_goal % mss_now);
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#20986;TSO&#30340;TCP&#27573;&#38271;&#24230;&#21518;&#65292;&#26356;&#26032;&#21040;&#20256;&#36755;&#23618;xmit_size_goal&#20013;</span>
        tp-&gt;xmit_size_goal = xmit_size_goal;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36820;&#22238;&#33719;&#21462;&#21040;&#30340;MSS</span>
        <span style="color: #F92672;">return</span> mss_now;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org70182bc" class="outline-2">
<h2 id="org70182bc"><span class="section-number-2">3.</span> sendmsg系统调用在TCP中的实现</h2>
<div class="outline-text-2" id="text-3">
<p>
sendmsg系统调用在TCP中的实现分为两层&#x2013;套接口层和传输接口层，主要实现在传输接口层。
</p>

<p>
系统调用通过proto_opt结构跳转表调用inet_sendmsg()，而inet_sendmsg()有通过proto结构跳转表调用tcp_sendmsg()，从而实现TCP的发送。主要部分在传输层接口tcp_sendmsg()中实现。
</p>


<div id="org3d21744" class="figure">
<p><img src="image/tcp-output/tcp-sendmsg-call.png" alt="tcp-sendmsg-call.png" />
</p>
<p><span class="figure-number">Figure 4: </span>TCP中的sendmsg系统调用过程</p>
</div>
</div>

<div id="outline-container-orgf499863" class="outline-3">
<h3 id="orgf499863"><span class="section-number-3">3.1.</span> 分割TCP段</h3>
<div class="outline-text-3" id="text-3-1">
<p>
tso_fragment()实现将支持TSO的TCP段剪切成LEN字节长，剩余的数据移动到新的SKB中，并将其添加到队列末尾的SKB后。
</p>

<p>
其中参数skb为待分段的TCP段，len为分段长，mss_now为当前MSS。如果len大于mss_now，则说明分出的段仍是支持TSO的段，mss_now用来设置该段的gso_size;否则分出的是普通段。
</p>

<p>
该函数做了多种判断，以加速段的分割，对于在线性区域有数据的段会调用tcp_fragment()来分割，而对于那些数据都在分散聚合中且从来没有发送过的SKB,分割是相当快的，不会涉及数据的复制。段分割前后的示意图如下：
</p>


<div id="org722b1f7" class="figure">
<p><img src="image/tcp-outpu/tcp-segment.png" alt="tcp-segment.png" />
</p>
<p><span class="figure-number">Figure 5: </span>分割前后的TCP段</p>
</div>
</div>
</div>

<div id="outline-container-org945cb05" class="outline-3">
<h3 id="org945cb05"><span class="section-number-3">3.2.</span> 套接口层的实现</h3>
<div class="outline-text-3" id="text-3-2">
<p>
inet_sendmsg()是sendmsg系统调用在TCP套接口层的实现，在调用传输层接口之前先判断端口与地址是否绑定，如果没有则动态绑定端口，最后调用传输层接口tcp_sendmsg()实现发送细节。
</p>
</div>
</div>

<div id="outline-container-org4e78628" class="outline-3">
<h3 id="org4e78628"><span class="section-number-3">3.3.</span> 传输层接口实现</h3>
<div class="outline-text-3" id="text-3-3">
<p>
TCP的发送工作大部分是在传输层接口中完成的，因此整个实现过程比较复杂，涉及从用户空间复制数据到内核空间、分割TCP段等。
</p>


<div id="orgc34faa7" class="figure">
<p><img src="image/tcp-output/tcp-sendmsg.png" alt="tcp-sendmsg.png" />
</p>
<p><span class="figure-number">Figure 6: </span>tcp_sendmsg()流程图</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_sendmsg</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *<span style="color: #FD971F;">iocb</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">msghdr</span> *<span style="color: #FD971F;">msg</span>,
                <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">size</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iovec</span> *<span style="color: #FD971F;">iov</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">iovlen</span>, <span style="color: #FD971F;">flags</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mss_now</span>, <span style="color: #FD971F;">size_goal</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>, <span style="color: #FD971F;">copied</span>;
        <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">timeo</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#21644;&#25509;&#25910;&#21069;&#37117;&#38656;&#35201;&#23545;&#20256;&#36755;&#25511;&#21046;&#22359;&#19978;&#38145;&#65292;&#38450;&#27490;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#21457;&#36865;&#25110;&#25509;&#25910;&#38431;&#21015;&#30001;&#20110;&#21516;&#26102;&#25805;&#20316;&#32780;&#28151;&#20081;</span>
        lock_sock(sk);
        TCP_CHECK_TIMER(sk);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#21457;&#36865;&#38459;&#22622;&#65292;&#21017;&#38656;&#35201;&#33719;&#21462;&#38459;&#22622;&#36229;&#26102;&#26102;&#38388;&#65292;&#36229;&#26102;&#26102;&#38388;&#20445;&#23384;&#22312;sock&#32467;&#26500;&#30340;sk_sndtimeo&#25104;&#21592;&#20013;</span>
        flags = msg-&gt;msg_flags;
        timeo = sock_sndtimeo(sk, flags &amp; MSG_DONTWAIT);
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#21482;&#26377;ESTABLISHED&#21644;CLOSE_WAIT&#29366;&#24577;&#19979;&#65292;&#25509;&#25910;&#31383;&#21475;&#25165;&#26159;&#25171;&#24320;&#30340;&#65292;&#25165;&#33021;&#22815;&#25509;&#25910;&#25968;&#25454;&#12290;</span>
<span style="color: #75715E;">        &#38750;&#36825;&#20004;&#31181;&#29366;&#24577;&#65292;&#36890;&#36807;sk_stream_wait_connect()&#25509;&#21475;&#31561;&#24453;&#24314;&#31435;&#36830;&#25509;&#65292;&#36229;&#26102;&#21017;&#36339;&#36716;&#21040;out_err</span><span style="color: #75715E;">*/</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Wait for a connection to finish.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> ((1 &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT))
                <span style="color: #F92672;">if</span> ((err = sk_stream_wait_connect(sk, &amp;timeo)) != 0)
                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out_err</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38656;&#35201;&#28165;&#38500;&#29992;&#26469;&#34920;&#31034;&#24322;&#27493;&#24773;&#20917;&#19979;&#22871;&#25509;&#21475;&#21457;&#36865;&#38431;&#21015;&#24050;&#28385;&#30340;&#26631;&#24535;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">This should be in poll</span><span style="color: #75715E;"> */</span>
        clear_bit(SOCK_ASYNC_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#33719;&#21462;&#24403;&#21069;&#26377;&#25928;MSS&#12290;</span>
<span style="color: #75715E;">        &#33719;&#21462;&#26102;&#38656;&#35201;&#23558;MSG_OOB&#21435;&#38500;&#65292;&#22312;tcp_current_mss()&#20013;&#65292;MSG_OOB&#26159;&#21028;&#26029;&#26159;&#21542;&#25903;&#25345;GSO&#30340;&#26465;&#20214;&#20043;&#19968;&#65292;</span>
<span style="color: #75715E;">        &#32780;&#24102;&#22806;&#25968;&#25454;&#19981;&#25903;&#25345;GSO</span><span style="color: #75715E;"> */</span>
        mss_now = tcp_current_mss(sk, <span style="color: #E6DB74; font-weight: bold;">!</span>(flags&amp;MSG_OOB));
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#33719;&#21462;&#21457;&#36865;&#25968;&#25454;&#25253;&#21040;&#36798;&#32593;&#32476;&#35774;&#22791;&#26102;&#25968;&#25454;&#27573;&#30340;&#26368;&#22823;&#38271;&#24230;&#65292;&#35813;&#38271;&#24230;&#29992;&#26469;&#20998;&#21106;&#25968;&#25454;&#65292;TCP&#21457;&#36865;&#27573;&#26102;&#65292;&#27599;&#20010;SKB&#22823;&#23567;&#19981;&#33021;&#36229;&#36807;&#35813;&#20540;&#12290;</span>
<span style="color: #75715E;">        &#22312;&#19981;&#25903;&#25345;GSO&#24773;&#20917;&#19979;&#65292;xmit_size_goal&#23601;&#31561;&#20110;MSS;&#22914;&#26524;&#25903;&#25345;GSO,&#21017;xmit_size_goal&#20250;&#26159;MSS&#30340;&#25972;&#25968;&#20493;&#12290;</span>
<span style="color: #75715E;">        &#25968;&#25454;&#25253;&#21457;&#36865;&#21040;&#32593;&#32476;&#35774;&#22791;&#21518;&#65292;&#20877;&#30001;&#32593;&#32476;&#35774;&#26681;&#25454;MSS&#36827;&#34892;&#20998;&#21106;&#12290;</span><span style="color: #75715E;">*/</span>
        size_goal = tp-&gt;xmit_size_goal;

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#24453;&#21457;&#36865;&#25968;&#25454;&#22359;&#22359;&#25968;&#20197;&#21450;&#25968;&#25454;&#22359;&#25351;&#38024;&#12290;&#28165;&#38646;copied&#65292;&#35813;&#20540;&#20195;&#34920;&#24050;&#20174;&#29992;&#25143;&#25968;&#25454;&#22359;&#22797;&#21046;&#21040;SKB&#30340;&#23383;&#33410;&#25968;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Ok commence sending.</span><span style="color: #75715E;"> */</span>
        iovlen = msg-&gt;msg_iovlen;
        iov = msg-&gt;msg_iov;
        copied = 0;

        err = -EPIPE; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#39318;&#20808;&#21021;&#22987;&#21270;&#38169;&#35823;&#30721;&#20026;EPIPE</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#26159;&#21542;&#23384;&#22312;&#38169;&#35823; || &#26159;&#21542;&#20801;&#35768;&#21457;&#36865;&#25968;&#25454;</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_err || (sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">do_error</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#27573;&#36807;&#31243;&#36890;&#36807;&#20004;&#20010;&#24490;&#29615;&#25511;&#21046;</span>
        <span style="color: #F92672;">while</span> (--iovlen &gt;= 0) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35813;&#24490;&#29615;&#25511;&#21046;&#26159;&#21542;&#25152;&#26377;&#29992;&#25143;&#25968;&#25454;&#22359;&#37117;&#24050;&#32463;&#22797;&#21046;&#23436;&#25104;</span>
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">seglen</span> = iov-&gt;iov_len;   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#25968;&#25454;&#22359;&#30340;&#38271;&#24230;</span>
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *from = iov-&gt;iov_base;   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#25968;&#25454;&#22359;&#30340;&#25351;&#38024;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25968;&#25454;&#22359;&#25351;&#38024;&#25351;&#21521;&#19979;&#19968;&#20010;&#25968;&#25454;&#22359;</span>
                iov++;

                <span style="color: #F92672;">while</span> (seglen &gt; 0) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#35813;&#24490;&#29615;&#25511;&#21046;&#27599;&#20010;&#25968;&#25454;&#22359;&#26159;&#21542;&#22797;&#21046;&#23436;&#25104;&#12290;</span>
                        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">copy</span>;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#20256;&#36755;&#25511;&#21046;&#22359;&#21457;&#36865;&#38431;&#21015;&#38431;&#23614;&#30340;SKB&#65292;&#21482;&#26377;&#38431;&#23614;&#30340;SKB&#21487;&#33021;&#23384;&#22312;&#21097;&#20313;&#31354;&#38388;</span>
                        skb = sk-&gt;sk_write_queue.prev;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23545;&#38431;&#23614;&#30340;SKB&#36827;&#34892;&#26657;&#39564;</span>
                        <span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;">                          + &#39318;&#20808;&#21028;&#26029;&#21457;&#36865;&#38431;&#21015;&#26159;&#21542;&#20026;&#31354;&#65292;&#20026;&#31354;&#21017;&#33719;&#21462;&#30340;SKB&#26080;&#25928;</span>
<span style="color: #E6DB74;">                          + &#22914;&#26524;&#38431;&#23614;&#30340;SKB&#26377;&#25928;&#65292;&#21017;&#36827;&#19968;&#27493;&#21028;&#26029;&#26159;&#21542;&#26377;&#21097;&#20313;&#31354;&#38388;&#65292;&#22914;&#26524;&#24050;&#20351;&#29992;&#31354;&#38388;&#36824;&#27809;&#26377;&#36798;&#21040;size_goal,&#21017;&#21487;&#20197;&#32487;&#32493;&#21521;&#20854;&#20013;&#22797;&#21046;&#25968;&#25454;&#12290;</span>
<span style="color: #E6DB74;">                          + &#21542;&#21017;&#21457;&#36865;&#38431;&#21015;&#20026;&#31354;&#65292;&#25110;&#32773;&#38431;&#23614;SKB&#27809;&#26377;&#21097;&#20313;&#31354;&#38388;&#65292;&#21017;&#38656;&#35201;&#20998;&#37197;&#26032;&#30340;SKB</span>
<span style="color: #E6DB74;">                        */</span>
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sk-&gt;sk_send_head ||
                            (copy = size_goal - skb-&gt;len) &lt;= 0) {

<span style="color: #AE81FF;">new_segment</span>:
                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Allocate new segment. If the interface is SG,</span>
<span style="color: #75715E;">                                 * allocate skb fitting to single page.</span>
<span style="color: #75715E;">                                 */</span>
                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21028;&#26029;&#21457;&#36865;&#38431;&#21015;&#20013;&#27573;&#25968;&#25454;&#30340;&#24635;&#38271;&#26159;&#21542;&#36798;&#21040;&#21457;&#36865;&#32531;&#20914;&#21306;&#30340;&#38271;&#24230;&#19978;&#38480;&#65292;&#36229;&#36807;&#21017;&#36339;&#36716;&#21040;wait_for_sndbuf&#22788;&#29702;</span><span style="color: #75715E;">*/</span>
                                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sk_stream_memory_free(sk))
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">wait_for_sndbuf</span>;
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;SKB,&#22833;&#36133;&#21017;&#36339;&#36716;&#22788;&#29702;</span>
                                skb = sk_stream_alloc_pskb(sk, select_size(sk, tp),
                                                           0, sk-&gt;sk_allocation);
                                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb)
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">wait_for_memory</span>;

                                <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">                                 * Check whether we can use HW checksum.</span>
<span style="color: #75715E;">                                 *///</span><span style="color: #75715E;">&#26681;&#25454;&#30446;&#30340;&#36335;&#30001;&#32593;&#32476;&#35774;&#22791;&#30340;&#29305;&#24615;&#65292;&#30830;&#23450;&#26159;&#21542;&#35774;&#32622;&#30001;&#30828;&#20214;&#25191;&#34892;&#26657;&#39564;&#21644;&#26631;&#24535;</span>
                                <span style="color: #F92672;">if</span> (sk-&gt;sk_route_caps &amp; NETIF_F_ALL_CSUM)
                                        skb-&gt;ip_summed = CHECKSUM_PARTIAL;
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;SKB&#28155;&#21152;&#21040;&#21457;&#36865;&#38431;&#21015;&#38431;&#23614;</span>
                                skb_entail(sk, tp, skb);
                                copy = size_goal; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;copy&#20026;&#21457;&#36865;&#21040;&#32593;&#32476;&#35774;&#22791;&#30340;&#26368;&#22823;&#25968;&#25454;&#27573;&#38271;&#24230;&#65292;copy&#34920;&#31034;&#27599;&#27425;&#22797;&#21046;&#21040;SKB&#30340;&#25968;&#25454;&#38271;&#24230;</span>
                        }

                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Try to append data to the end of skb.</span><span style="color: #75715E;"> */</span>
                        <span style="color: #F92672;">if</span> (copy &gt; seglen) <span style="color: #75715E;">//</span><span style="color: #75715E;">copy&#19981;&#33021;&#22823;&#20110;&#24453;&#22797;&#21046;&#25968;&#25454;&#38271;&#24230;</span>
                                copy = seglen;

                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Where to copy to?</span><span style="color: #75715E;"> */</span>
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21028;&#26029;SKB&#30340;&#32447;&#24615;&#23384;&#20648;&#21306;&#24213;&#37096;&#26159;&#21542;&#36824;&#26377;&#31354;&#38388;&#12290;&#22914;&#26524;&#26377;&#65292;&#21017;&#26681;&#25454;&#24213;&#37096;&#21097;&#20313;&#31354;&#38388;&#35843;&#25972;copy&#12290;</span><span style="color: #75715E;">*/</span>
                        <span style="color: #F92672;">if</span> (skb_tailroom(skb) &gt; 0) {
                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">We have some space in skb head. Superb!</span><span style="color: #75715E;"> */</span>
                                <span style="color: #F92672;">if</span> (copy &gt; skb_tailroom(skb))
                                        copy = skb_tailroom(skb);
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#29992;&#25143;&#31354;&#38388;&#22797;&#21046;copy&#38271;&#24230;&#30340;&#25968;&#25454;&#21040;SKB</span>
                                <span style="color: #F92672;">if</span> ((err = skb_add_data(skb, from, copy)) != 0)
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">do_fault</span>;
                        } <span style="color: #F92672;">else</span> { <span style="color: #75715E;">//</span><span style="color: #75715E;">SKB&#32447;&#24615;&#23384;&#20648;&#21306;&#24213;&#37096;&#27809;&#26377;&#31354;&#38388;&#65292;&#21017;&#38656;&#35201;&#25226;&#25968;&#25454;&#22797;&#21046;&#21040;&#25903;&#25345;&#20998;&#25955;&#32858;&#21512;I/O&#20998;&#39029;&#20013;&#12290;</span>
                                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">merge</span> = 0; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26631;&#35782;&#26159;&#21542;&#22312;&#26368;&#21518;&#19968;&#20010;&#20998;&#39029;&#20013;&#28155;&#21152;&#25968;&#25454;&#65292;&#21021;&#22987;&#21270;&#20026;0&#12290;</span>
                                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span> = skb_shinfo(skb)-&gt;nr_frags;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;SKB&#30340;&#20998;&#25955;&#29255;&#27573;&#25968;</span>
                                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> *<span style="color: #FD971F;">page</span> = TCP_PAGE(sk);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26368;&#21518;&#19968;&#20010;&#20998;&#29255;&#30340;&#39029;&#38754;</span>
                                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">off</span> = TCP_OFF(sk);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24050;&#22797;&#21046;&#25968;&#25454;&#30340;&#26411;&#23614;&#22312;&#26368;&#21518;&#19968;&#20010;&#20998;&#29255;&#30340;&#39029;&#20869;&#20559;&#31227;</span>
                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21028;&#26029;&#26368;&#21518;&#19968;&#20010;&#20998;&#39029;&#26159;&#21542;&#33021;&#36861;&#21152;&#25968;&#25454;&#65292;&#21487;&#20197;&#21017;&#35774;&#32622;merge&#26631;&#24535;&#12290;</span>
<span style="color: #75715E;">                                &#35813;&#25509;&#21475;&#29992;&#26469;&#21028;&#26029;&#35813;SKB&#19978;&#20998;&#25955;&#32858;&#21512;&#39029;&#38754;&#26159;&#21542;&#26377;&#25928;&#65292;&#21363;&#33021;&#21542;&#23558;&#25968;&#25454;&#28155;&#21152;&#21040;&#35813;&#39029;&#12290;</span><span style="color: #75715E;">*/</span>
                                <span style="color: #F92672;">if</span> (skb_can_coalesce(skb, i, page, off) &amp;&amp;
                                    off != PAGE_SIZE) {
                                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We can extend the last page</span>
<span style="color: #75715E;">                                         * fragment.</span><span style="color: #75715E;"> */</span>
                                        merge = 1;
                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#19981;&#33021;&#21521;&#26368;&#21518;&#19968;&#20010;&#20998;&#29255;&#36861;&#21152;&#25968;&#25454;&#65292;&#21017;&#38656;&#35201;&#21028;&#26029;&#20998;&#29255;&#25968;&#37327;&#26159;&#21542;&#36798;&#21040;&#19978;&#38480;&#65292;</span>
<span style="color: #75715E;">                                &#32593;&#32476;&#35774;&#22791;&#26159;&#21542;&#25903;&#25345;&#20998;&#25955;&#32858;&#21512;I/O&#65292;&#36825;&#20004;&#31181;&#24773;&#20917;&#37117;&#19981;&#33021;&#21521;SKB&#22797;&#21046;&#25968;&#25454;&#12290;</span><span style="color: #75715E;">*/</span>
                                } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (i == MAX_SKB_FRAGS ||  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#27966;&#20320;&#36798;&#21040;&#19978;&#38480;</span>
                                           (<span style="color: #E6DB74; font-weight: bold;">!</span>i &amp;&amp;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32593;&#32476;&#35774;&#22791;&#19981;&#25903;&#25345;&#20998;&#25955;&#32858;&#21512;I/O</span>
                                           <span style="color: #E6DB74; font-weight: bold;">!</span>(sk-&gt;sk_route_caps &amp; NETIF_F_SG))) {
                                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Need to add new fragment and cannot</span>
<span style="color: #75715E;">                                         * do this because interface is non-SG,</span>
<span style="color: #75715E;">                                         * or because all the page slots are</span>
<span style="color: #75715E;">                                         * busy.</span><span style="color: #75715E;"> */</span>
                                        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#23545;&#24403;&#21069;TCP&#27573;&#35774;&#32622;PSH&#26631;&#24535;&#65292;&#24182;&#26356;&#26032;pushed_seq&#25104;&#21592;&#65292;&#34920;&#31034;&#21040;pushed_seq&#20026;&#27490;&#65292;&#37117;&#26159;&#24076;&#26395;&#33021;&#23613;&#24555;&#21457;&#20986;&#30340;&#12290;</span><span style="color: #75715E;">*/</span>
                                        tcp_mark_push(tp, skb);
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">new_segment</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24320;&#22987;&#20998;&#37197;&#26032;&#30340;SKB</span>
                                } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (page) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#21040;&#20102;&#26368;&#21518;&#20998;&#39029;</span>
                                        <span style="color: #F92672;">if</span> (off == PAGE_SIZE) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#39029;&#20013;&#25968;&#25454;&#22635;&#28385;</span>
                                                put_page(page);
                                                TCP_PAGE(sk) = page = <span style="color: #AE81FF;">NULL</span>;
                                                off = 0;
                                        }
                                } <span style="color: #F92672;">else</span> <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21363;&#19981;&#33021;&#22312;&#26368;&#21518;&#30340;&#20998;&#39029;&#36861;&#21152;&#25968;&#25454;&#65292;&#20063;&#19981;&#33021;&#20998;&#37197;&#26032;&#30340;SKB&#65292;</span>
<span style="color: #75715E;">                                &#27492;&#26102;&#26080;&#35770;SKB&#26159;&#21542;&#23384;&#22312;&#20998;&#39029;&#65292;&#25968;&#25454;&#24517;&#39035;&#22797;&#21046;&#21040;&#20998;&#39029;&#30340;&#36215;&#22987;&#22788;&#12290;</span><span style="color: #75715E;">*/</span>
                                        off = 0;
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24453;&#22797;&#21046;&#25968;&#25454;&#38271;&#24230;&#19981;&#33021;&#22823;&#20110;&#39029;&#38754;&#20013;&#21097;&#20313;&#31354;&#38388;&#30340;&#38271;&#24230;&#12290;</span>
                                <span style="color: #F92672;">if</span> (copy &gt; PAGE_SIZE - off)
                                        copy = PAGE_SIZE - off;
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#25968;&#25454;&#21069;&#65292;&#21028;&#26029;&#36755;&#20986;&#32531;&#23384;&#26159;&#21542;&#36798;&#21040;&#19978;&#38480;&#65292;&#36798;&#21040;&#19978;&#38480;&#65292;&#21017;&#31561;&#24453;&#26377;&#36755;&#20986;&#32531;&#23384;&#21487;&#29992;&#25110;&#36229;&#26102;&#12290;</span>
                                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>sk_stream_wmem_schedule(sk, copy))
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">wait_for_memory</span>;
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26368;&#21518;&#19968;&#20010;&#39029;&#38754;&#20026;&#31354;&#65288;&#19968;&#33324;&#26159;&#26032;&#20998;&#37197;&#30340;SKB,&#25110;&#32773;&#21069;&#19968;&#20010;&#39029;&#38754;&#20998;&#27573;&#21018;&#22909;&#20840;&#37096;&#20351;&#29992;&#65289;</span>
                                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>page) {
                                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Allocate new cache page.</span><span style="color: #75715E;"> */</span>
                                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20998;&#37197;&#26032;&#30340;&#39029;&#38754;&#26469;&#23384;&#20648;&#25968;&#25454;</span>
                                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(page = sk_stream_alloc_page(sk)))
                                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">wait_for_memory</span>;
                                }

                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Time to copy data. We are close to</span>
<span style="color: #75715E;">                                 * the end!</span><span style="color: #75715E;"> *///</span><span style="color: #75715E;">&#24320;&#22987;&#22797;&#21046;&#25968;&#25454;</span>
                                err = skb_copy_to_page(sk, from, skb, page,
                                                       off, copy);
                                <span style="color: #F92672;">if</span> (err) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#22833;&#36133;&#65292;&#21017;&#38656;&#35201;&#23558;page&#26356;&#26032;&#21040;socket,&#22240;&#20026;page&#21487;&#33021;&#26159;&#26032;&#20998;&#37197;&#30340;</span>
                                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">If this page was new, give it to the</span>
<span style="color: #75715E;">                                         * socket so it does not get leaked.</span>
<span style="color: #75715E;">                                         */</span>
                                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>TCP_PAGE(sk)) {
                                                TCP_PAGE(sk) = page;
                                                TCP_OFF(sk) = 0;
                                        }
                                        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">do_error</span>;
                                }
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25104;&#21151;&#22797;&#21046;&#25968;&#25454;&#21040;&#20998;&#39029;&#20013;</span>
                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Update the skb.</span><span style="color: #75715E;"> */</span>
                                <span style="color: #F92672;">if</span> (merge) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#22312;&#26368;&#21518;&#19968;&#20010;&#20998;&#39029;&#20013;&#36861;&#21152;&#25968;&#25454;&#65292;&#21017;&#26356;&#26032;&#39029;&#38754;&#20869;&#30340;&#26377;&#25928;&#25968;&#25454;&#38271;&#24230;</span>
                                        skb_shinfo(skb)-&gt;frags[i - 1].size +=
                                                                        copy;
                                } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#25968;&#25454;&#26159;&#22797;&#21046;&#21040;&#20102;&#19968;&#20010;&#26032;&#30340;&#39029;&#38754;&#20998;&#27573;&#20013;</span>
                                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#20998;&#27573;&#20449;&#24687;</span>
                                        skb_fill_page_desc(skb, i, page, off, copy);
                                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26631;&#35782;&#26368;&#36817;&#19968;&#27425;&#20998;&#37197;&#39029;&#38754;&#30340;sk_sndmsg_page&#19981;&#20026;&#31354;&#65292;&#21017;&#22686;&#21152;&#23545;&#39029;&#38754;&#30340;&#24341;&#29992;</span>
                                        <span style="color: #F92672;">if</span> (TCP_PAGE(sk)) {
                                                get_page(page);
                                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#20026;&#31354;&#21017;&#34920;&#31034;&#22797;&#21046;&#20102;&#25968;&#25454;&#30340;&#39029;&#38754;&#26159;&#26032;&#20998;&#37197;&#30340;&#65292;&#22914;&#26524;&#39029;&#38754;&#27809;&#26377;&#20351;&#29992;&#23436;&#65292;&#21017;&#22686;&#21152;&#24341;&#29992;&#65292;&#24182;&#26356;&#26032;sk_sndmsg_page&#12290;</span>
<span style="color: #75715E;">                                        &#65288;&#22914;&#26524;&#39029;&#38754;&#24050;&#32463;&#20351;&#29992;&#23436;&#65292;&#21017;&#21482;&#35201;SKB&#27809;&#26377;&#36229;&#36807;&#20998;&#27573;&#19978;&#38480;&#65292;&#21017;&#19979;&#27425;&#36824;&#20250;&#20998;&#37197;&#26032;&#30340;&#39029;&#38754;&#65289;</span><span style="color: #75715E;">*/</span>
                                        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (off + copy &lt; PAGE_SIZE) {
                                                get_page(page);
                                                TCP_PAGE(sk) = page;
                                        }
                                }
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#20102;&#25968;&#25454;&#21518;&#65292;&#38656;&#35201;&#26356;&#26032;&#25968;&#25454;&#26411;&#23614;&#22312;&#26368;&#21518;&#19968;&#39029;&#20998;&#29255;&#30340;&#39029;&#20869;&#20559;&#31227;</span>
                                TCP_OFF(sk) = off + copy;
                        }

                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>copied) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#30340;&#25968;&#25454;&#38271;&#24230;&#20026;0&#65292; &#21017;&#21462;&#28040;TCPCB_FLAG_PSH&#26631;&#24535;</span>
                                TCP_SKB_CB(skb)-&gt;flags &amp;= ~TCPCB_FLAG_PSH;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#21457;&#36865;&#38431;&#21015;&#20013;&#26368;&#21518;&#19968;&#20010;&#24207;&#21495; write_seq</span>
                        tp-&gt;write_seq += copy;
                        TCP_SKB_CB(skb)-&gt;end_seq += copy; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27599;&#20010;&#25968;&#25454;&#21253;&#26368;&#21518;&#19968;&#20010;&#24207;&#21015;end_seq</span>
                        skb_shinfo(skb)-&gt;gso_segs = 0; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;gso&#20998;&#27573;&#25968;</span>

                        from += copy; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#28304;&#25968;&#25454;&#30340;&#25351;&#38024;</span>
                        copied += copy; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#24050;&#22797;&#21046;&#23383;&#33410;&#25968;</span>
                        <span style="color: #F92672;">if</span> ((seglen -= copy) == 0 &amp;&amp; iovlen == 0) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25152;&#26377;&#25968;&#25454;&#24050;&#32463;&#20840;&#37096;&#22797;&#21046;&#21040;SKB</span>
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;SKB&#38271;&#24230;&#23567;&#20110;MSS,&#21017;&#21487;&#20197;&#32487;&#32493;&#21521;&#20854;&#20013;&#22797;&#21046;&#25968;&#25454;&#65292;&#25110;&#32773;&#21457;&#36865;&#30340;&#26159;&#24102;&#22806;&#25968;&#25454;&#65292;&#21017;&#36339;&#36807;&#20197;&#19979;&#21457;&#36865;&#36807;&#31243;&#65292;&#32487;&#32493;&#22797;&#21046;&#25968;&#25454;&#21040;SKB</span>
                        <span style="color: #F92672;">if</span> (skb-&gt;len &lt; mss_now || (flags &amp; MSG_OOB))
                                <span style="color: #F92672;">continue</span>;
                        <span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;">                          &#26816;&#26597;&#26159;&#21542;&#24517;&#39035;&#31435;&#21363;&#21457;&#36865;&#65288;&#33258;&#19978;&#27425;&#21457;&#36865;&#21518;&#20135;&#29983;&#30340;&#25968;&#25454;&#26159;&#21542;&#24050;&#32463;&#36798;&#21040;&#23545;&#26041;&#36890;&#21578;&#36807;&#30340;&#26368;&#22823;&#36890;&#21578;&#31383;&#21475;&#20540;&#30340;&#19968;&#21322;&#65289;&#12290;</span>
<span style="color: #E6DB74;">                        &#22914;&#26524;&#24517;&#39035;&#31435;&#21363;&#21457;&#36865;&#65292;&#21017;&#35774;&#32622;PSH&#26631;&#24535;&#21518;&#65292;&#35843;&#29992;__tcp_push_pending_frames&#23558;&#22312;&#21457;&#36865;&#38431;&#21015;&#19978;&#30340;SKB&#20174;sk_send_head&#24320;&#22987;&#21457;&#36865;&#20986;&#21435;&#12290;</span>

<span style="color: #E6DB74;">                        __tcp_push_pending_frames&#23558;&#21457;&#36865;&#38431;&#21015;&#19978;&#30340;&#27573;&#21457;&#36865;&#20986;&#21435;&#65292;&#21457;&#36865;&#22833;&#36133;&#21017;&#26816;&#27979;&#26159;&#21542;&#38656;&#35201;&#28608;&#27963;&#25345;&#32493;&#23450;&#26102;&#22120;&#12290;</span>
<span style="color: #E6DB74;">                        &#24456;&#22810;&#22788;&#29702;&#22312;</span><span style="color: #AE81FF;">tcp_write_xmit()</span><span style="color: #E6DB74;">&#20013;&#36827;&#34892;&#65292;</span><span style="color: #AE81FF;">frame()</span><span style="color: #E6DB74;">&#21482;&#22312;&#21028;&#26029;&#26159;&#21542;&#26377;&#27573;&#38656;&#35201;&#21457;&#36865;&#26102;&#31616;&#21333;&#30340;&#35843;&#29992;</span><span style="color: #AE81FF;">tcp_write_xmit()</span><span style="color: #E6DB74;">&#21457;&#36865;&#27573;&#65292;&#21457;&#36865;&#22833;&#36133;&#20877;&#35843;&#29992;</span><span style="color: #AE81FF;">tcp_check_probe_timer()</span><span style="color: #E6DB74;">&#22797;&#20301;&#25345;&#32493;&#25506;&#27979;&#23450;&#26102;&#22120;&#12290;</span>
<span style="color: #E6DB74;">                        */</span>
                        <span style="color: #F92672;">if</span> (forced_push(tp)) {
                                tcp_mark_push(tp, skb);
                                __tcp_push_pending_frames(sk, tp, mss_now, TCP_NAGLE_PUSH);
                        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (skb == sk-&gt;sk_send_head) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#38656;&#35201;&#31435;&#21363;&#21457;&#36865;&#65292;&#19988;&#21457;&#36865;&#38431;&#21015;&#19978;&#21482;&#26377;&#36825;&#20010;&#27573;</span>
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;tcp_push_one&#20540;&#21457;&#36865;&#24403;&#21069;&#27573;&#12290;</span>
                                tcp_push_one(sk, mss_now);
                        <span style="color: #F92672;">continue</span>;

<span style="color: #AE81FF;">wait_for_sndbuf</span>:  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20869;&#23384;&#25805;&#20316;&#22833;&#36133;&#30340;&#22788;&#29702;</span>
 <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22871;&#25509;&#21475;&#21457;&#36865;&#32531;&#23384;&#22823;&#23567;&#26377;&#19978;&#38480;&#65292;&#19968;&#26086;&#21457;&#36865;&#38431;&#21015;&#20013;&#27573;&#30340;&#24635;&#25968;&#25454;&#38271;&#24230;&#36798;&#21040;&#21457;&#36865;&#32531;&#20914;&#21306;&#19978;&#38480;&#65292;&#21017;&#19981;&#33021;&#22312;&#20998;&#37197;SKB,&#21482;&#33021;&#31561;&#24453;</span><span style="color: #75715E;">*/</span>

                        set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);
<span style="color: #AE81FF;">wait_for_memory</span>:  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30452;&#25509;&#36339;&#36716;&#21040;&#27492;&#22788;&#65292;&#35828;&#26126;&#25972;&#20010;&#31995;&#32479;&#20869;&#23384;&#19981;&#22815;</span>
                        <span style="color: #F92672;">if</span> (copied) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#24050;&#32463;&#22797;&#21046;&#20102;&#37096;&#20998;&#25968;&#25454;</span>
                                <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#21457;&#36865;&#24050;&#32463;&#22797;&#21046;&#30340;&#25968;&#25454;&#65292; &#21435;&#25481;MSG_MORE&#34920;&#31034;&#26412;&#27425;&#21457;&#36865;&#27809;&#26377;&#26356;&#22810;&#30340;&#25968;&#25454;&#20102;&#12290;</span>
<span style="color: #75715E;">                                &#31532;&#20116;&#20010;&#21442;&#25968;&#34920;&#31034;&#20351;&#29992;Nagle&#31639;&#27861;&#65292;&#21487;&#33021;&#20250;&#24310;&#21518;&#21457;&#36865;</span><span style="color: #75715E;">*/</span>
                                tcp_push(sk, tp, flags &amp; ~MSG_MORE, mss_now, TCP_NAGLE_PUSH);
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36827;&#20837;&#30561;&#30496;&#65292;&#31561;&#24453;&#20869;&#23384;&#31354;&#38386;&#30340;&#20449;&#21495;&#65292;&#22914;&#26524;&#36229;&#26102;&#65292;&#21017;&#36890;&#36807;do_error&#22788;&#29702;</span>
                        <span style="color: #F92672;">if</span> ((err = sk_stream_wait_memory(sk, &amp;timeo)) != 0)
                                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">do_error</span>;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26377;&#20869;&#23384;&#21487;&#29992;&#65292;&#21017;&#37325;&#26032;&#33719;&#21462;&#24403;&#21069;MSS&#21644;TSO&#65288;&#30561;&#30496;&#36807;&#31243;&#20013;&#21487;&#33021;&#21457;&#29983;&#20102;&#21464;&#21270;&#65289;</span>
                        mss_now = tcp_current_mss(sk, <span style="color: #E6DB74; font-weight: bold;">!</span>(flags&amp;MSG_OOB));
                        size_goal = tp-&gt;xmit_size_goal;
                }
        }

<span style="color: #AE81FF;">out</span>:
        <span style="color: #F92672;">if</span> (copied)  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27491;&#24120;&#36864;&#20986;&#25110;&#32773;&#38169;&#35823;&#36864;&#20986;&#21069;&#65292;&#24050;&#32463;&#22797;&#21046;&#20102;&#25968;&#25454;</span>
                tcp_push(sk, tp, flags, mss_now, tp-&gt;nonagle);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#25968;&#25454;&#65292;&#26159;&#21542;&#31435;&#21363;&#21457;&#36865;&#21462;&#20915;&#20110;&#26159;&#21542;&#21551;&#29992;&#20102;Nagle&#31639;&#27861; tp-&gt;nonagle</span>
        TCP_CHECK_TIMER(sk);
        release_sock(sk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35299;&#38145;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#22914;&#26524;&#26377;&#36827;&#31243;&#31561;&#24453;&#35813;sk,&#21017;&#21796;&#37266;</span>
        <span style="color: #F92672;">return</span> copied;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36820;&#22238;&#24050;&#22797;&#21046;&#23383;&#33410;&#25968;&#12290;</span>

<span style="color: #AE81FF;">do_fault</span>:  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#25968;&#25454;&#24322;&#24120;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb-&gt;len) { <span style="color: #75715E;">//</span><span style="color: #75715E;">SKB&#25968;&#25454;&#38271;&#24230;&#20026;0,&#21017;&#26159;&#26032;&#20998;&#37197;&#30340;</span>
                <span style="color: #F92672;">if</span> (sk-&gt;sk_send_head == skb)  <span style="color: #75715E;">//</span><span style="color: #75715E;">sk_send_head&#25351;&#21521;&#35813;SKB,&#21017;&#35828;&#26126;&#35813;SBK&#20043;&#21069;&#27809;&#26377;&#38656;&#35201;&#21457;&#36865;&#30340;&#27573;&#65292;&#22240;&#27492;&#23558;sk_send_head&#32622;&#31354;&#12290;</span>
                        sk-&gt;sk_send_head = <span style="color: #AE81FF;">NULL</span>;
                __skb_unlink(skb, &amp;sk-&gt;sk_write_queue); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#21457;&#36865;&#38431;&#21015;&#21024;&#38500;&#24182;&#37322;&#25918;&#35813;SKB</span>
                sk_stream_free_skb(sk, skb);
        }

<span style="color: #AE81FF;">do_error</span>: <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21482;&#26377;&#22797;&#21046;&#25968;&#25454;&#24322;&#24120;&#20250;&#36339;&#21040;do_fault,&#20854;&#20182;&#38169;&#35823;&#36339;&#36716;&#21040;&#27492;&#22788;&#12290;</span>
        <span style="color: #F92672;">if</span> (copied)  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#24050;&#32463;&#22797;&#21046;&#20102;&#37096;&#20998;&#25968;&#25454;&#65292;&#21017;&#21457;&#36865;&#35813;&#25968;&#25454;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
<span style="color: #AE81FF;">out_err</span>:  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#27809;&#26377;&#22797;&#21046;&#25968;&#25454;&#65292;&#21017;&#33719;&#21462;&#38169;&#35823;&#30721;&#65292;&#35299;&#38145;&#20256;&#36755;&#25511;&#21046;&#22359;</span>
        err = sk_stream_error(sk, flags, err);
        TCP_CHECK_TIMER(sk);
        release_sock(sk);
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>


<div id="outline-container-org4d89a0f" class="outline-4">
<h4 id="org4d89a0f"><span class="section-number-4">3.3.1.</span> 输出发送队列上的段 tcp_write_xmit()</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
tcp_write_xmit()将发送队列上的SKB发送出去，返回值0表示发送成功。
</p>
<ul class="org-ul">
<li>检测当前状态是否TCP_CLOSE</li>
<li>检测拥塞窗口大小</li>
<li>检测当前段是否完全处在发送窗口内</li>
<li>检测段是否启用了Nagle算法</li>
<li>通过以上检测后，将SKB发送出去</li>
<li>循环检测并发送队列上所有未发送的SKB</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">This routine writes packets to the network.  It advances the</span>
<span style="color: #75715E;"> * send_head.  This happens as incoming acks open up the remote</span>
<span style="color: #75715E;"> * window for us.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * Returns 1, if no segments are in flight and we have queued segments, but</span>
<span style="color: #75715E;"> * cannot send anything now because of SWS or another problem.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_write_xmit</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mss_now</span>,  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;&#26377;&#25928;&#30340;MSS</span>
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">nonagle</span>)  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#34920;&#31034;&#26159;&#21542;&#21551;&#29992;nagle&#31639;&#27861;</span>
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">tso_segs</span>, <span style="color: #FD971F;">sent_pkts</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cwnd_quota</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">result</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">If we are closed, the bytes will have to remain here.</span>
<span style="color: #75715E;">         * In time closedown will finish, we empty the write queue and all</span>
<span style="color: #75715E;">         * will be happy.</span>
<span style="color: #75715E;">         */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">TCP_CLOSE&#29366;&#24577;&#21017;&#31435;&#21363;&#36820;&#22238;</span>
        <span style="color: #F92672;">if</span> (unlikely(sk-&gt;sk_state == TCP_CLOSE))
                <span style="color: #F92672;">return</span> 0;

        sent_pkts = 0; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#32479;&#35745;&#20989;&#25968;&#20013;&#24050;&#21457;&#36865;&#27573;&#25968;</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Do MTU probing.</span><span style="color: #75715E;"> */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#19968;&#20010;&#36335;&#24452;MTU&#25506;&#27979;&#27573;</span>
        <span style="color: #F92672;">if</span> ((result = tcp_mtu_probe(sk)) == 0) {
                <span style="color: #F92672;">return</span> 0;
        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (result &gt; 0) {<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#25104;&#21151;&#65292;&#21017;send_pkts+1</span>
                sent_pkts = 1;
        }

        <span style="color: #F92672;">while</span> ((skb = sk-&gt;sk_send_head)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#38431;&#21015;&#19981;&#20026;&#31354;</span>
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">limit</span>;
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35774;&#32622;tso&#30456;&#20851;&#30340;&#20449;&#24687;&#65288;GSO&#31867;&#22411;&#12289;GSO&#20998;&#27573;&#22823;&#23567;&#31561;&#65289;&#65292;&#29992;&#20110;&#36719;&#20214;TSO&#20998;&#27573;&#20351;&#29992;&#12290;</span>
<span style="color: #75715E;">                &#24403;&#32593;&#32476;&#35774;&#22791;&#19981;&#25903;&#25345;TSO,&#20294;&#21448;&#20351;&#29992;&#20102;TSO&#21151;&#33021;&#65292;&#21017;&#27573;&#22312;&#25552;&#20132;&#32473;&#32593;&#32476;&#35774;&#22791;&#20043;&#21069;&#36827;&#34892;&#36719;&#20998;&#27573;</span><span style="color: #75715E;">*/</span>
                tso_segs = tcp_init_tso_segs(sk, skb, mss_now);
                BUG_ON(<span style="color: #E6DB74; font-weight: bold;">!</span>tso_segs);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;&#25317;&#22622;&#31383;&#21475;&#22823;&#23567;&#65292;&#20026;0,&#21017;&#35828;&#26126;&#25317;&#22622;&#31383;&#21475;&#24050;&#28385;&#65292;&#19981;&#33021;&#21457;&#36865;</span>
                cwnd_quota = tcp_cwnd_test(tp, skb);
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>cwnd_quota)
                        <span style="color: #F92672;">break</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;&#27573;&#26159;&#21542;&#23436;&#20840;&#22312;&#21457;&#36865;&#31383;&#21475;&#20869;&#65292;&#26159;&#21017;&#21487;&#20197;&#21457;&#36865;</span>
                <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>tcp_snd_wnd_test(tp, skb, mss_now)))
                        <span style="color: #F92672;">break</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">tso_segs&#20026;1&#21017;&#26080;&#38656;TSO&#20998;&#27573;&#65292;&#26816;&#27979;&#26159;&#21542;&#20351;&#29992;nagle&#31639;&#27861;&#65292;&#24182;&#30830;&#23450;&#33021;&#21542;&#31435;&#21363;&#21457;&#36865;&#35813;&#27573;</span>
                <span style="color: #F92672;">if</span> (tso_segs == 1) {
                        <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>tcp_nagle_test(tp, skb, mss_now,
                                                     (tcp_skb_is_last(sk, skb) ?
                                                      nonagle : TCP_NAGLE_PUSH))))
                                <span style="color: #F92672;">break</span>;
                } <span style="color: #F92672;">else</span> { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#38656;&#35201;TSO&#20998;&#27573;&#65292;&#21017;&#26816;&#27979;&#35813;&#27573;&#26159;&#21542;&#24310;&#26102;&#21457;&#36865;</span>
                        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#24403;&#27573;&#20013;&#26377;FIN&#26631;&#24535;&#65292;&#25110;&#32773;&#19981;&#22788;&#20110;Open&#25317;&#22622;&#29366;&#24577;&#65292;&#25110;&#32773;TSO&#27573;&#24310;&#26102;&#36229;&#36807;2&#20010;&#26102;&#38047;&#25269;&#36798;&#65292;</span>
<span style="color: #75715E;">                        &#25110;&#32773;&#25317;&#22622;&#31383;&#21475;&#21644;&#21457;&#36865;&#31383;&#21475;&#30340;&#26368;&#23567;&#20540;&#22823;&#20110;64KB&#25110;&#19977;&#20493;&#30340;&#24403;&#21069;&#26377;&#25928;MSS,&#36825;&#20123;&#24773;&#20917;&#19979;&#20250;&#31435;&#21363;&#21457;&#36865;&#65292;</span>
<span style="color: #75715E;">                        &#20854;&#20182;&#24773;&#20917;&#24310;&#26102;&#21457;&#36865;&#12290; &#36825;&#26679;&#20570;&#20027;&#35201;&#20026;&#20102;&#20943;&#23569;&#36719;GSO&#20998;&#27573;&#30340;&#27425;&#25968;&#65292;&#25552;&#39640;&#24615;&#33021;</span><span style="color: #75715E;">*/</span>
                        <span style="color: #F92672;">if</span> (tcp_tso_should_defer(sk, tp, skb))
                                <span style="color: #F92672;">break</span>;
                }

                <span style="color: #E6DB74;">/** &#26681;&#25454;&#26465;&#20214;&#21487;&#33021;&#38656;&#35201;&#23545;SKB&#20013;&#30340;&#27573;&#36827;&#34892;&#20998;&#27573;&#22788;&#29702;&#65292;&#20998;&#27573;&#30340;&#27573;&#21253;&#25324;&#20004;&#31181;&#65306; &#19968;&#31181;&#26159;&#26222;&#36890;&#30340;&#25317;MSS&#20998;&#27573;&#30340;&#27573;&#65292;</span>
<span style="color: #E6DB74;">                &#21478;&#19968;&#31181;&#26159;TSO&#20998;&#27573;&#30340;&#27573;&#12290;&#33021;&#21542;&#21457;&#36865;&#21462;&#20915;&#19982;&#20004;&#20010;&#26465;&#20214;&#65306; &#27573;&#38656;&#35201;&#23436;&#20840;&#22788;&#20110;&#21457;&#36865;&#31383;&#21475;&#20869;&#65292;&#25317;&#22622;&#31383;&#21475;&#26410;&#28385;&#12290;</span>
<span style="color: #E6DB74;">                &#31532;&#19968;&#31181;&#27573;&#65292;&#24212;&#35813;&#19981;&#20250;&#20877;&#27425;&#20998;&#27573;&#20102;&#65292;&#22240;&#20026;&#22312;tcp_sendmsg&#20013;&#21019;&#24314;&#27573;&#30340;SKB&#26102;&#24050;&#32463;&#26681;&#25454;MSS&#22788;&#29702;&#12290;</span>
<span style="color: #E6DB74;">                &#31532;&#20108;&#31181;&#27573;&#65292;&#19968;&#33324;&#24773;&#20917;&#37117;&#20250;&#22823;&#20110;MSS,&#22240;&#27492;&#36890;&#36807;TSO&#20998;&#27573;&#30340;&#27573;&#21487;&#33021;&#22823;&#20110;&#25317;&#22622;&#31383;&#21475;&#21097;&#20313;&#31354;&#38388;&#65292;&#22914;&#26524;&#26159;&#36825;&#31181;&#24773;&#20917;&#65292;</span>
<span style="color: #E6DB74;">                &#23601;&#38656;&#35201;&#20197;&#21457;&#36865;&#31383;&#21475;&#21644;&#25317;&#22622;&#31383;&#21475;&#30340;&#26368;&#23567;&#20540;&#20316;&#20026;&#27573;&#38271;&#23545;&#25968;&#25454;&#21253;&#20877;&#27425;&#20998;&#27573;&#12290;</span>
<span style="color: #E6DB74;">                */</span>
                limit = mss_now; <span style="color: #75715E;">//</span><span style="color: #75715E;">limit&#26159;&#20877;&#27425;&#20998;&#27573;&#30340;&#27573;&#38271;&#65292;&#21021;&#22987;&#21270;&#20026;&#24403;&#21069;MSS</span>
                <span style="color: #F92672;">if</span> (tso_segs &gt; 1) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;TSO&#20998;&#27573;&#26102;&#65292;&#25165;&#36827;&#34892;&#22788;&#29702;</span>
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20197;&#21457;&#36865;&#31383;&#21475;&#21644;&#25317;&#22622;&#31383;&#21475;&#30340;&#26368;&#23567;&#20540;&#20316;&#20026;&#20998;&#27573;&#27573;&#38271;</span>
                        limit = tcp_window_allows(tp, skb,
                                                  mss_now, cwnd_quota);
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20877;&#27425;&#20998;&#27573;&#30340;&#27573;&#38271;&#22823;&#20110;SKB&#30340;&#38271;&#24230;&#65292;&#21017;&#37325;&#26032;&#35745;&#31639;</span>
                        <span style="color: #F92672;">if</span> (skb-&gt;len &lt; limit) {
                                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">trim</span> = skb-&gt;len % mss_now;
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25130;&#21462;&#21462;SKB&#38271;&#24230;&#30340;MSS&#30340;&#25972;&#25968;&#20493;</span>
                                <span style="color: #F92672;">if</span> (trim)
                                        limit = skb-&gt;len - trim;
                        }
                }

                <span style="color: #F92672;">if</span> (skb-&gt;len &gt; limit &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">SKB&#38271;&#24230;&#22823;&#20110;&#20998;&#27573;&#38271;&#24230;&#65292;&#21017;&#36890;&#36807;tso_fragment&#20998;&#27573;</span>
                    unlikely(tso_fragment(sk, skb, limit, mss_now)))
                        <span style="color: #F92672;">break</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35760;&#24405;&#27492;&#27573;&#30340;&#21457;&#36865;&#26102;&#38388;&#65292;&#29992;&#20110;RTT&#35745;&#31639;</span>
                TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;TCP&#27573;&#65292;&#31532;&#19977;&#20010;&#21442;&#25968;&#34920;&#31034;&#38656;&#35201;&#20811;&#38534;&#34987;&#21457;&#36865;&#30340;&#27573;&#12290;</span>
                <span style="color: #F92672;">if</span> (unlikely(tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC)))
                        <span style="color: #F92672;">break</span>;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Advance the send_head.  This one is sent out.</span>
<span style="color: #75715E;">                 * This call will increment packets_out.</span>
<span style="color: #75715E;">                 *//*</span><span style="color: #75715E;">&#26356;&#26032;sk_send_head&#65288;&#21457;&#36865;&#38431;&#21015;&#30340;&#19979;&#19968;&#20010;SKB&#65289;&#65292;&#21516;&#26102;&#26356;&#26032;snd_nxt(&#19979;&#19968;&#20010;&#21457;&#36865;&#30340;&#24207;&#21495;)&#12290;</span>
<span style="color: #75715E;">                 &#20043;&#21518;&#32479;&#35745;&#21457;&#20986;&#20294;&#27809;&#26377;&#24471;&#21040;&#30830;&#35748;&#30340;&#25968;&#25454;&#25253;&#25968;&#12290;&#26368;&#21518;&#22914;&#26524;&#21457;&#36865;&#35813;&#27573;&#21069;&#27809;&#26377;&#38656;&#35201;&#30830;&#35748;&#30340;&#27573;&#65292;&#21017;&#22797;&#20301;&#37325;&#20256;&#23450;&#26102;&#22120;&#65292;</span>
<span style="color: #75715E;">                 &#23545;&#26412;&#27425;&#21457;&#36865;&#30340;&#27573;&#20316;&#37325;&#20256;&#36229;&#26102;&#35745;&#26102;</span><span style="color: #75715E;">*/</span>
                update_send_head(sk, tp, skb);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#21457;&#36865;&#30340;&#27573;&#23567;&#20110;MSS,&#21017;&#26356;&#26032;&#26368;&#36817;&#21457;&#36865;&#30340;&#23567;&#21253;&#30340;&#26368;&#21518;&#19968;&#20010;&#23383;&#33410;&#24207;&#21495;</span>
                tcp_minshall_update(tp, mss_now, skb);
                sent_pkts++; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#21457;&#36865;&#27573;&#25968;</span>
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26412;&#27425;&#26377;&#25968;&#25454;&#21457;&#36865;&#65292;&#21017;&#23545;TCP&#25317;&#22622;&#31383;&#21475;&#36827;&#34892;&#30830;&#35748;</span>
        <span style="color: #F92672;">if</span> (likely(sent_pkts)) {
                tcp_cwnd_validate(sk, tp);
                <span style="color: #F92672;">return</span> 0;
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#26412;&#27425;&#27809;&#26377;&#25968;&#25454;&#21457;&#36865;&#65292;&#26681;&#25454;&#24050;&#32463;&#21457;&#36865;&#20294;&#27809;&#34987;&#30830;&#35748;&#30340;&#27573;&#25968;packets_out&#21644;sk_send_head&#36820;&#22238;&#65292;</span>
<span style="color: #75715E;">        packets_out&#19981;&#20026;&#38646;&#25110;sk_send_head&#20026;&#31354;&#37117;&#35270;&#20026;&#26377;&#25968;&#25454;&#21457;&#20986;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">return</span> <span style="color: #E6DB74; font-weight: bold;">!</span>tp-&gt;packets_out &amp;&amp; sk-&gt;sk_send_head;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgba10666" class="outline-4">
<h4 id="orgba10666"><span class="section-number-4">3.3.2.</span> 输出到网络层：tcp_transmit_skb()</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
该函数会给带发送的段构造TCP首部，然后调用网络层接口到IP层，最终到达网络设备。由于在成功发送到网络设备后会释放该SKB，而TCP需要在接收到确认后才能真正释放数据，因此在发送前会根据参数确定是克隆还是复制一份SKB用于发送。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">This routine actually transmits TCP packets queued in by</span>
<span style="color: #75715E;"> * tcp_do_sendmsg().  This is used by both the initial</span>
<span style="color: #75715E;"> * transmission and possible later retransmissions.</span>
<span style="color: #75715E;"> * All SKB's seen here are completely headerless.  It is our</span>
<span style="color: #75715E;"> * job to build the TCP header, and pass the packet down to</span>
<span style="color: #75715E;"> * IP so it can do the same plus pass the packet off to the</span>
<span style="color: #75715E;"> * device.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * We are working here with either a clone of the original</span>
<span style="color: #75715E;"> * SKB, or a fresh unique copy made by the retransmit engine.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_transmit_skb</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24453;&#21457;&#36865;&#30340;&#27573;</span>
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">clone_it</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#20811;&#38534;</span>
<span style="color: #66D9EF;">gfp_t</span> <span style="color: #FD971F;">gfp_mask</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20811;&#38534;&#25110;&#22797;&#21046;SKB&#26102;&#20998;&#37197;&#20869;&#23384;&#30340;&#26041;&#24335;</span>
{
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_skb_cb</span> *<span style="color: #FD971F;">tcb</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">tcp_header_size</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_md5sig_key</span> *<span style="color: #FD971F;">md5</span>;
        <span style="color: #66D9EF;">__u8</span> *<span style="color: #FD971F;">md5_hash_location</span>;
<span style="color: #F92672;">#endif</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *<span style="color: #FD971F;">th</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">sysctl_flags</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;

        BUG_ON(<span style="color: #E6DB74; font-weight: bold;">!</span>skb || <span style="color: #E6DB74; font-weight: bold;">!</span>tcp_skb_pcount(skb));

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">If congestion control is doing timestamping, we must</span>
<span style="color: #75715E;">         * take such a timestamp before we potentially clone/copy.</span>
<span style="color: #75715E;">         */</span> <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#25317;&#22622;&#25511;&#21046;&#35201;&#20316;&#26102;&#38388;&#37319;&#26679;&#65292;&#21017;&#24517;&#39035;&#35774;&#32622;&#19968;&#20010;&#26102;&#38388;&#25139;&#65292;&#20043;&#21518;&#22312;&#20811;&#38534;&#25110;&#22797;&#21046;&#25968;&#25454;&#21253;&#12290;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (icsk-&gt;icsk_ca_ops-&gt;rtt_sample)
                __net_timestamp(skb);

        <span style="color: #F92672;">if</span> (likely(clone_it)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20811;&#38534;</span>
                <span style="color: #F92672;">if</span> (unlikely(skb_cloned(skb))) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#35813;&#25968;&#25454;&#21253;&#24050;&#32463;&#34987;&#20811;&#38534;&#65292;&#21017;&#21482;&#33021;&#22797;&#21046;SKB</span>
                        skb = pskb_copy(skb, gfp_mask);
                <span style="color: #F92672;">else</span><span style="color: #75715E;">//</span><span style="color: #75715E;">&#21542;&#21017;&#20811;&#38534;SKB</span>
                        skb = skb_clone(skb, gfp_mask);
                <span style="color: #F92672;">if</span> (unlikely(<span style="color: #E6DB74; font-weight: bold;">!</span>skb)) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22797;&#21046;&#25110;&#20811;&#38534;&#22833;&#36133;</span>
                        <span style="color: #F92672;">return</span> -ENOBUFS;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;INET&#23618;&#21644;TCP&#23618;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#12289;SKB&#20013;&#30340;TCP&#31169;&#26377;&#25511;&#21046;&#22359;&#20197;&#21450;&#24403;&#21069;TCP&#39318;&#37096;&#38271;&#24230;</span>
        inet = inet_sk(sk);
        tp = tcp_sk(sk);
        tcb = TCP_SKB_CB(skb);
        tcp_header_size = tp-&gt;tcp_header_len;

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20197;&#19979;&#26681;&#25454;TCP&#36873;&#39033;&#37325;&#26032;&#35843;&#25972;TCP&#39318;&#37096;&#38271;&#24230;&#65292;&#19977;&#20010;&#23439;&#23450;&#20041;&#20027;&#35201;&#29992;&#20110;SYN&#27573;&#20013;&#26631;&#24535;&#23545;&#24212;&#30340;TCP&#36873;&#39033;</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYSCTL_FLAG_TSTAMPS</span>     0x1
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYSCTL_FLAG_WSCALE</span>      0x2
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">SYSCTL_FLAG_SACK</span>        0x4

        sysctl_flags = 0; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#26631;&#35782;TCP&#27573;&#30340;&#21508;&#31181;&#36873;&#39033;</span>
        <span style="color: #F92672;">if</span> (unlikely(tcb-&gt;flags &amp; TCPCB_FLAG_SYN)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">SYN&#27573;&#22788;&#29702;</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24314;&#31435;&#36830;&#25509;&#26102;&#65292;&#24517;&#39035;&#36890;&#21578;&#26412;&#31471;&#30340;&#26368;&#22823;&#27573;&#38271;&#24230;&#65292;&#35813;&#36873;&#39033;&#21482;&#33021;&#20986;&#29616;&#22312;SYN&#27573;&#20013;</span>
                tcp_header_size = <span style="color: #F92672;">sizeof</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span>) + TCPOLEN_MSS;
                <span style="color: #F92672;">if</span>(sysctl_tcp_timestamps) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#38656;&#35201;&#21152;&#20837;&#26102;&#38388;&#25139;&#36873;&#39033;</span>
                        tcp_header_size += TCPOLEN_TSTAMP_ALIGNED;
                        sysctl_flags |= SYSCTL_FLAG_TSTAMPS;
                }
                <span style="color: #F92672;">if</span> (sysctl_tcp_window_scaling) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#22686;&#21152;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#36873;&#39033;</span>
                        tcp_header_size += TCPOLEN_WSCALE_ALIGNED;
                        sysctl_flags |= SYSCTL_FLAG_WSCALE;
                }
                <span style="color: #F92672;">if</span> (sysctl_tcp_sack) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#21152;&#20837;&#20801;&#35768;SACK&#36873;&#39033;</span>
                        sysctl_flags |= SYSCTL_FLAG_SACK;
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(sysctl_flags &amp; SYSCTL_FLAG_TSTAMPS))
                                tcp_header_size += TCPOLEN_SACKPERM_ALIGNED;
                }
        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (unlikely(tp-&gt;rx_opt.eff_sacks)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;SACK&#22359;&#25968;eff_sacks&#65292;&#20877;&#27425;&#35843;&#25972;TCP&#39318;&#37096;&#38271;&#24230;</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">A SACK is 2 pad bytes, a 2 byte header, plus</span>
<span style="color: #75715E;">                 * 2 32-bit sequence numbers for each SACK block.</span>
<span style="color: #75715E;">                 */</span>
                tcp_header_size += (TCPOLEN_SACK_BASE_ALIGNED +
                                    (tp-&gt;rx_opt.eff_sacks *
                                     TCPOLEN_SACK_PERBLOCK));
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24050;&#32463;&#21457;&#20986;&#30340;&#26410;&#30830;&#35748;&#30340;&#25968;&#25454;&#21253;&#25968;&#20026;0,&#21017;&#21482;&#21021;&#22987;&#21270;&#25317;&#22622;&#25511;&#21046;&#65292;&#24182;&#24320;&#22987;&#36319;&#36394;&#35813;&#36830;&#25509;&#30340;RTT.</span>
        <span style="color: #F92672;">if</span> (tcp_packets_in_flight(tp) == 0)
                tcp_ca_event(sk, CA_EVENT_TX_START);

<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * Are we doing MD5 on this segment? If so - make</span>
<span style="color: #75715E;">         * room for it.</span>
<span style="color: #75715E;">         */</span>
        md5 = tp-&gt;af_specific-&gt;md5_lookup(sk, sk);
        <span style="color: #F92672;">if</span> (md5)
                tcp_header_size += TCPOLEN_MD5SIG_ALIGNED;
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22312;&#25968;&#25454;&#37096;&#20998;&#30340;&#22836;&#37096;&#28155;&#21152;TCP&#39318;&#37096;&#65292;&#38271;&#24230;&#20026;&#19978;&#38754;&#35745;&#31639;&#30340;tcp_header_size</span>
        th = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcphdr</span> *) skb_push(skb, tcp_header_size);
        skb-&gt;h.th = th;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20445;&#23384;&#39318;&#37096;&#22320;&#22336;&#65292;&#20415;&#20110;&#21518;&#32493;&#35775;&#38382;</span>
        skb_set_owner_w(skb, sk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#35813;SKB&#30340;&#23487;&#20027;&#65292;&#65288;SKB&#23646;&#20110;&#21738;&#20010;&#20256;&#36755;&#25511;&#21046;&#22359;&#65289;</span>

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22635;&#20805;TCP&#39318;&#37096;&#30340;&#31471;&#21475;&#12289;&#24207;&#21495;&#12289;&#30830;&#35748;&#24207;&#21495;&#20197;&#21450;&#26631;&#24535;&#20301;&#31561;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Build TCP header and checksum it.</span><span style="color: #75715E;"> */</span>
        th-&gt;source              = inet-&gt;sport;
        th-&gt;dest                = inet-&gt;dport;
        th-&gt;seq                 = htonl(tcb-&gt;seq);
        th-&gt;ack_seq             = htonl(tp-&gt;rcv_nxt);
        *(((<span style="color: #66D9EF;">__be16</span> *)th) + 6)   = htons(((tcp_header_size &gt;&gt; 2) &lt;&lt; 12) |
                                        tcb-&gt;flags);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;TCP&#39318;&#37096;&#30340;&#25509;&#25910;&#31383;&#21475;</span>
        <span style="color: #F92672;">if</span> (unlikely(tcb-&gt;flags &amp; TCPCB_FLAG_SYN)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">syn&#27573;&#30340;&#21021;&#22987;&#20540;&#20026;rcv_wnd</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">RFC1323: The window in SYN &amp; SYN/ACK segments</span>
<span style="color: #75715E;">                 * is never scaled.</span>
<span style="color: #75715E;">                 */</span>
                th-&gt;window      = htons(tp-&gt;rcv_wnd);
        } <span style="color: #F92672;">else</span> { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20854;&#20182;&#27573;&#65292;&#21017;&#35843;&#29992;tcp_select_window&#35745;&#31639;&#24403;&#21069;&#25509;&#25910;&#31383;&#21475;&#30340;&#22823;&#23567;</span>
                th-&gt;window      = htons(tcp_select_window(sk));
        }
        th-&gt;check               = 0;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26657;&#39564;&#30721;</span>
        th-&gt;urg_ptr     = 0; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32039;&#24613;&#25351;&#38024;</span>

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26159;&#21542;&#38656;&#35201;&#35774;&#32622;&#32039;&#24613;&#25351;&#38024;&#21644;&#24102;&#22806;&#25968;&#25454;&#26631;&#24535;</span>
        <span style="color: #F92672;">if</span> (unlikely(tp-&gt;urg_mode &amp;&amp; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#26102;&#35774;&#32622;&#20102;&#32039;&#24613;&#26041;&#24335;</span>
                     <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24182;&#19988;&#32039;&#24613;&#25351;&#38024;&#22312;&#20197;&#35813;&#25253;&#25991;&#25968;&#25454;&#24207;&#21495;&#20026;&#36215;&#22987;&#30340;65535&#30340;&#33539;&#22260;&#20869;</span>
                     between(tp-&gt;snd_up, tcb-&gt;seq+1, tcb-&gt;seq+0xFFFF))) {
                th-&gt;urg_ptr             = htons(tp-&gt;snd_up-tcb-&gt;seq); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#32039;&#24613;&#25351;&#38024;</span>
                th-&gt;urg                 = 1;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#24102;&#22806;&#25968;&#25454;&#26631;&#24535;</span>
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26500;&#24314;TCP&#39318;&#37096;&#36873;&#39033;&#65292;syn&#27573;&#20351;&#29992;tcp_syn_build_options&#65292;&#20854;&#20182;&#27573;&#20351;&#29992;tcp_build_and_update_options</span>
        <span style="color: #F92672;">if</span> (unlikely(tcb-&gt;flags &amp; TCPCB_FLAG_SYN)) {
                tcp_syn_build_options((<span style="color: #66D9EF;">__be32</span> *)(th + 1),
                                      tcp_advertise_mss(sk),
                                      (sysctl_flags &amp; SYSCTL_FLAG_TSTAMPS),
                                      (sysctl_flags &amp; SYSCTL_FLAG_SACK),
                                      (sysctl_flags &amp; SYSCTL_FLAG_WSCALE),
                                      tp-&gt;rx_opt.rcv_wscale,
                                      tcb-&gt;when,
                                      tp-&gt;rx_opt.ts_recent,

<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
                                      md5 ? &amp;md5_hash_location :
<span style="color: #F92672;">#endif</span>
                                      <span style="color: #AE81FF;">NULL</span>);
        } <span style="color: #F92672;">else</span> {
                tcp_build_and_update_options((<span style="color: #66D9EF;">__be32</span> *)(th + 1),
                                             tp, tcb-&gt;when,
<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
                                             md5 ? &amp;md5_hash_location :
<span style="color: #F92672;">#endif</span>
                                             <span style="color: #AE81FF;">NULL</span>);
                TCP_ECN_send(sk, tp, skb, tcp_header_size);
        }

<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Calculate the MD5 hash, as we have all we need now</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (md5) {
                tp-&gt;af_specific-&gt;calc_md5_hash(md5_hash_location,
                                               md5,
                                               sk, <span style="color: #AE81FF;">NULL</span>, <span style="color: #AE81FF;">NULL</span>,
                                               skb-&gt;h.th,
                                               sk-&gt;sk_protocol,
                                               skb-&gt;len);
        }
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;IPv4&#25191;&#34892;&#26657;&#39564;&#21644;&#30340;&#25509;&#21475;send_check&#35745;&#31639;&#26657;&#39564;&#21644;&#65292;&#24182;&#35774;&#32622;&#21040;TCP&#39318;&#37096;&#65288;tcp_v4_send_check()&#65289;</span>
        icsk-&gt;icsk_af_ops-&gt;send_check(sk, skb-&gt;len, skb);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#20986;&#21435;&#30340;&#27573;&#26377;ACK&#26631;&#24535;&#65292;&#21017;&#38656;&#35201;&#36890;&#30693;&#24310;&#26102;&#30830;&#35748;&#27169;&#22359;&#65292;&#36882;&#20943;&#24555;&#36895;&#21457;&#36865;ACK&#27573;&#30340;&#25968;&#37327;&#65292;&#21516;&#26102;&#20572;&#27490;&#24310;&#26102;&#30830;&#35748;&#23450;&#26102;&#22120;&#12290;</span>
        <span style="color: #F92672;">if</span> (likely(tcb-&gt;flags &amp; TCPCB_FLAG_ACK))
                tcp_event_ack_sent(sk, tcp_skb_pcount(skb));
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21457;&#36865;TCP&#27573;&#26377;&#36127;&#36733;&#65292;&#21017;&#26816;&#27979;&#25317;&#22622;&#31383;&#21475;&#38386;&#32622;&#26159;&#21542;&#36229;&#26102;&#65292;&#20351;&#20854;&#22833;&#25928;&#12290;&#24182;&#35760;&#24405;TCP&#21457;&#36865;&#26102;&#38388;&#65292;</span>
<span style="color: #75715E;">        &#26681;&#25454;&#26368;&#36817;&#25509;&#25910;&#27573;&#30340;&#26102;&#38388;&#65292;&#30830;&#23450;&#26412;&#31471;&#24310;&#26102;&#30830;&#35748;&#26159;&#21542;&#36827;&#20837;pingpong&#27169;&#24335;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (skb-&gt;len != tcp_header_size)
                tcp_event_data_sent(tp, skb, sk);

        <span style="color: #F92672;">if</span> (after(tcb-&gt;end_seq, tp-&gt;snd_nxt) || tcb-&gt;seq == tcb-&gt;end_seq)
                TCP_INC_STATS(TCP_MIB_OUTSEGS);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;&#21457;&#36865;&#25509;&#21475;queue_xmit&#21457;&#36865;&#25253;&#25991;&#65292;TCP&#20013;&#23454;&#29616;&#20026;ip_queue_xmit()</span>
        err = icsk-&gt;icsk_af_ops-&gt;queue_xmit(skb, 0);
        <span style="color: #F92672;">if</span> (likely(err &lt;= 0))
                <span style="color: #F92672;">return</span> err;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#22833;&#36133;&#26102;&#65292;&#31867;&#20284;&#25509;&#25910;&#21040;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;&#65292;&#20351;&#29992;&#22622;&#25511;&#21046;&#36827;&#20837;CWR&#29366;&#24577;&#12290;</span>
        tcp_enter_cwr(sk);

        <span style="color: #F92672;">return</span> net_xmit_eval(err);

<span style="color: #F92672;">#undef</span> SYSCTL_FLAG_TSTAMPS
<span style="color: #F92672;">#undef</span> SYSCTL_FLAG_WSCALE
<span style="color: #F92672;">#undef</span> SYSCTL_FLAG_SACK
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org836dfdb" class="outline-4">
<h4 id="org836dfdb"><span class="section-number-4">3.3.3.</span> 输出发送队列上的第一个段：tcp_push_one()</h4>
<div class="outline-text-4" id="text-3-3-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Send _single_ skb sitting at the send head. This function requires</span>
<span style="color: #75715E;"> * true push pending frames to setup probe timer etc.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">tcp_push_one</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mss_now</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span> = sk-&gt;sk_send_head;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">tso_segs</span>, <span style="color: #FD971F;">cwnd_quota</span>;

        BUG_ON(<span style="color: #E6DB74; font-weight: bold;">!</span>skb || skb-&gt;len &lt; mss_now);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#19982;GSO&#30456;&#20851;&#30340;&#35201;&#32032;&#65292;&#33719;&#21462;gso_segs,&#29992;&#26469;&#35745;&#31639;&#26412;&#27425;&#21457;&#36865;&#30340;&#25968;&#25454;&#38271;&#24230;</span>
        tso_segs = tcp_init_tso_segs(sk, skb, mss_now);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#30446;&#21069;&#26159;&#21542;&#21487;&#20197;&#31435;&#21363;&#21457;&#36865;&#65292;&#21487;&#20197;&#21017;&#33719;&#21462;&#24403;&#21069;&#25317;&#22622;&#31383;&#21475;&#30340;&#26410;&#20351;&#29992;&#37327;&#65292;&#29992;&#20110;&#21028;&#26029;&#25317;&#22622;&#31383;&#21475;&#26159;&#21542;&#36824;&#26377;&#37197;&#39069;&#29992;&#26469;&#21457;&#36865;&#12290;</span>
        cwnd_quota = tcp_snd_test(sk, skb, mss_now, TCP_NAGLE_PUSH);
        <span style="color: #75715E;">//</span>
        <span style="color: #F92672;">if</span> (likely(cwnd_quota)) {
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">limit</span>;

                BUG_ON(<span style="color: #E6DB74; font-weight: bold;">!</span>tso_segs);

                limit = mss_now;
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#35745;&#31639;&#26412;&#27425;&#21457;&#36865;&#30340;&#25968;&#25454;&#38271;&#24230;&#12290;&#22914;&#26524;&#26412;&#27425;&#21457;&#36865;&#30340;TCP&#27573;&#19981;&#26159;GSO&#22823;&#27573;&#65292;&#21017;&#26412;&#27425;&#21457;&#36865;&#30340;&#25968;&#25454;&#38271;&#24230;&#20026;&#24403;&#21069;&#30340;MSS&#12290;</span>
<span style="color: #75715E;">                &#21542;&#21017;&#21462;&#35813;&#22823;&#27573;&#21644;&#25509;&#25910;&#26041;&#25509;&#25910;&#31383;&#21475;&#30340;&#36739;&#23567;&#20540;&#20316;&#20026;&#21457;&#36865;&#38271;&#24230;&#65292;&#22914;&#26524;&#35813;&#22823;&#27573;&#30340;&#38271;&#24230;&#23567;&#20110;&#24403;&#21069;&#33719;&#21462;&#30340;&#21457;&#36865;&#38271;&#24230;&#65292;</span>
<span style="color: #75715E;">                &#19988;&#35813;&#22823;&#27573;&#30340;&#38271;&#24230;&#19981;&#26159;&#24403;&#21069;MSS&#30340;&#25972;&#25968;&#20493;&#65292;&#21017;&#20462;&#27491;&#20854;&#38271;&#24230;&#20026;MSS&#25972;&#25968;&#20493;</span><span style="color: #75715E;">*/</span>
                <span style="color: #F92672;">if</span> (tso_segs &gt; 1) {
                        limit = tcp_window_allows(tp, skb,
                                                  mss_now, cwnd_quota);

                        <span style="color: #F92672;">if</span> (skb-&gt;len &lt; limit) {
                                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">trim</span> = skb-&gt;len % mss_now;

                                <span style="color: #F92672;">if</span> (trim)
                                        limit = skb-&gt;len - trim;
                        }
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#35813;SKB&#30340;&#25968;&#25454;&#24635;&#38271;&#24230;&#22823;&#20110;&#33719;&#21462;&#30340;&#21457;&#36865;&#38271;&#24230;&#65292;&#21017;&#38656;&#35201;&#20998;&#27573;</span>
                <span style="color: #F92672;">if</span> (skb-&gt;len &gt; limit &amp;&amp;
                    unlikely(tso_fragment(sk, skb, limit, mss_now)))
                        <span style="color: #F92672;">return</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35760;&#24405;&#21457;&#36865;&#26102;&#38388;</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Send it out now.</span><span style="color: #75715E;"> */</span>
                TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#35813;&#25968;&#25454;&#27573;</span>
                <span style="color: #F92672;">if</span> (likely(<span style="color: #E6DB74; font-weight: bold;">!</span>tcp_transmit_skb(sk, skb, 1, sk-&gt;sk_allocation))) {
                        update_send_head(sk, tp, skb); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#21457;&#36865;&#38431;&#21015;&#22836;&#65292;&#21644;&#19979;&#19968;&#20010;&#21457;&#36865;&#27573;&#30340;&#24207;&#21495;&#20197;&#21450;&#19968;&#20123;&#32479;&#35745;&#25968;&#25454;&#12290;</span>
                        tcp_cwnd_validate(sk, tp);
                        <span style="color: #F92672;">return</span>;
                }
        }
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgc74d0cb" class="outline-4">
<h4 id="orgc74d0cb"><span class="section-number-4">3.3.4.</span> 输出发送队列上的tcp段：__tcp_push_pending_frames()</h4>
<div class="outline-text-4" id="text-3-3-4">
<p>
tcp_push()是调用__tcp_push_pending_frames()来实现输出发送队列上的TCP段。发送前需要根据flags标志确定是否添加PSH标志。带外数据则设置带外数据标志。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org2e8d8da" class="outline-2">
<h2 id="org2e8d8da"><span class="section-number-2">4.</span> 对TCP选项的处理</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgc6c73c2" class="outline-3">
<h3 id="orgc6c73c2"><span class="section-number-3">4.1.</span> 构建SYN段的选项</h3>
<div class="outline-text-3" id="text-4-1">
<p>
tcp_syn_build_options()为SYN或者SYN+ACK段构建TCP首部中的TCP选项。参数说明如下：
</p>
<ul class="org-ul">
<li>ptr: 生成的TCP选项，通常是TCP首部选项部分的地址</li>
<li>mss: 是否通告本端的MSS</li>
<li>ts: 是否启用TCP时间戳</li>
<li>sack: 是否启用SACK</li>
<li>offer_wscale: 是否允许窗口缩放</li>
<li>wscale: 窗口缩放的位移值</li>
<li>tstamp: 时间戳相关的输出时间</li>
<li>ts_recent: 时间戳相关的时间戳回显值</li>
<li>md5_hash: 是否使用tcp md5签名选项</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Construct a tcp options header for a SYN or SYN_ACK packet.</span>
<span style="color: #75715E;"> * If this is every changed make sure to change the definition of</span>
<span style="color: #75715E;"> * MAX_SYN_SIZE to match the new maximum number of options that you</span>
<span style="color: #75715E;"> * can generate.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * Note - that with the RFC2385 TCP option, we make room for the</span>
<span style="color: #75715E;"> * 16 byte MD5 hash. This will be filled in later, so the pointer for the</span>
<span style="color: #75715E;"> * location to be filled is passed back up.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">tcp_syn_build_options</span>(<span style="color: #66D9EF;">__be32</span> *<span style="color: #FD971F;">ptr</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mss</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ts</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">sack</span>,
                                  <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">offer_wscale</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">wscale</span>, <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">tstamp</span>,
                                  <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">ts_recent</span>, <span style="color: #66D9EF;">__u8</span> **<span style="color: #FD971F;">md5_hash</span>)
{
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We always get an MSS option.</span>
<span style="color: #75715E;">         * The option bytes which will be seen in normal data</span>
<span style="color: #75715E;">         * packets should timestamps be used, must be in the MSS</span>
<span style="color: #75715E;">         * advertised.  But we subtract them from tp-&gt;mss_cache so</span>
<span style="color: #75715E;">         * that calculations in tcp_sendmsg are simpler etc.</span>
<span style="color: #75715E;">         * So account for this fact here if necessary.  If we</span>
<span style="color: #75715E;">         * don't do this correctly, as a receiver we won't</span>
<span style="color: #75715E;">         * recognize data packets as being full sized when we</span>
<span style="color: #75715E;">         * should, and thus we won't abide by the delayed ACK</span>
<span style="color: #75715E;">         * rules correctly.</span>
<span style="color: #75715E;">         * SACKs don't matter, we never delay an ACK when we</span>
<span style="color: #75715E;">         * have any of those going out.</span>
<span style="color: #75715E;">         */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32452;&#25104;MSS&#36873;&#39033;&#65292;&#24314;&#31435;&#36830;&#25509;&#26102;&#65292;&#21452;&#26041;&#37117;&#38656;&#35201;&#36890;&#21578;&#21508;&#33258;&#30340;MSS</span>
        *ptr++ = htonl((TCPOPT_MSS &lt;&lt; 24) | (TCPOLEN_MSS &lt;&lt; 16) | mss);
        <span style="color: #F92672;">if</span> (ts) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#21551;&#29992;TCP&#26102;&#38388;&#25139;&#65292;&#21017;&#23558;&#26102;&#38388;&#25139;&#21152;&#20837;TCP&#36873;&#39033;</span>
                <span style="color: #F92672;">if</span>(sack)  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21551;&#29992;&#26102;&#38388;&#25139;&#21516;&#26102;&#20063;&#21551;&#29992;SACK&#36873;&#39033;&#65292;&#21017;&#21152;&#20837;&#36873;&#39033;&#20013;</span>
                        *ptr++ = htonl((TCPOPT_SACK_PERM &lt;&lt; 24) |
                                       (TCPOLEN_SACK_PERM &lt;&lt; 16) |
                                       (TCPOPT_TIMESTAMP &lt;&lt; 8) |
                                       TCPOLEN_TIMESTAMP);
                <span style="color: #F92672;">else</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#20801;&#35768;SACK&#36873;&#39033;</span>
                        *ptr++ = htonl((TCPOPT_NOP &lt;&lt; 24) |
                                       (TCPOPT_NOP &lt;&lt; 16) |
                                       (TCPOPT_TIMESTAMP &lt;&lt; 8) |
                                       TCPOLEN_TIMESTAMP);
                *ptr++ = htonl(tstamp);         <span style="color: #75715E;">/* </span><span style="color: #75715E;">TSVAL</span><span style="color: #75715E;"> */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22635;&#20805;&#26102;&#38388;&#25139;&#20540;</span>
                *ptr++ = htonl(ts_recent);      <span style="color: #75715E;">/* </span><span style="color: #75715E;">TSECR</span><span style="color: #75715E;"> */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26102;&#38388;&#25139;&#22238;&#26174;&#24212;&#31572;</span>
        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span>(sack) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#20801;&#35768;&#26102;&#38388;&#25139;&#65292;&#20801;&#35768;SACK</span>
                *ptr++ = htonl((TCPOPT_NOP &lt;&lt; 24) |
                               (TCPOPT_NOP &lt;&lt; 16) |
                               (TCPOPT_SACK_PERM &lt;&lt; 8) |
                               TCPOLEN_SACK_PERM);
        <span style="color: #F92672;">if</span> (offer_wscale) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20801;&#35768;&#31383;&#21475;&#32553;&#25918;</span>
                *ptr++ = htonl((TCPOPT_NOP &lt;&lt; 24) |
                               (TCPOPT_WINDOW &lt;&lt; 16) |
                               (TCPOLEN_WINDOW &lt;&lt; 8) |
                               (wscale));
<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #75715E;">/*</span>
<span style="color: #75715E;">         * If MD5 is enabled, then we set the option, and include the size</span>
<span style="color: #75715E;">         * (always 18). The actual MD5 hash is added just before the</span>
<span style="color: #75715E;">         * packet is sent.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #F92672;">if</span> (md5_hash) {
                *ptr++ = htonl((TCPOPT_NOP &lt;&lt; 24) |
                               (TCPOPT_NOP &lt;&lt; 16) |
                               (TCPOPT_MD5SIG &lt;&lt; 8) |
                               TCPOLEN_MD5SIG);
                *md5_hash = (<span style="color: #66D9EF;">__u8</span> *) ptr;
        }
<span style="color: #F92672;">#endif</span>
}
</pre>
</div>


<div id="org393f5cf" class="figure">
<p><img src="image/tcp-output/ts-sack.png" alt="ts-sack.png" />
</p>
<p><span class="figure-number">Figure 7: </span>允许时间戳和SACK</p>
</div>


<div id="orge23b55e" class="figure">
<p><img src="image/tcp-output/ts-nosack.png" alt="ts-nosack.png" />
</p>
<p><span class="figure-number">Figure 8: </span>允许时间戳，不允许SACK</p>
</div>


<div id="org4e9c6d0" class="figure">
<p><img src="image/tcp-output/ts-tsrc.png" alt="ts-tsrc.png" />
</p>
<p><span class="figure-number">Figure 9: </span>时间戳值和时间戳回显应答值</p>
</div>



<div id="orgb427736" class="figure">
<p><img src="image/tcp-output/nots-sack.png" alt="nots-sack.png" />
</p>
<p><span class="figure-number">Figure 10: </span>不允许时间戳，允许SACK</p>
</div>


<div id="org56253a9" class="figure">
<p><img src="image/tcp-output/offer-wscale.png" alt="offer-wscale.png" />
</p>
<p><span class="figure-number">Figure 11: </span>窗口扩大因子选项</p>
</div>
</div>
</div>


<div id="outline-container-orgbc8bf33" class="outline-3">
<h3 id="orgbc8bf33"><span class="section-number-3">4.2.</span> 构建非SYN段的选项：tcp_build_and_update_options()</h3>
<div class="outline-text-3" id="text-4-2">
<p>
该函数构建除了SYN和SYN+ACK之外的段的TCP选项。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">tcp_build_and_update_options</span>(<span style="color: #66D9EF;">__be32</span> *<span style="color: #FD971F;">ptr</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29983;&#25104;&#30340;TCP&#36873;&#39033;</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26500;&#24314;SYN&#27573;&#30340;&#20256;&#36755;&#25511;&#21046;&#22359;&#65292;&#21253;&#21547;&#21508;&#31181;&#36873;&#39033;&#20449;&#24687;</span>
<span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">tstamp</span>,  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26102;&#38388;&#25139;&#65292;&#27573;&#30340;&#36755;&#20986;&#26102;&#38388;</span>
<span style="color: #66D9EF;">__u8</span> **<span style="color: #FD971F;">md5_hash</span>)
{
        <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.tstamp_ok) {  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20801;&#35768;&#26102;&#38388;&#25139;&#36873;&#39033;</span>
                *ptr++ = htonl((TCPOPT_NOP &lt;&lt; 24) |
                               (TCPOPT_NOP &lt;&lt; 16) |
                               (TCPOPT_TIMESTAMP &lt;&lt; 8) |
                               TCPOLEN_TIMESTAMP);
                *ptr++ = htonl(tstamp);
                *ptr++ = htonl(tp-&gt;rx_opt.ts_recent);
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">eff_sacks&#26159;&#23558;&#35201;&#21457;&#36865;&#25253;&#25991;&#30340;SACK&#38431;&#21015;&#22823;&#23567;&#65292;&#26082;&#26377;&#22810;&#23569;&#20010;&#25968;&#25454;&#22359;&#24038;&#21491;&#36793;&#30028;&#20540;&#23545;&#65292; TCPOLEN_SACK_PERBLOCK&#26159;&#27599;&#20010;&#25968;&#25454;&#22359;&#24038;&#21491;&#36793;&#30028;&#20540;&#23545;&#30340;&#22823;&#23567;&#12290;&#27880;&#24847;&#22914;&#26524;&#26159;DACK,&#21017;eff_sacks&#26159;DACK&#38431;&#21015;&#30340;&#22823;&#23567;&#65292;&#22914;&#26524;&#26159;SACK,&#21017;&#26159;SACK&#38431;&#21015;&#30340;&#22823;&#23567;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.eff_sacks) {
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;SACK&#36873;&#39033;&#24635;&#38271;&#24230;</span>
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sack_block</span> *<span style="color: #FD971F;">sp</span> = tp-&gt;rx_opt.dsack ? tp-&gt;duplicate_sack : tp-&gt;selective_acks;
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">this_sack</span>;

                *ptr++ = htonl((TCPOPT_NOP  &lt;&lt; 24) |
                               (TCPOPT_NOP  &lt;&lt; 16) |
                               (TCPOPT_SACK &lt;&lt;  8) |
                               (TCPOLEN_SACK_BASE + (tp-&gt;rx_opt.eff_sacks *
                                                     TCPOLEN_SACK_PERBLOCK)));
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36941;&#21382;SACK&#38431;&#21015;&#65292;&#22635;&#20805;&#27599;&#20010;&#25968;&#25454;&#22359;&#24038;&#21491;&#36793;&#30028;&#20540;&#23545;</span>
                <span style="color: #F92672;">for</span>(this_sack = 0; this_sack &lt; tp-&gt;rx_opt.eff_sacks; this_sack++) {
                        *ptr++ = htonl(sp[this_sack].start_seq);
                        *ptr++ = htonl(sp[this_sack].end_seq);
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;DACK&#38431;&#21015;&#65292;&#21017;&#23558;dack&#38431;&#21015;&#28165;&#31354;&#65292;eff_sacks-1</span>
                <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.dsack) {
                        tp-&gt;rx_opt.dsack = 0;
                        tp-&gt;rx_opt.eff_sacks--;
                }
        }
<span style="color: #F92672;">#ifdef</span> CONFIG_TCP_MD5SIG
        <span style="color: #F92672;">if</span> (md5_hash) {
                *ptr++ = htonl((TCPOPT_NOP &lt;&lt; 24) |
                               (TCPOPT_NOP &lt;&lt; 16) |
                               (TCPOPT_MD5SIG &lt;&lt; 8) |
                               TCPOLEN_MD5SIG);
                *md5_hash = (<span style="color: #66D9EF;">__u8</span> *)ptr;
        }
<span style="color: #F92672;">#endif</span>
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org4ac180a" class="outline-2">
<h2 id="org4ac180a"><span class="section-number-2">5.</span> Nagle算法</h2>
<div class="outline-text-2" id="text-5">
<p>
为减少网络通信的开销，提升性能及吞吐速度，系统默认采用Nagle算法。若应用程序请求发送一批数据，系统在接收数据后，可能会延迟一段时间，等待数据累计到一定程度后一起发送。如果规定时间内没有新数据加入，则原先的数据也会被发送。这样会使得在单个TCP段内数据量增大。与之相反的则是使用多个TCP段，使每个段负载的数据量都比较少。如果是后一种情况，则每个段都会涉及首部的开销。采用Nagle算法后，更能有效的利用数据包的可用空间。该算法的另一个功能是确认消息的延迟发送。系统收到TCP数据之后，必须向对方发送ACK。采用该算法后，会等待一段时间，看系统是否有数据要发送给对方，以便能随发送数据一起反馈ACK，从而节省一个数据包的通信量。
</p>

<p>
但在某些情况下，会产生不利影响。例如网络应用通常只需要发送很少量的数据，同时要求能得到机器迅速的相应，那么在使用这种算法，反而影响性能，比如telnet，会导致显影迟钝。
</p>

<p>
tcp_nagel_test()用于检测在不考虑拥塞的情况下能否立即输出TCP段，检测到以下条件时，立即输出：
</p>
<ul class="org-ul">
<li>发送的是带外数据或有FIN标志的段。</li>
<li>待发送的段是全负荷段、没有启用Nagle算法或没有设置TCP_CORK标志，同时所有输出的段都已确认。</li>
</ul>
</div>
</div>


<div id="outline-container-org8449fad" class="outline-2">
<h2 id="org8449fad"><span class="section-number-2">6.</span> ACK的接收</h2>
<div class="outline-text-2" id="text-6">
<p>
接收已传输段的ACK，是发送方用来评估网络状况和数据传输状态和特性的基础。而ACK机制与数据传输状态和特性紧密关联体现在以下几个方面：
</p>
<ul class="org-ul">
<li>通过ACK可以是的发送方很容易的计算出数据的往返时间。</li>
<li>由于ACK段中携带了接收方的通告窗口，因此，此时接收方能够接收的数据上限为通告的接收窗口大小，接收到ACK后，在正常情况下会引发下一个段的发送。</li>
<li>通过拥塞窗口的调节，TCP可以进行限制性的传输，以免网络拥塞。从接收ACK可以判断和评估当前网络的状况，从而进一步调整拥塞窗口。</li>
</ul>
</div>

<div id="outline-container-org227b01e" class="outline-3">
<h3 id="org227b01e"><span class="section-number-3">6.1.</span> tcp_ack()</h3>
<div class="outline-text-3" id="text-6-1">
<p>
tcp_ack()用于处理接收到的有ACK标志的段，当接到有效的ACK后会更新发送窗口，发送窗口如下图：
</p>


<div id="orga42d114" class="figure">
<p><img src="image/tcp-output/send-wnd.png" alt="send-wnd.png" />
</p>
<p><span class="figure-number">Figure 12: </span>发送窗口</p>
</div>


<div id="org00884a2" class="figure">
<p><img src="image/tcp-output/tcp-ack.png" alt="tcp-ack.png" />
</p>
<p><span class="figure-number">Figure 13: </span>tcp_ack()流程图</p>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> tcp_ack()的flag参数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">flag</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">FLAG_DATA</td>
<td class="org-left">ACK段是由带有负荷数据的段携带的</td>
</tr>

<tr>
<td class="org-left">FLAG_WIN_UPDATE</td>
<td class="org-left">ACK段更新了发送窗口</td>
</tr>

<tr>
<td class="org-left">FLAG_DATA_ACKED</td>
<td class="org-left">ACK段确认了新的数据</td>
</tr>

<tr>
<td class="org-left">FLAG_RETRANS_DATA_ACKED</td>
<td class="org-left">表示此段已经重传过了</td>
</tr>

<tr>
<td class="org-left">FLAG_SYN_ACKED</td>
<td class="org-left">ACK段确认了SYN段</td>
</tr>

<tr>
<td class="org-left">FLAG_DATA_SACKED</td>
<td class="org-left">新的SACK</td>
</tr>

<tr>
<td class="org-left">FLAG_ECE</td>
<td class="org-left">ACK段中存在ECE标志，收到显式拥塞通知</td>
</tr>

<tr>
<td class="org-left">FLAG_DATA_LOST</td>
<td class="org-left">由SACK标识的数据已经丢失</td>
</tr>

<tr>
<td class="org-left">FLAG_SLOWPATH</td>
<td class="org-left">在慢速路径中处理的</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">This routine deals with incoming acks, but not outgoing ones.</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_ack</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25509;&#25910;&#21040;&#30340;ACK&#27573;</span>
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flag</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">prior_snd_una</span> = tp-&gt;snd_una;
        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">ack_seq</span> = TCP_SKB_CB(skb)-&gt;seq;
        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">ack</span> = TCP_SKB_CB(skb)-&gt;ack_seq;
        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">prior_in_flight</span>;
        <span style="color: #66D9EF;">s32</span> <span style="color: #FD971F;">seq_rtt</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">prior_packets</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">If the ack is newer than sent or older than previous acks</span>
<span style="color: #75715E;">         * then we can probably ignore it.</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#26816;&#39564;&#30830;&#35748;&#24207;&#21495;&#26159;&#21542;&#33853;&#22312; SND.UNA&#21644;SND.NXT&#20043;&#38388;&#65292;&#21542;&#21017;&#26159;&#19981;&#21512;&#27861;&#24207;&#21495;</span>
         <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30830;&#35748;&#24207;&#21495;&#22312;SND.NXT&#30340;&#21491;&#36793;&#65292;&#35828;&#26126;&#35813;&#24207;&#21495;&#30340;&#25968;&#25454;&#36824;&#27809;&#26377;&#21457;&#36865;</span>
        <span style="color: #F92672;">if</span> (after(ack, tp-&gt;snd_nxt))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">uninteresting_ack</span>;
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#30830;&#35748;&#24207;&#21495;&#22312;SND.UNA&#30340;&#24038;&#36793;&#65292;&#35828;&#26126;&#24050;&#32463;&#25509;&#25910;&#36807;&#35813;&#24207;&#21495;&#30340;ACK&#20102;&#12290;</span>
<span style="color: #75715E;">            &#27599;&#20010;&#26377;&#36127;&#36733;&#30340;TCP&#27573;&#37117;&#20250;&#39034;&#20415;&#25658;&#24102;&#19968;&#20010;ACK&#24207;&#21495;&#65292;&#21363;&#20351;&#27492;&#24207;&#21495;&#24050;&#32463;&#25509;&#25910;&#36807;&#12290;</span>
<span style="color: #75715E;">        &#22240;&#27492;&#65292;&#22914;&#26524;&#26159;&#37325;&#22797;&#30340;ACK,&#21017;&#26080;&#38656;&#22788;&#29702;&#12290;&#20294;&#22914;&#26524;&#27573;&#20013;&#25658;&#24102;&#26377;SACK&#36873;&#39033;&#65292;&#21017;&#38656;&#35201;&#22788;&#29702;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (before(ack, prior_snd_una))
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">old_ack</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21551;&#21160;tcp_abc&#21518;&#65292;&#22312;&#25317;&#22622;&#22238;&#36991;&#38454;&#27573;&#65292;&#35760;&#24405;&#24050;&#30830;&#35748;&#30340;&#23383;&#33410;&#25968;&#12290;</span>
        <span style="color: #F92672;">if</span> (sysctl_tcp_abc) {
                <span style="color: #F92672;">if</span> (icsk-&gt;icsk_ca_state &lt; TCP_CA_CWR)
                        tp-&gt;bytes_acked += ack - prior_snd_una;
                <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (icsk-&gt;icsk_ca_state == TCP_CA_Loss)
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">we assume just one segment left network</span><span style="color: #75715E;"> */</span>
                        tp-&gt;bytes_acked += min(ack - prior_snd_una, tp-&gt;mss_cache);
        }

        <span style="color: #E6DB74;">/** &#36827;&#34892;&#26356;&#26032;&#21457;&#36865;&#31383;&#21475;&#31561;&#25805;&#20316;&#65292;&#24182;&#26681;&#25454;&#21508;&#31181;&#20449;&#24687;&#33719;&#21462;ACK&#30340;&#21508;&#31181;&#26631;&#24535; */</span>

        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#25509;&#25910;ACK&#25191;&#34892;&#30340;&#26159;&#24555;&#36895;&#36335;&#24452;&#65292;&#21017;&#26356;&#26032;&#21457;&#36865;&#31383;&#21475;&#30340;&#24038;&#36793;&#30028;&#65292;&#28155;&#21152;FLAG_WIN_UPDATE&#26631;&#35760;&#65292;</span>
<span style="color: #75715E;">        &#21516;&#26102;&#36890;&#30693;&#25317;&#22622;&#25511;&#21046;&#31639;&#27861;&#27169;&#22359;&#26412;&#27425;ACK&#26159;&#24555;&#36895;&#36335;&#24452;&#65292;&#22914;&#26377;&#24517;&#35201;&#65292;&#20570;&#30456;&#24212;&#30340;&#22788;&#29702;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(flag&amp;FLAG_SLOWPATH) &amp;&amp; after(ack, prior_snd_una)) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Window is constant, pure forward advance.</span>
<span style="color: #75715E;">                 * No more checks are required.</span>
<span style="color: #75715E;">                 * Note, we use the fact that SND.UNA&gt;=SND.WL2.</span>
<span style="color: #75715E;">                 */</span>
                tcp_update_wl(tp, ack, ack_seq);
                tp-&gt;snd_una = ack;
                flag |= FLAG_WIN_UPDATE;

                tcp_ca_event(sk, CA_EVENT_FAST_ACK);

                NET_INC_STATS_BH(LINUX_MIB_TCPHPACKS);
        } <span style="color: #F92672;">else</span> { <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#25509;&#25910;ACK&#25191;&#34892;&#30340;&#24930;&#36895;&#36335;&#24452;&#65292;&#21017;&#39318;&#20808;&#21028;&#26029;ACK&#27573;&#20013;&#26159;&#21542;&#26377;&#25968;&#25454;&#36127;&#36733;&#65292;&#26377;&#21017;&#28155;&#21152;FLAG_DATA&#26631;&#35760;</span><span style="color: #75715E;">*/</span>
                <span style="color: #F92672;">if</span> (ack_seq != TCP_SKB_CB(skb)-&gt;end_seq)
                        flag |= FLAG_DATA;
                <span style="color: #F92672;">else</span>
                        NET_INC_STATS_BH(LINUX_MIB_TCPPUREACKS);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;&#21457;&#36865;&#31383;&#21475;&#65292;&#21516;&#26102;&#28155;&#21152;&#26356;&#26032;&#21457;&#36865;&#31383;&#21475;&#21518;&#33719;&#21462;&#30340;&#26631;&#35760;</span>
                flag |= tcp_ack_update_window(sk, tp, skb, ack, ack_seq);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;ACK&#27573;&#23384;&#22312;SACK&#36873;&#39033;</span>
                <span style="color: #F92672;">if</span> (TCP_SKB_CB(skb)-&gt;sacked)
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#36807;tcp_sacktag_write_queue&#26631;&#35760;&#37325;&#20256;&#38431;&#21015;</span>
                        flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;ACK&#27573;&#20013;&#26159;&#21542;&#23384;&#22312;ECE&#26631;&#24535;&#65292;&#26377;&#21017;&#28155;&#21152;FLAG_ECE</span>
                <span style="color: #F92672;">if</span> (TCP_ECN_rcv_ecn_echo(tp, skb-&gt;h.th))
                        flag |= FLAG_ECE;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36890;&#30693;&#25317;&#22622;&#25511;&#21046;&#31639;&#27861;&#27169;&#22359;&#26412;&#27425;ACK&#26159;&#24930;&#36895;&#36335;&#24452;&#12290;</span>
                tcp_ca_event(sk, CA_EVENT_SLOW_ACK);
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We passed data and got it acked, remove any soft error</span>
<span style="color: #75715E;">         * log. Something worked...</span>
<span style="color: #75715E;">         */</span>
        sk-&gt;sk_err_soft = 0;
        tp-&gt;rcv_tstamp = tcp_time_stamp;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35774;&#32622;&#26368;&#36817;&#25509;&#25910;&#25968;&#25454;&#30340;&#26102;&#38388;&#25139;</span>
        prior_packets = tp-&gt;packets_out;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#24050;&#32463;&#21457;&#36865;&#20294;&#36824;&#26410;&#30830;&#35748;&#30340;&#27573;&#25968;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>prior_packets)  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#23384;&#22312;&#24050;&#32463;&#21457;&#36865;&#20294;&#36824;&#26410;&#30830;&#35748;&#30340;&#27573;</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">no_queue</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#27491;&#22312;&#20256;&#36755;&#20013;&#30340;&#27573;&#25968;</span>
        prior_in_flight = tcp_packets_in_flight(tp);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;&#37325;&#20256;&#38431;&#21015;&#20013;&#21024;&#38500;&#24050;&#32463;&#30830;&#35748;&#30340;&#27573;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">See if we can take anything off of the retransmit queue.</span><span style="color: #75715E;"> */</span>
        flag |= tcp_clean_rtx_queue(sk, &amp;seq_rtt);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#22312;&#37325;&#20256;&#36229;&#26102;&#21518;&#20351;&#29992;FRTO&#31639;&#27861;&#65292;&#21017;&#36890;&#36807;tcp_process_frto()&#22788;&#29702;</span>
        <span style="color: #F92672;">if</span> (tp-&gt;frto_counter)
                tcp_process_frto(sk, prior_snd_una);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;ACK&#30340;&#26126;&#30830;&#19982;&#21542;&#65292;&#26356;&#26032;&#25317;&#22622;&#31383;&#21475;&#65292;&#36827;&#34892;&#25317;&#22622;&#25511;&#21046;&#12290;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">ACK&#26159;&#21542;&#26126;&#30830;&#65292;&#21462;&#20915;&#19982;&#20197;&#19979;&#26465;&#20214;&#65292;&#28385;&#36275;&#19968;&#39033;&#20415;&#26159;&#20026;ACK&#19981;&#26126;&#30830;&#65306;</span>
<span style="color: #75715E;">           + &#25509;&#25910;&#21040;&#30340;ACK&#26159;&#37325;&#22797;&#30340;</span>
<span style="color: #75715E;">           + &#25509;&#25910;&#21040;SACK&#22359;&#25110;&#32773;&#26174;&#24335;&#25317;&#22622;&#36890;&#30693;</span>
<span style="color: #75715E;">           + &#24403;&#21069;&#25317;&#22622;&#29366;&#24577;&#19981;&#22788;&#20110;Open</span>
<span style="color: #75715E;">        */</span>
        <span style="color: #F92672;">if</span> (tcp_ack_is_dubious(sk, flag)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">ACK&#26159;&#19981;&#26126;&#30830;&#30340;</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Advance CWND, if state allows this.</span><span style="color: #75715E;"> */</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;ACK&#30830;&#35748;&#20102;&#26032;&#30340;&#27573;&#65292;&#21364;&#25317;&#22622;&#31383;&#21475;&#21487;&#20197;&#26356;&#26032;&#65292;&#21017;&#26356;&#26032;&#25317;&#22622;&#31383;&#21475;&#65292;&#36801;&#31227;&#25317;&#22622;&#29366;&#24577;</span>
                <span style="color: #F92672;">if</span> ((flag &amp; FLAG_DATA_ACKED) &amp;&amp; tcp_may_raise_cwnd(sk, flag))
                        tcp_cong_avoid(sk, ack,  seq_rtt, prior_in_flight, 0);
                tcp_fastretrans_alert(sk, prior_snd_una, prior_packets, flag);
        } <span style="color: #F92672;">else</span> { <span style="color: #75715E;">//</span><span style="color: #75715E;">ACK&#26159;&#26126;&#30830;&#30340;&#65292;&#35828;&#26126;&#33267;&#23569;&#22788;&#20110;Open&#29366;&#24577;&#65292;&#22914;&#26524;ACK&#30830;&#35748;&#20102;&#26032;&#30340;&#27573;&#65292;&#21017;&#26356;&#26032;&#25317;&#22622;&#31383;&#21475;</span>
                <span style="color: #F92672;">if</span> ((flag &amp; FLAG_DATA_ACKED))
                        tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 1);
        }
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;ACK&#30830;&#35748;&#20102;&#26032;&#30340;&#27573;&#65288;&#26032;&#30340;&#25968;&#25454;&#27573;&#12289;SYN&#27573;&#20197;&#21450;&#25509;&#25910;&#21040;&#26032;&#30340;SACK&#36873;&#39033;&#65289;&#65292;&#25110;&#32773;&#25509;&#25910;&#21040;&#30340;ACK&#26159;&#37325;&#22797;&#30340;&#65292;</span>
<span style="color: #75715E;">        &#21017;&#30830;&#35748;&#35813;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#36755;&#20986;&#36335;&#30001;&#32531;&#23384;&#39033;&#26159;&#26377;&#25928;&#30340;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> ((flag &amp; FLAG_FORWARD_PROGRESS) || <span style="color: #E6DB74; font-weight: bold;">!</span>(flag&amp;FLAG_NOT_DUP))
                dst_confirm(sk-&gt;sk_dst_cache);

        <span style="color: #F92672;">return</span> 1;

<span style="color: #AE81FF;">no_queue</span>:
        icsk-&gt;icsk_probes_out = 0;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21463;&#21040;&#25509;&#25910;&#26041;&#30340;ACK,&#23558;TCP&#20445;&#27963;&#25506;&#27979;&#27573;&#26410;&#30830;&#35748;&#25968;&#28165;&#38646;&#12290;</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">If this ack opens up a zero window, clear backoff.  It was</span>
<span style="color: #75715E;">         * being used to time the probes, and is probably far higher than</span>
<span style="color: #75715E;">         * it needs to be for normal retransmission.</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#36824;&#26377;&#24102;&#21457;&#36865;&#30340;&#25968;&#25454;&#65292;&#26681;&#25454;&#24773;&#20917;&#30830;&#23450;&#26159;&#21542;&#36827;&#34892;&#38646;&#31383;&#21475;&#25506;&#27979;&#12290;</span>
         <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#25509;&#25910;&#21040;ACK,&#22914;&#26524;&#23545;&#26041;&#30340;&#25509;&#25910;&#31383;&#21475;&#27809;&#26377;&#20851;&#38381;&#65292;&#21017;&#38656;&#35201;&#28165;&#26970;&#25345;&#32493;&#23450;&#26102;&#22120;&#30340;&#25351;&#25968;&#36864;&#36991;&#31639;&#27861;&#25351;&#25968;&#65292;</span>
<span style="color: #75715E;">         &#20572;&#27490;&#25345;&#32493;&#23450;&#26102;&#22120;&#65292;&#21542;&#21017;&#24320;&#21551;&#25345;&#32493;&#23450;&#26102;&#22120;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_send_head)
                tcp_ack_probe(sk); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30830;&#23450;&#26159;&#21542;&#38656;&#35201;&#36827;&#34892;&#38646;&#31383;&#21475;&#25506;&#27979;&#12290;</span>
        <span style="color: #F92672;">return</span> 1;

<span style="color: #AE81FF;">old_ack</span>:
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#26159;&#24050;&#30830;&#35748;&#30340;ACK,&#24182;&#19988;&#24102;&#26377;SACK&#36873;&#39033;&#65292;&#21017;&#38656;&#35201;&#26631;&#35760;&#37325;&#20256;&#38431;&#21015;&#20013;&#30340;&#21508;&#20010;&#27573;&#30340;&#35760;&#20998;&#29260;</span>
        <span style="color: #F92672;">if</span> (TCP_SKB_CB(skb)-&gt;sacked)
                tcp_sacktag_write_queue(sk, skb, prior_snd_una);

<span style="color: #AE81FF;">uninteresting_ack</span>:
        SOCK_DEBUG(sk, <span style="color: #E6DB74;">"Ack %u out of %u:%u\n"</span>, ack, tp-&gt;snd_una, tp-&gt;snd_nxt);
        <span style="color: #F92672;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org88565cb" class="outline-3">
<h3 id="org88565cb"><span class="section-number-3">6.2.</span> 发送窗口的更新：tcp_ack_update_window()</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Update our send window.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * Window update algorithm, described in RFC793/RFC1122 (used in linux-2.2</span>
<span style="color: #75715E;"> * and in FreeBSD. NetBSD's one is even worse.) is wrong.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_ack_update_window</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span>,
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25509;&#25910;&#30340;ACK&#27573;</span>
<span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">ack</span>,  <span style="color: #75715E;">//</span><span style="color: #75715E;">ACK&#27573;&#30340;&#24207;&#21495;</span>
 <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">ack_seq</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">ACK&#27573;&#30340;&#30830;&#35748;&#24207;&#21495;</span>
{
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flag</span> = 0;
        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">nwin</span> = ntohs(skb-&gt;h.th-&gt;window); <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20174;TCP&#39318;&#37096;&#33719;&#21462;&#25509;&#25910;&#26041;&#25509;&#25910;&#31383;&#21475;&#22823;&#23567;</span>

        <span style="color: #F92672;">if</span> (likely(<span style="color: #E6DB74; font-weight: bold;">!</span>skb-&gt;h.th-&gt;syn))
                nwin &lt;&lt;= tp-&gt;rx_opt.snd_wscale; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#31383;&#21475;&#25193;&#22823;&#22240;&#23376;&#35745;&#31639;&#20986;&#25509;&#25910;&#31383;&#21475;&#30340;&#23383;&#33410;&#25968;&#12290;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#21028;&#26029;&#26159;&#21542;&#21487;&#20197;&#26356;&#26032;&#21457;&#36865;&#31383;&#21475;&#65292;&#28385;&#36275;&#20197;&#19979;&#19977;&#20010;&#26465;&#20214;&#20043;&#19968;&#23601;&#21487;&#20197;&#26356;&#26032;&#65306;</span>
<span style="color: #75715E;">               + &#30830;&#35748;&#30340;&#24207;&#21495;&#22312;&#21457;&#36865;&#31383;&#21475;&#30340;SND.UNA&#21644;SND.NXT&#20043;&#38388;&#12290;</span>
<span style="color: #75715E;">               + ACK&#27573;&#30340;&#24207;&#21495;&#26159;&#26368;&#26032;&#30340;&#12290;</span>
<span style="color: #75715E;">               + &#25509;&#25910;&#21040;&#37325;&#22797;&#30340;ACK&#65292;&#24182;&#19988;&#25509;&#25910;&#26041;&#30340;&#25509;&#25910;&#31383;&#21475;&#22823;&#20110;&#24403;&#21069;&#21457;&#36865;&#26041;&#30340;&#21457;&#36865;&#31383;&#21475;&#65288;&#21487;&#33021;&#26159;&#24102;&#26377;&#25968;&#25454;&#30340;TCP&#27573;&#65289;</span>
<span style="color: #75715E;">        */</span>
        <span style="color: #F92672;">if</span> (tcp_may_update_window(tp, ack, ack_seq, nwin)) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#21069;ACK&#21487;&#20197;&#26356;&#26032;&#21457;&#36865;&#31383;&#21475;</span>
                flag |= FLAG_WIN_UPDATE;   <span style="color: #75715E;">//</span><span style="color: #75715E;">&#28155;&#21152;FLAG_WIN_UPDATE&#26631;&#35760;</span>
                tcp_update_wl(tp, ack, ack_seq);  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35760;&#24405;&#26368;&#26032;&#30340;ACK&#24207;&#21495;&#21040;snd_wl1&#20013;&#12290;</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#25509;&#25910;&#26041;&#30340;&#25509;&#25910;&#31383;&#21475;&#19982;&#21457;&#36865;&#26041;&#30340;&#21457;&#36865;&#31383;&#21475;&#19981;&#31561;&#65292;&#21017;&#20197;&#25509;&#25910;&#26041;&#30340;&#25509;&#25910;&#31383;&#21475;&#26356;&#26032;&#21457;&#36865;&#26041;&#30340;&#21457;&#36865;&#31383;&#21475;&#65292;</span>
<span style="color: #75715E;">                &#30001;&#20110;&#29992;&#20110;&#39318;&#37096;&#39044;&#27979;&#30340;&#26631;&#35760;&#19982;&#25509;&#25910;&#31383;&#21475;&#22823;&#23567;&#26377;&#20851;&#65292;&#22240;&#27492;&#38656;&#28165;&#38646;&#39044;&#27979;&#26631;&#24535;&#65292;&#28982;&#21518;&#35843;&#29992;tcp_fast_path_check()</span>
<span style="color: #75715E;">                &#22312;&#28385;&#36275;&#26465;&#20214;&#30340;&#24773;&#20917;&#19979;&#37325;&#26032;&#35745;&#31639;&#39318;&#37096;&#39044;&#27979;&#26631;&#24535;&#12290;&#22914;&#26524;&#25509;&#25910;&#26041;&#30340;&#25509;&#25910;&#31383;&#21475;&#22823;&#20110;&#20043;&#21069;&#30340;&#26368;&#22823;&#25509;&#25910;&#31383;&#21475;&#65292;</span>
<span style="color: #75715E;">                &#21017;&#26356;&#26032;&#21457;&#36865;&#26041;&#21457;&#36865;&#31383;&#21475;&#65292;&#21516;&#26102;&#37325;&#26032;&#35745;&#31639;MSS</span><span style="color: #75715E;">*/</span>
                <span style="color: #F92672;">if</span> (tp-&gt;snd_wnd != nwin) {
                        tp-&gt;snd_wnd = nwin;

                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Note, it is the only place, where</span>
<span style="color: #75715E;">                         * fast path is recovered for sending TCP.</span>
<span style="color: #75715E;">                         */</span>
                        tp-&gt;pred_flags = 0;
                        tcp_fast_path_check(sk, tp);

                        <span style="color: #F92672;">if</span> (nwin &gt; tp-&gt;max_window) {
                                tp-&gt;max_window = nwin;
                                tcp_sync_mss(sk, inet_csk(sk)-&gt;icsk_pmtu_cookie);
                        }
                }
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26368;&#21518;&#26356;&#26032;&#21457;&#36865;&#31383;&#21475;&#30340;&#24038;&#31471;&#65292;&#21363;SND.UNA</span>
        tp-&gt;snd_una = ack;

        <span style="color: #F92672;">return</span> flag;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org41b6e3c" class="outline-3">
<h3 id="org41b6e3c"><span class="section-number-3">6.3.</span> 根据SACK选项标记重传队列中段的记分牌：tcp_sacktag_write_queue</h3>
<div class="outline-text-3" id="text-6-3">
<p>
在SKB的TCP控制块中有一个sacked成员，称为记分牌，用于记录该段的传输状态，其有效的标记组合见下表。包含三个标记位：SACKED(S)，RETRANS(R)和LOST(L)。通过这些标记位，可以比较准确的计算各变量的值，如sacked_out、retrans_out和retrans_out。SACK选项的发送。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> 记分牌的标记</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标记</th>
<th scope="col" class="org-right">当前网络中传输的数量</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">0</td>
<td class="org-right">1</td>
<td class="org-left">原先发送的段还在网络中传输</td>
</tr>

<tr>
<td class="org-left">S</td>
<td class="org-right">0</td>
<td class="org-left">原先发送的段已抵达接收方</td>
</tr>

<tr>
<td class="org-left">L</td>
<td class="org-right">0</td>
<td class="org-left">原先发送的段已丢失</td>
</tr>

<tr>
<td class="org-left">R</td>
<td class="org-right">2</td>
<td class="org-left">原先发送和重传的段还在网络中传输</td>
</tr>

<tr>
<td class="org-left">LR</td>
<td class="org-right">1</td>
<td class="org-left">原先发送的段已经丢失，重传的段还在网络中传输</td>
</tr>

<tr>
<td class="org-left">SR</td>
<td class="org-right">1</td>
<td class="org-left">原先发送的段已抵达接收方，重传的段还在网络中传输</td>
</tr>
</tbody>
</table>

<p>
以上六种状态的状态机，可以通过以下事件来控制：
</p>
<ul class="org-ul">
<li>接收到新的ACK或SACK,调用tcp_sacktag_write_queue()。</li>
<li>进行重传，调用tcp_retransmit_skb()和tcp_xmit_retransmit_queue()。</li>
<li>以下三种情况可以检测丢失事件：
<ul class="org-ul">
<li>通过记分牌来估计包是否丢失。在Reno算法中，连续接收到三个D-SACK，则说明重传队列的第一个段已经丢失。或者如果FACK发生变化，则重传队列到SND.FACK之间的段已经丢失。</li>
<li>回复的SACK超出了重传队列的尾部，则说明有段已经丢失。</li>
<li>在段被重传的时候，确认SND.NXT的SACK到达。</li>
</ul></li>
<li>D-SACK发生变化时会添加SACKED标记。</li>
</ul>

<p>
tcp_sacktag_write_queue()的功能是当接收到ACK后，根据SACK选项标记重传队列中SKB的记分牌状态，流程图如下：
</p>

<div id="org5658097" class="figure">
<p><img src="image/tcp-output/tcp-sacktag-write-queue.png" alt="tcp-sacktag-write-queue.png" />
</p>
<p><span class="figure-number">Figure 14: </span>tcp_sacktag_write_queue的流程图</p>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">This procedure tags the retransmission queue when SACKs arrive.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * We have three tag bits: SACKED(S), RETRANS(R) and LOST(L).</span>
<span style="color: #75715E;"> * Packets in queue with these bits set are counted in variables</span>
<span style="color: #75715E;"> * sacked_out, retrans_out and lost_out, correspondingly.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * Valid combinations are:</span>
<span style="color: #75715E;"> * Tag  InFlight        Description</span>
<span style="color: #75715E;"> * 0    1               - orig segment is in flight.</span>
<span style="color: #75715E;"> * S    0               - nothing flies, orig reached receiver.</span>
<span style="color: #75715E;"> * L    0               - nothing flies, orig lost by net.</span>
<span style="color: #75715E;"> * R    2               - both orig and retransmit are in flight.</span>
<span style="color: #75715E;"> * L|R  1               - orig is lost, retransmit is in flight.</span>
<span style="color: #75715E;"> * S|R  1               - orig reached receiver, retrans is still in flight.</span>
<span style="color: #75715E;"> * (L|S|R is logically valid, it could occur when L|R is sacked,</span>
<span style="color: #75715E;"> *  but it is equivalent to plain S and code short-curcuits it to S.</span>
<span style="color: #75715E;"> *  L|S is logically invalid, it would mean -1 packet in flight 8))</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * These 6 states form finite state machine, controlled by the following events:</span>
<span style="color: #75715E;"> * 1. New ACK (+SACK) arrives. (tcp_sacktag_write_queue())</span>
<span style="color: #75715E;"> * 2. Retransmission. (tcp_retransmit_skb(), tcp_xmit_retransmit_queue())</span>
<span style="color: #75715E;"> * 3. Loss detection event of one of three flavors:</span>
<span style="color: #75715E;"> *      A. Scoreboard estimator decided the packet is lost.</span>
<span style="color: #75715E;"> *         A'. Reno "three dupacks" marks head of queue lost.</span>
<span style="color: #75715E;"> *         A''. Its FACK modfication, head until snd.fack is lost.</span>
<span style="color: #75715E;"> *      B. SACK arrives sacking data transmitted after never retransmitted</span>
<span style="color: #75715E;"> *         hole was sent out.</span>
<span style="color: #75715E;"> *      C. SACK arrives sacking SND.NXT at the moment, when the</span>
<span style="color: #75715E;"> *         segment was retransmitted.</span>
<span style="color: #75715E;"> * 4. D-SACK added new rule: D-SACK changes any tag to S.</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * It is pleasant to note, that state diagram turns out to be commutative,</span>
<span style="color: #75715E;"> * so that we are allowed not to be bothered by order of our actions,</span>
<span style="color: #75715E;"> * when multiple events arrive simultaneously. (see the function below).</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * Reordering detection.</span>
<span style="color: #75715E;"> * --------------------</span>
<span style="color: #75715E;"> * Reordering metric is maximal distance, which a packet can be displaced</span>
<span style="color: #75715E;"> * in packet stream. With SACKs we can estimate it:</span>
<span style="color: #75715E;"> *</span>
<span style="color: #75715E;"> * 1. SACK fills old hole and the corresponding segment was not</span>
<span style="color: #75715E;"> *    ever retransmitted -&gt; reordering. Alas, we cannot use it</span>
<span style="color: #75715E;"> *    when segment was retransmitted.</span>
<span style="color: #75715E;"> * 2. The last flaw is solved with D-SACK. D-SACK arrives</span>
<span style="color: #75715E;"> *    for retransmitted and already SACKed segment -&gt; reordering..</span>
<span style="color: #75715E;"> * Both of these heuristics are not used in Loss state, when we cannot</span>
<span style="color: #75715E;"> * account for retransmits accurately.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span>
<span style="color: #A6E22E;">tcp_sacktag_write_queue</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">ack_skb</span>,
<span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">prior_snd_una</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22788;&#29702;ACK&#21069;&#30340;SND.UNA&#20540;</span>
{
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #E6DB74;">/** &#22312;&#25509;&#25910;TCP&#27573;&#20043;&#21021;&#35299;&#26512;TCP&#36873;&#39033;&#26102;&#65292;&#23545;SACK&#36873;&#39033;&#30340;&#22788;&#29702;&#27604;&#36739;&#31616;&#21333;&#65292;&#21482;&#26159;&#22312;SKB&#30340;TCP&#23618;TCP_SKB_CB&#23383;&#27573;sacked&#20013;</span>
<span style="color: #E6DB74;">        &#20445;&#23384;&#20102;SACK&#36873;&#39033;&#22312;TCP&#39318;&#37096;&#20013;&#30340;&#20559;&#31227;&#12290;&#22240;&#27492;&#22312;&#27492;&#65292;&#21487;&#20197;&#26681;&#25454;&#20559;&#31227;&#24471;&#20986;SACK&#36873;&#39033;&#30340;&#22320;&#22336;&#65292;&#20197;&#21450;SACK&#22359;&#25968;&#12290;*/</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">ptr</span> = ack_skb-&gt;h.raw + TCP_SKB_CB(ack_skb)-&gt;sacked;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sack_block_wire</span> *<span style="color: #FD971F;">sp</span> = (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sack_block_wire</span> *)(ptr+2);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">num_sacks</span> = (ptr[1] - TCPOLEN_SACK_BASE)&gt;&gt;3;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#29992;&#20110;&#35745;&#31639;&#26412;&#27425;&#30340;fackets_out&#65292;&#30001;&#20110;fackets_out&#24517;&#23450;&#23567;&#20110;&#25110;&#31561;&#20110;packets_out,&#22240;&#27492;&#21021;&#22987;&#20540;&#20026;packets_out</span><span style="color: #75715E;">*/</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">reord</span> = tp-&gt;packets_out;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">prior_fackets</span>;
        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">lost_retrans</span> = 0;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flag</span> = 0;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">dup_sack</span> = 0;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30001;&#20110;fackets_out&#26159;&#22522;&#20110;sacket_out&#30340;&#65292;&#22240;&#27492;&#22914;&#26524;&#23545;&#26041;&#25903;&#25345;SACK&#36873;&#39033;&#19988;sacked_out&#20026;&#38646;&#65292;&#21017;fackets_out&#20063;&#24517;&#23450;&#20026;&#38646;&#12290;</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tp-&gt;sacked_out)
                tp-&gt;fackets_out = 0;
        prior_fackets = tp-&gt;fackets_out; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26242;&#23384;fackets_out&#26356;&#26032;&#21069;&#30340;&#20540;</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">SACK fastpath:</span>
<span style="color: #75715E;">         * if the only SACK change is the increase of the end_seq of</span>
<span style="color: #75715E;">         * the first block then only apply that SACK block</span>
<span style="color: #75715E;">         * and use retrans queue hinting otherwise slowpath</span><span style="color: #75715E;"> */</span>
        <span style="color: #E6DB74;">/** &#20174;SACK&#36873;&#39033;&#20013;&#35835;&#21462;SACK&#22359;&#65292;&#24182;&#26816;&#27979;&#26159;&#21542;&#23384;&#22312;D-SACK*/</span>
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">flag&#26377;&#20004;&#20010;&#20316;&#29992;&#65292;&#31532;&#19968;&#20010;&#26159;&#26631;&#35760;&#26159;&#36827;&#34892;&#24555;&#36895;&#36335;&#24452;&#22788;&#29702;&#36824;&#26159;&#24930;&#36895;&#36335;&#24452;&#22788;&#29702;&#65292;</span>
<span style="color: #75715E;">        flag&#20026;1&#26102;&#25191;&#34892;&#24555;&#36895;&#36335;&#24452;&#22788;&#29702;&#65292;&#31532;&#20108;&#20010;&#20316;&#29992;&#21518;&#38754;&#35828;&#26126;</span><span style="color: #75715E;">*/</span>
        flag = 1;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36880;&#20010;&#22788;&#29702;SACK&#19981;&#36830;&#32493;&#22359;</span>
        <span style="color: #F92672;">for</span> (i = 0; i&lt; num_sacks; i++) {
                <span style="color: #E6DB74;">/** &#23558;SACK&#22359;&#23384;&#20648;&#21040;recv_sack_cache&#20013;&#65292;&#21516;&#26102;&#30830;&#23450;&#24555;&#36895;&#36335;&#24452;&#36824;&#26159;&#24930;&#36895;&#36335;&#24452;&#22788;&#29702;&#12290;</span>
<span style="color: #E6DB74;">                &#22914;&#26524;&#21482;&#26377;&#31532;&#19968;&#20010;SACK&#22359;&#30340;end_seq&#20986;&#29616;&#20102;&#22686;&#21152;&#65292;&#21017;&#25191;&#34892;&#24555;&#36895;&#36335;&#24452;&#65292;&#20174;&#19978;&#27425;&#22788;&#29702;SACK&#32467;&#26463;&#24320;&#22987;&#65292;</span>
<span style="color: #E6DB74;">                &#21542;&#21017;&#25191;&#34892;&#24930;&#36895;&#36335;&#24452;&#65292;&#20174;&#37325;&#20256;&#38431;&#21015;&#22836;&#24320;&#22987;*/</span>
                <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">start_seq</span> = ntohl(sp[i].start_seq);
                <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">end_seq</span> =  ntohl(sp[i].end_seq);

                <span style="color: #F92672;">if</span> (i == 0){
                        <span style="color: #F92672;">if</span> (tp-&gt;recv_sack_cache[i].start_seq != start_seq)
                                flag = 0;
                } <span style="color: #F92672;">else</span> {
                        <span style="color: #F92672;">if</span> ((tp-&gt;recv_sack_cache[i].start_seq != start_seq) ||
                            (tp-&gt;recv_sack_cache[i].end_seq != end_seq))
                                flag = 0;
                }
                tp-&gt;recv_sack_cache[i].start_seq = start_seq;
                tp-&gt;recv_sack_cache[i].end_seq = end_seq;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Check for D-SACK.</span><span style="color: #75715E;"> */</span>
                <span style="color: #E6DB74;">/** &#26816;&#27979;SACK&#20013;&#30340;&#31532;&#19968;&#20010;&#22359;&#26159;&#19981;&#26159;D-SACK&#22359;&#65292;&#26681;&#25454;RFC2883&#65292;&#21028;&#26029;&#20381;&#25454;&#22914;&#19979;&#65306;</span>
<span style="color: #E6DB74;">                       + &#22914;&#26524;&#31532;&#19968;&#20010;SACK&#22359;&#23567;&#20110;&#24050;&#30830;&#35748;&#22359;&#24207;&#21495;&#65292;&#21017;&#26159;D-SACK&#12290;</span>
<span style="color: #E6DB74;">                       + &#22914;&#26524;&#31532;&#19968;&#20010;SACK&#22359;&#22823;&#20110;&#24050;&#30830;&#35748;&#22359;&#24207;&#21495;&#65292;&#21017;&#36824;&#38656;&#35201;&#27604;&#36739;&#31532;&#19968;&#20010;SACK&#22359;&#21644;&#31532;&#20108;&#20010;SACK&#22359;&#65292;</span>
<span style="color: #E6DB74;">                         &#22914;&#26524;&#31532;&#19968;&#20010;SACK&#22359;&#21253;&#21547;&#22312;&#31532;&#20108;&#20010;SACK&#22359;&#20013;&#65292;&#21017;&#35828;&#26126;&#26159;D-SACK*/</span>
                <span style="color: #F92672;">if</span> (i == 0) {
                        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">ack</span> = TCP_SKB_CB(ack_skb)-&gt;ack_seq;

                        <span style="color: #F92672;">if</span> (before(start_seq, ack)) {
                                dup_sack = 1;
                                tp-&gt;rx_opt.sack_ok |= 4;
                                NET_INC_STATS_BH(LINUX_MIB_TCPDSACKRECV);
                        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (num_sacks &gt; 1 &amp;&amp;
                                   <span style="color: #E6DB74; font-weight: bold;">!</span>after(end_seq, ntohl(sp[1].end_seq)) &amp;&amp;
                                   <span style="color: #E6DB74; font-weight: bold;">!</span>before(start_seq, ntohl(sp[1].start_seq))) {
                                dup_sack = 1;
                                tp-&gt;rx_opt.sack_ok |= 4;
                                NET_INC_STATS_BH(LINUX_MIB_TCPDSACKOFORECV);
                        }
                        <span style="color: #E6DB74;">/** undo_marker&#26159;&#36229;&#26102;&#37325;&#20256;&#25110;FRTO&#26102;&#35760;&#24405;&#30340;SND.UMA&#65292;</span>
<span style="color: #E6DB74;">                        prior_snd_una&#26159;&#26681;&#25454;&#35813;ACK&#26356;&#26032;&#31383;&#21475;&#21069;&#30340;SND.UNA&#65292;&#22914;&#19979;&#22270;&#12290;</span>
<span style="color: #E6DB74;">                        &#22914;&#26524;&#22238;&#22797;&#30340;D-SACK&#22312;&#36825;&#22359;&#20013;&#38388;&#65292;&#35828;&#26126;&#26159;&#36229;&#26102;&#37325;&#20256;&#25110;FRTO&#21518;&#36827;&#34892;&#30340;&#37325;&#20256;&#65292;</span>
<span style="color: #E6DB74;">                        &#22240;&#27492;&#38656;&#35201;&#20943;&#23569;undo_retrans&#65292;&#20197;&#20026;&#25509;&#25910;&#26041;&#37325;&#22797;&#25509;&#25910;&#20102;&#65292;&#36825;&#35828;&#26126;&#32593;&#32476;&#30340;&#25317;&#22622;&#21487;&#33021;&#19981;&#20005;&#37325;&#12290;</span>
<span style="color: #E6DB74;">                        &#22914;&#26524;&#30001;&#20110;D-SACK&#32780;&#23548;&#33268;undo_retrans&#20026;0&#26102;&#65292;&#35828;&#26126;&#32593;&#32476;&#36890;&#24120;&#65292;&#25317;&#22622;&#29366;&#24577;&#24212;&#35813;&#24674;&#22797;&#21040;&#27491;&#24120;&#24773;&#20917;&#19979;&#12290;*/</span>
</pre>
</div>

<div id="org8703ae1" class="figure">
<p><img src="image/tcp-output/snd-una.png" alt="snd-una.png" />
</p>
<p><span class="figure-number">Figure 15: </span>三个时刻的SND.UNA</p>
</div>
<div class="org-src-container">
<pre class="src src-c">                <span style="color: #75715E;">/* </span><span style="color: #75715E;">D-SACK for already forgotten data...</span>
<span style="color: #75715E;">                 * Do dumb counting.</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (dup_sack &amp;&amp;
                    <span style="color: #E6DB74; font-weight: bold;">!</span>after(end_seq, prior_snd_una) &amp;&amp;
                    after(end_seq, tp-&gt;undo_marker))
                        tp-&gt;undo_retrans--;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Eliminate too old ACKs, but take into</span>
<span style="color: #75715E;">                 * account more or less fresh ones, they can</span>
<span style="color: #75715E;">                 * contain valid SACK info.</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#22238;&#22797;&#30340;ACK&#24207;&#21495;&#26159;&#19968;&#20010;&#31383;&#21475;&#20197;&#21069;&#30340;&#65292;&#21017;&#35828;&#26126;ACK&#22826;&#38472;&#26087;&#20102;&#65292;&#19981;&#38656;&#35201;&#22312;&#22788;&#29702;&#65292;&#30452;&#25509;&#36820;&#22238;&#12290;</span>
                <span style="color: #F92672;">if</span> (before(ack, prior_snd_una - tp-&gt;max_window))
                        <span style="color: #F92672;">return</span> 0;
        }
}
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#25191;&#34892;&#30340;&#24555;&#36895;&#36335;&#24452;&#65292;&#21017;&#35774;&#32622;SACK&#30340;&#22359;&#25968;&#20026;1&#65292;&#22240;&#20026;&#22788;&#29702;&#31532;&#19968;&#20010;&#22359;&#21363;&#21487;&#65292;&#20854;&#20182;&#30340;&#19981;&#36830;&#32493;&#22359;&#27809;&#26377;&#21457;&#29983;&#21464;&#21270;&#65292;&#26080;&#38656;&#22788;&#29702;</span>
<span style="color: #F92672;">if</span> (flag)
        num_sacks = 1;
<span style="color: #F92672;">else</span> { <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#25191;&#34892;&#24930;&#36895;&#36335;&#24452;&#65292;&#28165;&#38500;&#24555;&#36895;&#36335;&#24452;&#22788;&#29702;&#30340;&#24320;&#22987;&#28857;&#65288;fastpath_skb_hint&#25351;&#21521;&#30340;SKB&#65289;&#65292;</span>
<span style="color: #75715E;">&#20043;&#21518;&#36824;&#38656;&#35201;&#23545;&#21407;&#22987;&#30340;SACK&#19981;&#36830;&#32493;&#22359;&#36827;&#34892;&#20882;&#27873;&#25490;&#24207;&#65292;&#22240;&#20026;SACK&#22359;&#26368;&#22810;&#20026;&#22235;&#20010;&#65292;&#22240;&#27492;&#21363;&#20351;&#20882;&#27873;&#25490;&#24207;&#20063;&#19981;&#20250;&#24433;&#21709;&#24615;&#33021;&#12290;</span><span style="color: #75715E;"> */</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">j</span>;
        tp-&gt;fastpath_skb_hint = <span style="color: #AE81FF;">NULL</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">order SACK blocks to allow in order walk of the retrans queue</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">for</span> (i = num_sacks-1; i &gt; 0; i--) {
                <span style="color: #F92672;">for</span> (j = 0; j &lt; i; j++){
                        <span style="color: #F92672;">if</span> (after(ntohl(sp[j].start_seq),
                                  ntohl(sp[j+1].start_seq))){
                                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sack_block_wire</span> <span style="color: #FD971F;">tmp</span>;

                                tmp = sp[j];
                                sp[j] = sp[j+1];
                                sp[j+1] = tmp;
                        }

                }
        }
}
<span style="color: #75715E;">//</span><span style="color: #75715E;">flag&#26631;&#35760;&#30340;&#31532;&#19968;&#20010;&#20316;&#29992;&#33267;&#27492;&#23436;&#27605;&#65292;&#28165;&#38646;&#20197;&#20197;&#20869;&#32473;&#20104;&#31532;&#20108;&#20010;&#20316;&#29992;&#65292;&#35760;&#24405;&#22788;&#29702;&#37325;&#20256;&#38431;&#21015;&#30340;&#35760;&#20998;&#29260;</span>
<span style="color: #75715E;">/* </span><span style="color: #75715E;">clear flag as used for different purpose in following code</span><span style="color: #75715E;"> */</span>
flag = 0;
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#36880;&#20010;&#22788;&#29702;SACK&#19981;&#36830;&#32493;&#22359;</span>
<span style="color: #F92672;">for</span> (i=0; i&lt;num_sacks; i++, sp++) {
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;&#27599;&#20010;&#22359;&#30340;start_seq end_seq</span>
        <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">start_seq</span> = ntohl(sp-&gt;start_seq);
        <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">end_seq</span> = ntohl(sp-&gt;end_seq);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fack_count</span>; <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#20020;&#26102;&#35760;&#24405;&#26412;&#27425;&#35745;&#31639;&#24471;&#21040;&#30340;fackets_out,&#22914;&#26524;&#22823;&#20110;&#20256;&#36755;&#25511;&#21046;&#22359;&#24403;&#21069;&#30340;fackets_out&#26102;&#65292;&#21017;&#26356;&#26032;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#20013;&#12290;</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Use SACK fastpath hint if valid</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (tp-&gt;fastpath_skb_hint) {  <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24555;&#36895;&#36335;&#24452;</span>
                skb = tp-&gt;fastpath_skb_hint;
                fack_count = tp-&gt;fastpath_cnt_hint;
        } <span style="color: #F92672;">else</span> { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24930;&#36895;&#36335;&#24452;</span>
                skb = sk-&gt;sk_write_queue.next;
                fack_count = 0;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Event "B" in the comment above.</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#22238;&#22797;&#30340;SACK&#36229;&#20986;&#20102;&#37325;&#20256;&#38431;&#21015;&#30340;&#23614;&#37096;&#65292;&#21017;&#35828;&#26126;&#26377;&#27573;&#24050;&#32463;&#20002;&#22833;&#65292;&#38656;&#35201;&#21152;&#19978;LOST&#26631;&#24535;</span>
        <span style="color: #F92672;">if</span> (after(end_seq, tp-&gt;high_seq))
                flag |= FLAG_DATA_LOST;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36941;&#21382;&#37325;&#20256;&#38431;&#21015;&#65292;&#20174;SKB&#24320;&#22987;&#33267;sk_send_head&#25110;sk_write_queue&#21069;&#19968;&#20010;SKB&#20026;&#27490;&#12290;</span>
        sk_stream_for_retrans_queue_from(skb, sk) {
                <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">in_sack</span>, <span style="color: #FD971F;">pcount</span>;
                <span style="color: #66D9EF;">u8</span> <span style="color: #FD971F;">sacked</span>;
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35760;&#24405;&#37325;&#20256;&#38431;&#21015;&#20013;&#24050;&#22788;&#29702;&#30340;&#26368;&#21518;&#19968;&#20010;SKB,&#28385;&#36275;&#24555;&#36895;&#36335;&#24452;&#26102;&#65292;&#20174;&#19978;&#27425;&#32467;&#26463;&#22788;&#32780;&#19981;&#24517;&#20174;&#37325;&#20256;&#38431;&#21015;&#22836;&#24320;&#22987;&#22788;&#29702;&#12290;</span>
                tp-&gt;fastpath_skb_hint = skb;
                tp-&gt;fastpath_cnt_hint = fack_count;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">The retransmission queue is always in order, so</span>
<span style="color: #75715E;">                 * we can short-circuit the walk early.</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#30001;&#20110;&#37325;&#20256;&#38431;&#21015;&#26159;&#25490;&#24207;&#30340;&#65292;&#22240;&#27492;&#24403;&#21069;SKB&#30340;&#24207;&#21495;&#22823;&#20110;&#24403;&#21069;&#22788;&#29702;&#30340;SACK&#19981;&#36830;&#32493;&#22359;&#30340;&#21491;&#31471;&#24207;&#21495;&#26102;&#65292;</span>
<span style="color: #75715E;">                &#21017;&#35828;&#26126;&#24403;&#21069;SKB&#19981;&#20877;&#27492;SACK&#33539;&#22260;&#20869;&#65292;&#26412;&#27425;&#24490;&#29615;&#19981;&#24517;&#20877;&#22788;&#29702;&#12290;</span><span style="color: #75715E;">*/</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>before(TCP_SKB_CB(skb)-&gt;seq, end_seq))
                        <span style="color: #F92672;">break</span>;

                <span style="color: #E6DB74;">/** &#23545;&#37325;&#20256;&#38431;&#21015;&#20013;&#30340;TSO&#27573;&#36827;&#34892;&#22788;&#29702; */</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26816;&#27979;&#24403;&#21069;&#30340;&#27573;&#26159;&#21542;&#25972;&#20010;&#22788;&#20110;&#35813;SACK&#22359;&#20013;&#65288;&#22914;&#19979;&#22270;&#65289;&#65292;&#22914;&#26524;&#26159;&#65292;</span>
<span style="color: #75715E;">                &#21017;&#35828;&#26126;&#24403;&#21069;&#30340;&#27573;&#25509;&#25910;&#26041;&#24050;&#23436;&#20840;&#25509;&#25910;&#21040;&#65292;&#26080;&#35770;&#26159;TSO&#27573;&#36824;&#26159;&#26222;&#36890;&#27573;&#12290;</span><span style="color: #75715E;">*/</span>
                in_sack = <span style="color: #E6DB74; font-weight: bold;">!</span>after(start_seq, TCP_SKB_CB(skb)-&gt;seq) &amp;&amp;
                        <span style="color: #E6DB74; font-weight: bold;">!</span>before(end_seq, TCP_SKB_CB(skb)-&gt;end_seq);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;&#24403;&#21069;&#27573;&#26159;&#21542;&#26159;TSO&#27573;&#12290;</span>
                pcount = tcp_skb_pcount(skb);
                <span style="color: #E6DB74;">/** &#22914;&#26524;&#24403;&#21069;&#27573;&#26159;TSO&#27573;&#65292;&#19988;&#19982;SACK&#22359;&#26377;&#20132;&#38598;&#65292;&#21017;&#35828;&#26126;&#25509;&#25910;&#26041;&#25910;&#21040;&#20102;&#37096;&#20998;&#25968;&#25454;&#65292;</span>
<span style="color: #E6DB74;">                &#37027;&#20123;&#24050;&#25509;&#25910;&#30340;&#27573;&#23601;&#19981;&#35201;&#35201;&#20877;&#37325;&#20256;&#20102;&#65292;&#22240;&#27492;&#25226;TSO&#27573;&#20998;&#21106;&#25104;&#26222;&#36890;&#30340;&#27573;&#12290;*/</span>
                <span style="color: #F92672;">if</span> (pcount &gt; 1 &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>in_sack &amp;&amp;
                    after(TCP_SKB_CB(skb)-&gt;end_seq, start_seq)) {
                        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">pkt_len</span>;
                        <span style="color: #E6DB74;">/** &#22914;&#26524;&#24403;&#21069;&#27573;&#26159;TSO&#27573;&#19988;&#19982;SACK&#22359;&#26377;&#20132;&#38598;&#65292;&#21017;&#21482;&#26377;&#22914;&#22270;&#20013;a&#21644;c&#20004;&#31181;&#24773;&#20917;&#12290;</span>
<span style="color: #E6DB74;">                        &#36825;&#20004;&#31181;&#24773;&#24418;&#19979;&#35745;&#31639;TSO&#20998;&#27573;&#27573;&#38271;&#26159;&#19981;&#19968;&#26679;&#30340;&#12290;</span>
<span style="color: #E6DB74;">                           &#22914;&#26524;SACK&#22359;&#30340;start_seq&#22312;&#27573;&#30340;seq&#20043;&#21518;&#65292;&#21487;&#20197;&#20174;&#22270;&#20013;&#30340;a&#30475;&#20986;seq&#21644;start_seq</span>
<span style="color: #E6DB74;">                        &#20043;&#38388;&#30340;&#25968;&#25454;&#25509;&#25910;&#26041;&#27809;&#26377;&#25509;&#25910;&#21040;&#65292;&#22240;&#27492;&#21487;&#20197;&#20351;&#29992;&#65288;start_seq-seq&#65289;&#20316;&#20026;&#25163;&#21160;TSO&#20998;&#27573;&#30340;&#27573;&#38271;&#12290;</span>
<span style="color: #E6DB74;">                           &#22914;&#26524;&#27573;&#30340;seq&#22312;SACK&#22359;&#30340;start_seq&#20043;&#21518;&#65292;&#21487;&#20197;&#20174;&#22270;&#20013;&#30340;c&#30475;&#20986;seq&#21644;SACK&#22359;&#30340;end_seq&#20043;&#38388;&#30340;&#25968;&#25454;</span>
<span style="color: #E6DB74;">                           &#25509;&#25910;&#26041;&#24050;&#32463;&#25509;&#25910;&#21040;&#65292;&#22240;&#27492;&#21487;&#20197;&#20351;&#29992;&#65288;end_seq-seq&#65289;&#20316;&#20026;&#25163;&#21160;TSO&#20998;&#27573;&#30340;&#27573;&#38271;</span>
<span style="color: #E6DB74;">                        */</span>
                        in_sack = <span style="color: #E6DB74; font-weight: bold;">!</span>after(start_seq,
                                         TCP_SKB_CB(skb)-&gt;seq);

                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>in_sack)
                                pkt_len = (start_seq -
                                           TCP_SKB_CB(skb)-&gt;seq);
                        <span style="color: #F92672;">else</span>
                                pkt_len = (end_seq -
                                           TCP_SKB_CB(skb)-&gt;seq);
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35843;&#29992;tcp_fragment&#25163;&#21160;&#23545;TSO&#27573;&#36827;&#34892;&#20998;&#27573;</span>
                        <span style="color: #F92672;">if</span> (tcp_fragment(sk, skb, pkt_len, skb_shinfo(skb)-&gt;gso_size))
                                <span style="color: #F92672;">break</span>;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#33719;&#21462;TSO&#20998;&#27573;&#21518;&#30340;&#27573;&#25968;&#65292;&#29992;&#20110;&#35745;&#31639;fackets_out</span>
                        pcount = tcp_skb_pcount(skb);
                }
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#32047;&#35745;fackets_out</span>
                fack_count += pcount;

</pre>
</div>

<div id="orge82509c" class="figure">
<p><img src="image/tcp-output/retrans-queue-sack.png" alt="retrans-queue-sack.png" />
</p>
<p><span class="figure-number">Figure 16: </span>重传队列中段与SACK块的关系</p>
</div>
<div class="org-src-container">
<pre class="src src-c">                        <span style="color: #E6DB74;">/** &#22914;&#26524;&#26159;DSACK,&#19988;SACK&#22359;&#30340;start_seq&#22312;TCP&#27573;&#30340;seq&#20043;&#21069;&#65292;&#21516;&#26102;&#35813;TCP&#27573;&#30340;&#35760;&#20998;&#29260;&#26377;&#37325;&#20256;&#26631;&#24535;&#65292;</span>
<span style="color: #E6DB74;">                        &#21017;&#35828;&#26126;&#25509;&#25910;&#26041;&#24050;&#32463;&#37325;&#22797;&#25509;&#25910;&#20102;&#35813;TCP&#27573;&#65292;&#22240;&#27492;&#38656;&#35201;&#20943;&#23569;undo_retrans */</span>
                        sacked = TCP_SKB_CB(skb)-&gt;sacked;

                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Account D-SACK for retransmitted packet.</span><span style="color: #75715E;"> */</span>
                        <span style="color: #F92672;">if</span> ((dup_sack &amp;&amp; in_sack) &amp;&amp;
                            (sacked &amp; TCPCB_RETRANS) &amp;&amp;
                            after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;undo_marker))
                                tp-&gt;undo_retrans--;
                        <span style="color: #E6DB74;">/** &#22914;&#26524;&#27492;&#27425;&#30830;&#35748;&#30340;&#27573;&#24050;&#32463;&#30830;&#35748;&#36807;&#65292;&#21017;&#36339;&#36807;&#35813;&#27573;&#65292;&#22788;&#29702;&#21518;&#32493;&#30340;&#27573;*/</span>
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">The frame is ACKed.</span><span style="color: #75715E;"> */</span>
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una)) {
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#24050;&#30830;&#35748;&#30340;&#27573;&#37325;&#20256;&#36807;&#65292;SACK&#20013;&#23384;&#22312;DSACK,&#21516;&#26102;&#24403;&#21069;&#30340;SACK&#22359;&#30830;&#35748;&#20102;&#35813;&#27573;&#65292;</span>
<span style="color: #75715E;">                        &#21017;&#21462;fack_count&#21644;record&#20013;&#30340;&#36739;&#23567;&#20540;&#20316;&#20026;&#20020;&#26102;fackets_out&#20445;&#23384;&#36215;&#26469;</span><span style="color: #75715E;">*/</span>
                                <span style="color: #F92672;">if</span> (sacked&amp;TCPCB_RETRANS) {
                                        <span style="color: #F92672;">if</span> ((dup_sack &amp;&amp; in_sack) &amp;&amp;
                                            (sacked&amp;TCPCB_SACKED_ACKED))
                                                reord = min(fack_count, reord);
                                } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#24050;&#30830;&#35748;&#30340;&#27573;&#27809;&#26377;&#37325;&#20256;&#36807;&#65292;&#19988;&#33853;&#22312;SACK&#22359;&#20043;&#38388;&#30340;&#31354;&#27934;&#20013;&#65292;</span>
<span style="color: #75715E;">                                &#21017;&#21462;fack_count&#21644;record&#20013;&#30340;&#36739;&#23567;&#20540;&#20316;&#20026;&#20020;&#26102;fackets_out&#20540;&#20445;&#23384;&#36215;&#26469;</span><span style="color: #75715E;">*/</span>
                                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">If it was in a hole, we detected reordering.</span><span style="color: #75715E;"> */</span>
                                        <span style="color: #F92672;">if</span> (fack_count &lt; prior_fackets &amp;&amp;
                                            <span style="color: #E6DB74; font-weight: bold;">!</span>(sacked&amp;TCPCB_SACKED_ACKED))
                                                reord = min(fack_count, reord);
                                }

                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Nothing to do; acked frame is about to be dropped.</span><span style="color: #75715E;"> */</span>
                                <span style="color: #F92672;">continue</span>;
                        }
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21487;&#33021;&#20002;&#22833;&#30340;&#27573;&#30340;&#33539;&#22260;&#22788;&#20110;&#37325;&#20256;&#38431;&#21015;&#22836;&#21644;SACK&#22359;&#20013;&#26368;&#21518;&#19968;&#20010;&#37325;&#20256;&#27573;&#20043;&#38388;</span>
                        <span style="color: #F92672;">if</span> ((sacked&amp;TCPCB_SACKED_RETRANS) &amp;&amp;
                            after(end_seq, TCP_SKB_CB(skb)-&gt;ack_seq) &amp;&amp;
                            (<span style="color: #E6DB74; font-weight: bold;">!</span>lost_retrans || after(end_seq, lost_retrans)))
                                lost_retrans = end_seq;
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#19981;&#22788;&#29702;&#33853;&#22312;SACK&#22359;&#20043;&#38388;&#30340;&#31354;&#38553;&#20013;&#30340;&#27573;&#12290;</span>
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>in_sack)
                                <span style="color: #F92672;">continue</span>;

                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(sacked&amp;TCPCB_SACKED_ACKED)) {
                                <span style="color: #E6DB74;">/** &#22914;&#26524;SACK&#22359;&#30830;&#35748;&#30340;&#26159;&#35748;&#20026;&#20002;&#22833;&#36807;&#24182;&#32463;&#36807;&#37325;&#20256;&#30340;&#27573;&#65292;&#32780;&#27492;&#27425;&#32463;&#36807;&#20102;SACK&#30830;&#35748;&#65292;</span>
<span style="color: #E6DB74;">                                &#35828;&#26126;&#35813;&#27573;&#27809;&#26377;&#20002;&#22833;&#65292;&#22240;&#27492;&#21462;&#20986;LOST&#21644;SACKED_RETRANS&#26631;&#35760;&#65292;&#21516;&#26102;&#35843;&#25972;lost_out&#21644;retrans_out&#12290;</span>
<span style="color: #E6DB74;">                                &#23545;&#20110;&#27809;&#26377;&#20002;&#22833;&#30340;&#27573;&#65292;&#21017;&#26080;&#38656;&#28165;&#38500;RETRANS&#26631;&#35760;&#65292;&#22240;&#20026;&#27492;&#26102;&#35813;&#27573;&#36824;&#22312;&#20256;&#36755;&#36807;&#31243;&#20013;*/</span>
                                <span style="color: #F92672;">if</span> (sacked &amp; TCPCB_SACKED_RETRANS) {
                                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">If the segment is not tagged as lost,</span>
<span style="color: #75715E;">                                         * we do not clear RETRANS, believing</span>
<span style="color: #75715E;">                                         * that retransmission is still in flight.</span>
<span style="color: #75715E;">                                         */</span>
                                        <span style="color: #F92672;">if</span> (sacked &amp; TCPCB_LOST) {
                                                TCP_SKB_CB(skb)-&gt;sacked &amp;= ~(TCPCB_LOST|TCPCB_SACKED_RETRANS);
                                                tp-&gt;lost_out -= tcp_skb_pcount(skb);
                                                tp-&gt;retrans_out -= tcp_skb_pcount(skb);

                                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">clear lost hint</span><span style="color: #75715E;"> */</span>
                                                tp-&gt;retransmit_skb_hint = <span style="color: #AE81FF;">NULL</span>;
                                        }
                                } <span style="color: #F92672;">else</span> {<span style="color: #E6DB74;">/** &#22914;&#26524;SACK&#30830;&#35748;&#30340;&#26159;&#27809;&#26377;&#37325;&#20256;&#36807;&#30340;&#27573;&#65292;&#24182;&#19988;&#35745;&#31639;&#36807;&#31243;&#20013;&#30340;&#20020;&#26102;fackets_out&#20173;&#23567;&#20110;</span>
<span style="color: #E6DB74;">                                &#20256;&#36755;&#25511;&#21046;&#22359;&#24403;&#21069;&#30340;fackets_out&#65292;&#21017;&#21462;fack_count&#21644;record&#20013;&#30340;&#36739;&#23567;&#20540;&#20316;&#20026;&#20020;&#26102;fackets_out&#20540;&#20445;&#23384;&#36215;&#26469;&#12290;</span>
<span style="color: #E6DB74;">                                &#22914;&#26524;&#35813;&#27573;&#26631;&#35760;&#20002;&#22833;&#65292;&#21017;&#38656;&#35201;&#28165;&#26970;LOST&#26631;&#35760;&#65292;&#21516;&#26102;&#35843;&#25972;lost_out&#24182;&#28165;&#38500;retransmit_skb_hint.*/</span>
                                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">New sack for not retransmitted frame,</span>
<span style="color: #75715E;">                                         * which was in hole. It is reordering.</span>
<span style="color: #75715E;">                                         */</span>
                                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(sacked &amp; TCPCB_RETRANS) &amp;&amp;
                                            fack_count &lt; prior_fackets)
                                                reord = min(fack_count, reord);

                                        <span style="color: #F92672;">if</span> (sacked &amp; TCPCB_LOST) {
                                                TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_LOST;
                                                tp-&gt;lost_out -= tcp_skb_pcount(skb);

                                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">clear lost hint</span><span style="color: #75715E;"> */</span>
                                                tp-&gt;retransmit_skb_hint = <span style="color: #AE81FF;">NULL</span>;
                                        }
                                }
                                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35813;&#27573;&#22312;SACK&#20013;&#65292;&#38656;&#35201;&#28155;&#21152;&#30456;&#20851;&#26631;&#35760;&#65292;&#32047;&#35745;sacked_out,&#26356;&#26032;fackets_out</span>
                                TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_SACKED_ACKED;
                                flag |= FLAG_DATA_SACKED;
                                tp-&gt;sacked_out += tcp_skb_pcount(skb);

                                <span style="color: #F92672;">if</span> (fack_count &gt; tp-&gt;fackets_out)
                                        tp-&gt;fackets_out = fack_count;
                        } <span style="color: #F92672;">else</span> {<span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#35813;&#27573;&#24050;&#32463;&#36890;&#36807;SACK&#30830;&#35748;&#19988;&#37325;&#20256;&#36807;&#65292;&#21516;&#26102;SACK&#20013;&#23384;&#22312;DSACK,</span>
<span style="color: #75715E;">                        &#21017;&#21462;fack_count&#21644;record&#20013;&#30340;&#36739;&#23567;&#20540;&#20316;&#20026;&#20020;&#26102;fackets_out&#20540;&#20445;&#23384;&#36215;&#26469;&#12290;</span><span style="color: #75715E;">*/</span>
                                <span style="color: #F92672;">if</span> (dup_sack &amp;&amp; (sacked&amp;TCPCB_RETRANS))
                                        reord = min(fack_count, reord);
                        }

                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">D-SACK. We can detect redundant retransmission</span>
<span style="color: #75715E;">                         * in S|R and plain R frames and clear it.</span>
<span style="color: #75715E;">                         * undo_retrans is decreased above, L|R frames</span>
<span style="color: #75715E;">                         * are accounted above as well.</span>
<span style="color: #75715E;">                         */</span>
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#23545;&#20110;&#37325;&#20256;&#21253;&#30340;SACK,&#21017;&#35828;&#26126;&#37325;&#20256;&#26159;&#22810;&#20313;&#30340;&#65292;&#24182;&#19988;&#24050;&#32463;&#24471;&#21040;SACK&#30830;&#35748;&#65292;&#22240;&#27492;&#38656;&#35201;&#20943;&#23567;retrans_out&#65292;</span>
<span style="color: #75715E;">                        &#24182;&#28165;&#38500;retrasnmit_skb_hint</span><span style="color: #75715E;">*/</span>
                        <span style="color: #F92672;">if</span> (dup_sack &amp;&amp;
                            (TCP_SKB_CB(skb)-&gt;sacked&amp;TCPCB_SACKED_RETRANS)) {
                                TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_RETRANS;
                                tp-&gt;retrans_out -= tcp_skb_pcount(skb);
                                tp-&gt;retransmit_skb_hint = <span style="color: #AE81FF;">NULL</span>;
                        }
                }
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Check for lost retransmit. This superb idea is</span>
<span style="color: #75715E;">         * borrowed from "ratehalving". Event "C".</span>
<span style="color: #75715E;">         * Later note: FACK people cheated me again 8),</span>
<span style="color: #75715E;">         * we have to account for reordering! Ugly,</span>
<span style="color: #75715E;">         * but should help.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #E6DB74;">/**  &#24403;&#21069;&#25317;&#22622;&#29366;&#24577;&#26426;&#22788;&#20110;Recovery&#29366;&#24577;&#20013;&#65292;&#24182;&#19988;&#23384;&#22312;&#21487;&#33021;&#20002;&#22833;&#30340;&#27573;&#65292;&#37027;&#20040;&#22312;&#21551;&#29992;FACK&#21518;&#65292;</span>
<span style="color: #E6DB74;">        &#25110;&#27492;&#26102;&#22914;&#26524;&#24207;&#21495;&#22312;SND.UNA&#21644;lost_retrans&#20043;&#38388;&#30340;&#27573;&#19982;&#21487;&#33021;&#20002;&#22833;&#30340;&#26368;&#22823;&#24207;&#21495;&#20043;&#38388;&#30340;&#27573;&#21306;&#22495;&#36229;&#36807;</span>
<span style="color: #E6DB74;">        &#21487;&#20197;&#37325;&#26032;&#25490;&#24207;&#30340;&#38408;&#20540;&#65292;&#21017;&#23558;&#36825;&#20123;&#27573;&#30340;&#24050;&#37325;&#20256;&#26631;&#35760;&#21435;&#25481;&#65292;&#22240;&#20026;&#38656;&#35201;&#37325;&#26032;&#25490;&#24207;&#65292;&#21363;&#37325;&#20256;&#20174;&#22836;&#24320;&#22987;&#12290;</span>
<span style="color: #E6DB74;">        &#32780;&#37027;&#20123;&#27809;&#26377;&#26631;&#35760;&#20002;&#22833;&#25110;&#32463;&#36807;SACK&#30830;&#35748;&#30340;&#27573;&#65292;&#21017;&#26126;&#30830;&#30340;&#35748;&#20026;&#23427;&#20204;&#24050;&#32463;&#20002;&#22833;&#65292;&#21152;&#19978;LOST&#26631;&#35760;&#12290;</span>
<span style="color: #E6DB74;">        */</span>
        <span style="color: #F92672;">if</span> (lost_retrans &amp;&amp; icsk-&gt;icsk_ca_state == TCP_CA_Recovery) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;

                sk_stream_for_retrans_queue(skb, sk) {
                        <span style="color: #F92672;">if</span> (after(TCP_SKB_CB(skb)-&gt;seq, lost_retrans))
                                <span style="color: #F92672;">break</span>;
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una))
                                <span style="color: #F92672;">continue</span>;
                        <span style="color: #F92672;">if</span> ((TCP_SKB_CB(skb)-&gt;sacked&amp;TCPCB_SACKED_RETRANS) &amp;&amp;
                            after(lost_retrans, TCP_SKB_CB(skb)-&gt;ack_seq) &amp;&amp;
                            (IsFack(tp) ||
                             <span style="color: #E6DB74; font-weight: bold;">!</span>before(lost_retrans,
                                     TCP_SKB_CB(skb)-&gt;ack_seq + tp-&gt;reordering *
                                     tp-&gt;mss_cache))) {
                                TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_RETRANS;
                                tp-&gt;retrans_out -= tcp_skb_pcount(skb);

                                <span style="color: #75715E;">/* </span><span style="color: #75715E;">clear lost hint</span><span style="color: #75715E;"> */</span>
                                tp-&gt;retransmit_skb_hint = <span style="color: #AE81FF;">NULL</span>;

                                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(TCP_SKB_CB(skb)-&gt;sacked&amp;(TCPCB_LOST|TCPCB_SACKED_ACKED))) {
                                        tp-&gt;lost_out += tcp_skb_pcount(skb);
                                        TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;
                                        flag |= FLAG_DATA_SACKED;
                                        NET_INC_STATS_BH(LINUX_MIB_TCPLOSTRETRANSMIT);
                                }
                        }
                }
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35745;&#31639;&#24050;&#31163;&#24320;&#20027;&#26426;&#32593;&#32476;&#20294;&#26410;&#34987;&#30830;&#35748;&#30340;TCP&#27573;&#25968;&#65292;&#21253;&#25324;&#36890;&#36807;SACK&#30830;&#35748;&#30340;&#27573;&#21644;&#30830;&#35748;&#20002;&#22833;&#30340;&#27573;&#12290;</span>
        tp-&gt;left_out = tp-&gt;sacked_out + tp-&gt;lost_out;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24403;&#25317;&#22622;&#29366;&#24577;&#26426;&#19981;&#22788;&#20110;Loss&#29366;&#24577;&#26102;&#65292;&#22914;&#26524;&#26377;&#27573;&#34987;&#30830;&#35748;&#65292;&#21017;&#35201;&#26356;&#26032;&#25490;&#24207;&#38408;&#20540;&#12290;</span>
        <span style="color: #F92672;">if</span> ((reord &lt; tp-&gt;fackets_out) &amp;&amp; icsk-&gt;icsk_ca_state != TCP_CA_Loss)
                <span style="color: #A6E22E;">tcp_update_reordering</span>(sk, ((tp-&gt;fackets_out + 1) - reord), 0);

<span style="color: #F92672;">#if</span> FASTRETRANS_DEBUG &gt; 0
        <span style="color: #A6E22E;">BUG_TRAP</span>((<span style="color: #66D9EF;">int</span>)tp-&gt;sacked_out &gt;= 0);
        <span style="color: #A6E22E;">BUG_TRAP</span>((<span style="color: #66D9EF;">int</span>)tp-&gt;lost_out &gt;= 0);
        <span style="color: #A6E22E;">BUG_TRAP</span>((<span style="color: #66D9EF;">int</span>)tp-&gt;retrans_out &gt;= 0);
        <span style="color: #A6E22E;">BUG_TRAP</span>((<span style="color: #66D9EF;">int</span>)<span style="color: #A6E22E;">tcp_packets_in_flight</span>(tp) &gt;= 0);
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36820;&#22238;&#22788;&#29702;SACK&#36873;&#39033;&#24471;&#21040;&#30340;&#26631;&#35760;&#12290;</span>
        <span style="color: #F92672;">return</span> flag;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org7b741ef" class="outline-3">
<h3 id="org7b741ef"><span class="section-number-3">6.4.</span> 重传队列中已经确认段的删除：tcp_clean_rtx_queue()</h3>
<div class="outline-text-3" id="text-6-4">
<p>
tcp_clean_rtx_queue()用来删除释放重传队列中已确认的段。在处理时，会遍历重传队列，直至当前段没有被完全确认为止。过程如下：
</p>
<ul class="org-ul">
<li>如果只是确认了TSO段中的一部分，则需要做特别处理</li>
<li>如果确认了路径MTU探测段，则需要作调整发送窗口等操作</li>
<li>根据段中的记分牌和处理中得到的标志，做时间戳采样等处理</li>
<li>调整fackets_out和packets_out，最后将段从重传队列中删除并释放</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Remove acknowledged frames from the retransmission queue.</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_clean_rtx_queue</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>,
<span style="color: #66D9EF;">__s32</span> *<span style="color: #FD971F;">seq_rtt_p</span>) <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36820;&#22238;&#22312;&#21024;&#38500;&#37325;&#20256;&#38431;&#21015;&#20013;&#24050;&#30830;&#35748;&#27573;&#36807;&#31243;&#20013;&#24471;&#21040;&#30340;&#24448;&#36820;&#26102;&#38388;</span>
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>;
        <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">now</span> = tcp_time_stamp;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">acked</span> = 0;
        <span style="color: #66D9EF;">__s32</span> <span style="color: #FD971F;">seq_rtt</span> = -1;
        <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">pkts_acked</span> = 0;
        <span style="color: #66D9EF;">void</span> (*<span style="color: #A6E22E;">rtt_sample</span>)(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">usrtt</span>)
                = icsk-&gt;icsk_ca_ops-&gt;rtt_sample;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">timeval</span> <span style="color: #FD971F;">tv</span> = { .tv_sec = 0, .tv_usec = 0 };
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#24490;&#29615;&#22788;&#29702;&#37325;&#20256;&#38431;&#21015;&#30340;&#27573;</span>
        <span style="color: #F92672;">while</span> ((skb = skb_peek(&amp;sk-&gt;sk_write_queue)) &amp;&amp;
               skb != sk-&gt;sk_send_head) {
                <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_skb_cb</span> *<span style="color: #FD971F;">scb</span> = TCP_SKB_CB(skb);
                <span style="color: #66D9EF;">__u8</span> <span style="color: #FD971F;">sacked</span> = scb-&gt;sacked;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">If our packet is before the ack sequence we can</span>
<span style="color: #75715E;">                 * discard it as it's confirmed to have arrived at</span>
<span style="color: #75715E;">                 * the other end.</span>
<span style="color: #75715E;">                 */</span>
                 <span style="color: #E6DB74;">/** &#22914;&#26524;&#20043;&#30830;&#35748;&#20102;TSO&#27573;&#20013;&#30340;&#19968;&#37096;&#20998;&#65292;&#21017;&#25226;&#24050;&#30830;&#35748;&#30340;&#37096;&#20998;&#20174;TCP&#27573;&#20013;&#21024;&#38500;&#65292;</span>
<span style="color: #E6DB74;">                 &#21516;&#26102;&#35201;&#26356;&#26032;SKB&#20013;&#25903;&#25345;GSO&#30340;&#30456;&#20851;&#20449;&#24687;&#65288;gso_size gso_segs gso_type&#65289;,&#25509;&#30528;&#23545;&#20110;&#21097;&#19979;&#26410;&#30830;&#35748;&#30340;&#37096;&#20998;&#65292;</span>
<span style="color: #E6DB74;">                 &#26681;&#25454;&#26631;&#35760;&#23545;sacked_out&#12289;loss_out&#31561;&#20570;&#20986;&#26356;&#26032;&#65292;&#24182;&#35745;&#31639;&#24448;&#36820;&#26102;&#38388;&#12290;&#23436;&#25104;&#21518;&#65292;&#32467;&#26463;&#26412;&#27425;&#28165;&#29702;&#24050;&#30830;&#35748;&#27573;&#30340;&#32473;&#24037;&#20316;&#65292;</span>
<span style="color: #E6DB74;">                 &#22240;&#20026;&#25509;&#19979;&#26469;&#30340;&#27573;&#37117;&#26159;&#36824;&#26410;&#30830;&#35748;&#30340;*/</span>
                <span style="color: #F92672;">if</span> (after(scb-&gt;end_seq, tp-&gt;snd_una)) {
                        <span style="color: #F92672;">if</span> (tcp_skb_pcount(skb) &gt; 1 &amp;&amp;
                            after(tp-&gt;snd_una, scb-&gt;seq))
                                acked |= tcp_tso_acked(sk, skb,
                                                       now, &amp;seq_rtt);
                        <span style="color: #F92672;">break</span>;
                }

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Initial outgoing SYN's get put onto the write_queue</span>
<span style="color: #75715E;">                 * just like anything else we transmit.  It is not</span>
<span style="color: #75715E;">                 * true data, and if we misinform our callers that</span>
<span style="color: #75715E;">                 * this ACK acks real data, we will erroneously exit</span>
<span style="color: #75715E;">                 * connection startup slow start one packet too</span>
<span style="color: #75715E;">                 * quickly.  This is severely frowned upon behavior.</span>
<span style="color: #75715E;">                 */</span>
                <span style="color: #E6DB74;">/** &#22914;&#26524;&#30830;&#35748;&#20102;&#25972;&#20010;&#27573;&#65292;&#21017;&#26681;&#25454;&#26631;&#24535;&#35774;&#32622;&#20020;&#26102;&#21464;&#37327;acked&#26631;&#24535;&#65292;&#29992;&#20110;&#21518;&#32493;&#22788;&#29702;*/</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>(scb-&gt;flags &amp; TCPCB_FLAG_SYN)) {
                        acked |= FLAG_DATA_ACKED;
                        ++pkts_acked;
                } <span style="color: #F92672;">else</span> {
                        acked |= FLAG_SYN_ACKED;
                        tp-&gt;retrans_stamp = 0;
                }

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">MTU probing checks</span><span style="color: #75715E;"> */</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#30830;&#35748;&#20102;&#36335;&#24452;MTU&#25506;&#27979;&#27573;&#65292;&#21017;&#35843;&#29992;tcp_mtup_probe_success()&#22788;&#29702;</span>
                <span style="color: #F92672;">if</span> (icsk-&gt;icsk_mtup.probe_size) {
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>after(tp-&gt;mtu_probe.probe_seq_end, TCP_SKB_CB(skb)-&gt;end_seq)) {
                                tcp_mtup_probe_success(sk, skb);
                        }
                }
                <span style="color: #E6DB74;">/** &#26681;&#25454;&#35813;&#27573;&#20013;&#30340;&#35760;&#20998;&#29260;&#21644;&#22788;&#29702;&#36807;&#31243;&#20013;&#24471;&#21040;&#30340;&#26631;&#24535;&#65292;&#36827;&#34892;&#30456;&#24212;&#22788;&#29702;&#65292;&#27604;&#22914;&#36827;&#34892;&#26102;&#38388;&#25139;&#37319;&#26679;&#31561;*/</span>
                <span style="color: #F92672;">if</span> (sacked) {
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#27573;&#37325;&#20256;&#36807;&#65292;&#21017;&#35774;&#32622;&#30456;&#24212;&#30340;&#26631;&#24535;&#65292;&#21542;&#21017;&#33719;&#21462;&#24448;&#36820;&#26102;&#38388;&#21644;&#26102;&#38388;&#25139;</span>
                        <span style="color: #F92672;">if</span> (sacked &amp; TCPCB_RETRANS) {
                                <span style="color: #F92672;">if</span>(sacked &amp; TCPCB_SACKED_RETRANS)
                                        tp-&gt;retrans_out -= tcp_skb_pcount(skb);
                                acked |= FLAG_RETRANS_DATA_ACKED;
                                seq_rtt = -1;
                        } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (seq_rtt &lt; 0) {
                                seq_rtt = now - scb-&gt;when;
                                skb_get_timestamp(skb, &amp;tv);
                        }
                        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#26631;&#35760;&#26356;&#26032;sacked_out&#21644;lost_out</span>
                        <span style="color: #F92672;">if</span> (sacked &amp; TCPCB_SACKED_ACKED)
                                tp-&gt;sacked_out -= tcp_skb_pcount(skb);
                        <span style="color: #F92672;">if</span> (sacked &amp; TCPCB_LOST)
                                tp-&gt;lost_out -= tcp_skb_pcount(skb);
                        <span style="color: #F92672;">if</span> (sacked &amp; TCPCB_URG) { <span style="color: #75715E;">//</span><span style="color: #75715E;">&#30830;&#35748;&#30340;&#27573;&#20013;&#23384;&#22312;&#24102;&#22806;&#25968;&#25454;&#65292;&#19988;TCP&#22788;&#20110;&#32039;&#24613;&#27169;&#24335;&#65292;&#21017;&#22797;&#20301;</span>
                                <span style="color: #F92672;">if</span> (tp-&gt;urg_mode &amp;&amp;
                                    <span style="color: #E6DB74; font-weight: bold;">!</span>before(scb-&gt;end_seq, tp-&gt;snd_up))
                                        tp-&gt;urg_mode = 0;
                        }
                } <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (seq_rtt &lt; 0) {<span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#27573;&#20013;&#30340;&#35760;&#20998;&#29260;&#22312;&#22788;&#29702;&#36807;&#31243;&#20013;&#27809;&#26377;&#24471;&#21040;&#26631;&#24535;&#65292;</span>
<span style="color: #75715E;">                &#19988;&#26410;&#33719;&#21462;&#30701;&#30701;&#32780;&#24448;&#36820;&#26102;&#38388;&#65292;&#21017;&#20197;&#21457;&#36865;&#35813;&#27573;&#19982;&#25509;&#25910;&#21040;&#35813;ACK&#27573;&#20043;&#38388;&#30340;&#26102;&#38388;&#38388;&#38548;&#20316;&#20026;&#24448;&#36820;&#26102;&#38388;&#65292;</span>
<span style="color: #75715E;">                &#21516;&#26102;&#20174;SKB&#20013;&#33719;&#21462;&#26102;&#38388;&#25139;</span><span style="color: #75715E;">*/</span>
                        seq_rtt = now - scb-&gt;when;
                        skb_get_timestamp(skb, &amp;tv);
                }
                <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#24403;&#21069;&#27573;&#24050;&#30830;&#35748;&#20102;&#65292;&#22240;&#27492;&#38656;&#35201;&#35843;&#25972;fackets_out&#21644;packets_out,&#26368;&#21518;&#23558;&#35813;&#27573;&#20174;&#37325;&#20256;&#38431;&#21015;&#24635;&#21024;&#38500;&#37322;&#25918;</span><span style="color: #75715E;">*/</span>
                tcp_dec_pcount_approx(&amp;tp-&gt;fackets_out, skb);
                tcp_packets_out_dec(tp, skb);
                __skb_unlink(skb, &amp;sk-&gt;sk_write_queue);
                sk_stream_free_skb(sk, skb);
                clear_all_retrans_hints(tp);
        }
        <span style="color: #E6DB74;">/** &#22914;&#26524;&#26412;&#27425;&#22788;&#29702;&#20013;&#26377;&#23545;&#25968;&#25454;&#25110;SYN&#27573;&#30340;&#30830;&#35748;&#65292;&#21017;&#38656;&#35201;&#27979;&#37327;&#12289;&#26356;&#26032;&#24448;&#36820;&#26102;&#38388;&#12290;&#28982;&#21518;&#26681;&#25454;&#32593;&#32476;&#20256;&#36755;&#20013;&#30340;</span>
<span style="color: #E6DB74;">        &#27573;&#25968;&#26469;&#30830;&#23450;&#26159;&#21542;&#21551;&#21160;&#37325;&#20256;&#23450;&#26102;&#22120;&#12290;</span>
<span style="color: #E6DB74;">            &#22914;&#26524;&#24403;&#21069;&#30340;&#25317;&#22622;&#25511;&#21046;&#31639;&#27861;&#23454;&#29616;&#20102;rtt_sample&#25509;&#21475;&#65292;&#19988;&#26412;&#27425;&#22788;&#29702;&#30340;&#19981;&#26159;&#23545;&#37325;&#20256;&#27573;&#30340;&#30830;&#35748;&#65292;&#21017;&#35843;&#29992;</span>
<span style="color: #E6DB74;">        rtt_sample&#25509;&#21475;&#36827;&#34892;&#24448;&#36820;&#26102;&#38388;&#30340;&#37319;&#26679;&#12290;</span>
<span style="color: #E6DB74;">            &#22914;&#26524;&#24403;&#21069;&#30340;&#25317;&#22622;&#25511;&#21046;&#31639;&#27861;&#23454;&#29616;&#20102;pkts_acked&#25509;&#21475;&#65292;&#21017;&#35843;&#29992;&#35813;&#25509;&#21475;&#36827;&#34892;&#25317;&#22622;&#25511;&#21046;&#31639;&#27861;&#30340;&#20869;&#37096;&#22788;&#29702;&#12290;</span>
<span style="color: #E6DB74;">        */</span>
        <span style="color: #F92672;">if</span> (acked&amp;FLAG_ACKED) {
                tcp_ack_update_rtt(sk, acked, seq_rtt);
                tcp_ack_packets_out(sk, tp);
                <span style="color: #F92672;">if</span> (rtt_sample &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>(acked &amp; FLAG_RETRANS_DATA_ACKED))
                        (*rtt_sample)(sk, tcp_usrtt(&amp;tv));

                <span style="color: #F92672;">if</span> (icsk-&gt;icsk_ca_ops-&gt;pkts_acked)
                        icsk-&gt;icsk_ca_ops-&gt;pkts_acked(sk, pkts_acked);
        }

<span style="color: #F92672;">#if</span> FASTRETRANS_DEBUG &gt; 0
        BUG_TRAP((<span style="color: #66D9EF;">int</span>)tp-&gt;sacked_out &gt;= 0);
        BUG_TRAP((<span style="color: #66D9EF;">int</span>)tp-&gt;lost_out &gt;= 0);
        BUG_TRAP((<span style="color: #66D9EF;">int</span>)tp-&gt;retrans_out &gt;= 0);
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tp-&gt;packets_out &amp;&amp; tp-&gt;rx_opt.sack_ok) {
                <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
                <span style="color: #F92672;">if</span> (tp-&gt;lost_out) {
                        printk(KERN_DEBUG <span style="color: #E6DB74;">"Leak l=%u %d\n"</span>,
                               tp-&gt;lost_out, icsk-&gt;icsk_ca_state);
                        tp-&gt;lost_out = 0;
                }
                <span style="color: #F92672;">if</span> (tp-&gt;sacked_out) {
                        printk(KERN_DEBUG <span style="color: #E6DB74;">"Leak s=%u %d\n"</span>,
                               tp-&gt;sacked_out, icsk-&gt;icsk_ca_state);
                        tp-&gt;sacked_out = 0;
                }
                <span style="color: #F92672;">if</span> (tp-&gt;retrans_out) {
                        printk(KERN_DEBUG <span style="color: #E6DB74;">"Leak r=%u %d\n"</span>,
                               tp-&gt;retrans_out, icsk-&gt;icsk_ca_state);
                        tp-&gt;retrans_out = 0;
                }
        }
<span style="color: #F92672;">#endif</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36820;&#22238;&#26412;&#27425;&#22788;&#29702;&#33719;&#21462;&#30340;&#24448;&#36820;&#26102;&#38388;&#21644;&#22788;&#29702;&#26631;&#24535;</span>
        *seq_rtt_p = seq_rtt;
        <span style="color: #F92672;">return</span> acked;
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org24849e9" class="outline-2">
<h2 id="org24849e9"><span class="section-number-2">7.</span> 往返时间测量和RTO的计算</h2>
<div class="outline-text-2" id="text-7">
<p>
TCP往返时间测量是指从发送方发送TCP段开始，到发送方接收到该段的相应所耗费的传输时间。当接收方和发送方同时支持TCP时间戳选项时，发送方记录在TCP首部选项内的间戳会被接收方随着响应反射回来，发送方就可以利用响应段反射的时间戳计算出发送段的即时往返传输层时间。在接收方应答不反射时间戳的情况下，发送方利用重发队列中非重传响应所确认的最先数据片段的时间戳来取样RTT。
</p>

<p>
发送方每接收到一次新的确认，都会产生一个新的RTT样本。为了避免RTT样本的随机抖动，系统利用加权平均算法对样本进行平滑。为了回避浮点运算，RTT的平滑值SRTT是世纪RTT均值的8倍，第二代过程和总SRTT收敛于8倍的RTT。
</p>

<p>
在平滑RTT样本值的同时，发送方还跟踪样本的抖动性。RTT的抖动用中心差（mdev）来衡量，即RTT与RTT均值偏差绝对值的加权平均，其值越大，说明RTT抖动的很厉害。tp-&gt;mdev_max变量用来跟踪MDEV的最大值，经过平滑身成rttvar,描述RTT抖动的最大范围。发送方的重发超时设置为RTT均值与rttvar的和。有关往返时间和重传超时时间的估算参见RFC2988。
</p>

<p>
在tcp_clean_rtx_queue()中，删除重传队列中已确认的段时，如果当前的确认是有效的，则会调用tcp_ack_update_rtt()测量、更新往返时间。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">tcp_ack_update_rtt</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flag</span>,
                                      <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">s32</span> <span style="color: #FD971F;">seq_rtt</span>)
{
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Note that peer MAY send zero echo. In this case it is ignored. (rfc1323)</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;&#26159;&#21542;&#25903;&#25345;&#26102;&#38388;&#25139;&#36873;&#39033;&#65292;&#36873;&#25321;&#19981;&#21516;&#30340;&#20989;&#25968;&#36827;&#34892;&#24448;&#36820;&#26102;&#38388;&#27979;&#27979;&#37327;&#21644;&#26356;&#26032;</span>
        <span style="color: #F92672;">if</span> (tp-&gt;rx_opt.saw_tstamp &amp;&amp; tp-&gt;rx_opt.rcv_tsecr)
                tcp_ack_saw_tstamp(sk, flag);
        <span style="color: #F92672;">else</span> <span style="color: #F92672;">if</span> (seq_rtt &gt;= 0)
                tcp_ack_no_tstamp(sk, seq_rtt, flag);
}
</pre>
</div>

<p>
tcp_ack_saw_tstamp 和 tcp_ack_no_tstamp 这两个函数最终会调用tcp_rtt_estimator()来估算RTT,然后再设置重传超时时间。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Called to compute a smoothed rtt estimate. The data fed to this</span>
<span style="color: #75715E;"> * routine either comes from timestamps, or from segments that were</span>
<span style="color: #75715E;"> * known _not_ to have been retransmitted [see Karn/Partridge</span>
<span style="color: #75715E;"> * Proceedings SIGCOMM 87]. The algorithm is from the SIGCOMM 88</span>
<span style="color: #75715E;"> * piece by Van Jacobson.</span>
<span style="color: #75715E;"> * NOTE: the next three routines used to be one big routine.</span>
<span style="color: #75715E;"> * To save cycles in the RFC 1323 implementation it was better to break</span>
<span style="color: #75715E;"> * it up into three procedures. -- erics</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">tcp_rtt_estimator</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">mrtt</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">m</span> = mrtt; <span style="color: #75715E;">/* </span><span style="color: #75715E;">RTT</span><span style="color: #75715E;"> */</span>

        <span style="color: #75715E;">/*      </span><span style="color: #75715E;">The following amusing code comes from Jacobson's</span>
<span style="color: #75715E;">         *      article in SIGCOMM '88.  Note that rtt and mdev</span>
<span style="color: #75715E;">         *      are scaled versions of rtt and mean deviation.</span>
<span style="color: #75715E;">         *      This is designed to be as fast as possible</span>
<span style="color: #75715E;">         *      m stands for "measurement".</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         *      On a 1990 paper the rto value is changed to:</span>
<span style="color: #75715E;">         *      RTO = rtt + 4 * mdev</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         * Funny. This algorithm seems to be very broken.</span>
<span style="color: #75715E;">         * These formulae increase RTO, when it should be decreased, increase</span>
<span style="color: #75715E;">         * too slowly, when it should be increased quickly, decrease too quickly</span>
<span style="color: #75715E;">         * etc. I guess in BSD RTO takes ONE value, so that it is absolutely</span>
<span style="color: #75715E;">         * does not matter how to _calculate_ it. Seems, it was trap</span>
<span style="color: #75715E;">         * that VJ failed to avoid. 8)</span>
<span style="color: #75715E;">         */</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#29992;&#20110;&#20272;&#31639;RTT&#30340;&#37319;&#26679;&#19981;&#33021;&#20026;0</span>
        <span style="color: #F92672;">if</span>(m == 0)
                m = 1;
        <span style="color: #F92672;">if</span> (tp-&gt;srtt != 0) {
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#25353;&#29031;RFC2988&#20013;&#30340;&#31639;&#27861;&#65288;SRTT=(1-1/8)*SRTT+1/8*RTT&#65289;&#26469;&#33719;&#24471;RTT&#30340;&#24179;&#28369;&#20540;</span>
                m -= (tp-&gt;srtt &gt;&gt; 3);   <span style="color: #75715E;">/* </span><span style="color: #75715E;">m is now error in rtt est</span><span style="color: #75715E;"> */</span>
                tp-&gt;srtt += m;          <span style="color: #75715E;">/* </span><span style="color: #75715E;">rtt = 7/8 rtt + 1/8 new</span><span style="color: #75715E;"> */</span>
                <span style="color: #75715E;">// </span><span style="color: #75715E;">&#25353;&#29031;&#65288;mdev=3/4mdev+1/4*(|SRTT-RTT&#37319;&#26679;|)&#65289;&#26469;&#33719;&#24471;mdev</span>
                <span style="color: #F92672;">if</span> (m &lt; 0) {
                        m = -m;         <span style="color: #75715E;">/* </span><span style="color: #75715E;">m is now abs(error)</span><span style="color: #75715E;"> */</span>
                        m -= (tp-&gt;mdev &gt;&gt; 2);   <span style="color: #75715E;">/* </span><span style="color: #75715E;">similar update on mdev</span><span style="color: #75715E;"> */</span>
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">This is similar to one of Eifel findings.</span>
<span style="color: #75715E;">                         * Eifel blocks mdev updates when rtt decreases.</span>
<span style="color: #75715E;">                         * This solution is a bit different: we use finer gain</span>
<span style="color: #75715E;">                         * for mdev in this case (alpha*beta).</span>
<span style="color: #75715E;">                         * Like Eifel it also prevents growth of rto,</span>
<span style="color: #75715E;">                         * but also it limits too fast rto decreases,</span>
<span style="color: #75715E;">                         * happening in pure Eifel.</span>
<span style="color: #75715E;">                         */</span>
                        <span style="color: #F92672;">if</span> (m &gt; 0)
                                m &gt;&gt;= 3;
                } <span style="color: #F92672;">else</span> {
                        m -= (tp-&gt;mdev &gt;&gt; 2);   <span style="color: #75715E;">/* </span><span style="color: #75715E;">similar update on mdev</span><span style="color: #75715E;"> */</span>
                }
                tp-&gt;mdev += m;          <span style="color: #75715E;">/* </span><span style="color: #75715E;">mdev = 3/4 mdev + 1/4 new</span><span style="color: #75715E;"> */</span>
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26356;&#26032;RTT&#25238;&#21160;&#30340;&#26368;&#22823;&#20540;&#33539;&#22260;&#21644;&#24179;&#28369;&#30340;RTT&#24179;&#22343;&#20559;&#24046;</span>
                <span style="color: #F92672;">if</span> (tp-&gt;mdev &gt; tp-&gt;mdev_max) {
                        tp-&gt;mdev_max = tp-&gt;mdev;
                        <span style="color: #F92672;">if</span> (tp-&gt;mdev_max &gt; tp-&gt;rttvar)
                                tp-&gt;rttvar = tp-&gt;mdev_max;
                }
                <span style="color: #E6DB74;">/** &#26816;&#27979;&#26159;&#21542;&#24212;&#35813;&#22797;&#20301;mdev_max&#65292;&#21363;&#19978;&#27425;&#22797;&#20301;mdev_max&#21518;&#25509;&#25910;&#26041;&#26159;&#21542;&#24050;&#25509;&#21463;&#23436;&#19968;&#20010;&#25509;&#25910;&#31383;&#21475;&#30340;&#25968;&#25454;&#12290;&#22914;&#26524;&#26159;&#65292;&#21017;&#22797;&#20301;mdev_max,&#21516;&#26102;&#35760;&#24405;&#22797;&#20301;mdev_max&#26631;&#35760;&#65292;&#29992;&#20110;&#19979;&#27425;&#22797;&#20301;&#12290;*/</span>
                <span style="color: #F92672;">if</span> (after(tp-&gt;snd_una, tp-&gt;rtt_seq)) {
                        <span style="color: #F92672;">if</span> (tp-&gt;mdev_max &lt; tp-&gt;rttvar)
                                tp-&gt;rttvar -= (tp-&gt;rttvar-tp-&gt;mdev_max)&gt;&gt;2;
                        tp-&gt;rtt_seq = tp-&gt;snd_nxt;
                        tp-&gt;mdev_max = TCP_RTO_MIN;
                }
        } <span style="color: #F92672;">else</span> {<span style="color: #E6DB74;">/** &#23436;&#25104;&#19968;&#20010;RTT&#27979;&#37327;&#12290;&#26681;&#25454;RTT&#30340;&#24179;&#28369;&#20540;&#21021;&#22987;&#21270;&#19982;RTT&#30456;&#20851;&#30340;&#21464;&#37327;*/</span>
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">no previous measure.</span><span style="color: #75715E;"> */</span>
                tp-&gt;srtt = m&lt;&lt;3;        <span style="color: #75715E;">/* </span><span style="color: #75715E;">take the measured time to be rtt</span><span style="color: #75715E;"> */</span>
                tp-&gt;mdev = m&lt;&lt;1;        <span style="color: #75715E;">/* </span><span style="color: #75715E;">make sure rto = 3*rtt</span><span style="color: #75715E;"> */</span>
                tp-&gt;mdev_max = tp-&gt;rttvar = max(tp-&gt;mdev, TCP_RTO_MIN);
                tp-&gt;rtt_seq = tp-&gt;snd_nxt;
        }
}
</pre>
</div>

<p>
tcp_ack_saw_tstamp 和 tcp_ack_no_tstamp 这两个函数在进行往返时间的测量和更新时，会调用tcp_set_rto()。此函数根据最近一次计算得到的RTT来计算重传超时时间。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Calculate rto without backoff.  This is the second half of Van Jacobson's</span>
<span style="color: #75715E;"> * routine referred to above.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">tcp_set_rto</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>)
{
        <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Old crap is replaced with new one. 8)</span>
<span style="color: #75715E;">         *</span>
<span style="color: #75715E;">         * More seriously:</span>
<span style="color: #75715E;">         * 1. If rtt variance happened to be less 50msec, it is hallucination.</span>
<span style="color: #75715E;">         *    It cannot be less due to utterly erratic ACK generation made</span>
<span style="color: #75715E;">         *    at least by solaris and freebsd. "Erratic ACKs" has _nothing_</span>
<span style="color: #75715E;">         *    to do with delayed acks, because at cwnd&gt;2 true delack timeout</span>
<span style="color: #75715E;">         *    is invisible. Actually, Linux-2.4 also generates erratic</span>
<span style="color: #75715E;">         *    ACKs in some circumstances.</span>
<span style="color: #75715E;">         */</span>
        inet_csk(sk)-&gt;icsk_rto = (tp-&gt;srtt &gt;&gt; 3) + tp-&gt;rttvar;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">2. Fixups made earlier cannot be right.</span>
<span style="color: #75715E;">         *    If we do not estimate RTO correctly without them,</span>
<span style="color: #75715E;">         *    all the algo is pure shit and should be replaced</span>
<span style="color: #75715E;">         *    with correct one. It is exactly, which we pretend to do.</span>
<span style="color: #75715E;">         */</span>
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgdd260a5" class="outline-2">
<h2 id="orgdd260a5"><span class="section-number-2">8.</span> 路径MTU发现</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org6aae981" class="outline-3">
<h3 id="org6aae981"><span class="section-number-3">8.1.</span> 路径MTU发现原理</h3>
<div class="outline-text-3" id="text-8-1">
<p>
当网络上一台IP主机有数据要发送给另一台IP主机时，数据最终被封装成IP数据报来传输。最理想的情况是，数据报的大小是在从源主机到目的主机的路径上无需分片的最大尺寸。这种数据报的尺寸称作路径MTU（PMTU），等于路径上每一跳MTU中的最小值。PMTU与一条路径相关，路径是源IP地址、目的IP地址，可能还有服务类型（TOS）的特定组合，参见RFC1191。
</p>

<p>
PMTU实现的技术是简单的，在IP首部中使用不分片位DF动态发现一条路径的PMTU。基本思想是源主机一开始假定一条路径的PMTU是其已知的该路径的第一跳的MTU，在这条路径上发送的数据报都设置DF位。如果有数据报太大，不被路径中的某个路由器分片就不能转发，那么该路由器将丢弃这个数据报，然后返回一个“需要分片”，但设置了DF位的ICMP的目的不可达报文。在收到这种报文后，源主机将减小其假定的该路径的PMTU。当主机对PMTU的估计值小到其发送的数据报无需分片也能转发的时候，PMTU发现过程结束。
</p>

<p>
为了支持路i那个MTU发现技术，路由器使用需要分片的ICMP目的不可达报文，在ICMP首部第二个32位字的高16位包中包含下一跳的MTU（字段在ICMP规范中被标记位“未使用”）。低16位保持未用，必须设置位0.报文格式如下：
</p>


<div id="org8dcead0" class="figure">
<p><img src="image/tcp-output/frag-imcp.png" alt="frag-imcp.png" />
</p>
<p><span class="figure-number">Figure 17: </span>需要分片的ICMP目的不可达报文</p>
</div>

<p>
下一跳MTU字段的值是沿着原始数据报的路径，在当前路由器上无需分段就能转发的最大数据报的字节数，包含IP首部和IP数据，而不包含任何更底层协议的首部。该字段值不会小于68B，即每个路由器都必须能“不分段转发68B的数据报”。
</p>

<p>
RFC1191建议了PMTU发现实现在协议层次，以及PMTU信息缓存的地方、过时PMTU信息的删除、传输层的处理过程。
</p>

<p>
对于主机如何实现PMTU只是一个建议，而不是规范，因此不同的实现其算法有可能会不同。在Linux中，对于第一条PMTU发现的实现，显然没有按照[RFC 1191]的建议放在IP层，而是放在了TCP层。对于其他的几点，也只是基本根据建议的算法来实现的。
</p>
</div>
</div>

<div id="outline-container-orgc73bacf" class="outline-3">
<h3 id="orgc73bacf"><span class="section-number-3">8.2.</span> 路径MTU发现时的黑洞</h3>
<div class="outline-text-3" id="text-8-2">
<p>
主机执行路径MTU发现方法是发送尽可能大的包，在IP首部设置分片位DF。若包太大无法由路由器转发，路由器必须给源地址发送一个目的不可达需要分片的ICMP消息。主机将根据该ICMP消息调整包的大小。而实际上会由于路由器不支持该功能，或者内核bug,或者配置原因，导致许多路由器未能发送ICMP消息。
</p>

<p>
如果源主机未能收到此类ICMP消息，则将导致PMTU发现失败。没有ICMP消息通知，源主机就无法知道需要减小包大小，上层协议会继续尝试发送大包，这些包将在黑洞中消失。
</p>

<p>
当由于没有收到ICMP消息而导致PMTU发现失败时，TCP在某些条件下也会完全失效。对于到目的主机的ping和某些交互式TCP连接，这种故障难以察觉，因为其发送的数据报一般都比较小，表现正常。而大流量传输在第一个大包失败时，连接就会超时。这种情况下通常是由于网络中的配置错误造成的。
</p>
</div>
</div>

<div id="outline-container-org3809ec1" class="outline-3">
<h3 id="org3809ec1"><span class="section-number-3">8.3.</span> 有关数据结构的初始化</h3>
<div class="outline-text-3" id="text-8-3">
<p>
建立一个新的传输控制块后，会调用tcp_mtup_init()初始化相关成员，保活通过tcp_mtu_probing()确定是否启用路径MTU发现，用于路径MTU发现的区间，以及当前路径MTU探测段的长度。
</p>
</div>
</div>

<div id="outline-container-org01f47df" class="outline-3">
<h3 id="org01f47df"><span class="section-number-3">8.4.</span> 创建路径MTU发向TCP段并发送</h3>
<div class="outline-text-3" id="text-8-4">
<p>
tcp_mtu_probe()用来创建一个新的路径MTU发现段，该函数在tcp_write_xmit()中被调用。虽然只要有数据输出都会调用tcp_mtu_probe(),但是只有满足了某些条件才会真正创建路径MTU发现段，否则不会做任何操作。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">Create a new MTU probe if we are ready.</span>
<span style="color: #75715E;"> * Returns 0 if we should wait to probe (no cwnd available),</span>
<span style="color: #75715E;"> *         1 if a probe was sent,</span>
<span style="color: #75715E;"> *         -1 otherwise</span><span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_mtu_probe</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>, *<span style="color: #FD971F;">nskb</span>, *<span style="color: #FD971F;">next</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">probe_size</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">pif</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">copy</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mss_now</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Not currently probing/verifying,</span>
<span style="color: #75715E;">         * not in recovery,</span>
<span style="color: #75715E;">         * have enough cwnd, and</span>
<span style="color: #75715E;">         * not SACKing (the variable headers throw things off)</span><span style="color: #75715E;"> */</span>
         <span style="color: #E6DB74;">/**  &#20197;&#19979;&#20960;&#31181;&#24773;&#20917;&#65292;&#19981;&#38656;&#35201;&#36827;&#34892;&#36335;&#24452;MTU&#21457;&#29616;&#65306;</span>
<span style="color: #E6DB74;">         + &#26410;&#21551;&#29992;&#36335;&#24452;MTU</span>
<span style="color: #E6DB74;">         + &#24403;&#21069;&#36335;&#24452;MTU&#25506;&#27979;&#27573;&#30340;&#38271;&#24230;&#19981;&#26159;0&#65292;&#34920;&#31034;&#36335;&#24452;MTU&#21457;&#29616;&#27573;&#24050;&#32463;&#21457;&#20986;&#23578;&#26410;&#24471;&#21040;&#30830;&#35748;&#12290;</span>
<span style="color: #E6DB74;">         + &#25317;&#22622;&#25511;&#21046;&#29366;&#24577;&#19981;&#22788;&#20110;Open&#29366;&#24577;</span>
<span style="color: #E6DB74;">         + &#25317;&#22622;&#31383;&#21475;&#22823;&#23567;&#19981;&#36275;&#20351;&#29992;&#26102;</span>
<span style="color: #E6DB74;">         + &#19979;&#19968;&#20010;&#21457;&#36865;&#30340;&#27573;&#20013;&#23384;&#22312;SACK&#36873;&#39033;</span>
<span style="color: #E6DB74;">         */</span>

        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>icsk-&gt;icsk_mtup.enabled ||
            icsk-&gt;icsk_mtup.probe_size ||
            inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_Open ||
            tp-&gt;snd_cwnd &lt; 11 ||
            tp-&gt;rx_opt.eff_sacks)
                <span style="color: #F92672;">return</span> -1;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Very simple search strategy: just double the MSS.</span><span style="color: #75715E;"> */</span>
        mss_now = tcp_current_mss(sk, 0);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20351;&#29992;&#20004;&#20493;&#30340;MSS&#20316;&#20026;&#36335;&#24452;MTU&#21457;&#29616;&#27573;&#30340;&#27573;&#38271;&#12290;&#22914;&#26524;&#35813;&#27573;&#38271;&#24230;&#20540;&#22823;&#20110;&#36335;&#24452;MTU&#21457;&#29616;&#27573;&#27573;&#38271;&#30340;&#19978;&#38480;&#65292;&#21017;&#19981;&#33021;&#36827;&#34892;&#36335;&#24452;MTU&#30340;&#25506;&#27979;&#12290;</span>
        probe_size = 2*tp-&gt;mss_cache;
        <span style="color: #F92672;">if</span> (probe_size &gt; tcp_mtu_to_mss(sk, icsk-&gt;icsk_mtup.search_high)) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">TODO: set timer for probe_converge_event</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">return</span> -1;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#26597;&#21457;&#36865;&#38431;&#21015;&#20013;&#26159;&#21542;&#26377;&#36275;&#22815;&#30340;&#25968;&#25454;&#29992;&#26469;&#36827;&#34892;&#36335;&#24452;MTU&#30340;&#25506;&#27979;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Have enough data in the send queue to probe?</span><span style="color: #75715E;"> */</span>
        len = 0;
        <span style="color: #F92672;">if</span> ((skb = sk-&gt;sk_send_head) == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">return</span> -1;
        <span style="color: #F92672;">while</span> ((len += skb-&gt;len) &lt; probe_size &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">!</span>tcp_skb_is_last(sk, skb))
                skb = skb-&gt;next;
        <span style="color: #F92672;">if</span> (len &lt; probe_size)
                <span style="color: #F92672;">return</span> -1;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;&#23545;&#31471;&#25509;&#25910;&#31383;&#21475;&#26159;&#21542;&#26377;&#36275;&#22815;&#30340;&#31354;&#38388;&#29992;&#26469;&#25509;&#25910;&#36335;&#24452;MTU&#30340;&#25506;&#27979;&#27573;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Receive window check.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (after(TCP_SKB_CB(skb)-&gt;seq + probe_size, tp-&gt;snd_una + tp-&gt;snd_wnd)) {
                <span style="color: #F92672;">if</span> (tp-&gt;snd_wnd &lt; probe_size)
                        <span style="color: #F92672;">return</span> -1;
                <span style="color: #F92672;">else</span>
                        <span style="color: #F92672;">return</span> 0;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26816;&#27979;&#25317;&#22622;&#31383;&#21475;&#26159;&#21542;&#34987;&#32791;&#23613;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Do we need to wait to drain cwnd?</span><span style="color: #75715E;"> */</span>
        pif = tcp_packets_in_flight(tp);
        <span style="color: #F92672;">if</span> (pif + 2 &gt; tp-&gt;snd_cwnd) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">With no packets in flight, don't stall.</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (pif == 0)
                        <span style="color: #F92672;">return</span> -1;
                <span style="color: #F92672;">else</span>
                        <span style="color: #F92672;">return</span> 0;
        }
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20026;&#36335;&#24452;MTU&#25506;&#27979;&#27573;&#20998;&#37197;SKB&#65292;&#24182;&#25554;&#20837;&#21040;&#21457;&#36865;&#38431;&#21015;&#30340;&#38431;&#39318;&#12290;&#28982;&#21518;&#35774;&#32622;SKB&#20013;TCP&#25511;&#21046;&#22359;&#30340;&#30456;&#20851;&#20540;&#12290;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We're allowed to probe.  Build it now.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> ((nskb = sk_stream_alloc_skb(sk, probe_size, GFP_ATOMIC)) == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">return</span> -1;
        sk_charge_skb(sk, nskb);

        skb = sk-&gt;sk_send_head;
        __skb_insert(nskb, skb-&gt;prev, skb, &amp;sk-&gt;sk_write_queue);
        sk-&gt;sk_send_head = nskb;

        TCP_SKB_CB(nskb)-&gt;seq = TCP_SKB_CB(skb)-&gt;seq;
        TCP_SKB_CB(nskb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + probe_size;
        TCP_SKB_CB(nskb)-&gt;flags = TCPCB_FLAG_ACK;
        TCP_SKB_CB(nskb)-&gt;sacked = 0;
        nskb-&gt;csum = 0;
        nskb-&gt;ip_summed = skb-&gt;ip_summed;

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#21457;&#36865;&#38431;&#21015;&#20013;&#36335;&#24452;MTU&#25506;&#27979;&#27573;&#21518;&#30340;SKB&#20013;&#30340;&#25968;&#25454;&#22797;&#21046;&#21040;&#36335;&#24452;MTU&#25506;&#27979;&#27573;&#20013;&#65292;&#24182;&#37322;&#25918;&#24050;&#32463;&#34987;&#22797;&#21046;&#30340;SKB</span>
        len = 0;
        <span style="color: #F92672;">while</span> (len &lt; probe_size) {
                next = skb-&gt;next;

                copy = min_t(<span style="color: #66D9EF;">int</span>, skb-&gt;len, probe_size - len);
                <span style="color: #F92672;">if</span> (nskb-&gt;ip_summed)
                        skb_copy_bits(skb, 0, skb_put(nskb, copy), copy);
                <span style="color: #F92672;">else</span>
                        nskb-&gt;csum = skb_copy_and_csum_bits(skb, 0,
                                         skb_put(nskb, copy), copy, nskb-&gt;csum);

                <span style="color: #F92672;">if</span> (skb-&gt;len &lt;= copy) {
                        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We've eaten all the data from this skb.</span>
<span style="color: #75715E;">                         * Throw it away.</span><span style="color: #75715E;"> */</span>
                        TCP_SKB_CB(nskb)-&gt;flags |= TCP_SKB_CB(skb)-&gt;flags;
                        __skb_unlink(skb, &amp;sk-&gt;sk_write_queue);
                        sk_stream_free_skb(sk, skb);
                } <span style="color: #F92672;">else</span> {
                        TCP_SKB_CB(nskb)-&gt;flags |= TCP_SKB_CB(skb)-&gt;flags &amp;
                                                   ~(TCPCB_FLAG_FIN|TCPCB_FLAG_PSH);
                        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>skb_shinfo(skb)-&gt;nr_frags) {
                                skb_pull(skb, copy);
                                <span style="color: #F92672;">if</span> (skb-&gt;ip_summed != CHECKSUM_PARTIAL)
                                        skb-&gt;csum = csum_partial(skb-&gt;data, skb-&gt;len, 0);
                        } <span style="color: #F92672;">else</span> {
                                __pskb_trim_head(skb, copy);
                                tcp_set_skb_tso_segs(sk, skb, mss_now);
                        }
                        TCP_SKB_CB(skb)-&gt;seq += copy;
                }

                len += copy;
                skb = next;
        }
        tcp_init_tso_segs(sk, nskb, nskb-&gt;len);

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26368;&#21518;&#23558;&#35813;&#36335;&#24452;MTU&#25506;&#27979;&#27573;&#36755;&#20986;&#65292;&#24182;&#35760;&#24405;&#36335;&#24452;MTU&#25506;&#27979;&#27573;&#30340;&#24207;&#21495;&#65292;&#20197;&#20415;&#20043;&#21518;&#29992;&#26469;&#30830;&#35748;&#36335;&#24452;MTU&#25506;&#27979;&#25104;&#21151;&#19982;&#21542;&#12290;</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We're ready to send.  If this fails, the probe will</span>
<span style="color: #75715E;">         * be resegmented into mss-sized pieces by tcp_write_xmit().</span><span style="color: #75715E;"> */</span>
        TCP_SKB_CB(nskb)-&gt;when = tcp_time_stamp;
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tcp_transmit_skb(sk, nskb, 1, GFP_ATOMIC)) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Decrement cwnd here because we are sending</span>
<span style="color: #75715E;">                * effectively two packets.</span><span style="color: #75715E;"> */</span>
                tp-&gt;snd_cwnd--;
                update_send_head(sk, tp, nskb);
                <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35813;&#20989;&#25968;&#23558;mss&#36716;&#21270;&#20026;MTU, &#65288;mss+TCP&#39318;&#37096;+TCP&#36873;&#39033;+IP&#39318;&#37096;+IP&#36873;&#39033;&#65289;</span>
                icsk-&gt;icsk_mtup.probe_size = tcp_mss_to_mtu(sk, nskb-&gt;len);
                tp-&gt;mtu_probe.probe_seq_start = TCP_SKB_CB(nskb)-&gt;seq;
                tp-&gt;mtu_probe.probe_seq_end = TCP_SKB_CB(nskb)-&gt;end_seq;

                <span style="color: #F92672;">return</span> 1;
        }

        <span style="color: #F92672;">return</span> -1;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org795c82b" class="outline-3">
<h3 id="org795c82b"><span class="section-number-3">8.5.</span> 路径MTU发现失败后的处理</h3>
<div class="outline-text-3" id="text-8-5">
<p>
检测路径MTU发现是否失败是在进行拥塞处理的tcp_fastretrans_alert()中进行的。如果此时处于Open状态或Discoder拥塞状态，且当前存在进行路径MTU发现的段，而等待确认的正是进行路径MTU发现的段，则说明路径MTU发现失败，需要进行相应的失败处理。首先调用tcp_mtup_probe_failed()更新与PMTU相关的参数，缩小发现路径MTU段的区间，然后重传。
</p>
</div>
</div>


<div id="outline-container-org4e89db9" class="outline-3">
<h3 id="org4e89db9"><span class="section-number-3">8.6.</span> 处理需要分片的ICMP目的不可达报文</h3>
<div class="outline-text-3" id="text-8-6">
<p>
ICMP模块接收到“需要分片的ICMP目的不可达报文”的消息后，根据传输层协议，如果是TCP，则会调用到tcp_v4_err()。在该函数中进而根据ICMP_DEST_UNREACH和编码ICMP_FRASG_NEEDED调用do_pmtu_discovery()进行路径MTU发现失败处理。
</p>


<div id="orgc241765" class="figure">
<p><img src="image/tcp-output/icmp-dst-unreach.png" alt="icmp-dst-unreach.png" />
</p>
<p><span class="figure-number">Figure 18: </span>ICMP的ICMP_DEST_UNREACH茶所报文处理过程</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #75715E;"> * This routine does path mtu discovery as defined in RFC1191.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">do_pmtu_discovery</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iphdr</span> *<span style="color: #FD971F;">iph</span>, <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">mtu</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dst_entry</span> *<span style="color: #FD971F;">dst</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_sock</span> *<span style="color: #FD971F;">inet</span> = inet_sk(sk);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We are not interested in TCP_LISTEN and open_requests (SYN-ACKs</span>
<span style="color: #75715E;">         * send out by Linux are always &lt;576bytes so they should go through</span>
<span style="color: #75715E;">         * unfragmented).</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">listen&#29366;&#24577;&#19979;&#19981;&#38656;&#35201;&#36827;&#34892;&#36335;&#24452;MTU&#21457;&#29616;&#65292;&#35813;&#29366;&#24577;&#19979;&#36755;&#20986;&#30340;SYN+ACK&#27573;&#24635;&#26159;&#23567;&#20110;536B&#65292;&#22240;&#27492;&#36755;&#20986;&#30340;IP&#25968;&#25454;&#25253;&#19981;&#20250;&#34987;&#20998;&#29255;&#12290;</span>
        <span style="color: #F92672;">if</span> (sk-&gt;sk_state == TCP_LISTEN)
                <span style="color: #F92672;">return</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">We don't check in the destentry if pmtu discovery is forbidden</span>
<span style="color: #75715E;">         * on this route. We just assume that no packet_to_big packets</span>
<span style="color: #75715E;">         * are send back when pmtu discovery is not active.</span>
<span style="color: #75715E;">         * There is a small race when the user changes this flag in the</span>
<span style="color: #75715E;">         * route, but I think that's acceptable.</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#26816;&#27979;&#24403;&#21069;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#26159;&#21542;&#21487;&#29992;&#12290;&#19981;&#21487;&#29992;&#21017;&#19981;&#32487;&#32493;&#22788;&#29702;</span>
        <span style="color: #F92672;">if</span> ((dst = __sk_dst_check(sk, 0)) == <span style="color: #AE81FF;">NULL</span>)
                <span style="color: #F92672;">return</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#33719;&#21462;&#30340;&#19979;&#19968;&#36339;&#30340;MTU&#26356;&#26032;&#21040;&#19982;&#36335;&#30001;&#30456;&#20851;&#30340;&#36335;&#30001;&#32531;&#23384;&#39033;&#30340;&#24230;&#37327;&#20540;&#20013;</span>
        dst-&gt;ops-&gt;update_pmtu(dst, mtu);

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Something is about to be wrong... Remember soft error</span>
<span style="color: #75715E;">         * for the case, if this connection will not able to recover.</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#22914;&#26524;&#23384;&#20648;&#22312;&#36335;&#30001;&#32531;&#23384;&#39033;&#30340;&#24230;&#37327;&#20540;&#20013;&#30340;PMTU&#22823;&#20110;&#19979;&#19968;&#36339;&#30340;MTU,&#19988;&#21457;&#36865;&#20986;&#30340;IP&#25968;&#25454;&#25253;&#31105;&#27490;&#20998;&#29255;&#65292;&#21017;&#38656;&#35201;&#25253;&#21578;&#30456;&#24212;&#30340;&#38169;&#35823;</span>
        <span style="color: #F92672;">if</span> (mtu &lt; dst_mtu(dst) &amp;&amp; ip_dont_fragment(sk, dst))
                sk-&gt;sk_err_soft = EMSGSIZE;

        mtu = dst_mtu(dst);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20801;&#35768;&#36335;&#24452;MTU&#21457;&#29616;&#30340;&#24773;&#20917;&#19979;&#65292;&#22914;&#26524;&#32531;&#23384;&#22312;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#36335;&#24452;MTU&#20540;&#22823;&#20110;&#26032;&#30340;&#20540;&#65292;&#21017;&#38656;&#23558;&#26032;&#30340;&#36335;&#24452;MTU&#20540;&#26356;&#26032;&#21040;&#20256;&#36755;&#25511;&#21046;&#22359;&#30340;&#32531;&#23384;&#20013;&#65292;&#21516;&#26102;&#26356;&#26032;MSS,&#26368;&#21518;&#37325;&#20256;&#12290;</span>
        <span style="color: #F92672;">if</span> (inet-&gt;pmtudisc != IP_PMTUDISC_DONT &amp;&amp;
            inet_csk(sk)-&gt;icsk_pmtu_cookie &gt; mtu) {
                tcp_sync_mss(sk, mtu);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Resend the TCP packet because it's</span>
<span style="color: #75715E;">                 * clear that the old packet has been</span>
<span style="color: #75715E;">                 * dropped. This is the new "fast" path mtu</span>
<span style="color: #75715E;">                 * discovery.</span>
<span style="color: #75715E;">                 */</span>
                tcp_simple_retransmit(sk);
        } <span style="color: #75715E;">/* </span><span style="color: #75715E;">else let the usual retransmit timer handle it</span><span style="color: #75715E;"> */</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org51f57e6" class="outline-3">
<h3 id="org51f57e6"><span class="section-number-3">8.7.</span> 更新当前有效的MSS</h3>
<div class="outline-text-3" id="text-8-7">
<p>
tcp_sync_mss()为传输控制块中与MSS相关的成员进行数据同步。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">This function synchronize snd mss to current pmtu/exthdr set.</span>

<span style="color: #75715E;">   tp-&gt;rx_opt.user_mss is mss set by user by TCP_MAXSEG. It does NOT counts</span>
<span style="color: #75715E;">   for TCP options, but includes only bare TCP header.</span>

<span style="color: #75715E;">   tp-&gt;rx_opt.mss_clamp is mss negotiated at connection setup.</span>
<span style="color: #75715E;">   It is minimum of user_mss and mss received with SYN.</span>
<span style="color: #75715E;">   It also does not include TCP options.</span>

<span style="color: #75715E;">   inet_csk(sk)-&gt;icsk_pmtu_cookie is last pmtu, seen by this function.</span>

<span style="color: #75715E;">   tp-&gt;mss_cache is current effective sending mss, including</span>
<span style="color: #75715E;">   all tcp options except for SACKs. It is evaluated,</span>
<span style="color: #75715E;">   taking into account current pmtu, but never exceeds</span>
<span style="color: #75715E;">   tp-&gt;rx_opt.mss_clamp.</span>

<span style="color: #75715E;">   NOTE1. rfc1122 clearly states that advertised MSS</span>
<span style="color: #75715E;">   DOES NOT include either tcp or ip options.</span>

<span style="color: #75715E;">   NOTE2. inet_csk(sk)-&gt;icsk_pmtu_cookie and tp-&gt;mss_cache</span>
<span style="color: #75715E;">   are READ ONLY outside this function.         --ANK (980731)</span>
<span style="color: #75715E;"> */</span>

<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_sync_mss</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">pmtu</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mss_now</span>;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#22914;&#26524;&#36335;&#24452;MTU&#21457;&#29616;&#27573;&#30340;&#38271;&#24230;&#19978;&#38480;&#20540;&#26080;&#25928;&#65292;&#21017;&#26356;&#26032;</span>
        <span style="color: #F92672;">if</span> (icsk-&gt;icsk_mtup.search_high &gt; pmtu)
                icsk-&gt;icsk_mtup.search_high = pmtu;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#26681;&#25454;PMTU&#24471;&#21040;MSS</span>
        mss_now = tcp_mtu_to_mss(sk, pmtu);

        <span style="color: #75715E;">//</span><span style="color: #75715E;">MSS&#19981;&#33021;&#36229;&#36807;&#25509;&#25910;&#26041;&#36890;&#21578;&#36807;&#30340;&#25509;&#25910;&#31383;&#21475;&#30340;&#26368;&#22823;&#20540;&#30340;&#19968;&#21322;</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Bound mss with half of window</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (tp-&gt;max_window &amp;&amp; mss_now &gt; (tp-&gt;max_window&gt;&gt;1))
                mss_now = max((tp-&gt;max_window&gt;&gt;1), 68U - tp-&gt;tcp_header_len);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20445;&#23384;&#26368;&#36817;&#26356;&#26032;&#30340;&#26377;&#25928;PMTU</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">And store cached results</span><span style="color: #75715E;"> */</span>
        icsk-&gt;icsk_pmtu_cookie = pmtu;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#23558;&#24471;&#21040;&#30340;MSS&#26356;&#26032;&#21040;&#32531;&#23384;&#20013;</span>
        <span style="color: #F92672;">if</span> (icsk-&gt;icsk_mtup.enabled)
                mss_now = min(mss_now, tcp_mtu_to_mss(sk, icsk-&gt;icsk_mtup.search_low));
        tp-&gt;mss_cache = mss_now;

        <span style="color: #F92672;">return</span> mss_now;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orga11995d" class="outline-3">
<h3 id="orga11995d"><span class="section-number-3">8.8.</span> 路径MTU发现成功后的处理</h3>
<div class="outline-text-3" id="text-8-8">
<p>
tcp_clean_rtx_queue()用于检测路径MTU发心啊是否成功，如果当前存在进行路径MTU发现的段，且该端已被确认，则表示路径MTU发现成功，调用tcp_mtup_probe_sucess()进行路径MTU发现成功后的处理。
</p>

<p>
因为在Linux中拥塞窗口是以段数为单位，因此成功后需要更新与拥塞窗口相关的参数、路径MTU发现参数以及PMTU和MSS。
</p>
</div>
</div>
</div>


<div id="outline-container-org0295b7a" class="outline-2">
<h2 id="org0295b7a"><span class="section-number-2">9.</span> TCP重传接口</h2>
<div class="outline-text-2" id="text-9">
<p>
通常情况下，TCP在传送超时（即输出后，在超时时间内没接收到对应的ACK），以及接收到需要分片ICMP消息这两种情况下会发送重传，无论是什么原因导致重传，最后都会调用统一的入口函数tcp_retransmit_skb()。参数SKB为待重传的段。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #75715E;">This retransmits one SKB.  Policy decisions and retransmit queue</span>
<span style="color: #75715E;"> * state updates are done by the caller.  Returns non-zero if an</span>
<span style="color: #75715E;"> * error occurred which prevented the send.</span>
<span style="color: #75715E;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">tcp_retransmit_skb</span>(<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sock</span> *<span style="color: #FD971F;">sk</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *<span style="color: #FD971F;">skb</span>)
{
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tcp_sock</span> *<span style="color: #FD971F;">tp</span> = tcp_sk(sk);
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inet_connection_sock</span> *<span style="color: #FD971F;">icsk</span> = inet_csk(sk);
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cur_mss</span> = tcp_current_mss(sk, 0);
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">err</span>;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Inconslusive MTU probe</span><span style="color: #75715E;"> */</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#36335;&#24452;MTU&#21457;&#29616;&#36824;&#27809;&#26377;&#32467;&#26463;&#65292;&#26080;&#35770;&#20160;&#20040;&#21407;&#22240;&#23548;&#33268;&#30340;&#37325;&#20256;&#65292;&#37117;&#23558;&#20854;&#26631;&#24535;&#20026;&#32467;&#26463;</span>
        <span style="color: #F92672;">if</span> (icsk-&gt;icsk_mtup.probe_size) {
                icsk-&gt;icsk_mtup.probe_size = 0;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Do not sent more than we queued. 1/4 is reserved for possible</span>
<span style="color: #75715E;">         * copying overhead: fragmentation, tunneling, mangling etc.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;&#22312;&#21457;&#36865;&#32531;&#20914;&#21306;&#20013;&#28040;&#32791;&#20102;&#36807;&#22810;&#20869;&#23384;&#21435;&#20570;&#20854;&#20182;&#30340;&#19968;&#20123;&#24037;&#20316;&#65288;&#20363;&#22914;&#20998;&#29255;&#31561;&#65292;&#21482;&#26377;1/4&#30340;&#32531;&#23384;&#29992;&#20110;&#36825;&#20123;&#24037;&#20316;&#65289;&#65292;&#21017;&#26242;&#26102;&#19981;&#21487;&#20197;&#37325;&#20256;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &gt;
            min(sk-&gt;sk_wmem_queued + (sk-&gt;sk_wmem_queued &gt;&gt; 2), sk-&gt;sk_sndbuf))
                <span style="color: #F92672;">return</span> -EAGAIN;

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#26816;&#27979;&#37325;&#20256;&#30340;&#27573;&#65292;&#25509;&#25910;&#26041;&#26159;&#21542;&#24050;&#32463;&#25910;&#21040;&#20854;&#37096;&#20998;&#25110;&#32773;&#20840;&#37096;&#12290;&#22914;&#26524;&#25910;&#21040;&#20840;&#37096;&#65292;&#21017;&#35828;&#26126;TCP&#23454;&#29616;&#20195;&#30721;&#26377;BUG,&#22914;&#26524;&#25910;&#21040;&#37096;&#20998;&#65292;&#21017;&#38656;&#35201;&#35843;&#25972;TCP&#27573;&#30340;&#20239;&#22312;&#65292;&#21363;&#21024;&#38500;SKB&#23384;&#20648;&#21306;&#21069;&#37096;&#24050;&#32463;&#34987;&#25509;&#25910;&#26041;&#25509;&#25910;&#30340;&#25968;&#25454;&#12290;</span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">if</span> (before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;snd_una)) {
                <span style="color: #F92672;">if</span> (before(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una))
                        BUG();
                <span style="color: #F92672;">if</span> (tcp_trim_head(sk, skb, tp-&gt;snd_una - TCP_SKB_CB(skb)-&gt;seq))
                        <span style="color: #F92672;">return</span> -ENOMEM;
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">If receiver has shrunk his window, and skb is out of</span>
<span style="color: #75715E;">         * new window, do not retransmit it. The exception is the</span>
<span style="color: #75715E;">         * case, when window is shrunk to zero. In this case</span>
<span style="color: #75715E;">         * our retransmit serves as a zero window probe.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #75715E;">/*</span><span style="color: #75715E;">&#22914;&#26524;&#25509;&#25910;&#26041;&#24050;&#32463;&#32553;&#23567;&#20102;&#25509;&#25910;&#31383;&#21475;&#65292;&#19988;&#24453;&#37325;&#20256;&#30340;SKB&#24050;&#32463;&#19981;&#20877;&#26032;&#31383;&#21475;&#20869;&#65292;&#21017;&#19981;&#33021;&#20877;&#37325;&#20256;&#35813;SKB&#65292;&#12290;&#20294;&#26377;&#19968;&#31181;&#24773;&#20917;&#20363;&#22806;&#65292;&#23601;&#26159;&#24403;&#25509;&#25910;&#26041;&#25509;&#25910;&#31383;&#21475;&#32553;&#23567;&#21040;0,&#36825;&#31181;&#24773;&#20917;&#19979;&#65292;&#20250;&#21457;&#36865;&#38646;&#31383;&#21475;&#27979;&#27979;&#27573;</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;snd_una+tp-&gt;snd_wnd)
            &amp;&amp; TCP_SKB_CB(skb)-&gt;seq != tp-&gt;snd_una)
                <span style="color: #F92672;">return</span> -EAGAIN;
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">&#22914;&#26524;SKB&#20013;&#30340;&#25968;&#25454;&#38271;&#24230;&#22823;&#20110;&#24403;&#21069;&#30340;MSS,&#21017;&#38656;&#35201;&#23545;&#35813;SKB&#20998;&#27573;&#12290;&#36825;&#31181;&#24773;&#20917;&#19968;&#33324;&#20986;&#29616;&#22312;&#21551;&#29992;&#20102;&#36335;&#24452;MTU,&#25509;&#25910;&#21040;&#38656;&#35201;&#20998;&#29255;ICMP&#30446;&#30340;&#19981;&#21487;&#36798;&#25253;&#25991;&#26159;&#65292;&#22914;&#26524;ICMP&#19979;&#19968;&#36339;&#30340;PMTU&#23567;&#20110;&#24403;&#21069;PMTU,&#21017;&#26356;&#26032;&#24403;&#21069;PMTU&#21450;&#24403;&#21069;MSS.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span> (skb-&gt;len &gt; cur_mss) {
                <span style="color: #F92672;">if</span> (tcp_fragment(sk, skb, cur_mss, cur_mss))
                        <span style="color: #F92672;">return</span> -ENOMEM; <span style="color: #75715E;">/* </span><span style="color: #75715E;">We'll try again later.</span><span style="color: #75715E;"> */</span>
        }

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#20026;&#20860;&#23481;&#26576;&#20123;&#31967;&#31957;&#30340;&#25171;&#21360;&#26426;&#32780;&#35774;&#32622;&#30340;&#8220;&#23558;&#38169;&#23601;&#38169;&#8221;&#36873;&#39033; tcp_retrans_collapse.&#22914;&#26524;&#23454;&#29616;&#20102;&#35813;&#21151;&#33021;&#65292;&#21017;&#30001;tcp_retrans_try_collapse()&#23454;&#29616;&#65292;&#22312;&#37325;&#20256;&#26102;&#25226;&#25968;&#25454;&#21253;&#22686;&#22823;&#19968;&#20123;&#65292;&#26469;&#36991;&#20813;&#26576;&#20123;TCP&#21327;&#35758;&#26632;&#20013;&#30340;BUG.</span>
        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Collapse two adjacent packets if worthwhile and we can.</span><span style="color: #75715E;"> */</span>
        <span style="color: #F92672;">if</span>(<span style="color: #E6DB74; font-weight: bold;">!</span>(TCP_SKB_CB(skb)-&gt;flags &amp; TCPCB_FLAG_SYN) &amp;&amp;
           (skb-&gt;len &lt; (cur_mss &gt;&gt; 1)) &amp;&amp;
           (skb-&gt;next != sk-&gt;sk_send_head) &amp;&amp;
           (skb-&gt;next != (<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sk_buff</span> *)&amp;sk-&gt;sk_write_queue) &amp;&amp;
           (skb_shinfo(skb)-&gt;nr_frags == 0 &amp;&amp; skb_shinfo(skb-&gt;next)-&gt;nr_frags == 0) &amp;&amp;
           (tcp_skb_pcount(skb) == 1 &amp;&amp; tcp_skb_pcount(skb-&gt;next) == 1) &amp;&amp;
           (sysctl_tcp_retrans_collapse != 0))
                tcp_retrans_try_collapse(sk, skb, cur_mss);

        <span style="color: #E6DB74;">/** &#26681;&#25454;&#30446;&#30340;&#22320;&#22336;&#31561;&#26465;&#20214;&#33719;&#21462;&#36335;&#30001;&#12290;&#22914;&#26524;&#36335;&#30001;&#33719;&#21462;&#22833;&#36133;&#65292;&#21017;&#19981;&#33021;&#21457;&#36865;</span>
<span style="color: #E6DB74;">        &#27492;&#22788;&#30340;rebuild_header&#23383;&#38754;&#24847;&#24605;&#27604;&#36739;&#22855;&#24618;&#65292;&#23454;&#38469;&#25191;&#34892;&#30340;&#26159;&#26597;&#25214;&#36335;&#30001;&#30340;&#25805;&#20316;&#12290;</span>
<span style="color: #E6DB74;">        &#21442;&#35265;</span><span style="color: #AE81FF;">tcp_v4_init_sock()</span><span style="color: #E6DB74;">&#23545; inet_csk-&gt;icsk_af_ops&#30340;&#21021;&#22987;&#21270;&#21644;</span><span style="color: #AE81FF;">inet_sk_rebuild_header()</span><span style="color: #E6DB74;">.</span>
<span style="color: #E6DB74;">        */</span>
        <span style="color: #F92672;">if</span> (inet_csk(sk)-&gt;icsk_af_ops-&gt;rebuild_header(sk))
                <span style="color: #F92672;">return</span> -EHOSTUNREACH; <span style="color: #75715E;">/* </span><span style="color: #75715E;">Routing failure or similar.</span><span style="color: #75715E;"> */</span>

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Some Solaris stacks overoptimize and ignore the FIN on a</span>
<span style="color: #75715E;">         * retransmit when old data is attached.  So strip it off</span>
<span style="color: #75715E;">         * since it is cheap to do so and saves bytes on the network.</span>
<span style="color: #75715E;">         */</span>
        <span style="color: #E6DB74;">/** &#30001;&#20110;&#26576;&#20123;Solaris&#31995;&#32479;&#30340;&#21327;&#35758;&#26632;&#20250;&#24573;&#30053;&#37325;&#20256;&#27573;&#19978;&#24102;&#26377;FIN&#26631;&#24535;&#30340;Payload,&#25152;&#20197;&#23558;payload&#37096;&#20998;&#20840;&#37096;&#21093;&#31163;&#65292;&#36825;&#26679;&#21487;&#20197;&#22312;&#32593;&#32476;&#19978;&#33410;&#30465;&#19968;&#37096;&#20998;&#27969;&#37327;*/</span>
        <span style="color: #F92672;">if</span>(skb-&gt;len &gt; 0 &amp;&amp;
           (TCP_SKB_CB(skb)-&gt;flags &amp; TCPCB_FLAG_FIN) &amp;&amp;
           tp-&gt;snd_una == (TCP_SKB_CB(skb)-&gt;end_seq - 1)) {
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>pskb_trim(skb, 0)) {
                        TCP_SKB_CB(skb)-&gt;seq = TCP_SKB_CB(skb)-&gt;end_seq - 1;
                        skb_shinfo(skb)-&gt;gso_segs = 1;
                        skb_shinfo(skb)-&gt;gso_size = 0;
                        skb_shinfo(skb)-&gt;gso_type = 0;
                        skb-&gt;ip_summed = CHECKSUM_NONE;
                        skb-&gt;csum = 0;
                }
        }

        <span style="color: #75715E;">/* </span><span style="color: #75715E;">Make a copy, if the first transmission SKB clone we made</span>
<span style="color: #75715E;">         * is still in somebody's hands, else make a clone.</span>
<span style="color: #75715E;">         *///</span><span style="color: #75715E;">&#36827;&#34892;TCP&#27573;&#30340;&#21457;&#36865;&#20197;&#21450;&#21457;&#36865;&#21518;&#30340;&#25968;&#25454;&#35843;&#25972;</span>

        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#35760;&#24405;TCP&#27573;&#30340;&#21457;&#36865;&#26102;&#38388;</span>
        TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;TCP&#27573;</span>
        err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
        <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21457;&#36865;&#25104;&#21151;&#65292;&#38656;&#35201;&#26356;&#26032;&#32479;&#35745;&#25968;&#25454;&#21644;&#29366;&#24577;&#25968;&#25454;&#65288;&#37325;&#20256;&#24635;&#27425;&#25968;&#12289;&#37325;&#20256;&#32780;&#26410;&#24471;&#21040;&#30830;&#35748;&#30340;TCP&#27573;&#25968;&#65292;&#24182;&#20026;&#35813;TCP&#27573;&#21152;&#19978;&#37325;&#20256;&#26631;&#24535;&#31561;&#65289;</span>
        <span style="color: #F92672;">if</span> (err == 0) {
                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Update global TCP statistics.</span><span style="color: #75715E;"> */</span>
                TCP_INC_STATS(TCP_MIB_RETRANSSEGS);

                tp-&gt;total_retrans++;

<span style="color: #F92672;">#if</span> FASTRETRANS_DEBUG &gt; 0
                <span style="color: #F92672;">if</span> (TCP_SKB_CB(skb)-&gt;sacked&amp;TCPCB_SACKED_RETRANS) {
                        <span style="color: #F92672;">if</span> (net_ratelimit())
                                printk(KERN_DEBUG <span style="color: #E6DB74;">"retrans_out leaked.\n"</span>);
                }
<span style="color: #F92672;">#endif</span>
                TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_RETRANS;
                tp-&gt;retrans_out += tcp_skb_pcount(skb);

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">Save stamp of the first retransmit.</span><span style="color: #75715E;"> */</span>
                <span style="color: #F92672;">if</span> (<span style="color: #E6DB74; font-weight: bold;">!</span>tp-&gt;retrans_stamp)
                        tp-&gt;retrans_stamp = TCP_SKB_CB(skb)-&gt;when;

                tp-&gt;undo_retrans++;

                <span style="color: #75715E;">/* </span><span style="color: #75715E;">snd_nxt is stored to detect loss of retransmitted segment,</span>
<span style="color: #75715E;">                 * see tcp_input.c tcp_sacktag_write_queue().</span>
<span style="color: #75715E;">                 *///</span><span style="color: #75715E;">&#23558;&#24403;&#21069;&#30340;SND.NXT&#23384;&#20648;&#21040;&#35813;&#25511;&#21046;&#22359;&#30340;ack_seq&#20013;&#65292;&#20043;&#21518;&#26377;&#21487;&#33021;&#22312;tcp_sacktag_write_queue()&#20013;&#29992;&#26469;&#26816;&#27979;&#20002;&#22833;&#30340;&#37325;&#20256;&#27573;</span>
                TCP_SKB_CB(skb)-&gt;ack_seq = tp-&gt;snd_nxt;
        }
        <span style="color: #F92672;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: nandfan</p>
<p class="email">Email: <a href="mailto:nanders.fan@outlook.com">nanders.fan@outlook.com</a></p>
<p class="date">Created: 2024-06-23 Sun 15:55</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
